diff --git a/Copyright b/Copyright
old mode 100644
new mode 100755
diff --git a/build/Makefile b/build/Makefile
old mode 100644
new mode 100755
diff --git a/build/makdep.c b/build/makdep.c
old mode 100644
new mode 100755
diff --git a/build/srcfiles b/build/srcfiles
old mode 100644
new mode 100755
diff --git a/src/CoR/cor_cpl_interface.cxx b/src/CoR/cor_cpl_interface.cxx
old mode 100644
new mode 100755
index 7a708ea..6dc5051
--- a/src/CoR/cor_cpl_interface.cxx
+++ b/src/CoR/cor_cpl_interface.cxx
@@ -111,9 +111,9 @@ Remap_grid_data_class *cpl_duplicate_field_with_double_data_type(Remap_grid_data
     strcpy(double_field->get_grid_data_field()->data_type_in_application, DATA_TYPE_DOUBLE);
     strcpy(double_field->get_grid_data_field()->data_type_in_IO_file, DATA_TYPE_DOUBLE);
     delete [] double_field->get_grid_data_field()->data_buf;
-	EXECUTION_REPORT(REPORT_ERROR, -1, float_field->get_coord_value_grid()->get_grid_size() == double_field->get_grid_data_field()->required_data_size,
-				 "C-Coupler software error in cpl_duplicate_field_with_double_data_type\n");
-	EXECUTION_REPORT_LOG(REPORT_LOG, -1, true, "cpl duplicated field size is %ld", double_field->get_grid_data_field()->required_data_size);
+    EXECUTION_REPORT(REPORT_ERROR, -1, float_field->get_coord_value_grid()->get_grid_size() == double_field->get_grid_data_field()->required_data_size,
+                 "C-Coupler software error in cpl_duplicate_field_with_double_data_type\n");
+    EXECUTION_REPORT_LOG(REPORT_LOG, -1, true, "cpl duplicated field size is %ld", double_field->get_grid_data_field()->required_data_size);
     double_field->get_grid_data_field()->data_buf = new double [double_field->get_grid_data_field()->required_data_size];
 
     return double_field;
@@ -122,6 +122,6 @@ Remap_grid_data_class *cpl_duplicate_field_with_double_data_type(Remap_grid_data
 
 void cpl_check_remap_weights_format(Remap_weight_of_strategy_class *remap_weights)
 {
-	remap_weights->check_remap_weights_format();
+    remap_weights->check_remap_weights_format();
 }
 
diff --git a/src/CoR/cor_cpl_interface.h b/src/CoR/cor_cpl_interface.h
old mode 100644
new mode 100755
index b47e286..435d6db
--- a/src/CoR/cor_cpl_interface.h
+++ b/src/CoR/cor_cpl_interface.h
@@ -13,13 +13,13 @@
 #include "cor_global_data.h"
 
 
-#define GRID_LATS_GF		"n_grid_lats"
-#define GRID_LONS_GF		"n_grid_lons"
-#define LAT_GF						"lat"	
-#define LON_GF					"lon"
-#define AREA_GF					"arear"
-#define MASK_GF					"mask"
-#define SURFACE_FIELD_GF					"surface_field"
+#define GRID_LATS_GF        "n_grid_lats"
+#define GRID_LONS_GF        "n_grid_lons"
+#define LAT_GF                        "lat"    
+#define LON_GF                    "lon"
+#define AREA_GF                    "arear"
+#define MASK_GF                    "mask"
+#define SURFACE_FIELD_GF                    "surface_field"
 
 
 extern long cpl_get_grid_size(const char*);
diff --git a/src/CoR/cor_global_data.cxx b/src/CoR/cor_global_data.cxx
old mode 100644
new mode 100755
index feab677..7ef0445
--- a/src/CoR/cor_global_data.cxx
+++ b/src/CoR/cor_global_data.cxx
@@ -47,8 +47,8 @@ int get_data_type_size(const char *data_type)
         return sizeof(char);
     else if (words_are_the_same(data_type, DATA_TYPE_SHORT))
         return sizeof(short);
-	else if (words_are_the_same(data_type, DATA_TYPE_STRING))
-		return NAME_STR_SIZE;
+    else if (words_are_the_same(data_type, DATA_TYPE_STRING))
+        return NAME_STR_SIZE;
     else EXECUTION_REPORT(REPORT_ERROR, -1, false, 
                       "implicit data type %s is disabled in this software\n", 
                       data_type);
diff --git a/src/CoR/cor_global_data.h b/src/CoR/cor_global_data.h
old mode 100644
new mode 100755
index 9f3a8db..0413da1
--- a/src/CoR/cor_global_data.h
+++ b/src/CoR/cor_global_data.h
@@ -37,7 +37,7 @@
 
 #define FILL_VALUE_LABEL                      "_FillValue"
 #define MISS_VALUE_LABEL                      "missing_value"
-#define DEFAULT_FILL_VALUE                    (1.0e30)
+#define DEFAULT_FILL_VALUE                    (1.0e20)
 
 
 extern IO_mgt *io_manager;
diff --git a/src/CoR/delaunay_voronoi.cxx b/src/CoR/delaunay_voronoi.cxx
old mode 100644
new mode 100755
index d396f29..39573f8
--- a/src/CoR/delaunay_voronoi.cxx
+++ b/src/CoR/delaunay_voronoi.cxx
@@ -31,109 +31,109 @@ Delaunay_Voronoi *current_delaunay_voronoi = NULL;
 
 static inline double sind(double x)
 {
-	return sinl(x * PI / 180);
+    return sinl(x * PI / 180);
 }
 
 
 static inline double cosd(double x)
 {
-	return cosl(x * PI / 180);
+    return cosl(x * PI / 180);
 }
 
 
 double det(const Point *pt1, const Point *pt2, const Point *pt3)
 {
 
-//	return (pt1.lon-pt3.lon)*(pt2.lat-pt3.lat) - (pt1.lat-pt3.lat)*(pt2.lon-pt3.lon);
+//    return (pt1.lon-pt3.lon)*(pt2.lat-pt3.lat) - (pt1.lat-pt3.lat)*(pt2.lon-pt3.lon);
 
-	return compute_three_3D_points_cross_product(pt3->x, pt3->y, pt3->z, pt1->x, pt1->y, pt1->z, pt2->x, pt2->y, pt2->z);
+    return compute_three_3D_points_cross_product(pt3->x, pt3->y, pt3->z, pt1->x, pt1->y, pt1->z, pt2->x, pt2->y, pt2->z);
 }
 
 
 vector<Point*>::iterator get_nearest_point(const Point *pt, vector<Point*> *points)
 {
-	double min_dist = (double)1000000000000000;
-	int i, pos =-1;
+    double min_dist = (double)1000000000000000;
+    int i, pos =-1;
 
-	
-	for (i = 0; i < points->size(); i ++)
-		if (pt->calculate_distance((*points)[i]) < min_dist) {
-			min_dist = pt->calculate_distance((*points)[i]);
-			pos = i;
-		}
+    
+    for (i = 0; i < points->size(); i ++)
+        if (pt->calculate_distance((*points)[i]) < min_dist) {
+            min_dist = pt->calculate_distance((*points)[i]);
+            pos = i;
+        }
 
-	EXECUTION_REPORT(REPORT_ERROR, -1, pos != -1, "the input global grid is too sparse\n");
-		
-	return points->begin()+pos;
+    EXECUTION_REPORT(REPORT_ERROR, -1, pos != -1, "the input global grid is too sparse\n");
+        
+    return points->begin()+pos;
 }
 
 
 Triangle::Triangle()
 {
-	edge[0] = NULL;
-	edge[1] = NULL;
-	edge[2] = NULL;
+    edge[0] = NULL;
+    edge[1] = NULL;
+    edge[2] = NULL;
 }
 
 
 void Triangle::initialize_triangle_with_edges(Edge *edge1, Edge *edge2, Edge *edge3)
 {
-	Point *pt1, *pt2, *pt3;
-
-
-	is_leaf = true;
-	reference_count = 1;
-	visited = false;
-	
-	pt1 = edge1->head;
-	pt2 = edge2->head;
-	pt3 = edge3->head;
-
-	EXECUTION_REPORT(REPORT_ERROR, -1, fabs(det(pt1, pt2, pt3)) > e && fabs(det(pt2, pt3, pt1)) > e && fabs(det(pt3, pt1, pt2)) > e,
-		             "remap software error1 in new Triangle");
-	EXECUTION_REPORT(REPORT_ERROR, -1, edge1->tail==edge2->head && edge2->tail==edge3->head && edge3->tail==edge1->head, "remap software error2 in new Triangle");
-   	
-	v[0] = pt1;
-	if (pt1->position_to_edge(pt2, pt3) == 1) {
-		v[1] = pt2;
-		v[2] = pt3;
-		this->edge[0] = edge1;
-		this->edge[1] = edge2;
-		this->edge[2] = edge3;
-	}
-	else {
-		v[1] = pt3;
-		v[2] = pt2;
-		this->edge[0] = edge3->twin_edge;
-		this->edge[1] = edge2->twin_edge;
-		this->edge[2] = edge1->twin_edge;
-		EXECUTION_REPORT(REPORT_ERROR, -1, edge3->twin_edge != NULL && edge2->twin_edge != NULL && edge1->twin_edge != NULL, "remap software error3 in new Triangle");
-	}
-	
-	this->edge[0]->next_edge_in_triangle = this->edge[1];
-	this->edge[1]->next_edge_in_triangle = this->edge[2];
-	this->edge[2]->next_edge_in_triangle = this->edge[0];
-	this->edge[0]->prev_edge_in_triangle = this->edge[2];
-	this->edge[1]->prev_edge_in_triangle = this->edge[0];
-	this->edge[2]->prev_edge_in_triangle = this->edge[1];
-
-	this->edge[0]->triangle = this;
-	this->edge[1]->triangle = this;
-	this->edge[2]->triangle = this;
+    Point *pt1, *pt2, *pt3;
+
+
+    is_leaf = true;
+    reference_count = 1;
+    visited = false;
+    
+    pt1 = edge1->head;
+    pt2 = edge2->head;
+    pt3 = edge3->head;
+
+    EXECUTION_REPORT(REPORT_ERROR, -1, fabs(det(pt1, pt2, pt3)) > e && fabs(det(pt2, pt3, pt1)) > e && fabs(det(pt3, pt1, pt2)) > e,
+                     "remap software error1 in new Triangle");
+    EXECUTION_REPORT(REPORT_ERROR, -1, edge1->tail==edge2->head && edge2->tail==edge3->head && edge3->tail==edge1->head, "remap software error2 in new Triangle");
+       
+    v[0] = pt1;
+    if (pt1->position_to_edge(pt2, pt3) == 1) {
+        v[1] = pt2;
+        v[2] = pt3;
+        this->edge[0] = edge1;
+        this->edge[1] = edge2;
+        this->edge[2] = edge3;
+    }
+    else {
+        v[1] = pt3;
+        v[2] = pt2;
+        this->edge[0] = edge3->twin_edge;
+        this->edge[1] = edge2->twin_edge;
+        this->edge[2] = edge1->twin_edge;
+        EXECUTION_REPORT(REPORT_ERROR, -1, edge3->twin_edge != NULL && edge2->twin_edge != NULL && edge1->twin_edge != NULL, "remap software error3 in new Triangle");
+    }
+    
+    this->edge[0]->next_edge_in_triangle = this->edge[1];
+    this->edge[1]->next_edge_in_triangle = this->edge[2];
+    this->edge[2]->next_edge_in_triangle = this->edge[0];
+    this->edge[0]->prev_edge_in_triangle = this->edge[2];
+    this->edge[1]->prev_edge_in_triangle = this->edge[0];
+    this->edge[2]->prev_edge_in_triangle = this->edge[1];
+
+    this->edge[0]->triangle = this;
+    this->edge[1]->triangle = this;
+    this->edge[2]->triangle = this;
 }
 
 
 Triangle::Triangle(Point *point1, Point *point2, Point *point3)
 {
-	if (point1->position_to_edge(point2, point3) == 1)
-		initialize_triangle_with_edges(current_delaunay_voronoi->allocate_edge(point1,point2), current_delaunay_voronoi->allocate_edge(point2,point3), current_delaunay_voronoi->allocate_edge(point3,point1));
-	else initialize_triangle_with_edges(current_delaunay_voronoi->allocate_edge(point3,point2), current_delaunay_voronoi->allocate_edge(point2,point1), current_delaunay_voronoi->allocate_edge(point1,point3));
+    if (point1->position_to_edge(point2, point3) == 1)
+        initialize_triangle_with_edges(current_delaunay_voronoi->allocate_edge(point1,point2), current_delaunay_voronoi->allocate_edge(point2,point3), current_delaunay_voronoi->allocate_edge(point3,point1));
+    else initialize_triangle_with_edges(current_delaunay_voronoi->allocate_edge(point3,point2), current_delaunay_voronoi->allocate_edge(point2,point1), current_delaunay_voronoi->allocate_edge(point1,point3));
 }
 
 
 Triangle::Triangle(Edge *edge1, Edge *edge2, Edge *edge3)
 {
-	initialize_triangle_with_edges(edge1, edge2, edge3);
+    initialize_triangle_with_edges(edge1, edge2, edge3);
 }
 
 
@@ -144,84 +144,84 @@ Triangle::~Triangle()
 
 void Triangle::check_and_set_twin_edge_relationship(Triangle *another_triangle)
 {
-	for (int i = 0; i < 3; i ++)
-		for (int j = 0; j < 3; j ++)
-			if (this->edge[i]->head == another_triangle->edge[j]->tail && this->edge[i]->tail == another_triangle->edge[j]->head) {
-				this->edge[i]->twin_edge = another_triangle->edge[j];
-				another_triangle->edge[j]->twin_edge = this->edge[i];
-			}
+    for (int i = 0; i < 3; i ++)
+        for (int j = 0; j < 3; j ++)
+            if (this->edge[i]->head == another_triangle->edge[j]->tail && this->edge[i]->tail == another_triangle->edge[j]->head) {
+                this->edge[i]->twin_edge = another_triangle->edge[j];
+                another_triangle->edge[j]->twin_edge = this->edge[i];
+            }
 }
 
 
 int Triangle::find_best_candidate_point()
 {
-	double max_min_dist = -1, min_dist, dist;
-	int best_candidate_id;
+    double max_min_dist = -1, min_dist, dist;
+    int best_candidate_id;
 
-	
-	if (remained_points_in_triangle.size() == 0)
-		return -1;
+    
+    if (remained_points_in_triangle.size() == 0)
+        return -1;
 
-	for (int i = 0; i < remained_points_in_triangle.size(); i ++) {
-		min_dist = remained_points_in_triangle[i]->calculate_distance(v[0]);
-		dist = remained_points_in_triangle[i]->calculate_distance(v[1]);
-		if (min_dist > dist)
-			min_dist = dist;
-		dist = remained_points_in_triangle[i]->calculate_distance(v[2]);
-		if (min_dist > dist)
-			min_dist = dist;
-		if (max_min_dist < min_dist) {
-			max_min_dist = min_dist;
-			best_candidate_id = i;
-		}
-	}
+    for (int i = 0; i < remained_points_in_triangle.size(); i ++) {
+        min_dist = remained_points_in_triangle[i]->calculate_distance(v[0]);
+        dist = remained_points_in_triangle[i]->calculate_distance(v[1]);
+        if (min_dist > dist)
+            min_dist = dist;
+        dist = remained_points_in_triangle[i]->calculate_distance(v[2]);
+        if (min_dist > dist)
+            min_dist = dist;
+        if (max_min_dist < min_dist) {
+            max_min_dist = min_dist;
+            best_candidate_id = i;
+        }
+    }
 
-	return best_candidate_id;
+    return best_candidate_id;
 }
 
 
 void Triangle::get_center_coordinates()
 {
-	double temp_lon1, temp_lon2, temp_lon3, min_lon;
-	temp_lon1 = v[0]->lon;
-	temp_lon2 = v[1]->lon;
-	temp_lon3 = v[2]->lon;
-	min_lon = temp_lon1;
-	if (min_lon > temp_lon2)
-		min_lon = temp_lon2;
-	if (min_lon > temp_lon3)
-		min_lon = temp_lon3;
-	if (temp_lon1-min_lon > 180)
-		temp_lon1 -= 360;
-	if (temp_lon2-min_lon > 180)
-		temp_lon2 -= 360;
-	if (temp_lon3-min_lon > 180)
-		temp_lon3 -= 360;
-	center.lat = (v[0]->lat+v[1]->lat+v[2]->lat) / 3;
-	center.lon = (temp_lon1+temp_lon2+temp_lon3) / 3;
-	if (center.lon < 0)
-		center.lon += 360;
+    double temp_lon1, temp_lon2, temp_lon3, min_lon;
+    temp_lon1 = v[0]->lon;
+    temp_lon2 = v[1]->lon;
+    temp_lon3 = v[2]->lon;
+    min_lon = temp_lon1;
+    if (min_lon > temp_lon2)
+        min_lon = temp_lon2;
+    if (min_lon > temp_lon3)
+        min_lon = temp_lon3;
+    if (temp_lon1-min_lon > 180)
+        temp_lon1 -= 360;
+    if (temp_lon2-min_lon > 180)
+        temp_lon2 -= 360;
+    if (temp_lon3-min_lon > 180)
+        temp_lon3 -= 360;
+    center.lat = (v[0]->lat+v[1]->lat+v[2]->lat) / 3;
+    center.lon = (temp_lon1+temp_lon2+temp_lon3) / 3;
+    if (center.lon < 0)
+        center.lon += 360;
 }
 
 
 Edge::Edge(Point *head, Point *tail) 
 {
-	this->head = head;
-	this->tail = tail;
-	twin_edge = NULL; 
-	prev_edge_in_triangle = NULL; 
-	next_edge_in_triangle = NULL;
-	triangle = NULL;
+    this->head = head;
+    this->tail = tail;
+    twin_edge = NULL; 
+    prev_edge_in_triangle = NULL; 
+    next_edge_in_triangle = NULL;
+    triangle = NULL;
 }
 
 
 Edge *Edge::generate_twins_edge()
 {
-	Edge *twins_edge = current_delaunay_voronoi->allocate_edge(tail, head);
-	twins_edge->twin_edge = this;
-	this->twin_edge = twins_edge;
+    Edge *twins_edge = current_delaunay_voronoi->allocate_edge(tail, head);
+    twins_edge->twin_edge = this;
+    this->twin_edge = twins_edge;
 
-	return twins_edge;
+    return twins_edge;
 }
 
 
@@ -232,255 +232,255 @@ Edge::~Edge()
 
 void Point::update_coord_values(double lon, double lat)
 {
-	this->lon = lon;
-	this->lat = lat;
-	x = cosd(lat) * cosd(lon);
-	y = cosd(lat) * sind(lon);
-	z = sind(lat);	
+    this->lon = lon;
+    this->lat = lat;
+    x = cosd(lat) * cosd(lon);
+    y = cosd(lat) * sind(lon);
+    z = sind(lat);    
 }
 
 
 Point::Point(double lat, double lon, int id)
 {
-	this->id = id;
-	update_coord_values(lon, lat);
-	this->current_triangle = NULL;
+    this->id = id;
+    update_coord_values(lon, lat);
+    this->current_triangle = NULL;
 }
 
 
 Point::Point(const Point *pt1, const Point *pt2)
 {
-	this->x = pt1->x - pt2->x;
-	this->y = pt1->y - pt2->y;
-	this->z = pt1->z - pt2->z;
+    this->x = pt1->x - pt2->x;
+    this->y = pt1->y - pt2->y;
+    this->z = pt1->z - pt2->z;
 }
 
 
 double Point::calculate_distance(const Point *pt) const
 {
-	return calculate_distance_of_two_points_2D(lon, lat, pt->lon, pt->lat, true);
+    return calculate_distance_of_two_points_2D(lon, lat, pt->lon, pt->lat, true);
 }
 
 
 /**
  * Check point's position relative to an edge<pt1, pt2>
  * Points should be distinct
- * @param  pt1	the head of the edge
- * @param  pt2	the head of the edge 
- * @return	1	left
- *			0	on
- *			-1	right
+ * @param  pt1    the head of the edge
+ * @param  pt2    the head of the edge 
+ * @return    1    left
+ *            0    on
+ *            -1    right
  */
 int Point::position_to_edge(const Point *pt1, const Point *pt2) const
 {
-	double res1 = det(pt1, pt2, this);
+    double res1 = det(pt1, pt2, this);
 
 
-	if (fabs(res1) <= e)
-		return 0;
-	else if (res1 > 0)
-		return 1;
-	else return -1;
+    if (fabs(res1) <= e)
+        return 0;
+    else if (res1 > 0)
+        return 1;
+    else return -1;
 }
 
 
 /**
  * Check point's position relative to a triangle
  * This point and points of the triangle should be distinct
- * @return	 0	inside
- *			-1	outside
- *			 1	lies on the edge <pt1, pt2>
- *			 2	lies on the edge <pt2, pt3>
- *			 3	lies on the edge <pt3, pt1>
+ * @return     0    inside
+ *            -1    outside
+ *             1    lies on the edge <pt1, pt2>
+ *             2    lies on the edge <pt2, pt3>
+ *             3    lies on the edge <pt3, pt1>
  */
 int Point::position_to_triangle(const Triangle *triangle) const
 {
-	int pos, ret = 0;
-	pos = position_to_edge(triangle->v[0], triangle->v[1]);
-	if (pos == -1)
-		return -1;
-	else if (pos == 0)
-		ret = 1;
-	pos = position_to_edge(triangle->v[1], triangle->v[2]);
-	if (pos == -1)
-		return -1;
-	else if (pos == 0)
-		ret = 2;
-	pos = position_to_edge(triangle->v[2], triangle->v[0]);
-	if (pos == -1)
-		return -1;
-	else if (pos == 0)
-		ret = 3;
-	return ret;
+    int pos, ret = 0;
+    pos = position_to_edge(triangle->v[0], triangle->v[1]);
+    if (pos == -1)
+        return -1;
+    else if (pos == 0)
+        ret = 1;
+    pos = position_to_edge(triangle->v[1], triangle->v[2]);
+    if (pos == -1)
+        return -1;
+    else if (pos == 0)
+        ret = 2;
+    pos = position_to_edge(triangle->v[2], triangle->v[0]);
+    if (pos == -1)
+        return -1;
+    else if (pos == 0)
+        ret = 3;
+    return ret;
 }
 
 ostream& operator<<(ostream &out, const Point &point)
 {
-	out<<'('<<point.lat<<','<<point.lon<<')';
-	return out;
+    out<<'('<<point.lat<<','<<point.lon<<')';
+    return out;
 }
 
 
 void Delaunay_Voronoi::check_and_set_twin_edge_relationship(vector<Triangle*> *triangles)
 {
-	for (int i = 0; i < triangles->size(); i ++)
-		for (int j = i+1; j < triangles->size(); j ++)
-			(*triangles)[i]->check_and_set_twin_edge_relationship((*triangles)[j]);
+    for (int i = 0; i < triangles->size(); i ++)
+        for (int j = i+1; j < triangles->size(); j ++)
+            (*triangles)[i]->check_and_set_twin_edge_relationship((*triangles)[j]);
 }
 
 
 Point *Delaunay_Voronoi::generate_boundary_point(double lon, double lat, Triangle *root, bool is_virtual_point)
 {
-	vector<Point*>::iterator boundary_iter;
-	Point *boundary_point;
+    vector<Point*>::iterator boundary_iter;
+    Point *boundary_point;
 
-	
-	if (is_virtual_point)
-		return new Point(lat, lon);
+    
+    if (is_virtual_point)
+        return new Point(lat, lon);
 
-	Point temp_point(lat, lon);
-	boundary_iter = get_nearest_point(&temp_point, &(root->remained_points_in_triangle));
-	boundary_point = *boundary_iter;
-	root->remained_points_in_triangle.erase(boundary_iter);
-	return boundary_point;
+    Point temp_point(lat, lon);
+    boundary_iter = get_nearest_point(&temp_point, &(root->remained_points_in_triangle));
+    boundary_point = *boundary_iter;
+    root->remained_points_in_triangle.erase(boundary_iter);
+    return boundary_point;
 }
 
 
 void Delaunay_Voronoi::generate_initial_triangles(Triangle *root, vector<Point*> *boundary_points1, vector<Point*> *boundary_points2, bool cyclic)
 {
-	int i, max_i, i1, i2, j1, j2;
+    int i, max_i, i1, i2, j1, j2;
 
-	
-	EXECUTION_REPORT(REPORT_ERROR, -1, boundary_points1->size()==boundary_points2->size() || boundary_points1->size()==1 || boundary_points2->size()==1,
-		             "remap software error in generate_initial_triangles");
-	max_i = boundary_points1->size() > boundary_points2->size()? boundary_points1->size() : boundary_points2->size();
-	if (!cyclic)
-		max_i --;
-	for (i = 0; i < max_i; i ++) {
-		i1 = i % boundary_points1->size();
-		i2 = (i+1) % boundary_points1->size();
-		j1 = i % boundary_points2->size();
-		j2 = (i+1) % boundary_points2->size();
-		if (j1 != j2)
-			root->children.push_back(current_delaunay_voronoi->allocate_Triangle((*boundary_points1)[i1], (*boundary_points2)[j1], (*boundary_points2)[j2]));
-		if (i1 != i2)
-			root->children.push_back(current_delaunay_voronoi->allocate_Triangle((*boundary_points2)[j2], (*boundary_points1)[i2], (*boundary_points1)[i1]));
-	}
+    
+    EXECUTION_REPORT(REPORT_ERROR, -1, boundary_points1->size()==boundary_points2->size() || boundary_points1->size()==1 || boundary_points2->size()==1,
+                     "remap software error in generate_initial_triangles");
+    max_i = boundary_points1->size() > boundary_points2->size()? boundary_points1->size() : boundary_points2->size();
+    if (!cyclic)
+        max_i --;
+    for (i = 0; i < max_i; i ++) {
+        i1 = i % boundary_points1->size();
+        i2 = (i+1) % boundary_points1->size();
+        j1 = i % boundary_points2->size();
+        j2 = (i+1) % boundary_points2->size();
+        if (j1 != j2)
+            root->children.push_back(current_delaunay_voronoi->allocate_Triangle((*boundary_points1)[i1], (*boundary_points2)[j1], (*boundary_points2)[j2]));
+        if (i1 != i2)
+            root->children.push_back(current_delaunay_voronoi->allocate_Triangle((*boundary_points2)[j2], (*boundary_points1)[i2], (*boundary_points1)[i1]));
+    }
 }
 
 
 void Delaunay_Voronoi::get_convex_set(int num_points, double *lat_values, double *lon_values, double min_lon, double max_lon, int &num_convex_set_points, int **convex_set_points_indx_ptr)
 {
-	double *temp_lat_values, *temp_lon_values, *points_angle_to_start;
-	double start_point_lat, start_point_lon, dx, dy;
-	int *index, *convex_set_points_indx;
-	int i, j, start_point_indx, num_convex_point_candidates, pos;
-	Point edge_start, edge_end, candidate_point;
-
-
-	points_angle_to_start = new double [num_points];
-	temp_lat_values = new double [num_points];
-	temp_lon_values = new double [num_points];
-	index = new int [num_points];
-	convex_set_points_indx = new int [num_points];
-	start_point_indx = -1;
-	for (i = 0; i < num_points; i ++) {
-		temp_lat_values[i] = lat_values[i];
-		temp_lon_values[i] = lon_values[i];
-		if (min_lon > max_lon && lon_values[i] < 360)
-			temp_lon_values[i] = lon_values[i] + 360;
-		if (start_point_indx == -1) {
-			start_point_lon = lon_values[0];
-			start_point_lat = lat_values[0];
-			start_point_indx = 0;
-		}
-		if (start_point_lat > lat_values[i] || (start_point_lat == lat_values[i] && start_point_lon > lon_values[i])) {
-			start_point_lon = lon_values[i];
-			start_point_lat = lat_values[i];
-			start_point_indx = i;
-		}
-	}
-
-	for (i = 0; i < num_points; i ++) {
-		index[i] = i;
-		if (i == start_point_indx) {
-			points_angle_to_start[i] = 0;
-			continue;
-		}
-		dx = temp_lon_values[i] - start_point_lon;
-		dy = temp_lat_values[i] - start_point_lat;
-		EXECUTION_REPORT(REPORT_ERROR, -1, dy >= 0, "Software error in Delaunay_Voronoi::get_convex_set");
-		if (dx == 0) {
-			points_angle_to_start[i] = 90;
-			continue;
-		}
-		points_angle_to_start[i] = atan(dy/dx)*180/PI;
-		if (points_angle_to_start[i] < 0)
-			points_angle_to_start[i] += 180;
-	}
-
-	do_quick_sort(points_angle_to_start, index, 0, num_points-1);
-	
-	for (i = 1, num_convex_point_candidates = 1; i < num_points; i ++) {
-		if (points_angle_to_start[i] != points_angle_to_start[i-1]) {
-			index[num_convex_point_candidates++] = index[i];
-			continue;
-		}
-		double dist1, dist2, dx, dy;
-		dx = temp_lon_values[index[num_convex_point_candidates-1]] - start_point_lon;
-		dy = temp_lat_values[index[num_convex_point_candidates-1]] - start_point_lat;
-		dist1 = dx*dx+dy*dy;
-		dx = temp_lon_values[index[i]] - start_point_lon;
-		dy = temp_lat_values[index[i]] - start_point_lat;
-		dist2 = dx*dx+dy*dy;
-		if (dist2 > dist1)
-			index[num_convex_point_candidates-1] = index[i];
-	}
-
-	EXECUTION_REPORT(REPORT_ERROR, -1, num_convex_point_candidates >= 3, "Software error2 in Delaunay_Voronoi::get_convex_set");
-
-	num_convex_set_points = 0;
-	convex_set_points_indx[num_convex_set_points++] = index[0];
-	convex_set_points_indx[num_convex_set_points++] = index[1];
-	convex_set_points_indx[num_convex_set_points++] = index[2];
-
-	for (i = 3; i < num_convex_point_candidates; i ++) {
-		for (j = num_convex_set_points-1; j > 0; j --) {
-			edge_start.update_coord_values(temp_lon_values[convex_set_points_indx[j-1]], temp_lat_values[convex_set_points_indx[j-1]]);
-			edge_end.update_coord_values(temp_lon_values[convex_set_points_indx[j]], temp_lat_values[convex_set_points_indx[j]]);
-			candidate_point.update_coord_values(temp_lon_values[index[i]], temp_lat_values[index[i]]);
-			pos = candidate_point.position_to_edge(&edge_start, &edge_end);
-			if (pos == 1 || pos == 0)
-				break;
-		}
-		num_convex_set_points = j+1;
-		convex_set_points_indx[num_convex_set_points++] = index[i];
-	}
-
-	for (i = 0; i < num_points; i ++) {
-		for (j = 0; j < num_convex_set_points; j ++)
-			if (i == convex_set_points_indx[j])
-				break;
-		if (i < num_convex_set_points)
-			continue;
-		for (j = 0; j < num_convex_set_points; j ++) {
-			int j1 = j-1;
-			if (j1 < 0)
-				j1 += num_convex_set_points;
-			edge_start.update_coord_values(temp_lon_values[convex_set_points_indx[j1]], temp_lat_values[convex_set_points_indx[j1]]);
-			edge_end.update_coord_values(temp_lon_values[convex_set_points_indx[j]], temp_lat_values[convex_set_points_indx[j]]);
-			candidate_point.update_coord_values(temp_lon_values[index[i]], temp_lat_values[index[i]]);
-			pos = candidate_point.position_to_edge(&edge_start, &edge_end);
-			EXECUTION_REPORT(REPORT_ERROR, -1, pos >= 0, "Software error4 in Delaunay_Voronoi::get_convex_set");
-		}
-	}
-	
-	*convex_set_points_indx_ptr = convex_set_points_indx;
-
-	delete [] temp_lon_values;
-	delete [] temp_lat_values;
-	delete [] index;
-	delete [] points_angle_to_start;
+    double *temp_lat_values, *temp_lon_values, *points_angle_to_start;
+    double start_point_lat, start_point_lon, dx, dy;
+    int *index, *convex_set_points_indx;
+    int i, j, start_point_indx, num_convex_point_candidates, pos;
+    Point edge_start, edge_end, candidate_point;
+
+
+    points_angle_to_start = new double [num_points];
+    temp_lat_values = new double [num_points];
+    temp_lon_values = new double [num_points];
+    index = new int [num_points];
+    convex_set_points_indx = new int [num_points];
+    start_point_indx = -1;
+    for (i = 0; i < num_points; i ++) {
+        temp_lat_values[i] = lat_values[i];
+        temp_lon_values[i] = lon_values[i];
+        if (min_lon > max_lon && lon_values[i] < 360)
+            temp_lon_values[i] = lon_values[i] + 360;
+        if (start_point_indx == -1) {
+            start_point_lon = lon_values[0];
+            start_point_lat = lat_values[0];
+            start_point_indx = 0;
+        }
+        if (start_point_lat > lat_values[i] || (start_point_lat == lat_values[i] && start_point_lon > lon_values[i])) {
+            start_point_lon = lon_values[i];
+            start_point_lat = lat_values[i];
+            start_point_indx = i;
+        }
+    }
+
+    for (i = 0; i < num_points; i ++) {
+        index[i] = i;
+        if (i == start_point_indx) {
+            points_angle_to_start[i] = 0;
+            continue;
+        }
+        dx = temp_lon_values[i] - start_point_lon;
+        dy = temp_lat_values[i] - start_point_lat;
+        EXECUTION_REPORT(REPORT_ERROR, -1, dy >= 0, "Software error in Delaunay_Voronoi::get_convex_set");
+        if (dx == 0) {
+            points_angle_to_start[i] = 90;
+            continue;
+        }
+        points_angle_to_start[i] = atan(dy/dx)*180/PI;
+        if (points_angle_to_start[i] < 0)
+            points_angle_to_start[i] += 180;
+    }
+
+    do_quick_sort(points_angle_to_start, index, 0, num_points-1);
+    
+    for (i = 1, num_convex_point_candidates = 1; i < num_points; i ++) {
+        if (points_angle_to_start[i] != points_angle_to_start[i-1]) {
+            index[num_convex_point_candidates++] = index[i];
+            continue;
+        }
+        double dist1, dist2, dx, dy;
+        dx = temp_lon_values[index[num_convex_point_candidates-1]] - start_point_lon;
+        dy = temp_lat_values[index[num_convex_point_candidates-1]] - start_point_lat;
+        dist1 = dx*dx+dy*dy;
+        dx = temp_lon_values[index[i]] - start_point_lon;
+        dy = temp_lat_values[index[i]] - start_point_lat;
+        dist2 = dx*dx+dy*dy;
+        if (dist2 > dist1)
+            index[num_convex_point_candidates-1] = index[i];
+    }
+
+    EXECUTION_REPORT(REPORT_ERROR, -1, num_convex_point_candidates >= 3, "Software error2 in Delaunay_Voronoi::get_convex_set");
+
+    num_convex_set_points = 0;
+    convex_set_points_indx[num_convex_set_points++] = index[0];
+    convex_set_points_indx[num_convex_set_points++] = index[1];
+    convex_set_points_indx[num_convex_set_points++] = index[2];
+
+    for (i = 3; i < num_convex_point_candidates; i ++) {
+        for (j = num_convex_set_points-1; j > 0; j --) {
+            edge_start.update_coord_values(temp_lon_values[convex_set_points_indx[j-1]], temp_lat_values[convex_set_points_indx[j-1]]);
+            edge_end.update_coord_values(temp_lon_values[convex_set_points_indx[j]], temp_lat_values[convex_set_points_indx[j]]);
+            candidate_point.update_coord_values(temp_lon_values[index[i]], temp_lat_values[index[i]]);
+            pos = candidate_point.position_to_edge(&edge_start, &edge_end);
+            if (pos == 1 || pos == 0)
+                break;
+        }
+        num_convex_set_points = j+1;
+        convex_set_points_indx[num_convex_set_points++] = index[i];
+    }
+
+    for (i = 0; i < num_points; i ++) {
+        for (j = 0; j < num_convex_set_points; j ++)
+            if (i == convex_set_points_indx[j])
+                break;
+        if (i < num_convex_set_points)
+            continue;
+        for (j = 0; j < num_convex_set_points; j ++) {
+            int j1 = j-1;
+            if (j1 < 0)
+                j1 += num_convex_set_points;
+            edge_start.update_coord_values(temp_lon_values[convex_set_points_indx[j1]], temp_lat_values[convex_set_points_indx[j1]]);
+            edge_end.update_coord_values(temp_lon_values[convex_set_points_indx[j]], temp_lat_values[convex_set_points_indx[j]]);
+            candidate_point.update_coord_values(temp_lon_values[index[i]], temp_lat_values[index[i]]);
+            pos = candidate_point.position_to_edge(&edge_start, &edge_end);
+            EXECUTION_REPORT(REPORT_ERROR, -1, pos >= 0, "Software error4 in Delaunay_Voronoi::get_convex_set");
+        }
+    }
+    
+    *convex_set_points_indx_ptr = convex_set_points_indx;
+
+    delete [] temp_lon_values;
+    delete [] temp_lat_values;
+    delete [] index;
+    delete [] points_angle_to_start;
 }
 
 
@@ -488,506 +488,506 @@ Delaunay_Voronoi::Delaunay_Voronoi(int num_points, double *lat_values, double *l
                    double min_lon, double max_lon, double min_lat, double max_lat, bool *redundant_cell_mark,
                    double **output_vertex_lon_values, double **output_vertex_lat_values, int *output_num_vertexes)
 {
-	Triangle *root;
-	struct timeval start, end;
-	gettimeofday(&start, NULL);
-	Point boundary_point1, boundary_point2, boundary_point3, boundary_point4, boundary_point5, boundary_point6;
-	int i, j;
-	int max_num_vertexes, current_num_vertices;
-	double *tmp_vertexes_lons, *tmp_vertexes_lats;
-	double boundary_point_lons[256];
-	vector<Point*> boundary_points[3];
-	int set_id = 0;
-	bool cyclic = min_lon==0 && max_lon==360, *mark;
-	int num_convex_set_points, *convex_set_points_indx;
-
-	current_delaunay_voronoi = this;
-
-	num_cells = num_points;
-	
-	mark = new bool [num_points];
-	for (i = 0; i < num_points; i ++)
-		mark[i] = true;
-
-	if (max_lat != 90 && min_lat != -90 && !cyclic && false) {
-		get_convex_set(num_points, lat_values, lon_values, min_lon, max_lon, num_convex_set_points, &convex_set_points_indx);
-		for (i = 0; i < num_convex_set_points; i ++)
-			mark[convex_set_points_indx[i]] = false;
-	}
-
-	this->is_global_grid = is_global_grid;
-
-	root = new Triangle();
-
-	cells = new Cell[num_points];	
-	for (i = 0; i < num_points; i ++) {
-		Point *point = new Point(lat_values[i], lon_values[i], i);
-		cells[i].center = point;
-		if (!mark[i])
-			continue;
-		if (!redundant_cell_mark[i]) {
-			point->current_triangle = root;
-			root->remained_points_in_triangle.push_back(point);
-		}
-	}
-	
-	delete [] mark;
-
-	EXECUTION_REPORT_LOG(REPORT_LOG, -1, true, "there are %d valid grid points in the grid for Voronoi generation: %lf %lf %lf %lf", root->remained_points_in_triangle.size(), min_lon, max_lon, min_lat, max_lat);
-
-	if (cyclic) {
-		for (i = 0; i < 4; i ++)
-			boundary_point_lons[i] = i*90;
-	}
-	else {
-		boundary_point_lons[0] = min_lon;
-		boundary_point_lons[3] = max_lon;
-		if (min_lon < max_lon) {
-			boundary_point_lons[1] = (max_lon-min_lon)/3+min_lon;
-			boundary_point_lons[2] = (max_lon-min_lon)*2/3+min_lon;
-		}
-		else {
-			boundary_point_lons[1] = (max_lon-min_lon+360)/3+min_lon;
-			boundary_point_lons[2] = (max_lon-min_lon+360)*2/3+min_lon;
-			if (boundary_point_lons[1] >= 360)
-				boundary_point_lons[1] -= 360;
-			if (boundary_point_lons[2] >= 360)
-				boundary_point_lons[2] -= 360;
-		}
-	}
-
-	if (max_lat == 90) {
-		if (cyclic)
-			boundary_points[set_id++].push_back(generate_boundary_point(0, max_lat, root, false));
-		else boundary_points[set_id++].push_back(generate_boundary_point(0, max_lat, root, true));
-	}
-	else {
-		double enlarged_max_lat1 = max_lat + (max_lat-min_lat) / 3;
-		double enlarged_max_lat2 = max_lat + (90.0-max_lat) / 2;
-		double enlarged_max_lat = enlarged_max_lat1 < enlarged_max_lat2? enlarged_max_lat1 : enlarged_max_lat2;
-		EXECUTION_REPORT_LOG(REPORT_LOG, -1, true, "enlarged_max_lat is %lf vs %lf", enlarged_max_lat, max_lat);
-		for (i = 0; i < 4; i ++)
-			boundary_points[set_id].push_back(generate_boundary_point(boundary_point_lons[i], enlarged_max_lat, root, true));
-		set_id ++;
-	}
-	if (is_global_grid || min_lat == -90 && max_lat == 90) {
-		for (i = 0; i < 4; i ++)
-			boundary_points[set_id].push_back(generate_boundary_point(boundary_point_lons[i], 0, root, false));
-		set_id ++;		
-	}
-	if (min_lat == -90) {
-		if (cyclic)
-			boundary_points[set_id++].push_back(generate_boundary_point(0, min_lat, root, false));
-		else boundary_points[set_id++].push_back(generate_boundary_point(0, min_lat, root, true));
-	}
-	else {
-		double enlarged_min_lat1 = min_lat - (max_lat-min_lat) / 3;
-		double enlarged_min_lat2 = min_lat - (min_lat+90.0) / 2;
-		double enlarged_min_lat = enlarged_min_lat1 > enlarged_min_lat2? enlarged_min_lat1 : enlarged_min_lat2;
-		EXECUTION_REPORT_LOG(REPORT_LOG, -1, true, "enlarged_min_lat is %lf vs %lf", enlarged_min_lat, min_lat);
-		for (i = 0; i < 4; i ++)
-			boundary_points[set_id].push_back(generate_boundary_point(boundary_point_lons[i], enlarged_min_lat, root, true));
-		set_id ++;
-	}
-
-	if (max_lat != 90 && min_lat != -90 && !cyclic && false) {
-		boundary_points[0].clear();
-		boundary_points[1].clear();
-		for (i = 1; i < num_convex_set_points; i ++) {
-			boundary_points[1].push_back(new Point(lat_values[convex_set_points_indx[i]], lon_values[convex_set_points_indx[i]], convex_set_points_indx[i]));
-			cells[convex_set_points_indx[i]].center = boundary_points[1][boundary_points[1].size()-1];
-		}
-		boundary_points[0].push_back(new Point(lat_values[convex_set_points_indx[0]], lon_values[convex_set_points_indx[0]], convex_set_points_indx[0]));
-		cells[convex_set_points_indx[0]].center = boundary_points[0][boundary_points[0].size()-1];
-		set_id = 2;
-		delete [] convex_set_points_indx;
-	}
-
-	generate_initial_triangles(root, &boundary_points[0], &boundary_points[1], cyclic);
-	if (set_id > 2)
-		generate_initial_triangles(root, &boundary_points[1], &boundary_points[2], cyclic);
-	check_and_set_twin_edge_relationship(&(root->children));
-	for (i = 0; i < root->children.size(); i ++)
-		root->children[i]->reference_count ++;
-
-	distribute_points_into_triangles(&(root->remained_points_in_triangle), &(root->children));
-	for (int i = 0; i < root->children.size(); i ++)
-		triangularization_process(root->children[i], is_global_grid);
-
-	generate_Voronoi_diagram();
-	extract_vertex_coordinate_values(num_points, is_global_grid, output_vertex_lon_values, output_vertex_lat_values, output_num_vertexes);
-
-	/* Below is for testing */
-	gettimeofday(&end, NULL);
+    Triangle *root;
+    struct timeval start, end;
+    gettimeofday(&start, NULL);
+    Point boundary_point1, boundary_point2, boundary_point3, boundary_point4, boundary_point5, boundary_point6;
+    int i, j;
+    int max_num_vertexes, current_num_vertices;
+    double *tmp_vertexes_lons, *tmp_vertexes_lats;
+    double boundary_point_lons[256];
+    vector<Point*> boundary_points[3];
+    int set_id = 0;
+    bool cyclic = min_lon==0 && max_lon==360, *mark;
+    int num_convex_set_points, *convex_set_points_indx;
+
+    current_delaunay_voronoi = this;
+
+    num_cells = num_points;
+    
+    mark = new bool [num_points];
+    for (i = 0; i < num_points; i ++)
+        mark[i] = true;
+
+    if (max_lat != 90 && min_lat != -90 && !cyclic && false) {
+        get_convex_set(num_points, lat_values, lon_values, min_lon, max_lon, num_convex_set_points, &convex_set_points_indx);
+        for (i = 0; i < num_convex_set_points; i ++)
+            mark[convex_set_points_indx[i]] = false;
+    }
+
+    this->is_global_grid = is_global_grid;
+
+    root = new Triangle();
+
+    cells = new Cell[num_points];    
+    for (i = 0; i < num_points; i ++) {
+        Point *point = new Point(lat_values[i], lon_values[i], i);
+        cells[i].center = point;
+        if (!mark[i])
+            continue;
+        if (redundant_cell_mark == NULL || !redundant_cell_mark[i]) {
+            point->current_triangle = root;
+            root->remained_points_in_triangle.push_back(point);
+        }
+    }
+    
+    delete [] mark;
+
+    EXECUTION_REPORT_LOG(REPORT_LOG, -1, true, "there are %d valid grid points in the grid for Voronoi generation: %lf %lf %lf %lf", root->remained_points_in_triangle.size(), min_lon, max_lon, min_lat, max_lat);
+
+    if (cyclic) {
+        for (i = 0; i < 4; i ++)
+            boundary_point_lons[i] = i*90;
+    }
+    else {
+        boundary_point_lons[0] = min_lon;
+        boundary_point_lons[3] = max_lon;
+        if (min_lon < max_lon) {
+            boundary_point_lons[1] = (max_lon-min_lon)/3+min_lon;
+            boundary_point_lons[2] = (max_lon-min_lon)*2/3+min_lon;
+        }
+        else {
+            boundary_point_lons[1] = (max_lon-min_lon+360)/3+min_lon;
+            boundary_point_lons[2] = (max_lon-min_lon+360)*2/3+min_lon;
+            if (boundary_point_lons[1] >= 360)
+                boundary_point_lons[1] -= 360;
+            if (boundary_point_lons[2] >= 360)
+                boundary_point_lons[2] -= 360;
+        }
+    }
+
+    if (max_lat == 90) {
+        if (cyclic)
+            boundary_points[set_id++].push_back(generate_boundary_point(0, max_lat, root, false));
+        else boundary_points[set_id++].push_back(generate_boundary_point(0, max_lat, root, true));
+    }
+    else {
+        double enlarged_max_lat1 = max_lat + (max_lat-min_lat) / 3;
+        double enlarged_max_lat2 = max_lat + (90.0-max_lat) / 2;
+        double enlarged_max_lat = enlarged_max_lat1 < enlarged_max_lat2? enlarged_max_lat1 : enlarged_max_lat2;
+        EXECUTION_REPORT_LOG(REPORT_LOG, -1, true, "enlarged_max_lat is %lf vs %lf", enlarged_max_lat, max_lat);
+        for (i = 0; i < 4; i ++)
+            boundary_points[set_id].push_back(generate_boundary_point(boundary_point_lons[i], enlarged_max_lat, root, true));
+        set_id ++;
+    }
+    if (is_global_grid || min_lat == -90 && max_lat == 90) {
+        for (i = 0; i < 4; i ++)
+            boundary_points[set_id].push_back(generate_boundary_point(boundary_point_lons[i], 0, root, false));
+        set_id ++;        
+    }
+    if (min_lat == -90) {
+        if (cyclic)
+            boundary_points[set_id++].push_back(generate_boundary_point(0, min_lat, root, false));
+        else boundary_points[set_id++].push_back(generate_boundary_point(0, min_lat, root, true));
+    }
+    else {
+        double enlarged_min_lat1 = min_lat - (max_lat-min_lat) / 3;
+        double enlarged_min_lat2 = min_lat - (min_lat+90.0) / 2;
+        double enlarged_min_lat = enlarged_min_lat1 > enlarged_min_lat2? enlarged_min_lat1 : enlarged_min_lat2;
+        EXECUTION_REPORT_LOG(REPORT_LOG, -1, true, "enlarged_min_lat is %lf vs %lf", enlarged_min_lat, min_lat);
+        for (i = 0; i < 4; i ++)
+            boundary_points[set_id].push_back(generate_boundary_point(boundary_point_lons[i], enlarged_min_lat, root, true));
+        set_id ++;
+    }
+
+    if (max_lat != 90 && min_lat != -90 && !cyclic && false) {
+        boundary_points[0].clear();
+        boundary_points[1].clear();
+        for (i = 1; i < num_convex_set_points; i ++) {
+            boundary_points[1].push_back(new Point(lat_values[convex_set_points_indx[i]], lon_values[convex_set_points_indx[i]], convex_set_points_indx[i]));
+            cells[convex_set_points_indx[i]].center = boundary_points[1][boundary_points[1].size()-1];
+        }
+        boundary_points[0].push_back(new Point(lat_values[convex_set_points_indx[0]], lon_values[convex_set_points_indx[0]], convex_set_points_indx[0]));
+        cells[convex_set_points_indx[0]].center = boundary_points[0][boundary_points[0].size()-1];
+        set_id = 2;
+        delete [] convex_set_points_indx;
+    }
+
+    generate_initial_triangles(root, &boundary_points[0], &boundary_points[1], cyclic);
+    if (set_id > 2)
+        generate_initial_triangles(root, &boundary_points[1], &boundary_points[2], cyclic);
+    check_and_set_twin_edge_relationship(&(root->children));
+    for (i = 0; i < root->children.size(); i ++)
+        root->children[i]->reference_count ++;
+
+    distribute_points_into_triangles(&(root->remained_points_in_triangle), &(root->children));
+    for (int i = 0; i < root->children.size(); i ++)
+        triangularization_process(root->children[i], is_global_grid);
+
+    generate_Voronoi_diagram();
+    extract_vertex_coordinate_values(num_points, is_global_grid, output_vertex_lon_values, output_vertex_lat_values, output_num_vertexes);
+
+    /* Below is for testing */
+    gettimeofday(&end, NULL);
 }
 
 
 void Delaunay_Voronoi::extract_vertex_coordinate_values(int num_points, bool is_global_grid, 
                                  double **output_vertex_lon_values, double **output_vertex_lat_values, int *output_num_vertexes)
 {
-	int i, j; 
-	int max_num_vertexes, current_num_vertices;
-	double *tmp_vertexes_lons, *tmp_vertexes_lats;
-
-
-	max_num_vertexes = 0;
-	for (i = 0; i < num_points; i ++) {
-		if (cells[i].vertexes_lons.size() > max_num_vertexes)
-			max_num_vertexes = cells[i].vertexes_lons.size();
-	}
-	max_num_vertexes ++;
-	tmp_vertexes_lons = new double [max_num_vertexes];
-	tmp_vertexes_lats = new double [max_num_vertexes];
-
-	max_num_vertexes = 0;
-	for (i = 0; i < num_points; i++) {
-		current_num_vertices = cells[i].vertexes_lons.size();
-		for (j = 0; j < current_num_vertices; j ++) {
-			tmp_vertexes_lons[j] = cells[i].vertexes_lons[j];
-			tmp_vertexes_lats[j] = cells[i].vertexes_lats[j];
-		}
-		sort_vertexes_of_sphere_cell(current_num_vertices, tmp_vertexes_lons, tmp_vertexes_lats);
-		if (!is_point_in_2D_cell(cells[i].center->lon, cells[i].center->lat, tmp_vertexes_lons, tmp_vertexes_lats, 
-			                     current_num_vertices, true, true, true)) {
-//			EXECUTION_REPORT(REPORT_ERROR, -1, !is_global_grid, "remap software erorr in extract_vertex_coordinate_values\n");
-			tmp_vertexes_lons[current_num_vertices] = cells[i].center->lon;
-			tmp_vertexes_lats[current_num_vertices] = cells[i].center->lat;
-			current_num_vertices ++;
-			sort_vertexes_of_sphere_cell(current_num_vertices, tmp_vertexes_lons, tmp_vertexes_lats);
-		}
-		if (current_num_vertices > max_num_vertexes)
-			max_num_vertexes = current_num_vertices;
-		cells[i].vertexes_lons.clear();
-		cells[i].vertexes_lats.clear();
-		for (j = 0; j < current_num_vertices; j ++) {
-			cells[i].vertexes_lons.push_back(tmp_vertexes_lons[j]);
-			cells[i].vertexes_lats.push_back(tmp_vertexes_lats[j]);
-		}
-	}	
-
-	*output_num_vertexes = max_num_vertexes;
-	*output_vertex_lon_values = new double [max_num_vertexes*num_points];
-	*output_vertex_lat_values = new double [max_num_vertexes*num_points];
-	for (i = 0; i < max_num_vertexes*num_points; i ++) {
-		(*output_vertex_lon_values)[i] = NULL_COORD_VALUE;
-		(*output_vertex_lat_values)[i] = NULL_COORD_VALUE;
-	}
-	
-	for (i = 0; i < num_points; i++) {
-		for (j = 0; j < cells[i].vertexes_lons.size(); j ++) {
-			(*output_vertex_lon_values)[i*max_num_vertexes+j] = cells[i].vertexes_lons[j];
-			(*output_vertex_lat_values)[i*max_num_vertexes+j] = cells[i].vertexes_lats[j];
-		}
-	}
-
-	delete [] tmp_vertexes_lons;
-	delete [] tmp_vertexes_lats;
+    int i, j; 
+    int max_num_vertexes, current_num_vertices;
+    double *tmp_vertexes_lons, *tmp_vertexes_lats;
+
+
+    max_num_vertexes = 0;
+    for (i = 0; i < num_points; i ++) {
+        if (cells[i].vertexes_lons.size() > max_num_vertexes)
+            max_num_vertexes = cells[i].vertexes_lons.size();
+    }
+    max_num_vertexes ++;
+    tmp_vertexes_lons = new double [max_num_vertexes];
+    tmp_vertexes_lats = new double [max_num_vertexes];
+
+    max_num_vertexes = 0;
+    for (i = 0; i < num_points; i++) {
+        current_num_vertices = cells[i].vertexes_lons.size();
+        for (j = 0; j < current_num_vertices; j ++) {
+            tmp_vertexes_lons[j] = cells[i].vertexes_lons[j];
+            tmp_vertexes_lats[j] = cells[i].vertexes_lats[j];
+        }
+        sort_vertexes_of_sphere_cell(current_num_vertices, tmp_vertexes_lons, tmp_vertexes_lats);
+        if (!is_point_in_2D_cell(cells[i].center->lon, cells[i].center->lat, tmp_vertexes_lons, tmp_vertexes_lats, 
+                                 current_num_vertices, true, true, true)) {
+//            EXECUTION_REPORT(REPORT_ERROR, -1, !is_global_grid, "remap software erorr in extract_vertex_coordinate_values\n");
+            tmp_vertexes_lons[current_num_vertices] = cells[i].center->lon;
+            tmp_vertexes_lats[current_num_vertices] = cells[i].center->lat;
+            current_num_vertices ++;
+            sort_vertexes_of_sphere_cell(current_num_vertices, tmp_vertexes_lons, tmp_vertexes_lats);
+        }
+        if (current_num_vertices > max_num_vertexes)
+            max_num_vertexes = current_num_vertices;
+        cells[i].vertexes_lons.clear();
+        cells[i].vertexes_lats.clear();
+        for (j = 0; j < current_num_vertices; j ++) {
+            cells[i].vertexes_lons.push_back(tmp_vertexes_lons[j]);
+            cells[i].vertexes_lats.push_back(tmp_vertexes_lats[j]);
+        }
+    }    
+
+    *output_num_vertexes = max_num_vertexes;
+    *output_vertex_lon_values = new double [max_num_vertexes*num_points];
+    *output_vertex_lat_values = new double [max_num_vertexes*num_points];
+    for (i = 0; i < max_num_vertexes*num_points; i ++) {
+        (*output_vertex_lon_values)[i] = NULL_COORD_VALUE;
+        (*output_vertex_lat_values)[i] = NULL_COORD_VALUE;
+    }
+    
+    for (i = 0; i < num_points; i++) {
+        for (j = 0; j < cells[i].vertexes_lons.size(); j ++) {
+            (*output_vertex_lon_values)[i*max_num_vertexes+j] = cells[i].vertexes_lons[j];
+            (*output_vertex_lat_values)[i*max_num_vertexes+j] = cells[i].vertexes_lats[j];
+        }
+    }
+
+    delete [] tmp_vertexes_lons;
+    delete [] tmp_vertexes_lats;
 }
 
 
 Triangle *Delaunay_Voronoi::search_triangle_with_point(Triangle *cur_triangle, const Point *pt)
 {
-	if (pt->position_to_triangle(cur_triangle) < 0)
-		return NULL;
-	
-	if (cur_triangle->is_leaf)
-		return cur_triangle;
+    if (pt->position_to_triangle(cur_triangle) < 0)
+        return NULL;
+    
+    if (cur_triangle->is_leaf)
+        return cur_triangle;
 
-	for (int i = 0; i < cur_triangle->children.size(); i ++) {
-		Triangle *found_triangle = search_triangle_with_point(cur_triangle->children[i], pt);
-		if (found_triangle != NULL)
-			return found_triangle;
-	}
+    for (int i = 0; i < cur_triangle->children.size(); i ++) {
+        Triangle *found_triangle = search_triangle_with_point(cur_triangle->children[i], pt);
+        if (found_triangle != NULL)
+            return found_triangle;
+    }
 
-	return NULL;
+    return NULL;
 }
 
 
 void Delaunay_Voronoi::distribute_points_into_triangles(vector<Point*> *pnts, vector<Triangle*> *triangles)
 {
-	bool find_triangle;
+    bool find_triangle;
 
 
-	for (int i = 0; i < pnts->size(); i ++) {
-		find_triangle = false;
-		for (int j = 0; j < triangles->size(); j ++) {
-			if (!((*triangles)[j])->is_leaf)
-				continue;
-			if ((*pnts)[i]->position_to_triangle(((*triangles)[j])) >= 0) {
-				(*pnts)[i]->current_triangle = (*triangles)[j];
-				(*triangles)[j]->remained_points_in_triangle.push_back((*pnts)[i]);
-				find_triangle = true;
-				break;
-			}
-		}
-		if (!find_triangle) 
-			if (is_global_grid)
-				EXECUTION_REPORT(REPORT_ERROR, -1, false, "CoR may have bugs, please contact liuli-cess@tsinghua.edu.cn");
-			else EXECUTION_REPORT(REPORT_ERROR, -1, false, "please enlarge the boundary of the regional grid: point (%lf %lf): ", (*pnts)[i]->lon, (*pnts)[i]->lat); 
-	}
+    for (int i = 0; i < pnts->size(); i ++) {
+        find_triangle = false;
+        for (int j = 0; j < triangles->size(); j ++) {
+            if (!((*triangles)[j])->is_leaf)
+                continue;
+            if ((*pnts)[i]->position_to_triangle(((*triangles)[j])) >= 0) {
+                (*pnts)[i]->current_triangle = (*triangles)[j];
+                (*triangles)[j]->remained_points_in_triangle.push_back((*pnts)[i]);
+                find_triangle = true;
+                break;
+            }
+        }
+        if (!find_triangle) 
+            if (is_global_grid)
+                EXECUTION_REPORT(REPORT_ERROR, -1, false, "CoR may have bugs, please contact liuli-cess@tsinghua.edu.cn");
+            else EXECUTION_REPORT(REPORT_ERROR, -1, false, "please enlarge the boundary of the regional grid: point (%lf %lf): ", (*pnts)[i]->lon, (*pnts)[i]->lat); 
+    }
 }
 
 
 void Delaunay_Voronoi::triangularization_process(Triangle *triangle, bool is_global_grid)
 {
-	int best_candidate_point_id;
-	Point *best_candidate_point;
-	vector<Triangle *> leaf_triangles;
-	vector<Triangle *> existing_triangles;
-
-
-	if (!triangle->is_leaf) {
-		triangle->reference_count --;
-		return;
-	}
-		
-	if (triangle->remained_points_in_triangle.size() == 0) {
-		result_leaf_triangles.push_back(triangle);
-		return;
-	}
-
-	triangle->is_leaf = false;
-	
-	best_candidate_point_id = triangle->find_best_candidate_point();
-	best_candidate_point = triangle->remained_points_in_triangle[best_candidate_point_id];
-	triangle->remained_points_in_triangle.erase(triangle->remained_points_in_triangle.begin()+best_candidate_point_id);
-
-	if (best_candidate_point->position_to_triangle(triangle) == 0) {
-		Edge *e_v1_can = current_delaunay_voronoi->allocate_edge(triangle->v[0], best_candidate_point);
-		Edge *e_can_v1 = e_v1_can->generate_twins_edge();
-		Edge *e_v2_can = current_delaunay_voronoi->allocate_edge(triangle->v[1], best_candidate_point);
-		Edge *e_can_v2 = e_v2_can->generate_twins_edge();
-		Edge *e_v3_can = current_delaunay_voronoi->allocate_edge(triangle->v[2], best_candidate_point);
-		Edge *e_can_v3 = e_v3_can->generate_twins_edge();
-		Triangle *t_v1_v2_can = current_delaunay_voronoi->allocate_Triangle(triangle->edge[0], e_v2_can, e_can_v1);
-		Triangle *t_v2_v3_can = current_delaunay_voronoi->allocate_Triangle(triangle->edge[1], e_v3_can, e_can_v2);
-		Triangle *t_v3_v1_can = current_delaunay_voronoi->allocate_Triangle(triangle->edge[2], e_v1_can, e_can_v3);
-		leaf_triangles.push_back(triangle);
-		leaf_triangles.push_back(t_v1_v2_can);
-		leaf_triangles.push_back(t_v2_v3_can);
-		leaf_triangles.push_back(t_v3_v1_can);
-		triangle->reference_count ++;
-		t_v1_v2_can->reference_count ++;
-		t_v2_v3_can->reference_count ++;
-		t_v3_v1_can->reference_count ++;
-		legalize_triangles(best_candidate_point, triangle->edge[0], &leaf_triangles);
-		legalize_triangles(best_candidate_point, triangle->edge[1], &leaf_triangles);
-		legalize_triangles(best_candidate_point, triangle->edge[2], &leaf_triangles);
-	}
-	else {
-		Point *vi, *vj, *vk, *vl;
-		Edge *eij, *ejk, *eki;
-		Edge *eil, *elj, *eji;
-		switch (best_candidate_point->position_to_triangle(triangle)) {
-			case 1:
-				vi = triangle->v[0];
-				vj = triangle->v[1];
-				vk = triangle->v[2];
-				eij = triangle->edge[0];
-				break;
-			case 2:
-				vi = triangle->v[1];
-				vj = triangle->v[2];
-				vk = triangle->v[0];
-				eij = triangle->edge[1];
-				break;
-			case 3:
-				vi = triangle->v[2];
-				vj = triangle->v[0];
-				vk = triangle->v[1];
-				eij = triangle->edge[2];
-				break;
-			default:
-				EXECUTION_REPORT(REPORT_ERROR, -1, false, "remap software error2 in triangularization_process");
-				break;
-		}
-		EXECUTION_REPORT(REPORT_ERROR, -1, best_candidate_point->position_to_edge(vi, vj) == 0, "remap software error3 in triangularization_process");
-		if (eij->twin_edge != NULL)
-			EXECUTION_REPORT(REPORT_ERROR, -1, eij->twin_edge->triangle->is_leaf, "remap software error3 in triangularization_process");
+    int best_candidate_point_id;
+    Point *best_candidate_point;
+    vector<Triangle *> leaf_triangles;
+    vector<Triangle *> existing_triangles;
+
+
+    if (!triangle->is_leaf) {
+        triangle->reference_count --;
+        return;
+    }
+        
+    if (triangle->remained_points_in_triangle.size() == 0) {
+        result_leaf_triangles.push_back(triangle);
+        return;
+    }
+
+    triangle->is_leaf = false;
+    
+    best_candidate_point_id = triangle->find_best_candidate_point();
+    best_candidate_point = triangle->remained_points_in_triangle[best_candidate_point_id];
+    triangle->remained_points_in_triangle.erase(triangle->remained_points_in_triangle.begin()+best_candidate_point_id);
+
+    if (best_candidate_point->position_to_triangle(triangle) == 0) {
+        Edge *e_v1_can = current_delaunay_voronoi->allocate_edge(triangle->v[0], best_candidate_point);
+        Edge *e_can_v1 = e_v1_can->generate_twins_edge();
+        Edge *e_v2_can = current_delaunay_voronoi->allocate_edge(triangle->v[1], best_candidate_point);
+        Edge *e_can_v2 = e_v2_can->generate_twins_edge();
+        Edge *e_v3_can = current_delaunay_voronoi->allocate_edge(triangle->v[2], best_candidate_point);
+        Edge *e_can_v3 = e_v3_can->generate_twins_edge();
+        Triangle *t_v1_v2_can = current_delaunay_voronoi->allocate_Triangle(triangle->edge[0], e_v2_can, e_can_v1);
+        Triangle *t_v2_v3_can = current_delaunay_voronoi->allocate_Triangle(triangle->edge[1], e_v3_can, e_can_v2);
+        Triangle *t_v3_v1_can = current_delaunay_voronoi->allocate_Triangle(triangle->edge[2], e_v1_can, e_can_v3);
+        leaf_triangles.push_back(triangle);
+        leaf_triangles.push_back(t_v1_v2_can);
+        leaf_triangles.push_back(t_v2_v3_can);
+        leaf_triangles.push_back(t_v3_v1_can);
+        triangle->reference_count ++;
+        t_v1_v2_can->reference_count ++;
+        t_v2_v3_can->reference_count ++;
+        t_v3_v1_can->reference_count ++;
+        legalize_triangles(best_candidate_point, triangle->edge[0], &leaf_triangles);
+        legalize_triangles(best_candidate_point, triangle->edge[1], &leaf_triangles);
+        legalize_triangles(best_candidate_point, triangle->edge[2], &leaf_triangles);
+    }
+    else {
+        Point *vi, *vj, *vk, *vl;
+        Edge *eij, *ejk, *eki;
+        Edge *eil, *elj, *eji;
+        switch (best_candidate_point->position_to_triangle(triangle)) {
+            case 1:
+                vi = triangle->v[0];
+                vj = triangle->v[1];
+                vk = triangle->v[2];
+                eij = triangle->edge[0];
+                break;
+            case 2:
+                vi = triangle->v[1];
+                vj = triangle->v[2];
+                vk = triangle->v[0];
+                eij = triangle->edge[1];
+                break;
+            case 3:
+                vi = triangle->v[2];
+                vj = triangle->v[0];
+                vk = triangle->v[1];
+                eij = triangle->edge[2];
+                break;
+            default:
+                EXECUTION_REPORT(REPORT_ERROR, -1, false, "remap software error2 in triangularization_process");
+                break;
+        }
+        EXECUTION_REPORT(REPORT_ERROR, -1, best_candidate_point->position_to_edge(vi, vj) == 0, "remap software error3 in triangularization_process");
+        if (eij->twin_edge != NULL)
+            EXECUTION_REPORT(REPORT_ERROR, -1, eij->twin_edge->triangle->is_leaf, "remap software error3 in triangularization_process");
         ejk = eij->next_edge_in_triangle;
         eki = ejk->next_edge_in_triangle;
-		if (eij->twin_edge != NULL) { 
-	        eji = eij->twin_edge;
-			eij->twin_edge->triangle->is_leaf = false;
-	        eil = eji->next_edge_in_triangle;
-	        elj = eil->next_edge_in_triangle;
-			vl = elj->head;
-		}
-		Edge *eri = current_delaunay_voronoi->allocate_edge(best_candidate_point, vi);
-		Edge *eir = eri->generate_twins_edge();
-		Edge *erk = current_delaunay_voronoi->allocate_edge(best_candidate_point, vk);
-		Edge *ekr = erk->generate_twins_edge();
-		Edge *erj = current_delaunay_voronoi->allocate_edge(best_candidate_point, vj);
-		Triangle* tirk = current_delaunay_voronoi->allocate_Triangle(eir, erk, eki);
-		Triangle* tjkr = current_delaunay_voronoi->allocate_Triangle(ejk, ekr, erj);
-		leaf_triangles.push_back(triangle);
-		leaf_triangles.push_back(tirk);
-		leaf_triangles.push_back(tjkr);
-		triangle->reference_count ++;
-		tirk->reference_count ++;
-		tjkr->reference_count ++;
+        if (eij->twin_edge != NULL) { 
+            eji = eij->twin_edge;
+            eij->twin_edge->triangle->is_leaf = false;
+            eil = eji->next_edge_in_triangle;
+            elj = eil->next_edge_in_triangle;
+            vl = elj->head;
+        }
+        Edge *eri = current_delaunay_voronoi->allocate_edge(best_candidate_point, vi);
+        Edge *eir = eri->generate_twins_edge();
+        Edge *erk = current_delaunay_voronoi->allocate_edge(best_candidate_point, vk);
+        Edge *ekr = erk->generate_twins_edge();
+        Edge *erj = current_delaunay_voronoi->allocate_edge(best_candidate_point, vj);
+        Triangle* tirk = current_delaunay_voronoi->allocate_Triangle(eir, erk, eki);
+        Triangle* tjkr = current_delaunay_voronoi->allocate_Triangle(ejk, ekr, erj);
+        leaf_triangles.push_back(triangle);
+        leaf_triangles.push_back(tirk);
+        leaf_triangles.push_back(tjkr);
+        triangle->reference_count ++;
+        tirk->reference_count ++;
+        tjkr->reference_count ++;
         legalize_triangles(best_candidate_point, ejk, &leaf_triangles);
-        legalize_triangles(best_candidate_point, eki, &leaf_triangles);	
-		if (eij->twin_edge != NULL) {
-			Edge *ejr = erj->generate_twins_edge();
-			Edge *erl = current_delaunay_voronoi->allocate_edge(best_candidate_point, vl);
-			Edge *elr = erl->generate_twins_edge();
-			Triangle* tilr = current_delaunay_voronoi->allocate_Triangle(eil, elr, eri);
-			Triangle* tjrl = current_delaunay_voronoi->allocate_Triangle(ejr, erl, elj);
-			leaf_triangles.push_back(eij->twin_edge->triangle);
-			leaf_triangles.push_back(tilr);
-			leaf_triangles.push_back(tjrl);
-			tilr->reference_count ++;
-			tjrl->reference_count ++;
-			legalize_triangles(best_candidate_point, eil, &leaf_triangles);
-			legalize_triangles(best_candidate_point, elj, &leaf_triangles);
-		}
-		else {
-			eir->twin_edge = NULL;
-		}
-	}
-
-	for (int i = 0; i < leaf_triangles.size(); i ++) {
-		if (leaf_triangles[i]->is_leaf)
-			EXECUTION_REPORT(REPORT_ERROR, -1, leaf_triangles[i]->remained_points_in_triangle.size() == 0, "remap software error1 in triangularization_process");
-	}
-	for (int i = 0; i < leaf_triangles.size(); i ++) {
-		if (leaf_triangles[i]->is_leaf)
-			continue;
-		distribute_points_into_triangles(&(leaf_triangles[i]->remained_points_in_triangle), &leaf_triangles);
-	}		
-	for (int i = 0; i < leaf_triangles.size(); i ++)
-		triangularization_process(leaf_triangles[i], is_global_grid);
-
-	triangle->reference_count --;
+        legalize_triangles(best_candidate_point, eki, &leaf_triangles);    
+        if (eij->twin_edge != NULL) {
+            Edge *ejr = erj->generate_twins_edge();
+            Edge *erl = current_delaunay_voronoi->allocate_edge(best_candidate_point, vl);
+            Edge *elr = erl->generate_twins_edge();
+            Triangle* tilr = current_delaunay_voronoi->allocate_Triangle(eil, elr, eri);
+            Triangle* tjrl = current_delaunay_voronoi->allocate_Triangle(ejr, erl, elj);
+            leaf_triangles.push_back(eij->twin_edge->triangle);
+            leaf_triangles.push_back(tilr);
+            leaf_triangles.push_back(tjrl);
+            tilr->reference_count ++;
+            tjrl->reference_count ++;
+            legalize_triangles(best_candidate_point, eil, &leaf_triangles);
+            legalize_triangles(best_candidate_point, elj, &leaf_triangles);
+        }
+        else {
+            eir->twin_edge = NULL;
+        }
+    }
+
+    for (int i = 0; i < leaf_triangles.size(); i ++) {
+        if (leaf_triangles[i]->is_leaf)
+            EXECUTION_REPORT(REPORT_ERROR, -1, leaf_triangles[i]->remained_points_in_triangle.size() == 0, "remap software error1 in triangularization_process");
+    }
+    for (int i = 0; i < leaf_triangles.size(); i ++) {
+        if (leaf_triangles[i]->is_leaf)
+            continue;
+        distribute_points_into_triangles(&(leaf_triangles[i]->remained_points_in_triangle), &leaf_triangles);
+    }        
+    for (int i = 0; i < leaf_triangles.size(); i ++)
+        triangularization_process(leaf_triangles[i], is_global_grid);
+
+    triangle->reference_count --;
 }
 
 
 Delaunay_Voronoi::~Delaunay_Voronoi()
 {
-	for (int i = 0; i < num_cells; i ++)
-		delete cells[i].center;
-	delete [] cells;
-	for (int i = 0; i < edge_pool.size(); i ++)
-		delete edge_pool[i];
-	for (int i = 0; i < triangle_pool.size(); i ++)
-		delete triangle_pool[i];
-	current_delaunay_voronoi = NULL;
+    for (int i = 0; i < num_cells; i ++)
+        delete cells[i].center;
+    delete [] cells;
+    for (int i = 0; i < edge_pool.size(); i ++)
+        delete edge_pool[i];
+    for (int i = 0; i < triangle_pool.size(); i ++)
+        delete triangle_pool[i];
+    current_delaunay_voronoi = NULL;
 }
 
 
 bool Delaunay_Voronoi::is_triangle_legal(const Point *pt, const Edge *edge)
 {
-	if (!edge->twin_edge)
-		return true;
+    if (!edge->twin_edge)
+        return true;
 
-	const Point *vi = edge->head;
-	const Point *vj = edge->next_edge_in_triangle->head;
-	const Point *vk = edge->twin_edge->prev_edge_in_triangle->head;
+    const Point *vi = edge->head;
+    const Point *vj = edge->next_edge_in_triangle->head;
+    const Point *vk = edge->twin_edge->prev_edge_in_triangle->head;
 
-	Point temp_point1(vi, pt);
-	Point temp_point2(vj, pt);
-	Point temp_point3(vk, pt);
+    Point temp_point1(vi, pt);
+    Point temp_point2(vj, pt);
+    Point temp_point3(vk, pt);
 
-	if (det(&temp_point1, &temp_point2, &temp_point3) >= e)
-		return false;
-	else return true;
+    if (det(&temp_point1, &temp_point2, &temp_point3) >= e)
+        return false;
+    else return true;
 }
 
 
 void Delaunay_Voronoi::legalize_triangles(Point *vr, Edge *edge, vector<Triangle*> *leaf_triangles)
 {
-	if (is_triangle_legal(vr, edge))
-		return;
-
-	EXECUTION_REPORT(REPORT_ERROR, -1, edge->triangle->is_leaf, "remap software error1 in legalize_triangles\n");
-	EXECUTION_REPORT(REPORT_ERROR, -1, edge->twin_edge->triangle->is_leaf, "remap software error2 in legalize_triangles %lx\n", (long)(edge->twin_edge->triangle));
-	leaf_triangles->push_back(edge->twin_edge->triangle);
-	edge->twin_edge->triangle->reference_count ++;
-	edge->triangle->is_leaf = false;
-	edge->twin_edge->triangle->is_leaf = false;
-
-	Point *vk = edge->twin_edge->prev_edge_in_triangle->head;
-	Edge *eij = edge;
-	Edge *ejr = eij->next_edge_in_triangle;
-	Edge *eri = ejr->next_edge_in_triangle;
-	Edge *eji = eij->twin_edge;
-	Edge *eik = eji->next_edge_in_triangle;
-	Edge *ekj = eik->next_edge_in_triangle;
-	Edge *erk = current_delaunay_voronoi->allocate_edge(vr, vk);
-	Edge *ekr = erk->generate_twins_edge();
-	Triangle* tikr = current_delaunay_voronoi->allocate_Triangle(eik,ekr,eri);
-	Triangle* tjrk = current_delaunay_voronoi->allocate_Triangle(ejr,erk,ekj);
-	leaf_triangles->push_back(tikr);
-	leaf_triangles->push_back(tjrk);
-	tikr->reference_count ++;
-	tjrk->reference_count ++;
-	legalize_triangles(vr, eik, leaf_triangles);
-	legalize_triangles(vr, ekj, leaf_triangles);
+    if (is_triangle_legal(vr, edge))
+        return;
+
+    EXECUTION_REPORT(REPORT_ERROR, -1, edge->triangle->is_leaf, "remap software error1 in legalize_triangles\n");
+    EXECUTION_REPORT(REPORT_ERROR, -1, edge->twin_edge->triangle->is_leaf, "remap software error2 in legalize_triangles %lx\n", (long)(edge->twin_edge->triangle));
+    leaf_triangles->push_back(edge->twin_edge->triangle);
+    edge->twin_edge->triangle->reference_count ++;
+    edge->triangle->is_leaf = false;
+    edge->twin_edge->triangle->is_leaf = false;
+
+    Point *vk = edge->twin_edge->prev_edge_in_triangle->head;
+    Edge *eij = edge;
+    Edge *ejr = eij->next_edge_in_triangle;
+    Edge *eri = ejr->next_edge_in_triangle;
+    Edge *eji = eij->twin_edge;
+    Edge *eik = eji->next_edge_in_triangle;
+    Edge *ekj = eik->next_edge_in_triangle;
+    Edge *erk = current_delaunay_voronoi->allocate_edge(vr, vk);
+    Edge *ekr = erk->generate_twins_edge();
+    Triangle* tikr = current_delaunay_voronoi->allocate_Triangle(eik,ekr,eri);
+    Triangle* tjrk = current_delaunay_voronoi->allocate_Triangle(ejr,erk,ekj);
+    leaf_triangles->push_back(tikr);
+    leaf_triangles->push_back(tjrk);
+    tikr->reference_count ++;
+    tjrk->reference_count ++;
+    legalize_triangles(vr, eik, leaf_triangles);
+    legalize_triangles(vr, ekj, leaf_triangles);
 }
 
 
 void Delaunay_Voronoi::generate_Voronoi_diagram()
 {
-	int num_none_virtual_vertexes, none_virtual_vertexes[3];
-	int empty_id;
-	int i, j;
-
-	
-	for (i = 0; i < result_leaf_triangles.size(); i ++)
-		if (!result_leaf_triangles[i]->is_leaf) {
-		}
-		else {
-			result_leaf_triangles[i]->get_center_coordinates();
-			EXECUTION_REPORT(REPORT_ERROR, -1, is_triangle_legal(result_leaf_triangles[i]->v[0],result_leaf_triangles[i]->edge[1])&&
-				             is_triangle_legal(result_leaf_triangles[i]->v[1],result_leaf_triangles[i]->edge[2])&&
-				             is_triangle_legal(result_leaf_triangles[i]->v[2],result_leaf_triangles[i]->edge[0]),
-				             "remap_software error in generate_Voronoi_diagram");
-			for (j = 0, num_none_virtual_vertexes = 0; j < 3; j ++)
-				if (result_leaf_triangles[i]->v[j]->id != -1)
-					none_virtual_vertexes[num_none_virtual_vertexes ++] = result_leaf_triangles[i]->v[j]->id;
-			if (num_none_virtual_vertexes == 0)
-				continue;
-			if (num_none_virtual_vertexes == 1) {
-				result_leaf_triangles[i]->center.lat = cells[none_virtual_vertexes[0]].center->lat;
-				result_leaf_triangles[i]->center.lon = cells[none_virtual_vertexes[0]].center->lon;
-			}
-			if (num_none_virtual_vertexes == 2) {
-				result_leaf_triangles[i]->center.lat = (cells[none_virtual_vertexes[0]].center->lat+cells[none_virtual_vertexes[1]].center->lat) / 2;
-				result_leaf_triangles[i]->center.lon = (cells[none_virtual_vertexes[0]].center->lon+cells[none_virtual_vertexes[1]].center->lon) / 2;;
-			}
-			for (j = 0; j < 3; j ++)
-				if (result_leaf_triangles[i]->v[j]->id != -1) {
-					cells[result_leaf_triangles[i]->v[j]->id].vertexes_lats.push_back(result_leaf_triangles[i]->center.lat);
-					cells[result_leaf_triangles[i]->v[j]->id].vertexes_lons.push_back(result_leaf_triangles[i]->center.lon);
-				}		
-		}
+    int num_none_virtual_vertexes, none_virtual_vertexes[3];
+    int empty_id;
+    int i, j;
+
+    
+    for (i = 0; i < result_leaf_triangles.size(); i ++)
+        if (!result_leaf_triangles[i]->is_leaf) {
+        }
+        else {
+            result_leaf_triangles[i]->get_center_coordinates();
+            EXECUTION_REPORT(REPORT_ERROR, -1, is_triangle_legal(result_leaf_triangles[i]->v[0],result_leaf_triangles[i]->edge[1])&&
+                             is_triangle_legal(result_leaf_triangles[i]->v[1],result_leaf_triangles[i]->edge[2])&&
+                             is_triangle_legal(result_leaf_triangles[i]->v[2],result_leaf_triangles[i]->edge[0]),
+                             "remap_software error in generate_Voronoi_diagram");
+            for (j = 0, num_none_virtual_vertexes = 0; j < 3; j ++)
+                if (result_leaf_triangles[i]->v[j]->id != -1)
+                    none_virtual_vertexes[num_none_virtual_vertexes ++] = result_leaf_triangles[i]->v[j]->id;
+            if (num_none_virtual_vertexes == 0)
+                continue;
+            if (num_none_virtual_vertexes == 1) {
+                result_leaf_triangles[i]->center.lat = cells[none_virtual_vertexes[0]].center->lat;
+                result_leaf_triangles[i]->center.lon = cells[none_virtual_vertexes[0]].center->lon;
+            }
+            if (num_none_virtual_vertexes == 2) {
+                result_leaf_triangles[i]->center.lat = (cells[none_virtual_vertexes[0]].center->lat+cells[none_virtual_vertexes[1]].center->lat) / 2;
+                result_leaf_triangles[i]->center.lon = (cells[none_virtual_vertexes[0]].center->lon+cells[none_virtual_vertexes[1]].center->lon) / 2;;
+            }
+            for (j = 0; j < 3; j ++)
+                if (result_leaf_triangles[i]->v[j]->id != -1) {
+                    cells[result_leaf_triangles[i]->v[j]->id].vertexes_lats.push_back(result_leaf_triangles[i]->center.lat);
+                    cells[result_leaf_triangles[i]->v[j]->id].vertexes_lons.push_back(result_leaf_triangles[i]->center.lon);
+                }        
+        }
 }
 
 Edge *Delaunay_Voronoi::allocate_edge(Point *head, Point *tail)
 {
-	Edge *new_edge = new Edge(head, tail);
-	edge_pool.push_back(new_edge);
+    Edge *new_edge = new Edge(head, tail);
+    edge_pool.push_back(new_edge);
 
-	return new_edge;
+    return new_edge;
 }
 
 
 Triangle *Delaunay_Voronoi::allocate_Triangle(Point *point1, Point *point2, Point *point3)
 {
-	Triangle *new_triangle = new Triangle(point1, point2, point3);
-	triangle_pool.push_back(new_triangle);
+    Triangle *new_triangle = new Triangle(point1, point2, point3);
+    triangle_pool.push_back(new_triangle);
 
-	return new_triangle;
+    return new_triangle;
 }
 
 
 Triangle *Delaunay_Voronoi::allocate_Triangle(Edge *edge1, Edge *edge2, Edge *edge3)
 {
-	Triangle *new_triangle = new Triangle(edge1, edge2, edge3);
-	triangle_pool.push_back(new_triangle);
+    Triangle *new_triangle = new Triangle(edge1, edge2, edge3);
+    triangle_pool.push_back(new_triangle);
 
-	return new_triangle;
+    return new_triangle;
 }
 
 
diff --git a/src/CoR/delaunay_voronoi.h b/src/CoR/delaunay_voronoi.h
old mode 100644
new mode 100755
index c7e18f6..817b45d
--- a/src/CoR/delaunay_voronoi.h
+++ b/src/CoR/delaunay_voronoi.h
@@ -29,108 +29,108 @@ class Triangle;
 
 class Point
 {
-	public:
-		double lat; 	/* latitude coordinate	*/
-		double lon; 	/* lontitude coordinate */
-		double x;	
-		double y;
-		double z;
-		int id;
-		Triangle *current_triangle;
-
-		Point(double lat = double(), double lon = double(), int id = -1);
-		double calculate_distance(const Point *pt) const;
-		int position_to_edge(const Point *pt1, const Point*pt2) const;
-		int position_to_triangle(const Triangle *) const;
-		Point(const Point *, const Point *);
-		void update_coord_values(double, double);
-		~Point() {}
+    public:
+        double lat;     /* latitude coordinate    */
+        double lon;     /* lontitude coordinate */
+        double x;    
+        double y;
+        double z;
+        int id;
+        Triangle *current_triangle;
+
+        Point(double lat = double(), double lon = double(), int id = -1);
+        double calculate_distance(const Point *pt) const;
+        int position_to_edge(const Point *pt1, const Point*pt2) const;
+        int position_to_triangle(const Triangle *) const;
+        Point(const Point *, const Point *);
+        void update_coord_values(double, double);
+        ~Point() {}
 };
 
 
 class Triangle
 {
-	public:
-		Point *v[3];	/* vertexes of triangle */
-		Point center;	/* circumcenter */
-		Edge *edge[3];
-		bool is_leaf;
-		bool visited;
-		int reference_count;	/* reference count, used to destruct */
-		int legalize_count[3];
-		vector<Point*> remained_points_in_triangle;
-		vector<Triangle*> children;
-
-		Triangle();
-		Triangle(Point*, Point*, Point*);
-		Triangle(Edge*, Edge*, Edge*);
-		~Triangle();
-		void get_center_coordinates();
-		int find_best_candidate_point();
-		void check_and_set_twin_edge_relationship(Triangle*);
-
-	private:
-		Triangle(const Triangle &triangle);
-		void initialize_triangle_with_edges(Edge*, Edge*, Edge*);
-		Triangle& operator=(const Triangle &triangle);
+    public:
+        Point *v[3];    /* vertexes of triangle */
+        Point center;    /* circumcenter */
+        Edge *edge[3];
+        bool is_leaf;
+        bool visited;
+        int reference_count;    /* reference count, used to destruct */
+        int legalize_count[3];
+        vector<Point*> remained_points_in_triangle;
+        vector<Triangle*> children;
+
+        Triangle();
+        Triangle(Point*, Point*, Point*);
+        Triangle(Edge*, Edge*, Edge*);
+        ~Triangle();
+        void get_center_coordinates();
+        int find_best_candidate_point();
+        void check_and_set_twin_edge_relationship(Triangle*);
+
+    private:
+        Triangle(const Triangle &triangle);
+        void initialize_triangle_with_edges(Edge*, Edge*, Edge*);
+        Triangle& operator=(const Triangle &triangle);
 };
 
 
 struct Cell
 {
-	Point *center;
-	vector<double> vertexes_lons;
-	vector<double> vertexes_lats;
+    Point *center;
+    vector<double> vertexes_lons;
+    vector<double> vertexes_lats;
 };
 
 
 class Edge
 {
-	public:
-		Point *head;
-		Point *tail;	/* the tail of this edge, constant */
-		Edge *twin_edge;			/* the twin_edge edge, whose tail is the head of this edge and head is the tail of this edge */
-		Edge *next_edge_in_triangle;			/* the next_edge_in_triangle edge, whose tail is the head of this edge but head isn't the tail of this edge */
-		Edge *prev_edge_in_triangle;			/* the prev_edge_in_triangle edge, whose head is the tail of this edge but tail isn't the head of this edge */
-		Triangle *triangle; /* the triangle which is composed by this edge and its next_edge_in_triangle and prev_edge_in_triangle */
-
-		Edge(Point *head, Point *tail);
-		~Edge();
-		Edge *generate_twins_edge();
-
-	private:
+    public:
+        Point *head;
+        Point *tail;    /* the tail of this edge, constant */
+        Edge *twin_edge;            /* the twin_edge edge, whose tail is the head of this edge and head is the tail of this edge */
+        Edge *next_edge_in_triangle;            /* the next_edge_in_triangle edge, whose tail is the head of this edge but head isn't the tail of this edge */
+        Edge *prev_edge_in_triangle;            /* the prev_edge_in_triangle edge, whose head is the tail of this edge but tail isn't the head of this edge */
+        Triangle *triangle; /* the triangle which is composed by this edge and its next_edge_in_triangle and prev_edge_in_triangle */
+
+        Edge(Point *head, Point *tail);
+        ~Edge();
+        Edge *generate_twins_edge();
+
+    private:
 };
 
 
 class Delaunay_Voronoi
 {
-	public:
-		Cell *cells;
-		vector<Triangle*> result_leaf_triangles;
-		vector<Triangle*> triangle_pool;
-		vector<Edge*> edge_pool;
-		bool is_global_grid;
-		int num_cells;
-
-		Delaunay_Voronoi(int, double*, double*, bool, double, double, double, double, bool*, double**, double**, int*);
-		~Delaunay_Voronoi();
-		static bool is_triangle_legal(const Point *pt, const Edge *edge);
-		void legalize_triangles(Point *pt, Edge *edge, vector<Triangle*>*);
-		Edge *allocate_edge(Point *head, Point *tail);
-		Triangle *allocate_Triangle(Point*, Point*, Point*);
-		Triangle *allocate_Triangle(Edge*, Edge*, Edge*);
-
-
-	private:
-		void check_and_set_twin_edge_relationship(vector<Triangle*>*);
-		Point *generate_boundary_point(double, double, Triangle*, bool);
-		void generate_initial_triangles(Triangle*, vector<Point*>*, vector<Point*>*, bool);
-		void triangularization_process(Triangle*, bool);
-		void distribute_points_into_triangles(vector<Point*>*, vector<Triangle*>*);
-		Triangle *search_triangle_with_point(Triangle*, const Point *pt);
-		void generate_Voronoi_diagram();
-		void extract_vertex_coordinate_values(int, bool, double**, double**, int*);
-		void get_convex_set(int, double*, double*, double, double, int &, int **);
+    public:
+        Cell *cells;
+        vector<Triangle*> result_leaf_triangles;
+        vector<Triangle*> triangle_pool;
+        vector<Edge*> edge_pool;
+        bool is_global_grid;
+        int num_cells;
+
+        Delaunay_Voronoi(int, double*, double*, bool, double, double, double, double, bool*, double**, double**, int*);
+        ~Delaunay_Voronoi();
+        static bool is_triangle_legal(const Point *pt, const Edge *edge);
+        void legalize_triangles(Point *pt, Edge *edge, vector<Triangle*>*);
+        Edge *allocate_edge(Point *head, Point *tail);
+        Triangle *allocate_Triangle(Point*, Point*, Point*);
+        Triangle *allocate_Triangle(Edge*, Edge*, Edge*);
+
+
+    private:
+        void check_and_set_twin_edge_relationship(vector<Triangle*>*);
+        Point *generate_boundary_point(double, double, Triangle*, bool);
+        void generate_initial_triangles(Triangle*, vector<Point*>*, vector<Point*>*, bool);
+        void triangularization_process(Triangle*, bool);
+        void distribute_points_into_triangles(vector<Point*>*, vector<Triangle*>*);
+        Triangle *search_triangle_with_point(Triangle*, const Point *pt);
+        void generate_Voronoi_diagram();
+        void extract_vertex_coordinate_values(int, bool, double**, double**, int*);
+        void get_convex_set(int, double*, double*, double, double, int &, int **);
 };
 
 #endif
diff --git a/src/CoR/grid_cell_search.cxx b/src/CoR/grid_cell_search.cxx
old mode 100644
new mode 100755
index 70d4e3b..21be671
--- a/src/CoR/grid_cell_search.cxx
+++ b/src/CoR/grid_cell_search.cxx
@@ -15,193 +15,193 @@
 void seperate_cells_in_children_tiles(int num_cells, H2D_grid_cell_search_cell **cells, double center_lon, double center_lat, 
                                       double dlon, double dlat, int *num_cells_in_children, long *index_buffer)
 {
-	double new_dlon, new_dlat, min_lon, min_lat, diff_lon, diff_lat;
-	int i, child_indx, indx_at_lon, indx_at_lat;
-	
-
-	new_dlon = dlon / ((double)TILE_DIVIDE_FACTOR);
-	new_dlat = dlat / ((double)TILE_DIVIDE_FACTOR);
-	min_lon = center_lon - dlon/2;
-	min_lat = center_lat - dlat/2;
-
-
-	if (min_lon < 0)
-		min_lon += 360;
-	for (i = 0; i < TILE_DIVIDE_FACTOR*TILE_DIVIDE_FACTOR; i ++) 
-		num_cells_in_children[i] = 0;
-	for (i = 0; i < num_cells; i ++) {
-		diff_lon = cells[i]->get_bounding_circle_center_lon() - min_lon;
-		if (diff_lon < 0)
-			diff_lon += 360;
-		diff_lat = cells[i]->get_bounding_circle_center_lat() - min_lat;
-		indx_at_lon = (int)(diff_lon / new_dlon);
-		indx_at_lat = (int)(diff_lat / new_dlat);
-		if (indx_at_lon == TILE_DIVIDE_FACTOR)
-			indx_at_lon = TILE_DIVIDE_FACTOR - 1;
-		if (indx_at_lat == TILE_DIVIDE_FACTOR)
-			indx_at_lat = TILE_DIVIDE_FACTOR - 1;
-		EXECUTION_REPORT(REPORT_ERROR, indx_at_lon < TILE_DIVIDE_FACTOR && indx_at_lat < TILE_DIVIDE_FACTOR, "Software error1 in H2D_grid_cell_search_tile::seperate_cells_in_children_tiles");
-		child_indx = indx_at_lat*TILE_DIVIDE_FACTOR+indx_at_lon;
-		num_cells_in_children[child_indx] ++;
-		index_buffer[i] = child_indx;
-	}
+    double new_dlon, new_dlat, min_lon, min_lat, diff_lon, diff_lat;
+    int i, child_indx, indx_at_lon, indx_at_lat;
+    
+
+    new_dlon = dlon / ((double)TILE_DIVIDE_FACTOR);
+    new_dlat = dlat / ((double)TILE_DIVIDE_FACTOR);
+    min_lon = center_lon - dlon/2;
+    min_lat = center_lat - dlat/2;
+
+
+    if (min_lon < 0)
+        min_lon += 360;
+    for (i = 0; i < TILE_DIVIDE_FACTOR*TILE_DIVIDE_FACTOR; i ++) 
+        num_cells_in_children[i] = 0;
+    for (i = 0; i < num_cells; i ++) {
+        diff_lon = cells[i]->get_bounding_circle_center_lon() - min_lon;
+        if (diff_lon < 0)
+            diff_lon += 360;
+        diff_lat = cells[i]->get_bounding_circle_center_lat() - min_lat;
+        indx_at_lon = (int)(diff_lon / new_dlon);
+        indx_at_lat = (int)(diff_lat / new_dlat);
+        if (indx_at_lon == TILE_DIVIDE_FACTOR)
+            indx_at_lon = TILE_DIVIDE_FACTOR - 1;
+        if (indx_at_lat == TILE_DIVIDE_FACTOR)
+            indx_at_lat = TILE_DIVIDE_FACTOR - 1;
+        EXECUTION_REPORT(REPORT_ERROR, indx_at_lon < TILE_DIVIDE_FACTOR && indx_at_lat < TILE_DIVIDE_FACTOR, "Software error1 in H2D_grid_cell_search_tile::seperate_cells_in_children_tiles");
+        child_indx = indx_at_lat*TILE_DIVIDE_FACTOR+indx_at_lon;
+        num_cells_in_children[child_indx] ++;
+        index_buffer[i] = child_indx;
+    }
 }
 
 
 H2D_grid_cell_cartesian_coord::H2D_grid_cell_cartesian_coord()
 {
-	center_x = NULL_COORD_VALUE;
-	center_y = NULL_COORD_VALUE;
-	center_z = NULL_COORD_VALUE;
-	vertex_x = NULL;
-	vertex_y = NULL;
-	vertex_z = NULL;
+    center_x = NULL_COORD_VALUE;
+    center_y = NULL_COORD_VALUE;
+    center_z = NULL_COORD_VALUE;
+    vertex_x = NULL;
+    vertex_y = NULL;
+    vertex_z = NULL;
 }
 
 
 H2D_grid_cell_cartesian_coord::~H2D_grid_cell_cartesian_coord()
 {
-	if (vertex_x != NULL) {
-		delete [] vertex_x;
-		delete [] vertex_y;
-		delete [] vertex_z;
-	}
+    if (vertex_x != NULL) {
+        delete [] vertex_x;
+        delete [] vertex_y;
+        delete [] vertex_z;
+    }
 }
 
 
 H2D_grid_cell_search_cell::H2D_grid_cell_search_cell(int cell_index, double center_lon, double center_lat, bool mask, 
                                                        int num_vertex, const double *vertex_lons, const double *vertex_lats, int edge_type)
 {
-	int i, j;
-
-
-	EXECUTION_REPORT(REPORT_ERROR, edge_type == EDGE_TYPE_LATLON || edge_type == EDGE_TYPE_GREAT_ARC, "Software error1 in H2D_grid_cell_search_cell::H2D_grid_cell_search_cell");
-	
-	this->cell_index = cell_index;
-	this->center_lon = center_lon;
-	this->center_lat = center_lat;
-	this->mask = mask;
-	this->vertex_lons = NULL;
-	this->vertex_lats = NULL;
-	this->num_vertex = 0;
-	this->bounding_circle_radius = 0.0;
-	this->bounding_circle_center_lon = center_lon;
-	this->bounding_circle_center_lat = center_lat;
-	this->edge_type = edge_type;
-	this->cartesian_coord = NULL;
-	
-	if (num_vertex > 0) {
-		EXECUTION_REPORT(REPORT_ERROR, vertex_lons != NULL && vertex_lats != NULL, "Software error2 in H2D_grid_cell_search_cell::H2D_grid_cell_search_cell");
-		for (i = 0; i < num_vertex; i ++)
-			if (vertex_lons[i] == NULL_COORD_VALUE || vertex_lats[i] == NULL_COORD_VALUE) 
-				EXECUTION_REPORT(REPORT_ERROR, vertex_lons[i] == NULL_COORD_VALUE && vertex_lats[i] == NULL_COORD_VALUE, "Software error3 in H2D_grid_cell_search_cell::H2D_grid_cell_search_cell");
-			else this->num_vertex ++;
-		if (this->num_vertex > 0) {
-			this->vertex_lons = new double [this->num_vertex];
-			this->vertex_lats = new double [this->num_vertex];
-			for (i = 0, j = 0; i < num_vertex; i ++) {
-				if (vertex_lons[i] == NULL_COORD_VALUE)
-					continue;
-				this->vertex_lons[j] = vertex_lons[i];
-				this->vertex_lats[j] = vertex_lats[i];
-				j ++;
-			}
-			double min_lon, max_lon;
-			min_lon = this->vertex_lons[0];
-			max_lon = min_lon;
-			for (i = 1; i < this->num_vertex; i ++) {
-				if (min_lon > this->vertex_lons[i])
-					min_lon = this->vertex_lons[i];
-				if (max_lon < this->vertex_lons[i])
-					max_lon = this->vertex_lons[i];
-			}
-			double sum_lon = 0.0, sum_lat = 0.0;
-			for (i = 0; i < this->num_vertex; i ++) {
-				sum_lat += this->vertex_lats[i];
-				if (max_lon - min_lon > 180 && min_lon < 180 && this->vertex_lons[i] < 180)
-					sum_lon += this->vertex_lons[i] + 360;
-				else sum_lon += this->vertex_lons[i];
-			}
-			bounding_circle_center_lon = sum_lon / this->num_vertex;
-			bounding_circle_center_lat = sum_lat / this->num_vertex;
-			if (bounding_circle_center_lon >= 360)
-				bounding_circle_center_lon -= 360;
-			bounding_circle_radius = 0;
-			for (i = 0; i < this->num_vertex; i ++) {
-				double dist = calculate_distance_of_two_points_2D(bounding_circle_center_lon, bounding_circle_center_lat, this->vertex_lons[i], this->vertex_lats[i],true);
-				if (bounding_circle_radius < dist)
-					bounding_circle_radius = dist;
-			}
-			bounding_circle_radius *= 1.00001;
-		}
-	}
-
-	if (edge_type == EDGE_TYPE_GREAT_ARC) {
-		cartesian_coord = new H2D_grid_cell_cartesian_coord();
-		get_3D_cartesian_coord_of_sphere_coord(cartesian_coord->center_x, cartesian_coord->center_y, cartesian_coord->center_z, center_lon, center_lat);
-		if (this->num_vertex > 0) {
-			cartesian_coord->vertex_x = new double [this->num_vertex];
-			cartesian_coord->vertex_y = new double [this->num_vertex];
-			cartesian_coord->vertex_z = new double [this->num_vertex];
-			for (i = 0; i < this->num_vertex; i ++)
-				get_3D_cartesian_coord_of_sphere_coord(cartesian_coord->vertex_x[i], cartesian_coord->vertex_y[i], cartesian_coord->vertex_z[i], this->vertex_lons[i], this->vertex_lats[i]);
-		}
-	}
+    int i, j;
+
+
+    EXECUTION_REPORT(REPORT_ERROR, edge_type == EDGE_TYPE_LATLON || edge_type == EDGE_TYPE_GREAT_ARC, "Software error1 in H2D_grid_cell_search_cell::H2D_grid_cell_search_cell");
+    
+    this->cell_index = cell_index;
+    this->center_lon = center_lon;
+    this->center_lat = center_lat;
+    this->mask = mask;
+    this->vertex_lons = NULL;
+    this->vertex_lats = NULL;
+    this->num_vertex = 0;
+    this->bounding_circle_radius = 0.0;
+    this->bounding_circle_center_lon = center_lon;
+    this->bounding_circle_center_lat = center_lat;
+    this->edge_type = edge_type;
+    this->cartesian_coord = NULL;
+    
+    if (num_vertex > 0) {
+        EXECUTION_REPORT(REPORT_ERROR, vertex_lons != NULL && vertex_lats != NULL, "Software error2 in H2D_grid_cell_search_cell::H2D_grid_cell_search_cell");
+        for (i = 0; i < num_vertex; i ++)
+            if (vertex_lons[i] == NULL_COORD_VALUE || vertex_lats[i] == NULL_COORD_VALUE) 
+                EXECUTION_REPORT(REPORT_ERROR, vertex_lons[i] == NULL_COORD_VALUE && vertex_lats[i] == NULL_COORD_VALUE, "Software error3 in H2D_grid_cell_search_cell::H2D_grid_cell_search_cell");
+            else this->num_vertex ++;
+        if (this->num_vertex > 0) {
+            this->vertex_lons = new double [this->num_vertex];
+            this->vertex_lats = new double [this->num_vertex];
+            for (i = 0, j = 0; i < num_vertex; i ++) {
+                if (vertex_lons[i] == NULL_COORD_VALUE)
+                    continue;
+                this->vertex_lons[j] = vertex_lons[i];
+                this->vertex_lats[j] = vertex_lats[i];
+                j ++;
+            }
+            double min_lon, max_lon;
+            min_lon = this->vertex_lons[0];
+            max_lon = min_lon;
+            for (i = 1; i < this->num_vertex; i ++) {
+                if (min_lon > this->vertex_lons[i])
+                    min_lon = this->vertex_lons[i];
+                if (max_lon < this->vertex_lons[i])
+                    max_lon = this->vertex_lons[i];
+            }
+            double sum_lon = 0.0, sum_lat = 0.0;
+            for (i = 0; i < this->num_vertex; i ++) {
+                sum_lat += this->vertex_lats[i];
+                if (max_lon - min_lon > 180 && min_lon < 180 && this->vertex_lons[i] < 180)
+                    sum_lon += this->vertex_lons[i] + 360;
+                else sum_lon += this->vertex_lons[i];
+            }
+            bounding_circle_center_lon = sum_lon / this->num_vertex;
+            bounding_circle_center_lat = sum_lat / this->num_vertex;
+            if (bounding_circle_center_lon >= 360)
+                bounding_circle_center_lon -= 360;
+            bounding_circle_radius = 0;
+            for (i = 0; i < this->num_vertex; i ++) {
+                double dist = calculate_distance_of_two_points_2D(bounding_circle_center_lon, bounding_circle_center_lat, this->vertex_lons[i], this->vertex_lats[i],true);
+                if (bounding_circle_radius < dist)
+                    bounding_circle_radius = dist;
+            }
+            bounding_circle_radius *= 1.00001;
+        }
+    }
+
+    if (edge_type == EDGE_TYPE_GREAT_ARC) {
+        cartesian_coord = new H2D_grid_cell_cartesian_coord();
+        get_3D_cartesian_coord_of_sphere_coord(cartesian_coord->center_x, cartesian_coord->center_y, cartesian_coord->center_z, center_lon, center_lat);
+        if (this->num_vertex > 0) {
+            cartesian_coord->vertex_x = new double [this->num_vertex];
+            cartesian_coord->vertex_y = new double [this->num_vertex];
+            cartesian_coord->vertex_z = new double [this->num_vertex];
+            for (i = 0; i < this->num_vertex; i ++)
+                get_3D_cartesian_coord_of_sphere_coord(cartesian_coord->vertex_x[i], cartesian_coord->vertex_y[i], cartesian_coord->vertex_z[i], this->vertex_lons[i], this->vertex_lats[i]);
+        }
+    }
 }
 
 
 H2D_grid_cell_search_cell::~H2D_grid_cell_search_cell()
 {
     if (vertex_lons != NULL) {
-		delete [] vertex_lons;
-		delete [] vertex_lats;
+        delete [] vertex_lons;
+        delete [] vertex_lats;
     }
 
-	if (cartesian_coord != NULL)
-		delete cartesian_coord;
+    if (cartesian_coord != NULL)
+        delete cartesian_coord;
 }
 
 
 bool H2D_grid_cell_search_cell::is_point_in_latlon_coord_cell(double point_lon,double point_lat) const
 {
-	int last_pos = -100, i, next_i, pos;
-	double det, distance1, distance2, distance3, lon_diff1, lon_diff2;
-	bool in_cell = true;
-	double e1 = 1.0e-12, e2 = 1.0e-7;
-	
-
-	for (i = 0; i < num_vertex; i ++) {
-		next_i = (i+1) % num_vertex;
-		lon_diff1 = vertex_lons[i]-point_lon;
-		lon_diff2 = vertex_lons[next_i]-point_lon;
-		if (lon_diff1 < -180)
-			lon_diff1 += 360;
-		if (lon_diff1 > 180)
-			lon_diff1 -= 360;
-		if (lon_diff2 < -180)
-			lon_diff2 += 360;
-		if (lon_diff2 > 180)
-			lon_diff2 -= 360;
-		det = lon_diff1 * (vertex_lats[next_i]-point_lat) - (vertex_lats[i]-point_lat) * lon_diff2;
-		if (fabs(det) <= e1) {
+    int last_pos = -100, i, next_i, pos;
+    double det, distance1, distance2, distance3, lon_diff1, lon_diff2;
+    bool in_cell = true;
+    double e1 = 1.0e-12, e2 = 1.0e-7;
+    
+
+    for (i = 0; i < num_vertex; i ++) {
+        next_i = (i+1) % num_vertex;
+        lon_diff1 = vertex_lons[i]-point_lon;
+        lon_diff2 = vertex_lons[next_i]-point_lon;
+        if (lon_diff1 < -180)
+            lon_diff1 += 360;
+        if (lon_diff1 > 180)
+            lon_diff1 -= 360;
+        if (lon_diff2 < -180)
+            lon_diff2 += 360;
+        if (lon_diff2 > 180)
+            lon_diff2 -= 360;
+        det = lon_diff1 * (vertex_lats[next_i]-point_lat) - (vertex_lats[i]-point_lat) * lon_diff2;
+        if (fabs(det) <= e1) {
             distance1 = calculate_distance_of_two_points_2D(point_lon, point_lat, vertex_lons[i], vertex_lats[i], true);
             distance2 = calculate_distance_of_two_points_2D(point_lon, point_lat, vertex_lons[next_i], vertex_lats[next_i], true);
             distance3 = calculate_distance_of_two_points_2D(vertex_lons[i], vertex_lats[i], vertex_lons[next_i], vertex_lats[next_i], true);
-			in_cell = distance1 <= distance3 && distance2 <= distance3;
-			break;
-		}
-		else if (det > 0)
-			pos = 1;
-		else pos = -1;
-		if (last_pos == -100)
-			last_pos = pos;
-		else if (last_pos != pos) {
-			in_cell = false;
-			break;
-		}
-	}
-
-	return in_cell;
+            in_cell = distance1 <= distance3 && distance2 <= distance3;
+            break;
+        }
+        else if (det > 0)
+            pos = 1;
+        else pos = -1;
+        if (last_pos == -100)
+            last_pos = pos;
+        else if (last_pos != pos) {
+            in_cell = false;
+            break;
+        }
+    }
+
+    return in_cell;
 }
 
 
@@ -259,462 +259,462 @@ bool H2D_grid_cell_search_cell::is_point_in_cartesian_coord_cell(double point_lo
 
 bool H2D_grid_cell_search_cell::check_possible_overlapping(const H2D_grid_cell_search_cell *src_cell) const
 {
-	double dist;
-	int i;
-	bool possible_overlapping = false;
-
-
-	EXECUTION_REPORT(REPORT_ERROR, src_cell->get_bounding_circle_radius() > 0, "Software error in H2D_grid_cell_search_cell::check_possible_overlapping");
-	dist = calculate_distance_of_two_points_2D(bounding_circle_center_lon, bounding_circle_center_lat, src_cell->get_bounding_circle_center_lon(), src_cell->get_bounding_circle_center_lat(), true);
-	if (dist > bounding_circle_radius + src_cell->get_bounding_circle_radius())
-		return false;
-	
-	if (num_vertex == 0)
-		return true;
-
-	for (i = 0; i < num_vertex; i ++) {
-		dist = calculate_distance_of_two_points_2D(vertex_lons[i], vertex_lats[i], src_cell->get_bounding_circle_center_lon(), src_cell->get_bounding_circle_center_lat(), true);
-		if (dist <= src_cell->get_bounding_circle_radius()) {
-			possible_overlapping = true;
-			break;
-		}
-	}
-
-	for (i = 0; i < src_cell->get_num_vertex(); i ++) {
-		dist = calculate_distance_of_two_points_2D(src_cell->get_vertex_lon(i), src_cell->get_vertex_lat(i), bounding_circle_center_lon, bounding_circle_center_lat, true);
-		if (dist <= bounding_circle_radius) {
-			possible_overlapping = true;
-			break;
-		}
-	}
-
-	return possible_overlapping;
+    double dist;
+    int i;
+    bool possible_overlapping = false;
+
+
+    EXECUTION_REPORT(REPORT_ERROR, src_cell->get_bounding_circle_radius() > 0, "Software error in H2D_grid_cell_search_cell::check_possible_overlapping");
+    dist = calculate_distance_of_two_points_2D(bounding_circle_center_lon, bounding_circle_center_lat, src_cell->get_bounding_circle_center_lon(), src_cell->get_bounding_circle_center_lat(), true);
+    if (dist > bounding_circle_radius + src_cell->get_bounding_circle_radius())
+        return false;
+    
+    if (num_vertex == 0)
+        return true;
+
+    for (i = 0; i < num_vertex; i ++) {
+        dist = calculate_distance_of_two_points_2D(vertex_lons[i], vertex_lats[i], src_cell->get_bounding_circle_center_lon(), src_cell->get_bounding_circle_center_lat(), true);
+        if (dist <= src_cell->get_bounding_circle_radius()) {
+            possible_overlapping = true;
+            break;
+        }
+    }
+
+    for (i = 0; i < src_cell->get_num_vertex(); i ++) {
+        dist = calculate_distance_of_two_points_2D(src_cell->get_vertex_lon(i), src_cell->get_vertex_lat(i), bounding_circle_center_lon, bounding_circle_center_lat, true);
+        if (dist <= bounding_circle_radius) {
+            possible_overlapping = true;
+            break;
+        }
+    }
+
+    return possible_overlapping;
 }
 
 
 bool H2D_grid_cell_search_cell::check_overlapping(const H2D_grid_cell_search_cell *src_cell, bool accurately_match) const
 {
-	bool possible_overlapping, is_overlapping;
-	int i;
-
-
-	if (!src_cell->get_mask())
-		return false;
-
-	possible_overlapping = check_possible_overlapping(src_cell);
-
-	if (!accurately_match || !possible_overlapping)
-		return possible_overlapping;
-
-	if (num_vertex > 0) {
-		for (i = 0; i < num_vertex; i ++) {
-			if (src_cell->get_edge_type() == EDGE_TYPE_LATLON)
-				is_overlapping = src_cell->is_point_in_latlon_coord_cell(vertex_lons[i], vertex_lats[i]);
-			else is_overlapping = src_cell->is_point_in_cartesian_coord_cell(vertex_lons[i], vertex_lats[i]); 
-			if (is_overlapping)
-				return true;
-		}
-		for (i = 0; i < src_cell->get_num_vertex(); i ++) {
-			if (edge_type == EDGE_TYPE_LATLON)
-				is_overlapping = is_point_in_latlon_coord_cell(src_cell->get_vertex_lon(i), src_cell->get_vertex_lat(i));
-			else is_overlapping = is_point_in_cartesian_coord_cell(src_cell->get_vertex_lon(i), src_cell->get_vertex_lat(i));
-			if (is_overlapping)
-				return true;
-		}
-	}
-	else {
-		if (edge_type == EDGE_TYPE_LATLON)
-			is_overlapping = src_cell->is_point_in_latlon_coord_cell(center_lon, center_lat);
-		else is_overlapping = src_cell->is_point_in_cartesian_coord_cell(center_lon, center_lat);
-		if (is_overlapping)
-			return true;
-	}
-
-	return false;
+    bool possible_overlapping, is_overlapping;
+    int i;
+
+
+    if (!src_cell->get_mask())
+        return false;
+
+    possible_overlapping = check_possible_overlapping(src_cell);
+
+    if (!accurately_match || !possible_overlapping)
+        return possible_overlapping;
+
+    if (num_vertex > 0) {
+        for (i = 0; i < num_vertex; i ++) {
+            if (src_cell->get_edge_type() == EDGE_TYPE_LATLON)
+                is_overlapping = src_cell->is_point_in_latlon_coord_cell(vertex_lons[i], vertex_lats[i]);
+            else is_overlapping = src_cell->is_point_in_cartesian_coord_cell(vertex_lons[i], vertex_lats[i]); 
+            if (is_overlapping)
+                return true;
+        }
+        for (i = 0; i < src_cell->get_num_vertex(); i ++) {
+            if (edge_type == EDGE_TYPE_LATLON)
+                is_overlapping = is_point_in_latlon_coord_cell(src_cell->get_vertex_lon(i), src_cell->get_vertex_lat(i));
+            else is_overlapping = is_point_in_cartesian_coord_cell(src_cell->get_vertex_lon(i), src_cell->get_vertex_lat(i));
+            if (is_overlapping)
+                return true;
+        }
+    }
+    else {
+        if (edge_type == EDGE_TYPE_LATLON)
+            is_overlapping = src_cell->is_point_in_latlon_coord_cell(center_lon, center_lat);
+        else is_overlapping = src_cell->is_point_in_cartesian_coord_cell(center_lon, center_lat);
+        if (is_overlapping)
+            return true;
+    }
+
+    return false;
 }
 
 
 double H2D_grid_cell_search_cell::get_vertex_lon(int indx) const 
 {
-	EXECUTION_REPORT(REPORT_ERROR, indx < num_vertex && indx >= 0, "Software error in H2D_grid_cell_search_cell::get_vertex_lon");
-	return vertex_lons[indx];
+    EXECUTION_REPORT(REPORT_ERROR, indx < num_vertex && indx >= 0, "Software error in H2D_grid_cell_search_cell::get_vertex_lon");
+    return vertex_lons[indx];
 }
 
 
 double H2D_grid_cell_search_cell::get_vertex_lat(int indx) const 
 {
-	EXECUTION_REPORT(REPORT_ERROR, indx < num_vertex && indx >= 0, "Software error in H2D_grid_cell_search_cell::get_vertex_lat");
-	return vertex_lats[indx];
+    EXECUTION_REPORT(REPORT_ERROR, indx < num_vertex && indx >= 0, "Software error in H2D_grid_cell_search_cell::get_vertex_lat");
+    return vertex_lats[indx];
 }
 
 
 H2D_grid_cell_search_tile::H2D_grid_cell_search_tile(int num_cells, H2D_grid_cell_search_cell **cells, H2D_grid_cell_search_cell **cells_buffer, 
-	                                                 long *index_buffer, H2D_grid_cell_search_tile *parent, double center_lon, double center_lat, double dlon, double dlat)
+                                                     long *index_buffer, H2D_grid_cell_search_tile *parent, double center_lon, double center_lat, double dlon, double dlat)
 {
-	this->num_cells = num_cells;
-	this->cells = cells;
-	this->cells_buffer = cells_buffer;
-	this->index_buffer = index_buffer;
-	this->parent = parent;
-	this->center_lon = center_lon;
-	this->center_lat = center_lat;
-	this->dlon = dlon;
-	this->dlat = dlat;
-
-	compute_bounding_circle();
-	divide_tile();
+    this->num_cells = num_cells;
+    this->cells = cells;
+    this->cells_buffer = cells_buffer;
+    this->index_buffer = index_buffer;
+    this->parent = parent;
+    this->center_lon = center_lon;
+    this->center_lat = center_lat;
+    this->dlon = dlon;
+    this->dlat = dlat;
+
+    compute_bounding_circle();
+    divide_tile();
 }
 
 
 H2D_grid_cell_search_tile::~H2D_grid_cell_search_tile()
 {
-	for (int i = 0; i < TILE_DIVIDE_FACTOR*TILE_DIVIDE_FACTOR; i ++)
-		if (children[i] != NULL)
-			delete children[i];
+    for (int i = 0; i < TILE_DIVIDE_FACTOR*TILE_DIVIDE_FACTOR; i ++)
+        if (children[i] != NULL)
+            delete children[i];
 }
 
 
 
 void H2D_grid_cell_search_tile::compute_bounding_circle()
 {
-	double point_lon, point_lat, dist, max_dist;
-	int i, j;
-
-	point_lon = center_lon - dlon/2;
-	point_lat = center_lat - dlat/2;
-	if (point_lon < 0)
-		point_lon += 360;
-	circle_radius = calculate_distance_of_two_points_2D(center_lon, center_lat, point_lon, point_lat, true);
-
-	for (i = 0; i < num_cells; i ++) {
-		dist = calculate_distance_of_two_points_2D(center_lon, center_lat, cells[i]->get_bounding_circle_center_lon(), cells[i]->get_bounding_circle_center_lat(), true);
-		if (circle_radius < dist + cells[i]->get_bounding_circle_radius()) {
-			circle_radius = dist + cells[i]->get_bounding_circle_radius();
-		}
-	}
-	circle_radius *= 1.00001;
+    double point_lon, point_lat, dist, max_dist;
+    int i, j;
+
+    point_lon = center_lon - dlon/2;
+    point_lat = center_lat - dlat/2;
+    if (point_lon < 0)
+        point_lon += 360;
+    circle_radius = calculate_distance_of_two_points_2D(center_lon, center_lat, point_lon, point_lat, true);
+
+    for (i = 0; i < num_cells; i ++) {
+        dist = calculate_distance_of_two_points_2D(center_lon, center_lat, cells[i]->get_bounding_circle_center_lon(), cells[i]->get_bounding_circle_center_lat(), true);
+        if (circle_radius < dist + cells[i]->get_bounding_circle_radius()) {
+            circle_radius = dist + cells[i]->get_bounding_circle_radius();
+        }
+    }
+    circle_radius *= 1.00001;
 }
 
 
 void H2D_grid_cell_search_tile::divide_tile()
 {
-	int i, j, indx_at_lon, indx_at_lat, child_indx, displ;
-	int num_cells_in_children[TILE_DIVIDE_FACTOR*TILE_DIVIDE_FACTOR], displ_of_children_in_cells[TILE_DIVIDE_FACTOR*TILE_DIVIDE_FACTOR];
-	double new_dlon, new_dlat, min_lon, min_lat, diff_lon, diff_lat;
-	double children_center_lon[TILE_DIVIDE_FACTOR*TILE_DIVIDE_FACTOR], children_center_lat[TILE_DIVIDE_FACTOR*TILE_DIVIDE_FACTOR];
-
-
-	for (i = 0; i < TILE_DIVIDE_FACTOR*TILE_DIVIDE_FACTOR; i ++)
-		children[i] = NULL;
-	
-	if (num_cells <= MAX_NUM_CELLS_IN_TILE)
-		return;
-
-	seperate_cells_in_children_tiles(num_cells, cells, center_lon, center_lat, dlon, dlat, num_cells_in_children, index_buffer);
-
-	new_dlon = dlon / ((double)TILE_DIVIDE_FACTOR);
-	new_dlat = dlat / ((double)TILE_DIVIDE_FACTOR);
-	min_lon = center_lon - dlon/2;
-	min_lat = center_lat - dlat/2;
-	if (min_lon < 0)
-		min_lon += 360;
-
-	for (i = 0, displ = 0; i < TILE_DIVIDE_FACTOR*TILE_DIVIDE_FACTOR; i ++) {
-		displ_of_children_in_cells[i] = displ;
-		displ += num_cells_in_children[i];
-	}
-	for (i = 0; i < num_cells; i ++)
-		cells_buffer[displ_of_children_in_cells[index_buffer[i]]++] = cells[i];
-	for (i = 0; i < num_cells; i ++)
-		cells[i] = cells_buffer[i];
-	for (i = 0, displ = 0; i < TILE_DIVIDE_FACTOR*TILE_DIVIDE_FACTOR; i ++) {
-		EXECUTION_REPORT(REPORT_ERROR, displ_of_children_in_cells[i] == displ+num_cells_in_children[i], "Software error2 in H2D_grid_cell_search_tile::divide_tile");
-		displ_of_children_in_cells[i] = displ;
-		displ += num_cells_in_children[i];
-	}	
-
-	for (indx_at_lat = 0; indx_at_lat < TILE_DIVIDE_FACTOR; indx_at_lat ++)
-		for (indx_at_lon = 0; indx_at_lon <  TILE_DIVIDE_FACTOR; indx_at_lon ++) {
-			child_indx = indx_at_lat*TILE_DIVIDE_FACTOR+indx_at_lon;
-			children_center_lon[child_indx] = min_lon + new_dlon*indx_at_lon + new_dlon/2;
-			children_center_lat[child_indx] = min_lat + new_dlat*indx_at_lat + new_dlat/2;
-			if (children_center_lon[child_indx] < 0)
-				children_center_lon[child_indx] += 360;
-			if (children_center_lon[child_indx] >= 360)
-				children_center_lon[child_indx] -= 360;
-		}
-	for (i = 0, j = 0; i < TILE_DIVIDE_FACTOR*TILE_DIVIDE_FACTOR; i ++)
-		if (num_cells_in_children[i] != 0) {
-			children[j++] = new H2D_grid_cell_search_tile(num_cells_in_children[i], cells+displ_of_children_in_cells[i], cells_buffer, index_buffer,
-														  this, children_center_lon[i], children_center_lat[i], new_dlon, new_dlat);
-		}
-
-	if (j > 0)
-		cells = NULL;
+    int i, j, indx_at_lon, indx_at_lat, child_indx, displ;
+    int num_cells_in_children[TILE_DIVIDE_FACTOR*TILE_DIVIDE_FACTOR], displ_of_children_in_cells[TILE_DIVIDE_FACTOR*TILE_DIVIDE_FACTOR];
+    double new_dlon, new_dlat, min_lon, min_lat, diff_lon, diff_lat;
+    double children_center_lon[TILE_DIVIDE_FACTOR*TILE_DIVIDE_FACTOR], children_center_lat[TILE_DIVIDE_FACTOR*TILE_DIVIDE_FACTOR];
+
+
+    for (i = 0; i < TILE_DIVIDE_FACTOR*TILE_DIVIDE_FACTOR; i ++)
+        children[i] = NULL;
+    
+    if (num_cells <= MAX_NUM_CELLS_IN_TILE)
+        return;
+
+    seperate_cells_in_children_tiles(num_cells, cells, center_lon, center_lat, dlon, dlat, num_cells_in_children, index_buffer);
+
+    new_dlon = dlon / ((double)TILE_DIVIDE_FACTOR);
+    new_dlat = dlat / ((double)TILE_DIVIDE_FACTOR);
+    min_lon = center_lon - dlon/2;
+    min_lat = center_lat - dlat/2;
+    if (min_lon < 0)
+        min_lon += 360;
+
+    for (i = 0, displ = 0; i < TILE_DIVIDE_FACTOR*TILE_DIVIDE_FACTOR; i ++) {
+        displ_of_children_in_cells[i] = displ;
+        displ += num_cells_in_children[i];
+    }
+    for (i = 0; i < num_cells; i ++)
+        cells_buffer[displ_of_children_in_cells[index_buffer[i]]++] = cells[i];
+    for (i = 0; i < num_cells; i ++)
+        cells[i] = cells_buffer[i];
+    for (i = 0, displ = 0; i < TILE_DIVIDE_FACTOR*TILE_DIVIDE_FACTOR; i ++) {
+        EXECUTION_REPORT(REPORT_ERROR, displ_of_children_in_cells[i] == displ+num_cells_in_children[i], "Software error2 in H2D_grid_cell_search_tile::divide_tile");
+        displ_of_children_in_cells[i] = displ;
+        displ += num_cells_in_children[i];
+    }    
+
+    for (indx_at_lat = 0; indx_at_lat < TILE_DIVIDE_FACTOR; indx_at_lat ++)
+        for (indx_at_lon = 0; indx_at_lon <  TILE_DIVIDE_FACTOR; indx_at_lon ++) {
+            child_indx = indx_at_lat*TILE_DIVIDE_FACTOR+indx_at_lon;
+            children_center_lon[child_indx] = min_lon + new_dlon*indx_at_lon + new_dlon/2;
+            children_center_lat[child_indx] = min_lat + new_dlat*indx_at_lat + new_dlat/2;
+            if (children_center_lon[child_indx] < 0)
+                children_center_lon[child_indx] += 360;
+            if (children_center_lon[child_indx] >= 360)
+                children_center_lon[child_indx] -= 360;
+        }
+    for (i = 0, j = 0; i < TILE_DIVIDE_FACTOR*TILE_DIVIDE_FACTOR; i ++)
+        if (num_cells_in_children[i] != 0) {
+            children[j++] = new H2D_grid_cell_search_tile(num_cells_in_children[i], cells+displ_of_children_in_cells[i], cells_buffer, index_buffer,
+                                                          this, children_center_lon[i], children_center_lat[i], new_dlon, new_dlat);
+        }
+
+    if (j > 0)
+        cells = NULL;
 }
 
 
 bool H2D_grid_cell_search_tile::search_points_within_distance(double dist_threshold, double dst_point_lon, double dst_point_lat, int &num_found_points, long *found_points_indx, double *found_points_dist, bool early_quit)
 {
-	double distance;
-	bool have_the_same_point = false;
-
-
-	distance = calculate_distance_of_two_points_2D(center_lon, center_lat, dst_point_lon, dst_point_lat, true);
-	if (distance - circle_radius > dist_threshold)
-		return have_the_same_point;
-
-	if (cells == NULL) {
-		for (int i = 0; i < TILE_DIVIDE_FACTOR*TILE_DIVIDE_FACTOR; i ++) {
-			if (children[i] == NULL) 
-				break;
-			have_the_same_point |= children[i]->search_points_within_distance(dist_threshold, dst_point_lon, dst_point_lat, num_found_points, found_points_indx, found_points_dist, early_quit);
-			if (early_quit && have_the_same_point)
-				break;
-		}
-	}
-	else {
-		for (int i = 0; i < num_cells; i ++) {
-			if (!cells[i]->get_mask())
-				continue;
-			if (cells[i]->get_center_lon() == dst_point_lon && cells[i]->get_center_lat() == dst_point_lat) {
-				have_the_same_point = true;
-				distance = 0;
-			}
-			else distance = calculate_distance_of_two_points_2D(cells[i]->get_center_lon(), cells[i]->get_center_lat(), dst_point_lon, dst_point_lat, true);
-			if (distance <= dist_threshold) {
-				found_points_indx[num_found_points] = cells[i]->get_cell_index();
-				found_points_dist[num_found_points] = distance;
-				num_found_points ++;
-			}
-			if (early_quit && have_the_same_point) {
-				found_points_indx[0] = cells[i]->get_cell_index();
-				found_points_dist[0] = 0;
-				num_found_points = 1;
-				break;
-			}
-		}
-	}
-
-	return have_the_same_point;
+    double distance;
+    bool have_the_same_point = false;
+
+
+    distance = calculate_distance_of_two_points_2D(center_lon, center_lat, dst_point_lon, dst_point_lat, true);
+    if (distance - circle_radius > dist_threshold)
+        return have_the_same_point;
+
+    if (cells == NULL) {
+        for (int i = 0; i < TILE_DIVIDE_FACTOR*TILE_DIVIDE_FACTOR; i ++) {
+            if (children[i] == NULL) 
+                break;
+            have_the_same_point |= children[i]->search_points_within_distance(dist_threshold, dst_point_lon, dst_point_lat, num_found_points, found_points_indx, found_points_dist, early_quit);
+            if (early_quit && have_the_same_point)
+                break;
+        }
+    }
+    else {
+        for (int i = 0; i < num_cells; i ++) {
+            if (!cells[i]->get_mask())
+                continue;
+            if (cells[i]->get_center_lon() == dst_point_lon && cells[i]->get_center_lat() == dst_point_lat) {
+                have_the_same_point = true;
+                distance = 0;
+            }
+            else distance = calculate_distance_of_two_points_2D(cells[i]->get_center_lon(), cells[i]->get_center_lat(), dst_point_lon, dst_point_lat, true);
+            if (distance <= dist_threshold) {
+                found_points_indx[num_found_points] = cells[i]->get_cell_index();
+                found_points_dist[num_found_points] = distance;
+                num_found_points ++;
+            }
+            if (early_quit && have_the_same_point) {
+                found_points_indx[0] = cells[i]->get_cell_index();
+                found_points_dist[0] = 0;
+                num_found_points = 1;
+                break;
+            }
+        }
+    }
+
+    return have_the_same_point;
 }
 
 
 bool H2D_grid_cell_search_tile::has_cell_index(int cell_index)
 {
-	if (cells == NULL) {
-		for (int i = 0; i < TILE_DIVIDE_FACTOR*TILE_DIVIDE_FACTOR; i ++) {
-			if (children[i] == NULL) 
-				break;
-			if (children[i]->has_cell_index(cell_index))
-				return true;
-		}
-	}
-	else {
-		for (int i = 0; i < num_cells; i ++)
-			if (cells[i]->get_cell_index() == cell_index)
-				return true;
-	}
-
-	return false;
+    if (cells == NULL) {
+        for (int i = 0; i < TILE_DIVIDE_FACTOR*TILE_DIVIDE_FACTOR; i ++) {
+            if (children[i] == NULL) 
+                break;
+            if (children[i]->has_cell_index(cell_index))
+                return true;
+        }
+    }
+    else {
+        for (int i = 0; i < num_cells; i ++)
+            if (cells[i]->get_cell_index() == cell_index)
+                return true;
+    }
+
+    return false;
 }
 
 
 void H2D_grid_cell_search_tile::search_overlapping_cells(int &num_overlapping_cells, long *overlapping_cells_index, const H2D_grid_cell_search_cell *dst_cell, bool accurately_match, bool early_quit)
 {
-	double dist = calculate_distance_of_two_points_2D(dst_cell->get_bounding_circle_center_lon(), dst_cell->get_bounding_circle_center_lat(), center_lon, center_lat, true);
-
-	if (dist > dst_cell->get_bounding_circle_radius() + circle_radius)
-		return;
-
-	if (cells == NULL) {
-		for (int i = 0; i < TILE_DIVIDE_FACTOR*TILE_DIVIDE_FACTOR; i ++) {
-			if (children[i] == NULL) 
-				break;
-			children[i]->search_overlapping_cells(num_overlapping_cells, overlapping_cells_index, dst_cell, accurately_match, early_quit);
-			if (early_quit && num_overlapping_cells > 0)
-				return;
-		}
-
-	}
-	else {
-		for (int i = 0; i < num_cells; i ++) {
-			if (dst_cell->check_overlapping(cells[i], accurately_match)) {
-				overlapping_cells_index[num_overlapping_cells++] = cells[i]->get_cell_index();
-				if (early_quit)
-					return;
-			}
-		}
-	}
+    double dist = calculate_distance_of_two_points_2D(dst_cell->get_bounding_circle_center_lon(), dst_cell->get_bounding_circle_center_lat(), center_lon, center_lat, true);
+
+    if (dist > dst_cell->get_bounding_circle_radius() + circle_radius)
+        return;
+
+    if (cells == NULL) {
+        for (int i = 0; i < TILE_DIVIDE_FACTOR*TILE_DIVIDE_FACTOR; i ++) {
+            if (children[i] == NULL) 
+                break;
+            children[i]->search_overlapping_cells(num_overlapping_cells, overlapping_cells_index, dst_cell, accurately_match, early_quit);
+            if (early_quit && num_overlapping_cells > 0)
+                return;
+        }
+
+    }
+    else {
+        for (int i = 0; i < num_cells; i ++) {
+            if (dst_cell->check_overlapping(cells[i], accurately_match)) {
+                overlapping_cells_index[num_overlapping_cells++] = cells[i]->get_cell_index();
+                if (early_quit)
+                    return;
+            }
+        }
+    }
 }
 
 
 H2D_grid_cell_search_engine::H2D_grid_cell_search_engine(const Remap_grid_class *remap_grid, const double *center_lons, const double *center_lats, const bool *masks, 
-	                                                     const bool *redundant_mask, int num_vertex, const double *vertex_lons, const double *vertex_lats, int edge_type, bool build_search_structure)
+                                                         const bool *redundant_mask, int num_vertex, const double *vertex_lons, const double *vertex_lats, int edge_type, bool build_search_structure)
 {
-	double center_lon, center_lat, dlon, dlat;
-	bool mask = true;
-	int i;
-
-	
-	EXECUTION_REPORT(REPORT_ERROR, remap_grid->get_is_sphere_grid(), "Software error1 in H2D_grid_cell_search_engine::H2D_grid_cell_search_engine");
-	
-	this->remap_grid = remap_grid;
-	if (redundant_mask == NULL)
-		num_cells = remap_grid->get_grid_size();
-	else {
-		for (i = 0, num_cells = 0; i < remap_grid->get_grid_size(); i ++)
-			if (!redundant_mask[i])
-				num_cells ++;
-	}
-		
-	cells = new H2D_grid_cell_search_cell* [remap_grid->get_grid_size()];
-	cells_ptr = new H2D_grid_cell_search_cell* [num_cells];
-	cells_buffer = new H2D_grid_cell_search_cell* [num_cells];
-	index_buffer = new long [num_cells];
-	dist_buffer = new double [num_cells];
-	dist_threshold = 1 / 6000.0;
-
-	for (int i = 0, num_cells = 0; i < remap_grid->get_grid_size(); i ++) {
-		if (masks != NULL)
-			mask = masks[i];
-		cells[i] = new H2D_grid_cell_search_cell(i, center_lons[i], center_lats[i], mask, num_vertex, vertex_lons+num_vertex*i, vertex_lats+num_vertex*i, edge_type);
-		if (redundant_mask != NULL && redundant_mask[i])
-			continue;
-		cells_ptr[num_cells] = cells[i];
-		num_cells++;
-	}
-
-	center_lon = NULL_COORD_VALUE;
-	center_lat = NULL_COORD_VALUE;
-	dlon = NULL_COORD_VALUE;
-	dlat = NULL_COORD_VALUE;
-	recursively_search_initial_boundary(180, 0, 360, 180, center_lon, center_lat, dlon, dlat);
-	EXECUTION_REPORT(REPORT_ERROR, center_lon != NULL_COORD_VALUE && center_lat != NULL_COORD_VALUE && dlon != NULL_COORD_VALUE && dlat != NULL_COORD_VALUE, 
-		             "Software error2 in in H2D_grid_cell_search_engine::H2D_grid_cell_search_engine");
-	
-	if (build_search_structure)
-		root_tile = new H2D_grid_cell_search_tile(num_cells, cells_ptr, cells_buffer, index_buffer, NULL, center_lon, center_lat, dlon, dlat);
-	else root_tile = NULL;
+    double center_lon, center_lat, dlon, dlat;
+    bool mask = true;
+    int i;
+
+    
+    EXECUTION_REPORT(REPORT_ERROR, remap_grid->get_is_sphere_grid(), "Software error1 in H2D_grid_cell_search_engine::H2D_grid_cell_search_engine");
+    
+    this->remap_grid = remap_grid;
+    if (redundant_mask == NULL)
+        num_cells = remap_grid->get_grid_size();
+    else {
+        for (i = 0, num_cells = 0; i < remap_grid->get_grid_size(); i ++)
+            if (!redundant_mask[i])
+                num_cells ++;
+    }
+        
+    cells = new H2D_grid_cell_search_cell* [remap_grid->get_grid_size()];
+    cells_ptr = new H2D_grid_cell_search_cell* [num_cells];
+    cells_buffer = new H2D_grid_cell_search_cell* [num_cells];
+    index_buffer = new long [num_cells];
+    dist_buffer = new double [num_cells];
+    dist_threshold = 1 / 6000.0;
+
+    for (int i = 0, num_cells = 0; i < remap_grid->get_grid_size(); i ++) {
+        if (masks != NULL)
+            mask = masks[i];
+        cells[i] = new H2D_grid_cell_search_cell(i, center_lons[i], center_lats[i], mask, num_vertex, vertex_lons+num_vertex*i, vertex_lats+num_vertex*i, edge_type);
+        if (redundant_mask != NULL && redundant_mask[i])
+            continue;
+        cells_ptr[num_cells] = cells[i];
+        num_cells++;
+    }
+
+    center_lon = NULL_COORD_VALUE;
+    center_lat = NULL_COORD_VALUE;
+    dlon = NULL_COORD_VALUE;
+    dlat = NULL_COORD_VALUE;
+    recursively_search_initial_boundary(180, 0, 360, 180, center_lon, center_lat, dlon, dlat);
+    EXECUTION_REPORT(REPORT_ERROR, center_lon != NULL_COORD_VALUE && center_lat != NULL_COORD_VALUE && dlon != NULL_COORD_VALUE && dlat != NULL_COORD_VALUE, 
+                     "Software error2 in in H2D_grid_cell_search_engine::H2D_grid_cell_search_engine");
+    
+    if (build_search_structure)
+        root_tile = new H2D_grid_cell_search_tile(num_cells, cells_ptr, cells_buffer, index_buffer, NULL, center_lon, center_lat, dlon, dlat);
+    else root_tile = NULL;
 }
 
 
 H2D_grid_cell_search_engine::~H2D_grid_cell_search_engine()
 {
-	for (int i = 0; i < remap_grid->get_grid_size(); i ++)
-		delete cells[i];
-	delete [] cells;
-	delete [] cells_ptr;
-	delete [] cells_buffer;
-	delete [] index_buffer;
-	delete [] dist_buffer;
-	delete root_tile;
+    for (int i = 0; i < remap_grid->get_grid_size(); i ++)
+        delete cells[i];
+    delete [] cells;
+    delete [] cells_ptr;
+    delete [] cells_buffer;
+    delete [] index_buffer;
+    delete [] dist_buffer;
+    delete root_tile;
 }
 
 
 void H2D_grid_cell_search_engine::recursively_search_initial_boundary(double center_lon, double center_lat, double dlon, double dlat, double &result_center_lon, 
-	                                                                  double &result_center_lat, double &result_dlon, double &result_dlat)
+                                                                      double &result_center_lat, double &result_dlon, double &result_dlat)
 {
-	int num_cells_in_children[TILE_DIVIDE_FACTOR*TILE_DIVIDE_FACTOR];
-	int i, num_children, unique_child_indx, indx_at_lon, indx_at_lat;
-	double new_dlon, new_dlat, min_lon, min_lat, new_center_lon, new_center_lat;
-
-	
-	seperate_cells_in_children_tiles(num_cells, cells_ptr, center_lon, center_lat, dlon, dlat, num_cells_in_children, index_buffer);
-	for (i = 0, num_children = 0; i < TILE_DIVIDE_FACTOR*TILE_DIVIDE_FACTOR; i ++)
-		if (num_cells_in_children[i] > 0) {
-			unique_child_indx = i;
-			num_children ++;
-		}
-
-	if (num_children > 1) {
-		result_center_lon = center_lon;
-		result_center_lat = center_lat;
-		result_dlon = dlon;
-		result_dlat = dlat;
-		return;
-	}
-
-	new_dlon = dlon / ((double)TILE_DIVIDE_FACTOR);
-	new_dlat = dlat / ((double)TILE_DIVIDE_FACTOR);
-	min_lon = center_lon - dlon/2;
-	min_lat = center_lat - dlat/2;
-	if (min_lon < 0)
-		min_lon += 360;
-	indx_at_lon = unique_child_indx % TILE_DIVIDE_FACTOR;
-	indx_at_lat = unique_child_indx / TILE_DIVIDE_FACTOR;
-	new_center_lon = min_lon + new_dlon*indx_at_lon + new_dlon/2;
-	new_center_lat = min_lat + new_dlat*indx_at_lat + new_dlat/2;
-	if (new_center_lon >= 360)
-		new_center_lon -= 360;
-	
-	recursively_search_initial_boundary(new_center_lon, new_center_lat, new_dlon, new_dlat, result_center_lon, result_center_lat, result_dlon, result_dlat);
+    int num_cells_in_children[TILE_DIVIDE_FACTOR*TILE_DIVIDE_FACTOR];
+    int i, num_children, unique_child_indx, indx_at_lon, indx_at_lat;
+    double new_dlon, new_dlat, min_lon, min_lat, new_center_lon, new_center_lat;
+
+    
+    seperate_cells_in_children_tiles(num_cells, cells_ptr, center_lon, center_lat, dlon, dlat, num_cells_in_children, index_buffer);
+    for (i = 0, num_children = 0; i < TILE_DIVIDE_FACTOR*TILE_DIVIDE_FACTOR; i ++)
+        if (num_cells_in_children[i] > 0) {
+            unique_child_indx = i;
+            num_children ++;
+        }
+
+    if (num_children > 1) {
+        result_center_lon = center_lon;
+        result_center_lat = center_lat;
+        result_dlon = dlon;
+        result_dlat = dlat;
+        return;
+    }
+
+    new_dlon = dlon / ((double)TILE_DIVIDE_FACTOR);
+    new_dlat = dlat / ((double)TILE_DIVIDE_FACTOR);
+    min_lon = center_lon - dlon/2;
+    min_lat = center_lat - dlat/2;
+    if (min_lon < 0)
+        min_lon += 360;
+    indx_at_lon = unique_child_indx % TILE_DIVIDE_FACTOR;
+    indx_at_lat = unique_child_indx / TILE_DIVIDE_FACTOR;
+    new_center_lon = min_lon + new_dlon*indx_at_lon + new_dlon/2;
+    new_center_lat = min_lat + new_dlat*indx_at_lat + new_dlat/2;
+    if (new_center_lon >= 360)
+        new_center_lon -= 360;
+    
+    recursively_search_initial_boundary(new_center_lon, new_center_lat, new_dlon, new_dlat, result_center_lon, result_center_lat, result_dlon, result_dlat);
 }
 
 
 void H2D_grid_cell_search_engine::search_nearest_points_var_number(int num_required_points, double dst_point_lon, double dst_point_lat, int &num_found_points, long *found_points_indx, double *found_points_dist, bool early_quit)
 {
-	bool have_the_same_point = false;
-	double old_dist_threshold;
-
-
-	if (num_required_points > remap_grid->get_grid_size())
-		num_required_points = remap_grid->get_grid_size();
-	
-	num_found_points = 0;
-	
-	while (num_found_points < num_required_points) {
-		num_found_points = 0;
-		have_the_same_point = root_tile->search_points_within_distance(dist_threshold, dst_point_lon, dst_point_lat, num_found_points, index_buffer, dist_buffer, early_quit);
-		if (num_found_points== 0)
-			dist_threshold *= 2;
-		if (have_the_same_point && early_quit)
-			break;
-		old_dist_threshold = dist_threshold;
-		dist_threshold *= sqrt(((double)num_required_points)/((double)num_found_points))*1.1;
-	}
-
-	if (have_the_same_point && early_quit) {
-		EXECUTION_REPORT(REPORT_ERROR, num_found_points == 1, "Software error in H2D_grid_cell_search_engine::search_nearest_points_var_number");
-		found_points_indx[0] = index_buffer[0];
-		found_points_dist[0] = dist_buffer[0];
-		return;
-	}
-	
-	do_quick_sort(dist_buffer, index_buffer, 0, num_found_points-1);
-
-	for (int i = 0; i < num_required_points; i ++) {
-		found_points_indx[i] = index_buffer[i];
-		found_points_dist[i] = dist_buffer[i];
-	}
-	num_found_points = num_required_points;
+    bool have_the_same_point = false;
+
+
+    if (num_required_points > remap_grid->get_grid_size())
+        num_required_points = remap_grid->get_grid_size();
+    
+    num_found_points = 0;
+    
+    while (num_found_points < num_required_points) {
+        num_found_points = 0;
+        have_the_same_point = root_tile->search_points_within_distance(dist_threshold, dst_point_lon, dst_point_lat, num_found_points, index_buffer, dist_buffer, early_quit);
+        if (num_found_points == 0) {
+            dist_threshold *= 2;
+			continue;
+        }
+        if (have_the_same_point && early_quit)
+            break;
+        dist_threshold *= sqrt(((double)num_required_points)/((double)num_found_points))*1.1;
+    }
+
+    if (have_the_same_point && early_quit) {
+        EXECUTION_REPORT(REPORT_ERROR, num_found_points == 1, "Software error in H2D_grid_cell_search_engine::search_nearest_points_var_number");
+        found_points_indx[0] = index_buffer[0];
+        found_points_dist[0] = dist_buffer[0];
+        return;
+    }
+    
+    do_quick_sort(dist_buffer, index_buffer, 0, num_found_points-1);
+
+    for (int i = 0; i < num_required_points; i ++) {
+        found_points_indx[i] = index_buffer[i];
+        found_points_dist[i] = dist_buffer[i];
+    }
+    num_found_points = num_required_points;
 }
 
 
 void H2D_grid_cell_search_engine::search_nearest_points_var_distance(double dist_threshold, double dst_point_lon, double dst_point_lat, int &num_found_points, long *found_points_indx, double *found_points_dist, bool early_quit)
 {
-	bool have_the_same_point;
-
-
-	EXECUTION_REPORT(REPORT_ERROR, root_tile != NULL, "Software error1 in H2D_grid_cell_search_engine::search_nearest_points_var_distance");
-	
-	this->dist_threshold = dist_threshold;
-	num_found_points = 0;
-	have_the_same_point = root_tile->search_points_within_distance(dist_threshold, dst_point_lon, dst_point_lat, num_found_points, index_buffer, dist_buffer, early_quit);
-
-	do_quick_sort(dist_buffer, index_buffer, 0, num_found_points-1);
-	
-	if (have_the_same_point && early_quit) {
-		EXECUTION_REPORT(REPORT_ERROR, num_found_points == 1, "Software error2 in H2D_grid_cell_search_engine::search_nearest_points_var_distance");
-		found_points_indx[0] = index_buffer[0];
-		found_points_dist[0] = dist_buffer[0];
-		return;
-	}
-
-	for (int i = 0; i < num_found_points; i ++) {
-		found_points_indx[i] = index_buffer[i];
-		found_points_dist[i] = dist_buffer[i];
-	}
+    bool have_the_same_point;
+
+
+    EXECUTION_REPORT(REPORT_ERROR, root_tile != NULL, "Software error1 in H2D_grid_cell_search_engine::search_nearest_points_var_distance");
+    
+    this->dist_threshold = dist_threshold;
+    num_found_points = 0;
+    have_the_same_point = root_tile->search_points_within_distance(dist_threshold, dst_point_lon, dst_point_lat, num_found_points, index_buffer, dist_buffer, early_quit);
+
+    do_quick_sort(dist_buffer, index_buffer, 0, num_found_points-1);
+    
+    if (have_the_same_point && early_quit) {
+        EXECUTION_REPORT(REPORT_ERROR, num_found_points == 1, "Software error2 in H2D_grid_cell_search_engine::search_nearest_points_var_distance");
+        found_points_indx[0] = index_buffer[0];
+        found_points_dist[0] = dist_buffer[0];
+        return;
+    }
+
+    for (int i = 0; i < num_found_points; i ++) {
+        found_points_indx[i] = index_buffer[i];
+        found_points_dist[i] = dist_buffer[i];
+    }
 }
 
 
@@ -722,86 +722,86 @@ void H2D_grid_cell_search_engine::search_nearest_points_var_distance(double dist
 
 void H2D_grid_cell_search_engine::search_overlapping_cells(int &num_overlapping_cells, long *overlapping_cells_index, const H2D_grid_cell_search_cell *dst_cell, bool accurately_match, bool early_quit) const
 {
-	EXECUTION_REPORT(REPORT_ERROR, -1, root_tile != NULL, "Software error1 in H2D_grid_cell_search_engine::search_overlapping_cells");
-
-	num_overlapping_cells = 0;
-	root_tile->search_overlapping_cells(num_overlapping_cells, index_buffer, dst_cell, accurately_match, early_quit);
-	
-	if (early_quit)
-		EXECUTION_REPORT(REPORT_ERROR, -1, num_overlapping_cells <= 1, "Software error2 in H2D_grid_cell_search_engine::search_overlapping_cells %d", num_overlapping_cells);
-		
-	for (int i = 0; i < num_overlapping_cells; i ++)
-		overlapping_cells_index[i] = index_buffer[i];
-
-	if (early_quit && num_overlapping_cells > 0)
-		return;
-	
-	do_quick_sort(overlapping_cells_index, (long*) NULL, 0, num_overlapping_cells-1);
+    EXECUTION_REPORT(REPORT_ERROR, -1, root_tile != NULL, "Software error1 in H2D_grid_cell_search_engine::search_overlapping_cells");
+
+    num_overlapping_cells = 0;
+    root_tile->search_overlapping_cells(num_overlapping_cells, index_buffer, dst_cell, accurately_match, early_quit);
+    
+    if (early_quit)
+        EXECUTION_REPORT(REPORT_ERROR, -1, num_overlapping_cells <= 1, "Software error2 in H2D_grid_cell_search_engine::search_overlapping_cells %d", num_overlapping_cells);
+        
+    for (int i = 0; i < num_overlapping_cells; i ++)
+        overlapping_cells_index[i] = index_buffer[i];
+
+    if (early_quit && num_overlapping_cells > 0)
+        return;
+    
+    do_quick_sort(overlapping_cells_index, (long*) NULL, 0, num_overlapping_cells-1);
 /*
-	int temp_num_overlapping_cells = 0;
-	for (int i = 0; i < num_cells; i ++) {
-		if (!cells[i]->get_mask())
-			continue;
-		bool result1 = cells[i]->check_overlapping(dst_cell, accurately_match);
-		bool result2 = dst_cell->check_overlapping(cells[i], accurately_match);
-		if (result1 != result2) {
-			printf("error1 in H2D_grid_cell_search_engine::search_overlapping_cells for %d %d\n", dst_cell->get_cell_index(), cells[i]->get_cell_index());
-			
-		}
-		if (cells[i]->check_overlapping(dst_cell, accurately_match)) {
-			index_buffer[temp_num_overlapping_cells++] = cells[i]->get_cell_index();
-		}
-	}
-	do_quick_sort(index_buffer, (long*) NULL, 0, temp_num_overlapping_cells-1);
-	
-	bool same_result = temp_num_overlapping_cells == num_overlapping_cells;
-	if (same_result)
-		for (int i = 0; i < num_overlapping_cells; i ++)
-			if (index_buffer[i] != overlapping_cells_index[i]) {
-				same_result = false;
-				break;
-			}
-	if (!same_result) {
-		printf("error in H2D_grid_cell_search_engine::search_overlapping_cells\n");
-		printf("result of all scan %d: ", temp_num_overlapping_cells);
-		for (int i = 0; i < temp_num_overlapping_cells; i ++)
-			printf("%d ", index_buffer[i]);
-		printf("\n");
-		printf("result of fast %d: ", num_overlapping_cells);
-		for (int i = 0; i < num_overlapping_cells; i ++)
-			printf("%d ", overlapping_cells_index[i]);
-		printf("\n");
-		EXECUTION_REPORT(REPORT_ERROR, -1, false, "error");
-	}
-	*/
+    int temp_num_overlapping_cells = 0;
+    for (int i = 0; i < num_cells; i ++) {
+        if (!cells[i]->get_mask())
+            continue;
+        bool result1 = cells[i]->check_overlapping(dst_cell, accurately_match);
+        bool result2 = dst_cell->check_overlapping(cells[i], accurately_match);
+        if (result1 != result2) {
+            printf("error1 in H2D_grid_cell_search_engine::search_overlapping_cells for %d %d\n", dst_cell->get_cell_index(), cells[i]->get_cell_index());
+            
+        }
+        if (cells[i]->check_overlapping(dst_cell, accurately_match)) {
+            index_buffer[temp_num_overlapping_cells++] = cells[i]->get_cell_index();
+        }
+    }
+    do_quick_sort(index_buffer, (long*) NULL, 0, temp_num_overlapping_cells-1);
+    
+    bool same_result = temp_num_overlapping_cells == num_overlapping_cells;
+    if (same_result)
+        for (int i = 0; i < num_overlapping_cells; i ++)
+            if (index_buffer[i] != overlapping_cells_index[i]) {
+                same_result = false;
+                break;
+            }
+    if (!same_result) {
+        printf("error in H2D_grid_cell_search_engine::search_overlapping_cells\n");
+        printf("result of all scan %d: ", temp_num_overlapping_cells);
+        for (int i = 0; i < temp_num_overlapping_cells; i ++)
+            printf("%d ", index_buffer[i]);
+        printf("\n");
+        printf("result of fast %d: ", num_overlapping_cells);
+        for (int i = 0; i < num_overlapping_cells; i ++)
+            printf("%d ", overlapping_cells_index[i]);
+        printf("\n");
+        EXECUTION_REPORT(REPORT_ERROR, -1, false, "error");
+    }
+    */
 }
 
 
 int H2D_grid_cell_search_engine::search_cell_of_locating_point(double point_lon, double point_lat, bool accurately_match) const
 {
-	int num_overlapping_cells;
-	H2D_grid_cell_search_cell *temp_cell;
+    int num_overlapping_cells;
+    H2D_grid_cell_search_cell *temp_cell;
 
 
-	temp_cell = new H2D_grid_cell_search_cell(0, point_lon, point_lat, true, 0, NULL, NULL, EDGE_TYPE_LATLON);
+    temp_cell = new H2D_grid_cell_search_cell(0, point_lon, point_lat, true, 0, NULL, NULL, EDGE_TYPE_LATLON);
 
-	search_overlapping_cells(num_overlapping_cells, index_buffer, temp_cell, accurately_match, true);
+    search_overlapping_cells(num_overlapping_cells, index_buffer, temp_cell, accurately_match, true);
 
-	if (num_overlapping_cells == 0)
-		return -1;
-	else return index_buffer[0];
-	
-	delete temp_cell;
+    if (num_overlapping_cells == 0)
+        return -1;
+    else return index_buffer[0];
+    
+    delete temp_cell;
 }
 
 
 void H2D_grid_cell_search_engine::update(const bool *new_masks)
 {
-	if (new_masks == NULL)
-		return;
+    if (new_masks == NULL)
+        return;
 
-	for (int i = 0; i < remap_grid->get_grid_size(); i ++)
-		cells[i]->set_mask(new_masks[i]);
+    for (int i = 0; i < remap_grid->get_grid_size(); i ++)
+        cells[i]->set_mask(new_masks[i]);
 }
 
 
diff --git a/src/CoR/grid_cell_search.h b/src/CoR/grid_cell_search.h
old mode 100644
new mode 100755
index 8966b50..3666453
--- a/src/CoR/grid_cell_search.h
+++ b/src/CoR/grid_cell_search.h
@@ -24,112 +24,112 @@ class H2D_grid_cell_search_cell;
 
 struct H2D_grid_cell_cartesian_coord
 {
-	protected:
-		friend class H2D_grid_cell_search_cell;
-		double center_x;
-		double center_y;
-		double center_z;
-		double *vertex_x;
-		double *vertex_y;
-		double *vertex_z;
-
-	public:
-		H2D_grid_cell_cartesian_coord();
-		~H2D_grid_cell_cartesian_coord();
+    protected:
+        friend class H2D_grid_cell_search_cell;
+        double center_x;
+        double center_y;
+        double center_z;
+        double *vertex_x;
+        double *vertex_y;
+        double *vertex_z;
+
+    public:
+        H2D_grid_cell_cartesian_coord();
+        ~H2D_grid_cell_cartesian_coord();
 };
 
 
 class H2D_grid_cell_search_cell
 {
-	private:
-		int cell_index;
-		double center_lon;
-		double center_lat;
-		int num_vertex;
-		double *vertex_lons;
-		double *vertex_lats;
-		double bounding_circle_center_lon;
-		double bounding_circle_center_lat;
-		double bounding_circle_radius;
-		bool mask;
-		int edge_type;   // 1: latlon edge; 2: great arc edge
-		H2D_grid_cell_cartesian_coord *cartesian_coord;
-
-		bool check_overlapping_for_latlon_grid(const H2D_grid_cell_search_cell*) const;
-		bool check_overlapping_for_cartesian_grid(const H2D_grid_cell_search_cell*) const;
-		bool check_possible_overlapping(const H2D_grid_cell_search_cell*) const;
-		bool is_point_in_latlon_coord_cell(double, double) const;
-		bool is_point_in_cartesian_coord_cell(double, double) const;
-
-	public:
-		H2D_grid_cell_search_cell(int, double, double, bool, int, const double*, const double*, int);
-		H2D_grid_cell_search_cell() {}
-		~H2D_grid_cell_search_cell();
-		double get_center_lon() const { return center_lon; }
-		double get_center_lat() const { return center_lat; }
-		int get_num_vertex() const { return num_vertex; }
-		int get_cell_index() const { return cell_index; }
-		double get_vertex_lon(int indx) const ;
-		double get_vertex_lat(int indx) const ;
-		bool get_mask() const { return mask; }
-		void set_mask(bool new_mask) { mask = new_mask; } 
-		int get_edge_type() const { return edge_type; }
-		bool check_overlapping(const H2D_grid_cell_search_cell*, bool) const;
-		double get_bounding_circle_radius() const { return bounding_circle_radius; }
-		double get_bounding_circle_center_lon() const { return bounding_circle_center_lon; }
-		double get_bounding_circle_center_lat() const { return bounding_circle_center_lat; }
+    private:
+        int cell_index;
+        double center_lon;
+        double center_lat;
+        int num_vertex;
+        double *vertex_lons;
+        double *vertex_lats;
+        double bounding_circle_center_lon;
+        double bounding_circle_center_lat;
+        double bounding_circle_radius;
+        bool mask;
+        int edge_type;   // 1: latlon edge; 2: great arc edge
+        H2D_grid_cell_cartesian_coord *cartesian_coord;
+
+        bool check_overlapping_for_latlon_grid(const H2D_grid_cell_search_cell*) const;
+        bool check_overlapping_for_cartesian_grid(const H2D_grid_cell_search_cell*) const;
+        bool check_possible_overlapping(const H2D_grid_cell_search_cell*) const;
+        bool is_point_in_latlon_coord_cell(double, double) const;
+        bool is_point_in_cartesian_coord_cell(double, double) const;
+
+    public:
+        H2D_grid_cell_search_cell(int, double, double, bool, int, const double*, const double*, int);
+        H2D_grid_cell_search_cell() {}
+        ~H2D_grid_cell_search_cell();
+        double get_center_lon() const { return center_lon; }
+        double get_center_lat() const { return center_lat; }
+        int get_num_vertex() const { return num_vertex; }
+        int get_cell_index() const { return cell_index; }
+        double get_vertex_lon(int indx) const ;
+        double get_vertex_lat(int indx) const ;
+        bool get_mask() const { return mask; }
+        void set_mask(bool new_mask) { mask = new_mask; } 
+        int get_edge_type() const { return edge_type; }
+        bool check_overlapping(const H2D_grid_cell_search_cell*, bool) const;
+        double get_bounding_circle_radius() const { return bounding_circle_radius; }
+        double get_bounding_circle_center_lon() const { return bounding_circle_center_lon; }
+        double get_bounding_circle_center_lat() const { return bounding_circle_center_lat; }
 };
 
 
 class H2D_grid_cell_search_tile
 {
-	private:
-		int num_cells;
-		H2D_grid_cell_search_cell **cells;
-		H2D_grid_cell_search_cell **cells_buffer;
-		H2D_grid_cell_search_tile *children[TILE_DIVIDE_FACTOR*TILE_DIVIDE_FACTOR];
-		H2D_grid_cell_search_tile *parent;
-		long *index_buffer;
-		double center_lon;
-		double center_lat;
-		double circle_radius;
-		double dlon;
-		double dlat;
-
-	public:
-		bool has_cell_index(int);
-		H2D_grid_cell_search_tile(int, H2D_grid_cell_search_cell**, H2D_grid_cell_search_cell**, long*, H2D_grid_cell_search_tile*, double, double, double, double);
-		~H2D_grid_cell_search_tile();
-		void divide_tile();
-		void compute_bounding_circle();
-		bool search_points_within_distance(double, double, double, int&, long*, double*, bool);
-		void search_overlapping_cells(int&, long*, const H2D_grid_cell_search_cell*, bool, bool);
+    private:
+        int num_cells;
+        H2D_grid_cell_search_cell **cells;
+        H2D_grid_cell_search_cell **cells_buffer;
+        H2D_grid_cell_search_tile *children[TILE_DIVIDE_FACTOR*TILE_DIVIDE_FACTOR];
+        H2D_grid_cell_search_tile *parent;
+        long *index_buffer;
+        double center_lon;
+        double center_lat;
+        double circle_radius;
+        double dlon;
+        double dlat;
+
+    public:
+        bool has_cell_index(int);
+        H2D_grid_cell_search_tile(int, H2D_grid_cell_search_cell**, H2D_grid_cell_search_cell**, long*, H2D_grid_cell_search_tile*, double, double, double, double);
+        ~H2D_grid_cell_search_tile();
+        void divide_tile();
+        void compute_bounding_circle();
+        bool search_points_within_distance(double, double, double, int&, long*, double*, bool);
+        void search_overlapping_cells(int&, long*, const H2D_grid_cell_search_cell*, bool, bool);
 };
 
 
 class H2D_grid_cell_search_engine
 {
-	private:
-		const Remap_grid_class *remap_grid;
-		H2D_grid_cell_search_cell **cells;
-		H2D_grid_cell_search_cell **cells_ptr;
-		H2D_grid_cell_search_cell **cells_buffer;
-		long *index_buffer;
-		double *dist_buffer;
-		H2D_grid_cell_search_tile *root_tile;
-		double dist_threshold;
-		int num_cells;
-		
-	public:
-		H2D_grid_cell_search_engine(const Remap_grid_class*, const double*, const double*, const bool*, const bool*, int, const double*, const double*, int, bool);
-		~H2D_grid_cell_search_engine();
-		void recursively_search_initial_boundary(double, double, double, double, double&, double&, double&, double&);
-		void search_nearest_points_var_number(int, double, double, int&, long*, double *, bool);
-		void search_nearest_points_var_distance(double, double, double, int&, long*, double*, bool);
-		void search_overlapping_cells(int&, long*, const H2D_grid_cell_search_cell*, bool, bool) const;
-		int search_cell_of_locating_point(double, double, bool) const;
-		const H2D_grid_cell_search_cell* get_cell(int) const;
-		void update(const bool*);
+    private:
+        const Remap_grid_class *remap_grid;
+        H2D_grid_cell_search_cell **cells;
+        H2D_grid_cell_search_cell **cells_ptr;
+        H2D_grid_cell_search_cell **cells_buffer;
+        long *index_buffer;
+        double *dist_buffer;
+        H2D_grid_cell_search_tile *root_tile;
+        double dist_threshold;
+        int num_cells;
+        
+    public:
+        H2D_grid_cell_search_engine(const Remap_grid_class*, const double*, const double*, const bool*, const bool*, int, const double*, const double*, int, bool);
+        ~H2D_grid_cell_search_engine();
+        void recursively_search_initial_boundary(double, double, double, double, double&, double&, double&, double&);
+        void search_nearest_points_var_number(int, double, double, int&, long*, double *, bool);
+        void search_nearest_points_var_distance(double, double, double, int&, long*, double*, bool);
+        void search_overlapping_cells(int&, long*, const H2D_grid_cell_search_cell*, bool, bool) const;
+        int search_cell_of_locating_point(double, double, bool) const;
+        const H2D_grid_cell_search_cell* get_cell(int) const;
+        void update(const bool*);
 };
 
 #endif
diff --git a/src/CoR/io_basis.cxx b/src/CoR/io_basis.cxx
old mode 100644
new mode 100755
index 5ee965c..cdb12c8
--- a/src/CoR/io_basis.cxx
+++ b/src/CoR/io_basis.cxx
@@ -85,8 +85,8 @@ void IO_basis::copy_field_data_for_IO(Remap_grid_data_class *field_data_in_appli
 
     if (field_data_in_application->get_coord_value_grid() != NULL) {
         field_data_in_application->get_coord_value_grid()->compute_remap_field_data_runtime_mask(field_data_in_application->get_coord_value_grid(), mask_sub_grids, &num_mask_sub_grids, &runtime_mask_field);
-		if (runtime_mask_field != NULL)
-	        runtime_mask_values = (bool*) runtime_mask_field->get_grid_data_field()->data_buf;
+        if (runtime_mask_field != NULL)
+            runtime_mask_values = (bool*) runtime_mask_field->get_grid_data_field()->data_buf;
     }
 
     if (words_are_the_same(field_data_in_application->get_grid_data_field()->data_type_in_application, DATA_TYPE_DOUBLE)) 
@@ -138,10 +138,10 @@ void IO_basis::copy_field_data_for_IO(Remap_grid_data_class *field_data_in_appli
             copy_data_values_for_IO((bool*)field_data_in_application->get_grid_data_field()->data_buf, (bool)fill_value_application, 
                                    (int*)field_data_in_io->get_grid_data_field()->data_buf, (int)fill_value_io, runtime_mask_values, 
                                    field_data_in_application->get_grid_data_field()->required_data_size, is_restart_field);
-		else if (words_are_the_same(field_data_in_io->get_grid_data_field()->data_type_in_application, DATA_TYPE_BOOL)) 
-					copy_data_values_for_IO((bool*)field_data_in_application->get_grid_data_field()->data_buf, (bool)fill_value_application, 
-										   (bool*)field_data_in_io->get_grid_data_field()->data_buf, (bool)fill_value_io, runtime_mask_values, 
-										   field_data_in_application->get_grid_data_field()->required_data_size, is_restart_field);
+        else if (words_are_the_same(field_data_in_io->get_grid_data_field()->data_type_in_application, DATA_TYPE_BOOL)) 
+                    copy_data_values_for_IO((bool*)field_data_in_application->get_grid_data_field()->data_buf, (bool)fill_value_application, 
+                                           (bool*)field_data_in_io->get_grid_data_field()->data_buf, (bool)fill_value_io, runtime_mask_values, 
+                                           field_data_in_application->get_grid_data_field()->required_data_size, is_restart_field);
         else EXECUTION_REPORT(REPORT_ERROR, -1, false, "C-Coupler error5 in copy_field_data_for_IO\n");
     else if (words_are_the_same(field_data_in_application->get_grid_data_field()->data_type_in_application, DATA_TYPE_SHORT)) 
         if (words_are_the_same(field_data_in_io->get_grid_data_field()->data_type_in_application, DATA_TYPE_SHORT)) 
@@ -158,11 +158,11 @@ void IO_basis::copy_field_data_for_IO(Remap_grid_data_class *field_data_in_appli
 
 int IO_basis::get_recorded_grid_num(Remap_grid_class *grid)
 {
-	for (int i = 0; i < recorded_grids.size(); i ++)
-		if (recorded_grids[i] == grid || words_are_the_same(recorded_grids[i]->get_grid_name(), grid->get_grid_name()))
-			return i;
+    for (int i = 0; i < recorded_grids.size(); i ++)
+        if (recorded_grids[i] == grid || words_are_the_same(recorded_grids[i]->get_grid_name(), grid->get_grid_name()))
+            return i;
 
-	EXECUTION_REPORT(REPORT_ERROR, -1, false, "Software error in IO_basis::get_recorded_grid_num %s %lx", grid->get_grid_name(), grid);
-	return -1;
+    EXECUTION_REPORT(REPORT_ERROR, -1, false, "Software error in IO_basis::get_recorded_grid_num %s %lx", grid->get_grid_name(), grid);
+    return -1;
 }
 
diff --git a/src/CoR/io_basis.h b/src/CoR/io_basis.h
old mode 100644
new mode 100755
index 80ba884..bd84166
--- a/src/CoR/io_basis.h
+++ b/src/CoR/io_basis.h
@@ -31,7 +31,7 @@ class IO_basis
         char file_type[256];
         char open_format[256];
         std::map<const Remap_grid_class*, int> sized_grids_map;
-		std::vector<const Remap_grid_class*> recorded_grids;
+        std::vector<const Remap_grid_class*> recorded_grids;
 
         virtual void write_grid(Remap_grid_class*, bool, bool) = 0;
         virtual void write_field_data(Remap_grid_data_class*, Remap_grid_class*, bool, const char*, int, bool, bool) = 0;
@@ -47,7 +47,7 @@ class IO_basis
         virtual long get_dimension_size(const char*, MPI_Comm, bool) = 0;
         Remap_grid_data_class *generate_field_data_for_IO(Remap_grid_data_class*, bool);
         void copy_field_data_for_IO(Remap_grid_data_class*, Remap_grid_data_class*, bool);
-		int get_recorded_grid_num(Remap_grid_class*);
+        int get_recorded_grid_num(Remap_grid_class*);
 };
 
 #endif
diff --git a/src/CoR/io_binary.cxx b/src/CoR/io_binary.cxx
old mode 100644
new mode 100755
index 3f68492..ce597d5
--- a/src/CoR/io_binary.cxx
+++ b/src/CoR/io_binary.cxx
@@ -7,10 +7,8 @@
   ***************************************************************/
 
 
-#ifndef ONLY_CoR
 #include <mpi.h>
 #include "global_data.h"
-#endif
 #include "io_binary.h"
 #include "cor_global_data.h"
 #include "remap_operator_conserv_2D.h"
@@ -74,8 +72,8 @@ void IO_binary::write_field_data(Remap_grid_data_class *field_data,
 bool IO_binary::read_data(Remap_data_field *read_data_field, int time_pos, bool check_existence)
 {
     EXECUTION_REPORT(REPORT_ERROR, -1, false, "remap software error4-1 in using binary io\n");
-	EXECUTION_REPORT(REPORT_ERROR, -1, time_pos==-1, "remap software error4-2 in using binary io\n");
-	return false;
+    EXECUTION_REPORT(REPORT_ERROR, -1, time_pos==-1, "remap software error4-2 in using binary io\n");
+    return false;
 }
 
 
@@ -88,18 +86,18 @@ long IO_binary::get_dimension_size(const char *dim_name, MPI_Comm comm, bool is_
 
 void IO_binary::write_remap_weights(Remap_weight_of_strategy_class *remap_weights)
 {
-	char *flat_array;
-	long array_size;
+    char *flat_array;
+    long array_size;
 
 
     EXECUTION_REPORT(REPORT_ERROR, -1, words_are_the_same(open_format, "w"), "can not write to binary file %s: %s, whose open format is not write\n", object_name, file_name);
     EXECUTION_REPORT(REPORT_ERROR, -1, remap_weights != NULL, "remap software error1 in write_remap_weights binary\n");
     
     if (execution_phase_number == 1) {
-		remap_weights->write_remap_weights_into_array(&flat_array, array_size, true);
+        remap_weights->write_remap_weights_into_array(&flat_array, array_size, true);
         fp_binary = fopen(file_name, "w+");
-		fwrite(flat_array, array_size, 1, fp_binary);
-		delete [] flat_array;
+        fwrite(flat_array, array_size, 1, fp_binary);
+        delete [] flat_array;
         fclose(fp_binary);
     }
 }
@@ -107,27 +105,25 @@ void IO_binary::write_remap_weights(Remap_weight_of_strategy_class *remap_weight
 
 void IO_binary::read_remap_weights(Remap_weight_of_strategy_class *remap_weights, Remap_strategy_class *remap_strategy, bool read_weight_values)
 {    
-	long array_size;
-	
+    long array_size;
+    
 
     EXECUTION_REPORT(REPORT_ERROR, -1, remap_weights != NULL, "remap software error1 in read_remap_weights binary\n");
-	if (read_weight_values)
-		EXECUTION_REPORT(REPORT_ERROR, -1, true, "remapping weight values will be read into %s", remap_weights->get_object_name());
-	else EXECUTION_REPORT(REPORT_ERROR, -1, true, "remapping weight values will not be read into %s", remap_weights->get_object_name());
+    if (read_weight_values)
+        EXECUTION_REPORT(REPORT_ERROR, -1, true, "remapping weight values will be read into %s", remap_weights->get_object_name());
+    else EXECUTION_REPORT(REPORT_ERROR, -1, true, "remapping weight values will not be read into %s", remap_weights->get_object_name());
 
     if (execution_phase_number == 1) {
         fp_binary = fopen(file_name, "r"); 
-		fseek(fp_binary, 0, SEEK_END);
-		long array_size = ftell(fp_binary);
-		int num_proc_computing_node_comp_group, current_proc_id_computing_node_comp_group = 0;
-#ifndef ONLY_CoR
-		EXECUTION_REPORT(REPORT_ERROR, -1, false, "to be rewritten: IO_binary::read_remap_weights");
-#endif
-		EXECUTION_REPORT_LOG(REPORT_LOG, -1, true, "begin reading file of weights values at process %d", current_proc_id_computing_node_comp_group); 
-		fseek(fp_binary, 0, SEEK_SET);
-		remap_weights->read_remap_weights_from_array(NULL, fp_binary, array_size, true, NULL, read_weight_values);
-		fclose(fp_binary);
-		EXECUTION_REPORT_LOG(REPORT_LOG, -1, true, "Finish reading file of weights values at process %d", current_proc_id_computing_node_comp_group); 
+        fseek(fp_binary, 0, SEEK_END);
+        long array_size = ftell(fp_binary);
+        int num_proc_computing_node_comp_group, current_proc_id_computing_node_comp_group = 0;
+        EXECUTION_REPORT(REPORT_ERROR, -1, false, "to be rewritten: IO_binary::read_remap_weights");
+        EXECUTION_REPORT_LOG(REPORT_LOG, -1, true, "begin reading file of weights values at process %d", current_proc_id_computing_node_comp_group); 
+        fseek(fp_binary, 0, SEEK_SET);
+        remap_weights->read_remap_weights_from_array(NULL, fp_binary, array_size, true, NULL, read_weight_values);
+        fclose(fp_binary);
+        EXECUTION_REPORT_LOG(REPORT_LOG, -1, true, "Finish reading file of weights values at process %d", current_proc_id_computing_node_comp_group); 
     }
 }
 
diff --git a/src/CoR/io_binary.h b/src/CoR/io_binary.h
old mode 100644
new mode 100755
diff --git a/src/CoR/io_mgt.cxx b/src/CoR/io_mgt.cxx
old mode 100644
new mode 100755
diff --git a/src/CoR/io_mgt.h b/src/CoR/io_mgt.h
old mode 100644
new mode 100755
diff --git a/src/CoR/io_netcdf.cxx b/src/CoR/io_netcdf.cxx
old mode 100644
new mode 100755
index 5fd1ebc..d4de25d
--- a/src/CoR/io_netcdf.cxx
+++ b/src/CoR/io_netcdf.cxx
@@ -23,7 +23,7 @@ IO_netcdf::IO_netcdf(int ncfile_id)
     strcpy(this->file_type, FILE_TYPE_NETCDF);
     strcpy(this->file_name, "NULL");
     strcpy(this->open_format, "NULL");
-	this->is_external_file = true;
+    this->is_external_file = true;
     this->ncfile_id = ncfile_id;
 }
 
@@ -35,7 +35,7 @@ IO_netcdf::IO_netcdf(const char *object_name, const char *file_name, const char
     strcpy(this->file_type, FILE_TYPE_NETCDF);
     strcpy(this->file_name, file_name);
     strcpy(this->open_format, format);
-	this->is_external_file = false;
+    this->is_external_file = false;
     if (words_are_the_same(format, "r"))
         rcode = nc_open(file_name, NC_NOWRITE, &ncfile_id);
     else if (words_are_the_same(format, "w")) {
@@ -115,19 +115,19 @@ bool IO_netcdf::read_data(Remap_data_field *read_data_field, int time_pos, bool
     nc_type nc_data_type;
     unsigned long data_size, dimension_size;
     Remap_field_attribute field_attribute;
-	size_t starts[256], counts[256];
+    size_t starts[256], counts[256];
 
 
     rcode = nc_open(file_name, NC_NOWRITE, &ncfile_id);
     report_nc_error();
 
     rcode = nc_inq_varid(ncfile_id, read_data_field->field_name_in_IO_file, &variable_id);
-	if (!check_existence && rcode == NC_ENOTVAR) {
-		EXECUTION_REPORT_LOG(REPORT_LOG, -1, true, "Does not find the field \"%s\" in the data file \"%s\"", read_data_field->field_name_in_IO_file, file_name);
-		rcode = nc_close(ncfile_id);
-		report_nc_error();
-		return false;
-	}
+    if (!check_existence && rcode == NC_ENOTVAR) {
+        EXECUTION_REPORT_LOG(REPORT_LOG, -1, true, "Does not find the field \"%s\" in the data file \"%s\"", read_data_field->field_name_in_IO_file, file_name);
+        rcode = nc_close(ncfile_id);
+        report_nc_error();
+        return false;
+    }
     report_nc_error();
     rcode = nc_inq_var(ncfile_id, variable_id, variable_name, &nc_data_type, &num_dimensions, dimension_ids, &num_attributes);
     report_nc_error();
@@ -135,16 +135,16 @@ bool IO_netcdf::read_data(Remap_data_field *read_data_field, int time_pos, bool
     for (i = 0, data_size = 1; i < num_dimensions; i ++) {
         rcode = nc_inq_dimlen(ncfile_id, dimension_ids[i], &dimension_size);
         report_nc_error();
-		if (time_pos != -1 && i == 0) {
-			EXECUTION_REPORT(REPORT_ERROR, -1, time_pos>=0 && time_pos < dimension_size, "C-Coupler error in IO_netcdf::read_data");
-			starts[0] = time_pos;
-			counts[0] = 1;
-		}
-		else {
-			starts[i] = 0;
-			counts[i] = dimension_size;
-			data_size *= dimension_size;
-		}
+        if (time_pos != -1 && i == 0) {
+            EXECUTION_REPORT(REPORT_ERROR, -1, time_pos>=0 && time_pos < dimension_size, "C-Coupler error in IO_netcdf::read_data");
+            starts[0] = time_pos;
+            counts[0] = 1;
+        }
+        else {
+            starts[i] = 0;
+            counts[i] = dimension_size;
+            data_size *= dimension_size;
+        }
     }
     read_data_field->read_data_size = data_size;
     if (read_data_field->data_buf != NULL)
@@ -174,7 +174,7 @@ bool IO_netcdf::read_data(Remap_data_field *read_data_field, int time_pos, bool
             case NC_BYTE:
             case NC_CHAR:
                 rcode = nc_get_att_text(ncfile_id, variable_id, field_attribute.attribute_name, field_attribute.attribute_value);
-				field_attribute.attribute_value[field_attribute.attribute_size] = '\0';
+                field_attribute.attribute_value[field_attribute.attribute_size] = '\0';
                 break;
             case NC_SHORT:
                 rcode = nc_get_att_short(ncfile_id, variable_id, field_attribute.attribute_name, (short*)field_attribute.attribute_value);
@@ -265,7 +265,7 @@ bool IO_netcdf::read_data(Remap_data_field *read_data_field, int time_pos, bool
     rcode = nc_close(ncfile_id);
     report_nc_error();
 
-	return true;
+    return true;
 }
 
 
@@ -289,42 +289,42 @@ void IO_netcdf::write_grid(Remap_grid_class *associated_grid, bool write_grid_na
     for (i = 0; i < num_sized_sub_grids; i ++)
         if (sized_grids_map.find(sized_sub_grids[i]) == sized_grids_map.end()) {
             if (write_grid_name) {
-				if (sized_sub_grids[i]->get_num_dimensions() == 1)
-					sprintf(tmp_string, "dim_%s_%d", sized_sub_grids[i]->get_coord_label(), recorded_grids.size());
-				else if (sized_sub_grids[i]->get_is_sphere_grid())
-					sprintf(tmp_string, "dim_H2D_%d", recorded_grids.size());
-				else EXECUTION_REPORT(REPORT_ERROR, -1, false, "Software error in IO_netcdf::write_grid");
+                if (sized_sub_grids[i]->get_num_dimensions() == 1)
+                    sprintf(tmp_string, "dim_%s_%d", sized_sub_grids[i]->get_coord_label(), recorded_grids.size());
+                else if (sized_sub_grids[i]->get_is_sphere_grid())
+                    sprintf(tmp_string, "dim_H2D_%d", recorded_grids.size());
+                else EXECUTION_REPORT(REPORT_ERROR, -1, false, "Software error in IO_netcdf::write_grid");
             }
             else if (sized_sub_grids[i]->get_num_dimensions() == 1)
                 sprintf(tmp_string, "%s", sized_sub_grids[i]->get_coord_label()); 
             else sprintf(tmp_string, "grid_size", sized_sub_grids[i]->get_grid_name()); 
             rcode = nc_def_dim(ncfile_id, tmp_string, sized_sub_grids[i]->get_grid_size(), &dim_ncid);
-			EXECUTION_REPORT_LOG(REPORT_LOG, -1, true, "define dim %s for grid \"%s\" (%lx) in ncfile %s", tmp_string, sized_sub_grids[i]->get_grid_name(), sized_sub_grids[i], file_name);
+            EXECUTION_REPORT_LOG(REPORT_LOG, -1, true, "define dim %s for grid \"%s\" (%lx) in ncfile %s", tmp_string, sized_sub_grids[i]->get_grid_name(), sized_sub_grids[i], file_name);
             report_nc_error();
             sized_grids_map[sized_sub_grids[i]] = dim_ncid;
-			recorded_grids.push_back(sized_sub_grids[i]);
+            recorded_grids.push_back(sized_sub_grids[i]);
         }
-	if (use_script_format) {
-		if (sized_grids_map.find(associated_grid) == sized_grids_map.end()) {
-			rcode = nc_def_dim(ncfile_id, "grid_size", associated_grid->get_grid_size(), &dim_ncid);
-			report_nc_error();
-			sized_grids_map[associated_grid] = dim_ncid;
-			recorded_grids.push_back(associated_grid);
-		}
-		rcode = nc_def_dim(ncfile_id, "grid_rank", num_sized_sub_grids, &dim_ncid);
-		report_nc_error();
-		int grid_dim_size[256], dims_ncid;
-		for (int i = 0; i < num_sized_sub_grids; i ++)
-			grid_dim_size[i] = sized_sub_grids[i]->get_grid_size();
+    if (use_script_format) {
+        if (sized_grids_map.find(associated_grid) == sized_grids_map.end()) {
+            rcode = nc_def_dim(ncfile_id, "grid_size", associated_grid->get_grid_size(), &dim_ncid);
+            report_nc_error();
+            sized_grids_map[associated_grid] = dim_ncid;
+            recorded_grids.push_back(associated_grid);
+        }
+        rcode = nc_def_dim(ncfile_id, "grid_rank", num_sized_sub_grids, &dim_ncid);
+        report_nc_error();
+        int grid_dim_size[256], dims_ncid;
+        for (int i = 0; i < num_sized_sub_grids; i ++)
+            grid_dim_size[i] = sized_sub_grids[i]->get_grid_size();
         rcode = nc_def_var(ncfile_id, "grid_dims", NC_INT, 1, &dim_ncid, &dims_ncid);
         report_nc_error();
-		rcode = nc_enddef(ncfile_id);
-		report_nc_error();
-		nc_put_var_int(ncfile_id, dims_ncid, grid_dim_size);
-		report_nc_error();
-		rcode = nc_redef(ncfile_id);
-		report_nc_error();
-	}
+        rcode = nc_enddef(ncfile_id);
+        report_nc_error();
+        nc_put_var_int(ncfile_id, dims_ncid, grid_dim_size);
+        report_nc_error();
+        rcode = nc_redef(ncfile_id);
+        report_nc_error();
+    }
     nc_enddef(ncfile_id);
     report_nc_error();
 
@@ -333,29 +333,29 @@ void IO_netcdf::write_grid(Remap_grid_class *associated_grid, bool write_grid_na
         grid_data_field = leaf_grids[i]->get_grid_center_field();
         if (grid_data_field != NULL) 
             write_field_data(grid_data_field, associated_grid, true, GRID_CENTER_LABEL, -1, write_grid_name, use_script_format);
-		if (leaf_grids[i]->get_sigma_grid_sigma_value_field() != NULL) {
-			EXECUTION_REPORT(REPORT_ERROR, -1, grid_data_field == NULL, "Software error in IO_netcdf::write_grid");
-			write_field_data(leaf_grids[i]->get_sigma_grid_sigma_value_field(), associated_grid, true, GRID_CENTER_LABEL, -1, write_grid_name, use_script_format);
-			if (leaf_grids[i]->get_hybrid_grid_coefficient_field() != NULL)
-				write_field_data(leaf_grids[i]->get_hybrid_grid_coefficient_field(), associated_grid, true, GRID_CENTER_LABEL, -1, write_grid_name, use_script_format);
-			sprintf(tmp_string, "P0");
-			if (write_grid_name)
-				sprintf(tmp_string, "grid_%d_P0", get_recorded_grid_num(leaf_grids[i]));
-			double P0 = leaf_grids[i]->get_sigma_grid_top_value();			
-			rcode = nc_redef(ncfile_id);
-			report_nc_error();
-			rcode = nc_put_att_double(ncfile_id, NC_GLOBAL, tmp_string, NC_DOUBLE, 1, &P0);
-			report_nc_error();
-			nc_enddef(ncfile_id);
-			report_nc_error();
-		}
+        if (leaf_grids[i]->get_sigma_grid_sigma_value_field() != NULL) {
+            EXECUTION_REPORT(REPORT_ERROR, -1, grid_data_field == NULL, "Software error in IO_netcdf::write_grid");
+            write_field_data(leaf_grids[i]->get_sigma_grid_sigma_value_field(), associated_grid, true, GRID_CENTER_LABEL, -1, write_grid_name, use_script_format);
+            if (leaf_grids[i]->get_hybrid_grid_coefficient_field() != NULL)
+                write_field_data(leaf_grids[i]->get_hybrid_grid_coefficient_field(), associated_grid, true, GRID_CENTER_LABEL, -1, write_grid_name, use_script_format);
+            sprintf(tmp_string, "P0");
+            if (write_grid_name)
+                sprintf(tmp_string, "grid_%d_P0", get_recorded_grid_num(leaf_grids[i]));
+            double P0 = leaf_grids[i]->get_sigma_grid_top_value();            
+            rcode = nc_redef(ncfile_id);
+            report_nc_error();
+            rcode = nc_put_att_double(ncfile_id, NC_GLOBAL, tmp_string, NC_DOUBLE, 1, &P0);
+            report_nc_error();
+            nc_enddef(ncfile_id);
+            report_nc_error();
+        }
         grid_data_field = leaf_grids[i]->get_grid_vertex_field();
         if (grid_data_field != NULL && !grid_data_field->get_coord_value_grid()->get_are_vertex_values_set_in_default()) {
-			if (grid_data_field->get_coord_value_grid()->get_num_dimensions() == 1)			
-	           sprintf(tmp_string, "num_vertexes_%s", grid_data_field->get_coord_value_grid()->get_coord_label());
-			else if (use_script_format)
-				sprintf(tmp_string, "grid_corners");
-			else sprintf(tmp_string, "num_vertexes_H2D");
+            if (grid_data_field->get_coord_value_grid()->get_num_dimensions() == 1)            
+               sprintf(tmp_string, "num_vertexes_%s", grid_data_field->get_coord_value_grid()->get_coord_label());
+            else if (use_script_format)
+                sprintf(tmp_string, "grid_corners");
+            else sprintf(tmp_string, "num_vertexes_H2D");
             rcode = nc_inq_dimid(ncfile_id, tmp_string, &dim_ncid);            
             if (rcode == NC_EBADDIM) {
                 rcode = nc_redef(ncfile_id);
@@ -371,8 +371,8 @@ void IO_netcdf::write_grid(Remap_grid_class *associated_grid, bool write_grid_na
     associated_grid->get_masked_sub_grids(&num_masked_sub_grids, masked_sub_grids);
     for (i = 0; i < num_masked_sub_grids; i ++)
         write_field_data(masked_sub_grids[i]->get_grid_mask_field(), associated_grid, true, GRID_MASK_LABEL, -1, write_grid_name, use_script_format);
-	if (associated_grid->get_grid_imported_area() != NULL)
-		write_field_data(associated_grid->get_grid_imported_area(), associated_grid, true, "area", -1, write_grid_name, use_script_format);
+    if (associated_grid->get_grid_imported_area() != NULL)
+        write_field_data(associated_grid->get_grid_imported_area(), associated_grid, true, "area", -1, write_grid_name, use_script_format);
 
     rcode = nc_close(ncfile_id);
     report_nc_error();
@@ -396,6 +396,9 @@ void IO_netcdf::write_field_data(Remap_grid_data_class *field_data,
     nc_type nc_data_type;
 
 
+    if (!is_grid_data)
+        field_data->set_masked_cell_to_missing_value();
+
     tmp_string[0] = '\0';
     if (is_grid_data && write_grid_name) {
         if (words_are_the_same(field_data->get_grid_data_field()->field_name_in_application, "mask"))
@@ -411,24 +414,24 @@ void IO_netcdf::write_field_data(Remap_grid_data_class *field_data,
             sprintf(tmp_string, "%s", field_data->get_grid_data_field()->field_name_in_IO_file);
         else {
             if (words_are_the_same(grid_field_type, GRID_VERTEX_LABEL))
-				if (!use_script_format)
-	                sprintf(tmp_string , "%s_%s", grid_field_type, field_data->get_grid_data_field()->field_name_in_application);
-				else if (words_are_the_same(field_data->get_grid_data_field()->field_name_in_application,COORD_LABEL_LON))
-					sprintf(tmp_string , SCRIP_VERTEX_LON_LABEL);
-				else sprintf(tmp_string , SCRIP_VERTEX_LAT_LABEL);
+                if (!use_script_format)
+                    sprintf(tmp_string , "%s_%s", grid_field_type, field_data->get_grid_data_field()->field_name_in_application);
+                else if (words_are_the_same(field_data->get_grid_data_field()->field_name_in_application,COORD_LABEL_LON))
+                    sprintf(tmp_string , SCRIP_VERTEX_LON_LABEL);
+                else sprintf(tmp_string , SCRIP_VERTEX_LAT_LABEL);
             else {
-				sprintf(tmp_string , "%s", field_data->get_grid_data_field()->field_name_in_application);
-				if (use_script_format) {
-					if (words_are_the_same(field_data->get_grid_data_field()->field_name_in_application, COORD_LABEL_LON))
-						sprintf(tmp_string , SCRIP_CENTER_LON_LABEL);
-					else if (words_are_the_same(field_data->get_grid_data_field()->field_name_in_application, COORD_LABEL_LAT))
-						sprintf(tmp_string , SCRIP_CENTER_LAT_LABEL);
-					else if (words_are_the_same(grid_field_type, GRID_MASK_LABEL))
-						sprintf(tmp_string , SCRIP_MASK_LABEL);
-				}
+                sprintf(tmp_string , "%s", field_data->get_grid_data_field()->field_name_in_application);
+                if (use_script_format) {
+                    if (words_are_the_same(field_data->get_grid_data_field()->field_name_in_application, COORD_LABEL_LON))
+                        sprintf(tmp_string , SCRIP_CENTER_LON_LABEL);
+                    else if (words_are_the_same(field_data->get_grid_data_field()->field_name_in_application, COORD_LABEL_LAT))
+                        sprintf(tmp_string , SCRIP_CENTER_LAT_LABEL);
+                    else if (words_are_the_same(grid_field_type, GRID_MASK_LABEL))
+                        sprintf(tmp_string , SCRIP_MASK_LABEL);
+                }
             }
         }
-		EXECUTION_REPORT_LOG(REPORT_LOG, -1, true, "IO field name is %s", tmp_string);
+        EXECUTION_REPORT_LOG(REPORT_LOG, -1, true, "IO field name is %s", tmp_string);
     }
 
     rcode = nc_inq_varid(ncfile_id, tmp_string, &var_ncid);
@@ -442,11 +445,11 @@ void IO_netcdf::write_field_data(Remap_grid_data_class *field_data,
 
     if (interchange_grid != NULL) {
         field_data->interchange_grid_data(interchange_grid);        
-		if (sized_grids_map.find(field_data->get_coord_value_grid()) != sized_grids_map.end()) {
-			num_sized_sub_grids = 1;
-			sized_sub_grids[0] = field_data->get_coord_value_grid();
-		}
-		else field_data->get_coord_value_grid()->get_sized_sub_grids(&num_sized_sub_grids, sized_sub_grids);
+        if (sized_grids_map.find(field_data->get_coord_value_grid()) != sized_grids_map.end()) {
+            num_sized_sub_grids = 1;
+            sized_sub_grids[0] = field_data->get_coord_value_grid();
+        }
+        else field_data->get_coord_value_grid()->get_sized_sub_grids(&num_sized_sub_grids, sized_sub_grids);
         for (i = 0; i < num_sized_sub_grids; i ++) {
             EXECUTION_REPORT(REPORT_ERROR, -1, sized_grids_map.find(sized_sub_grids[i]) != sized_grids_map.end(), "remap software error1 in write_field_data\n");
             dim_ncids[num_sized_sub_grids-1-i] = sized_grids_map[sized_sub_grids[i]];
@@ -641,20 +644,20 @@ long IO_netcdf::get_dimension_size(const char *dim_name, MPI_Comm comm, bool is_
     long dimension_size = -1;
 
 
-	if (is_root_proc) {
-	    rcode = nc_open(file_name, NC_NOWRITE, &ncfile_id);
-	    report_nc_error();
-	    rcode = nc_inq_dimid(ncfile_id, dim_name, &dimension_id);
-		if (rcode == NC_NOERR) {
-		    rcode = nc_inq_dimlen(ncfile_id, dimension_id, (unsigned long *)(&dimension_size));
-		    report_nc_error();   
-		}
-	    rcode = nc_close(ncfile_id);
-	    report_nc_error();
-	}
+    if (is_root_proc) {
+        rcode = nc_open(file_name, NC_NOWRITE, &ncfile_id);
+        report_nc_error();
+        rcode = nc_inq_dimid(ncfile_id, dim_name, &dimension_id);
+        if (rcode == NC_NOERR) {
+            rcode = nc_inq_dimlen(ncfile_id, dimension_id, (unsigned long *)(&dimension_size));
+            report_nc_error();   
+        }
+        rcode = nc_close(ncfile_id);
+        report_nc_error();
+    }
 
-	if (comm != MPI_COMM_NULL)
-		MPI_Bcast(&dimension_size, 1, MPI_LONG, 0, comm);
+    if (comm != MPI_COMM_NULL)
+        MPI_Bcast(&dimension_size, 1, MPI_LONG, 0, comm);
 
     return dimension_size;
 }
@@ -664,47 +667,51 @@ void IO_netcdf::write_remap_weights(Remap_weight_of_strategy_class *remap_weight
 {
     Remap_grid_class *remap_grid_src, *remap_grid_dst, *leaf_grids[256];
     int dim_ncid_n_a, dim_ncid_n_b, dim_ncid_n_s, dim_ncid_nv_a, dim_ncid_nv_b;
-	int col_id, row_id, S_id, area_a_id, area_b_id, yc_a_id, xc_a_id, yv_a_id, xv_a_id;
-	int yc_b_id, xc_b_id, yv_b_id, xv_b_id, mask_a_id, mask_b_id;
+    int col_id, row_id, S_id, area_a_id, area_b_id, yc_a_id, xc_a_id, yv_a_id, xv_a_id;
+    int yc_b_id, xc_b_id, yv_b_id, xv_b_id, mask_a_id, mask_b_id;
     int num_leaf_grids, i;
     Remap_operator_basis *remap_operator;
     Remap_weight_sparse_matrix *weight_sparse_matrix;
-	Remap_operator_grid *remap_operator_grid_src, *remap_operator_grid_dst;
+    Remap_operator_grid *remap_operator_grid_src, *remap_operator_grid_dst;
     double *area_or_volumn_a, *area_or_volumn_b;
     int *temp_int_values, dim_ncids[2];
     long j;
 
     EXECUTION_REPORT(REPORT_ERROR, -1, words_are_the_same(open_format, "w"), "can not write to netcdf file %s: %s, whose open format is not write\n", object_name, file_name);
     EXECUTION_REPORT(REPORT_ERROR, -1, remap_weights != NULL, "remap software error1 in write_remap_weights of netcdf file\n");
+	EXECUTION_REPORT_ERROR_OPTIONALLY(REPORT_ERROR, -1, remap_grid_manager->search_remap_grid_with_grid_name(remap_weights->get_data_grid_src()->get_grid_name()) != NULL && remap_grid_manager->search_remap_grid_with_grid_name(remap_weights->get_data_grid_dst()->get_grid_name()) != NULL, "Software error in Remap_weight_of_operator_class::write_overall_remapping_weights");
+
+    remap_grid_src = remap_grid_manager->search_remap_grid_with_grid_name(remap_weights->get_data_grid_src()->get_grid_name());
+    remap_grid_dst = remap_grid_manager->search_remap_grid_with_grid_name(remap_weights->get_data_grid_dst()->get_grid_name());
+
+	if (remap_weights->get_remap_strategy() != NULL) {
+	    EXECUTION_REPORT(REPORT_ERROR, -1, remap_grid_src->are_all_vertex_fields_specified_by_user(),
+	                 "all vertex values of coordinates in src grid \"%s\" must have been set by users\n",
+	                 remap_grid_src->get_grid_name());
+	    EXECUTION_REPORT(REPORT_ERROR, -1, remap_grid_dst->are_all_vertex_fields_specified_by_user(),
+	                 "all vertex values of coordinates in dst grid \"%s\" must have been set by users\n",
+	                 remap_grid_dst->get_grid_name());   
+	}
 
-    remap_grid_src = remap_weights->get_data_grid_src();
-    remap_grid_dst = remap_weights->get_data_grid_dst();
-
-    EXECUTION_REPORT(REPORT_ERROR, -1, remap_grid_src->are_all_vertex_fields_specified_by_user(),
-                 "all vertex values of coordinates in src grid \"%s\" must have been set by users\n",
-                 remap_grid_src->get_grid_name());
-    EXECUTION_REPORT(REPORT_ERROR, -1, remap_grid_dst->are_all_vertex_fields_specified_by_user(),
-                 "all vertex values of coordinates in dst grid \"%s\" must have been set by users\n",
-                 remap_grid_dst->get_grid_name());    
-    
     EXECUTION_REPORT(REPORT_ERROR, -1, remap_weights->get_data_grid_src()->get_is_sphere_grid() &&
-                 remap_weights->get_remap_strategy()->get_num_remap_operator() == 1 &&
-                 remap_weights->get_remap_strategy()->get_remap_operator(0)->get_num_dimensions() == 2,
+                 (remap_weights->get_remap_strategy() == NULL || remap_weights->get_remap_strategy()->get_num_remap_operator() == 1 &&
+                 remap_weights->get_remap_strategy()->get_remap_operator(0)->get_num_dimensions() == 2),
                  "for SCRIP format of remap weights, we only support horizontal 2D remap of only one remap algorithm\n");
     if (execution_phase_number == 1) {
         remap_operator = remap_weights->get_unique_remap_operator_of_weights();
         EXECUTION_REPORT(REPORT_ERROR, -1, remap_operator != NULL,
                      "for SCRIP format of remap weights, we only support horizontal 2D remap of only one 2D remap algorithm\n");
-        remap_operator_grid_src = new Remap_operator_grid(remap_weights->get_data_grid_src(), remap_operator, true, false);
-		remap_operator_grid_dst = new Remap_operator_grid(remap_weights->get_data_grid_dst(), remap_operator, true, false);
-		remap_operator_grid_src->update_operator_grid_data();
-		remap_operator_grid_dst->update_operator_grid_data();
+        remap_operator_grid_src = new Remap_operator_grid(remap_weights->get_data_grid_src(), remap_operator, false, false);
+        remap_operator_grid_dst = new Remap_operator_grid(remap_weights->get_data_grid_dst(), remap_operator, false, false);
+        remap_operator_grid_src->update_operator_grid_data();
+        remap_operator_grid_dst->update_operator_grid_data();
         EXECUTION_REPORT(REPORT_ERROR, -1, remap_operator->get_num_remap_weights_groups() == 1,
                      "for SCRIP format of remap weights, we only support horizontal 2D remap of only one remap algorithm\n");
         weight_sparse_matrix = remap_operator->get_remap_weights_group(0);
         area_or_volumn_a = remap_weights->get_data_grid_src()->get_area_or_volumn();
         area_or_volumn_b = remap_weights->get_data_grid_dst()->get_area_or_volumn();
-        EXECUTION_REPORT(REPORT_ERROR, -1, area_or_volumn_a != NULL && area_or_volumn_b != NULL, "remap software error2 in write_remap_weights of netcdf file\n");
+		if (remap_weights->get_remap_strategy() != NULL) 
+	        EXECUTION_REPORT(REPORT_ERROR, -1, area_or_volumn_a != NULL && area_or_volumn_b != NULL, "remap software error2 in write_remap_weights of netcdf file\n");
         rcode = nc_open(file_name, NC_WRITE, &ncfile_id);
         rcode = nc_redef(ncfile_id);
         report_nc_error();
@@ -720,10 +727,14 @@ void IO_netcdf::write_remap_weights(Remap_weight_of_strategy_class *remap_weight
         report_nc_error();
         rcode = nc_def_var(ncfile_id, "S", NC_DOUBLE, 1, &dim_ncid_n_s, &S_id);
         report_nc_error();
-        rcode = nc_def_var(ncfile_id, "area_a", NC_DOUBLE, 1, &dim_ncid_n_a, &area_a_id);
-        report_nc_error();            
-        rcode = nc_def_var(ncfile_id, "area_b", NC_DOUBLE, 1, &dim_ncid_n_b, &area_b_id);
-        report_nc_error();
+		if (area_or_volumn_a != NULL) {
+        	rcode = nc_def_var(ncfile_id, "area_a", NC_DOUBLE, 1, &dim_ncid_n_a, &area_a_id);
+	        report_nc_error();            
+		}
+		if (area_or_volumn_b != NULL) {
+        	rcode = nc_def_var(ncfile_id, "area_b", NC_DOUBLE, 1, &dim_ncid_n_b, &area_b_id);
+	        report_nc_error();
+		}
         rcode = nc_def_var(ncfile_id, "yc_a", NC_DOUBLE, 1, &dim_ncid_n_a, &yc_a_id);
         report_nc_error();
         rcode = nc_def_var(ncfile_id, "xc_a", NC_DOUBLE, 1, &dim_ncid_n_a, &xc_a_id);
@@ -732,26 +743,31 @@ void IO_netcdf::write_remap_weights(Remap_weight_of_strategy_class *remap_weight
         report_nc_error();
         rcode = nc_def_var(ncfile_id, "xc_b", NC_DOUBLE, 1, &dim_ncid_n_b, &xc_b_id);
         report_nc_error();
-        rcode = nc_def_dim(ncfile_id, "nv_a", remap_operator_grid_src->get_num_vertexes(), &dim_ncid_nv_a);
-   	    report_nc_error();			
-		dim_ncids[0] = dim_ncid_n_a;
-		dim_ncids[1] = dim_ncid_nv_a;
-		rcode = nc_def_var(ncfile_id, "yv_a", NC_DOUBLE, 2, dim_ncids, &yv_a_id);
-		report_nc_error();
-		rcode = nc_def_var(ncfile_id, "xv_a", NC_DOUBLE, 2, dim_ncids, &xv_a_id);
-		report_nc_error();
-        rcode = nc_def_dim(ncfile_id, "nv_b", remap_operator_grid_dst->get_num_vertexes(), &dim_ncid_nv_b);
-   	    report_nc_error();
-		dim_ncids[0] = dim_ncid_n_b;
-		dim_ncids[1] = dim_ncid_nv_b;
-		rcode = nc_def_var(ncfile_id, "yv_b", NC_DOUBLE, 2, dim_ncids, &yv_b_id);
-		report_nc_error();
-		rcode = nc_def_var(ncfile_id, "xv_b", NC_DOUBLE, 2, dim_ncids, &xv_b_id);
-		report_nc_error();
-		rcode = nc_def_var(ncfile_id, "mask_a", NC_INT, 1, &dim_ncid_n_a, &mask_a_id);
-		report_nc_error();
-		rcode = nc_def_var(ncfile_id, "mask_b", NC_INT, 1, &dim_ncid_n_b, &mask_b_id);
-		report_nc_error();
+
+		if (remap_grid_src->are_all_vertex_fields_specified_by_user()) {
+	        rcode = nc_def_dim(ncfile_id, "nv_a", remap_operator_grid_src->get_num_vertexes(), &dim_ncid_nv_a);
+	        report_nc_error();            
+	        dim_ncids[0] = dim_ncid_n_a;
+	        dim_ncids[1] = dim_ncid_nv_a;
+	        rcode = nc_def_var(ncfile_id, "yv_a", NC_DOUBLE, 2, dim_ncids, &yv_a_id);
+	        report_nc_error();
+	        rcode = nc_def_var(ncfile_id, "xv_a", NC_DOUBLE, 2, dim_ncids, &xv_a_id);
+	        report_nc_error();
+		}
+		if (remap_grid_dst->are_all_vertex_fields_specified_by_user()) {
+	        rcode = nc_def_dim(ncfile_id, "nv_b", remap_operator_grid_dst->get_num_vertexes(), &dim_ncid_nv_b);
+	        report_nc_error();
+	        dim_ncids[0] = dim_ncid_n_b;
+	        dim_ncids[1] = dim_ncid_nv_b;
+	        rcode = nc_def_var(ncfile_id, "yv_b", NC_DOUBLE, 2, dim_ncids, &yv_b_id);
+	        report_nc_error();
+	        rcode = nc_def_var(ncfile_id, "xv_b", NC_DOUBLE, 2, dim_ncids, &xv_b_id);
+	        report_nc_error();
+		}
+        rcode = nc_def_var(ncfile_id, "mask_a", NC_INT, 1, &dim_ncid_n_a, &mask_a_id);
+        report_nc_error();
+        rcode = nc_def_var(ncfile_id, "mask_b", NC_INT, 1, &dim_ncid_n_b, &mask_b_id);
+        report_nc_error();
         rcode = nc_enddef(ncfile_id);
         report_nc_error();
         temp_int_values = new int [weight_sparse_matrix->get_num_weights()];
@@ -762,277 +778,287 @@ void IO_netcdf::write_remap_weights(Remap_weight_of_strategy_class *remap_weight
         for (j = 0; j < weight_sparse_matrix->get_num_weights(); j ++)
             temp_int_values[j] = weight_sparse_matrix->get_indexes_dst_grid()[j] + 1;
         rcode = nc_put_var_int(ncfile_id, row_id, temp_int_values);
-		delete [] temp_int_values;
+        delete [] temp_int_values;
         report_nc_error();
         rcode = nc_put_var_double(ncfile_id, S_id, weight_sparse_matrix->get_weight_values());
         report_nc_error();
-        rcode = nc_put_var_double(ncfile_id, area_a_id, area_or_volumn_a);
+		if (area_or_volumn_a != NULL) {
+        	rcode = nc_put_var_double(ncfile_id, area_a_id, area_or_volumn_a);
+	        report_nc_error();
+		}
+		if (area_or_volumn_b != NULL) {
+        	rcode = nc_put_var_double(ncfile_id, area_b_id, area_or_volumn_b);
+	        report_nc_error();
+		}
+        
+        EXECUTION_REPORT(REPORT_ERROR, -1, remap_operator_grid_src->get_center_coord_values()[0] != NULL &&
+                         remap_operator_grid_src->get_center_coord_values()[1] != NULL, 
+                         "remap software error3 in write_remap_weights of netcdf file\n");
+        EXECUTION_REPORT(REPORT_ERROR, -1, remap_operator_grid_dst->get_center_coord_values()[0] != NULL &&
+                         remap_operator_grid_dst->get_center_coord_values()[1] != NULL, 
+                         "remap software error4 in write_remap_weights of netcdf file\n");
+        EXECUTION_REPORT(REPORT_ERROR, -1, remap_operator_grid_src->get_vertex_coord_values()[0] != NULL &&
+                         remap_operator_grid_src->get_vertex_coord_values()[1] != NULL, 
+                         "remap software error5 in write_remap_weights of netcdf file\n");
+        EXECUTION_REPORT(REPORT_ERROR, -1, remap_operator_grid_dst->get_vertex_coord_values()[0] != NULL &&
+                         remap_operator_grid_dst->get_vertex_coord_values()[1] != NULL, 
+                         "remap software error6 in write_remap_weights of netcdf file\n");
+        EXECUTION_REPORT(REPORT_ERROR, -1, remap_operator_grid_src->get_mask_values() != NULL &&
+                         remap_operator_grid_dst->get_mask_values() != NULL, 
+                         "remap software error7 in write_remap_weights of netcdf file\n");
+        rcode = nc_put_var_double(ncfile_id, yc_a_id, remap_operator_grid_src->get_center_coord_values()[1]);
+        report_nc_error();
+        rcode = nc_put_var_double(ncfile_id, xc_a_id, remap_operator_grid_src->get_center_coord_values()[0]);
+        report_nc_error();
+        rcode = nc_put_var_double(ncfile_id, yc_b_id, remap_operator_grid_dst->get_center_coord_values()[1]);
         report_nc_error();
-        rcode = nc_put_var_double(ncfile_id, area_b_id, area_or_volumn_b);
+        rcode = nc_put_var_double(ncfile_id, xc_b_id, remap_operator_grid_dst->get_center_coord_values()[0]);
+        report_nc_error();
+		if (remap_grid_src->are_all_vertex_fields_specified_by_user()) {
+	        rcode = nc_put_var_double(ncfile_id, yv_a_id, remap_operator_grid_src->get_vertex_coord_values()[1]);
+	        report_nc_error();
+	        rcode = nc_put_var_double(ncfile_id, xv_a_id, remap_operator_grid_src->get_vertex_coord_values()[0]);
+	        report_nc_error();
+		}
+		if (remap_grid_dst->are_all_vertex_fields_specified_by_user()) {
+	        rcode = nc_put_var_double(ncfile_id, yv_b_id, remap_operator_grid_dst->get_vertex_coord_values()[1]);
+    	    report_nc_error();
+        	rcode = nc_put_var_double(ncfile_id, xv_b_id, remap_operator_grid_dst->get_vertex_coord_values()[0]);
+	        report_nc_error();
+    	}
+        temp_int_values = new int [remap_operator->get_src_grid()->get_grid_size()];
+        for (j = 0; j < remap_operator->get_src_grid()->get_grid_size(); j ++)
+            if (remap_operator_grid_src->get_mask_values()[j])
+                temp_int_values[j] = 1;
+            else temp_int_values[j] = 0;
+        rcode = nc_put_var_int(ncfile_id, mask_a_id, temp_int_values);
+        report_nc_error();
+        delete [] temp_int_values;
+        temp_int_values = new int [remap_operator->get_dst_grid()->get_grid_size()];
+        for (j = 0; j < remap_operator->get_dst_grid()->get_grid_size(); j ++)
+            if (remap_operator_grid_dst->get_mask_values()[j])
+                temp_int_values[j] = 1;
+            else temp_int_values[j] = 0;
+        rcode = nc_put_var_int(ncfile_id, mask_b_id, temp_int_values);
         report_nc_error();
-		
-		EXECUTION_REPORT(REPORT_ERROR, -1, remap_operator_grid_src->get_center_coord_values()[0] != NULL &&
-			             remap_operator_grid_src->get_center_coord_values()[1] != NULL, 
-			             "remap software error3 in write_remap_weights of netcdf file\n");
-		EXECUTION_REPORT(REPORT_ERROR, -1, remap_operator_grid_dst->get_center_coord_values()[0] != NULL &&
-			             remap_operator_grid_dst->get_center_coord_values()[1] != NULL, 
-			             "remap software error4 in write_remap_weights of netcdf file\n");
-		EXECUTION_REPORT(REPORT_ERROR, -1, remap_operator_grid_src->get_vertex_coord_values()[0] != NULL &&
-			             remap_operator_grid_src->get_vertex_coord_values()[1] != NULL, 
-			             "remap software error5 in write_remap_weights of netcdf file\n");
-		EXECUTION_REPORT(REPORT_ERROR, -1, remap_operator_grid_dst->get_vertex_coord_values()[0] != NULL &&
-			             remap_operator_grid_dst->get_vertex_coord_values()[1] != NULL, 
-			             "remap software error6 in write_remap_weights of netcdf file\n");
-		EXECUTION_REPORT(REPORT_ERROR, -1, remap_operator_grid_src->get_mask_values() != NULL &&
-			             remap_operator_grid_dst->get_mask_values() != NULL, 
-			             "remap software error7 in write_remap_weights of netcdf file\n");
-		rcode = nc_put_var_double(ncfile_id, yc_a_id, remap_operator_grid_src->get_center_coord_values()[1]);
-		report_nc_error();
-		rcode = nc_put_var_double(ncfile_id, xc_a_id, remap_operator_grid_src->get_center_coord_values()[0]);
-		report_nc_error();
-		rcode = nc_put_var_double(ncfile_id, yc_b_id, remap_operator_grid_dst->get_center_coord_values()[1]);
-		report_nc_error();
-		rcode = nc_put_var_double(ncfile_id, xc_b_id, remap_operator_grid_dst->get_center_coord_values()[0]);
-		report_nc_error();
-		rcode = nc_put_var_double(ncfile_id, yv_a_id, remap_operator_grid_src->get_vertex_coord_values()[1]);
-		report_nc_error();
-		rcode = nc_put_var_double(ncfile_id, xv_a_id, remap_operator_grid_src->get_vertex_coord_values()[0]);
-		report_nc_error();
-		rcode = nc_put_var_double(ncfile_id, yv_b_id, remap_operator_grid_dst->get_vertex_coord_values()[1]);
-		report_nc_error();
-		rcode = nc_put_var_double(ncfile_id, xv_b_id, remap_operator_grid_dst->get_vertex_coord_values()[0]);
-		report_nc_error();
-		temp_int_values = new int [remap_operator->get_src_grid()->get_grid_size()];
-		for (j = 0; j < remap_operator->get_src_grid()->get_grid_size(); j ++)
-			if (remap_operator_grid_src->get_mask_values()[j])
-				temp_int_values[j] = 1;
-			else temp_int_values[j] = 0;
-		rcode = nc_put_var_int(ncfile_id, mask_a_id, temp_int_values);
-		report_nc_error();
-		delete [] temp_int_values;
-		temp_int_values = new int [remap_operator->get_dst_grid()->get_grid_size()];
-		for (j = 0; j < remap_operator->get_dst_grid()->get_grid_size(); j ++)
-			if (remap_operator_grid_dst->get_mask_values()[j])
-				temp_int_values[j] = 1;
-			else temp_int_values[j] = 0;
-		rcode = nc_put_var_int(ncfile_id, mask_b_id, temp_int_values);
-		report_nc_error();
         delete [] temp_int_values;
         rcode = nc_close(ncfile_id);
         report_nc_error();
-		delete remap_operator_grid_src;
-		delete remap_operator_grid_dst;
+        delete remap_operator_grid_src;
+        delete remap_operator_grid_dst;
     }
 }
 
 
 void IO_netcdf::put_global_attr(const char *text_title, const void *attr_value, const char *local_data_type, const char *nc_data_type, int size)
 {
-	int nc_datatype;
+    int nc_datatype;
 
-	
-	if (!is_external_file) {
-    	rcode = nc_open(file_name, NC_WRITE, &ncfile_id);
-    	report_nc_error();
-	}
+    
+    if (!is_external_file) {
+        rcode = nc_open(file_name, NC_WRITE, &ncfile_id);
+        report_nc_error();
+    }
     rcode = nc_redef(ncfile_id);
     report_nc_error();
 
-	if (words_are_the_same(nc_data_type, DATA_TYPE_STRING))
-		EXECUTION_REPORT(REPORT_ERROR, -1, words_are_the_same(local_data_type, DATA_TYPE_STRING), "software error in IO_netcdf::put_global_attr: miss match of data type");
-	else if (words_are_the_same(nc_data_type, DATA_TYPE_FLOAT))
-		nc_datatype = NC_FLOAT;
-	else if (words_are_the_same(nc_data_type, DATA_TYPE_DOUBLE))
-		nc_datatype = NC_DOUBLE;
-	else if (words_are_the_same(nc_data_type, DATA_TYPE_INT))
-		nc_datatype = NC_INT;
-	else EXECUTION_REPORT(REPORT_ERROR, -1, false, "software error in IO_netcdf::put_global_attr: wrong nc data type %s", nc_datatype);
-	
-	if (words_are_the_same(local_data_type, DATA_TYPE_STRING))
-	    rcode = nc_put_att_text(ncfile_id, NC_GLOBAL, text_title, strlen((const char*)attr_value), (const char*)attr_value);
-	else if (words_are_the_same(local_data_type, DATA_TYPE_FLOAT))
-		rcode = nc_put_att_float(ncfile_id, NC_GLOBAL, text_title, NC_FLOAT, size, (const float*)attr_value);
-	else if (words_are_the_same(local_data_type, DATA_TYPE_DOUBLE))
-		rcode = nc_put_att_double(ncfile_id, NC_GLOBAL, text_title, NC_DOUBLE, size, (const double*)attr_value);
-	else EXECUTION_REPORT(REPORT_ERROR, -1, false, "software error in IO_netcdf::put_global_attr: wrong local data type %s", local_data_type);
+    if (words_are_the_same(nc_data_type, DATA_TYPE_STRING))
+        EXECUTION_REPORT(REPORT_ERROR, -1, words_are_the_same(local_data_type, DATA_TYPE_STRING), "software error in IO_netcdf::put_global_attr: miss match of data type");
+    else if (words_are_the_same(nc_data_type, DATA_TYPE_FLOAT))
+        nc_datatype = NC_FLOAT;
+    else if (words_are_the_same(nc_data_type, DATA_TYPE_DOUBLE))
+        nc_datatype = NC_DOUBLE;
+    else if (words_are_the_same(nc_data_type, DATA_TYPE_INT))
+        nc_datatype = NC_INT;
+    else EXECUTION_REPORT(REPORT_ERROR, -1, false, "software error in IO_netcdf::put_global_attr: wrong nc data type %s", nc_datatype);
+    
+    if (words_are_the_same(local_data_type, DATA_TYPE_STRING))
+        rcode = nc_put_att_text(ncfile_id, NC_GLOBAL, text_title, strlen((const char*)attr_value), (const char*)attr_value);
+    else if (words_are_the_same(local_data_type, DATA_TYPE_FLOAT))
+        rcode = nc_put_att_float(ncfile_id, NC_GLOBAL, text_title, NC_FLOAT, size, (const float*)attr_value);
+    else if (words_are_the_same(local_data_type, DATA_TYPE_DOUBLE))
+        rcode = nc_put_att_double(ncfile_id, NC_GLOBAL, text_title, NC_DOUBLE, size, (const double*)attr_value);
+    else EXECUTION_REPORT(REPORT_ERROR, -1, false, "software error in IO_netcdf::put_global_attr: wrong local data type %s", local_data_type);
     report_nc_error();
     nc_enddef(ncfile_id);
     report_nc_error();
-	if (!is_external_file) {
-	    rcode = nc_close(ncfile_id);
-    	report_nc_error();
-	}
+    if (!is_external_file) {
+        rcode = nc_close(ncfile_id);
+        report_nc_error();
+    }
 }
 
 
 bool IO_netcdf::get_file_field_attribute(const char *field_name, const char *attribute_name, char *attribute_value, char *data_type)
 {
-	int variable_id = NC_GLOBAL;
-	nc_type nc_data_type;
-	unsigned long attribute_size;
+    int variable_id = NC_GLOBAL;
+    nc_type nc_data_type;
+    unsigned long attribute_size;
 
-	
+    
     rcode = nc_open(file_name, NC_NOWRITE, &ncfile_id);
     report_nc_error();
 
-	if (field_name != NULL) {
-	    rcode = nc_inq_varid(ncfile_id, field_name, &variable_id);
-		if (rcode != NC_NOERR) {
-			rcode = nc_close(ncfile_id);
-			report_nc_error();
-			return false;
-		}
-	}
+    if (field_name != NULL) {
+        rcode = nc_inq_varid(ncfile_id, field_name, &variable_id);
+        if (rcode != NC_NOERR) {
+            rcode = nc_close(ncfile_id);
+            report_nc_error();
+            return false;
+        }
+    }
 
-	rcode = nc_inq_att(ncfile_id, variable_id, attribute_name, &nc_data_type, &attribute_size);
-	if (rcode != NC_NOERR) {
-		rcode = nc_close(ncfile_id);
-		report_nc_error();
-		return false;	
-	}
+    rcode = nc_inq_att(ncfile_id, variable_id, attribute_name, &nc_data_type, &attribute_size);
+    if (rcode != NC_NOERR) {
+        rcode = nc_close(ncfile_id);
+        report_nc_error();
+        return false;    
+    }
 
-	switch (nc_data_type) {
-		case NC_BYTE:
-		case NC_CHAR:
-			strcpy(data_type, DATA_TYPE_STRING);
-			rcode = nc_get_att_text(ncfile_id, variable_id, attribute_name, attribute_value);
-			attribute_value[attribute_size] = '\0';
-			break;
-		case NC_SHORT:
-			rcode = nc_get_att_short(ncfile_id, variable_id, attribute_name, (short*)attribute_value);
-			strcpy(data_type, DATA_TYPE_SHORT);
-			break;
-		case NC_INT:
-			strcpy(data_type, DATA_TYPE_INT);
-			rcode = nc_get_att_int(ncfile_id, variable_id, attribute_name, (int*)attribute_value);
-			break;
-		case NC_FLOAT:
-			strcpy(data_type, DATA_TYPE_FLOAT);
-			rcode = nc_get_att_float(ncfile_id, variable_id, attribute_name, (float*)attribute_value);
-			break;
-		case NC_DOUBLE:
-			strcpy(data_type, DATA_TYPE_DOUBLE);
-			rcode = nc_get_att_double(ncfile_id, variable_id, attribute_name, (double*)attribute_value);
-			break;
-		default:
-			rcode = nc_close(ncfile_id);
-			report_nc_error();
-			return false;
-	}	
-
-	if (rcode != NC_NOERR) {
-		rcode = nc_close(ncfile_id);
-		report_nc_error();
-		return false;
-	}
+    switch (nc_data_type) {
+        case NC_BYTE:
+        case NC_CHAR:
+            strcpy(data_type, DATA_TYPE_STRING);
+            rcode = nc_get_att_text(ncfile_id, variable_id, attribute_name, attribute_value);
+            attribute_value[attribute_size] = '\0';
+            break;
+        case NC_SHORT:
+            rcode = nc_get_att_short(ncfile_id, variable_id, attribute_name, (short*)attribute_value);
+            strcpy(data_type, DATA_TYPE_SHORT);
+            break;
+        case NC_INT:
+            strcpy(data_type, DATA_TYPE_INT);
+            rcode = nc_get_att_int(ncfile_id, variable_id, attribute_name, (int*)attribute_value);
+            break;
+        case NC_FLOAT:
+            strcpy(data_type, DATA_TYPE_FLOAT);
+            rcode = nc_get_att_float(ncfile_id, variable_id, attribute_name, (float*)attribute_value);
+            break;
+        case NC_DOUBLE:
+            strcpy(data_type, DATA_TYPE_DOUBLE);
+            rcode = nc_get_att_double(ncfile_id, variable_id, attribute_name, (double*)attribute_value);
+            break;
+        default:
+            rcode = nc_close(ncfile_id);
+            report_nc_error();
+            return false;
+    }    
 
-	rcode = nc_close(ncfile_id);
-	report_nc_error();
-	
-	return true;
+    if (rcode != NC_NOERR) {
+        rcode = nc_close(ncfile_id);
+        report_nc_error();
+        return false;
+    }
+
+    rcode = nc_close(ncfile_id);
+    report_nc_error();
+    
+    return true;
 }
 
 
 bool IO_netcdf::get_file_field_string_attribute(const char *field_name, const char *attribute_name, char *attribute_value, char *data_type, MPI_Comm comm, bool is_root_proc)
 {
-	int success;
-
-	attribute_value[0] = '\0';
-	data_type[0] = '\0';
-
-	if (is_root_proc)
-		success = get_file_field_attribute(field_name, attribute_name, attribute_value, data_type)? 1 : 0;
-	if (comm != MPI_COMM_NULL)
-		MPI_Bcast(&success, 1, MPI_INT, 0, comm);
-	if (success == 0)
-		return false;
-	if (comm != MPI_COMM_NULL) {
-		MPI_Bcast(attribute_value, NAME_STR_SIZE, MPI_CHAR, 0, comm);
-		MPI_Bcast(data_type, NAME_STR_SIZE, MPI_CHAR, 0, comm);
-	}
+    int success;
+
+    attribute_value[0] = '\0';
+    data_type[0] = '\0';
+
+    if (is_root_proc)
+        success = get_file_field_attribute(field_name, attribute_name, attribute_value, data_type)? 1 : 0;
+    if (comm != MPI_COMM_NULL)
+        MPI_Bcast(&success, 1, MPI_INT, 0, comm);
+    if (success == 0)
+        return false;
+    if (comm != MPI_COMM_NULL) {
+        MPI_Bcast(attribute_value, NAME_STR_SIZE, MPI_CHAR, 0, comm);
+        MPI_Bcast(data_type, NAME_STR_SIZE, MPI_CHAR, 0, comm);
+    }
 
-	return true;
+    return true;
 }
 
 
 void IO_netcdf::read_file_field(const char *field_name, void **data_array_ptr, int *field_size, char *data_type, MPI_Comm comm, bool is_root_proc)
 {
-	int i, variable_id, *dim_ids, *dim_size, total_size, have_field = 1;
-	size_t dim_len;
-	nc_type nc_var_type;
-	char *data_array = NULL;
-	int num_dims = 0;
-
-	*data_array_ptr = NULL;
-	*field_size = -1;
-	
-	if (is_root_proc) {
-	    rcode = nc_open(file_name, NC_NOWRITE, &ncfile_id);
-	    report_nc_error();
-	    rcode = nc_inq_varid(ncfile_id, field_name, &variable_id);
-		if (rcode != NC_NOERR) {
-			rcode = nc_close(ncfile_id);
-			report_nc_error();
-			have_field = 0;
-		}
-		else {
-			rcode = nc_inq_varndims(ncfile_id, variable_id, &num_dims);
-			report_nc_error();
-			dim_ids = new int [num_dims];
-			dim_size = new int [num_dims];
-			rcode = nc_inq_vardimid(ncfile_id, variable_id, dim_ids);
-			report_nc_error();
-			for (i = 0; i < num_dims; i ++) {
-				rcode = nc_inq_dimlen(ncfile_id, dim_ids[i], &dim_len);
-				report_nc_error();
-				dim_size[i] = dim_len;
-			}
-			rcode = nc_inq_vartype(ncfile_id, variable_id, &nc_var_type);
-			report_nc_error();
-			datatype_from_netcdf_to_application(nc_var_type, data_type, field_name);
-
-			total_size = 1;
-			for (i = 0; i < num_dims; i ++)
-				total_size *= dim_size[i];
-			data_array = new char [total_size*get_data_type_size(data_type)];
-			switch(nc_var_type) {
-				case NC_SHORT:
-					rcode = nc_get_var_short(ncfile_id, variable_id, (short*)data_array);
-					break;
-				case NC_INT:
-					rcode = nc_get_var_int(ncfile_id, variable_id, (int*)data_array);
-					break;
-				case NC_FLOAT:
-					rcode = nc_get_var_float(ncfile_id, variable_id, (float*)data_array);
-					break;
-				case NC_DOUBLE:
-					rcode = nc_get_var_double(ncfile_id, variable_id, (double*)data_array);
-					break;
-				default:
-					EXECUTION_REPORT(REPORT_ERROR, -1, false, "software error in IO_netcdf::read_file_field: data type %s is not supported", data_type);
-					break;
-			}
-			report_nc_error();
-			*field_size = total_size;
-			delete [] dim_ids;
-			delete [] dim_size;
-			rcode = nc_close(ncfile_id);
-			report_nc_error();
-		}
-	}
+    int i, variable_id, *dim_ids, *dim_size, total_size, have_field = 1;
+    size_t dim_len;
+    nc_type nc_var_type;
+    char *data_array = NULL;
+    int num_dims = 0;
+
+    *data_array_ptr = NULL;
+    *field_size = -1;
+    
+    if (is_root_proc) {
+        rcode = nc_open(file_name, NC_NOWRITE, &ncfile_id);
+        report_nc_error();
+        rcode = nc_inq_varid(ncfile_id, field_name, &variable_id);
+        if (rcode != NC_NOERR) {
+            rcode = nc_close(ncfile_id);
+            report_nc_error();
+            have_field = 0;
+        }
+        else {
+            rcode = nc_inq_varndims(ncfile_id, variable_id, &num_dims);
+            report_nc_error();
+            dim_ids = new int [num_dims];
+            dim_size = new int [num_dims];
+            rcode = nc_inq_vardimid(ncfile_id, variable_id, dim_ids);
+            report_nc_error();
+            for (i = 0; i < num_dims; i ++) {
+                rcode = nc_inq_dimlen(ncfile_id, dim_ids[i], &dim_len);
+                report_nc_error();
+                dim_size[i] = dim_len;
+            }
+            rcode = nc_inq_vartype(ncfile_id, variable_id, &nc_var_type);
+            report_nc_error();
+            datatype_from_netcdf_to_application(nc_var_type, data_type, field_name);
 
-	if (comm != MPI_COMM_NULL) {
-		MPI_Bcast(&have_field, 1, MPI_INT, 0, comm);
-		if (have_field == 0)
-			return;
-		MPI_Bcast(field_size, 1, MPI_INT, 0, comm);
-		MPI_Bcast(data_type, NAME_STR_SIZE, MPI_CHAR, 0, comm);
-		if (data_array == NULL)
-			data_array = new char [(*field_size)*get_data_type_size(data_type)];
-		MPI_Bcast(data_array, (*field_size)*get_data_type_size(data_type), MPI_CHAR, 0, comm);
-	}
+            total_size = 1;
+            for (i = 0; i < num_dims; i ++)
+                total_size *= dim_size[i];
+            data_array = new char [total_size*get_data_type_size(data_type)];
+            switch(nc_var_type) {
+                case NC_SHORT:
+                    rcode = nc_get_var_short(ncfile_id, variable_id, (short*)data_array);
+                    break;
+                case NC_INT:
+                    rcode = nc_get_var_int(ncfile_id, variable_id, (int*)data_array);
+                    break;
+                case NC_FLOAT:
+                    rcode = nc_get_var_float(ncfile_id, variable_id, (float*)data_array);
+                    break;
+                case NC_DOUBLE:
+                    rcode = nc_get_var_double(ncfile_id, variable_id, (double*)data_array);
+                    break;
+                default:
+                    EXECUTION_REPORT(REPORT_ERROR, -1, false, "software error in IO_netcdf::read_file_field: data type %s is not supported", data_type);
+                    break;
+            }
+            report_nc_error();
+            *field_size = total_size;
+            delete [] dim_ids;
+            delete [] dim_size;
+            rcode = nc_close(ncfile_id);
+            report_nc_error();
+        }
+    }
+
+    if (comm != MPI_COMM_NULL) {
+        MPI_Bcast(&have_field, 1, MPI_INT, 0, comm);
+        if (have_field == 0)
+            return;
+        MPI_Bcast(field_size, 1, MPI_INT, 0, comm);
+        MPI_Bcast(data_type, NAME_STR_SIZE, MPI_CHAR, 0, comm);
+		if (field_size > 0) {
+	        if (data_array == NULL)
+	            data_array = new char [(*field_size)*get_data_type_size(data_type)];
+	        MPI_Bcast(data_array, (*field_size)*get_data_type_size(data_type), MPI_CHAR, 0, comm);
+		}
+    }
 
-	*data_array_ptr = data_array;
+    *data_array_ptr = data_array;
 }
 
 
@@ -1085,53 +1111,53 @@ void IO_netcdf::read_remap_weights(Remap_weight_of_strategy_class *remap_weights
                      "the dst grid in netcdf file does not match the dst grid of remap operator\n");
         area = new double [grid_size];
         rcode = nc_inq_varid(ncfile_id, "area_b", &var_id);
-		if (rcode == NC_NOERR) {
-    	    rcode = nc_get_var_double(ncfile_id, var_id, remap_weights->get_data_grid_dst()->get_area_or_volumn());
-	        report_nc_error();
-		}
+        if (rcode == NC_NOERR) {
+            rcode = nc_get_var_double(ncfile_id, var_id, remap_weights->get_data_grid_dst()->get_area_or_volumn());
+            report_nc_error();
+        }
         rcode = nc_inq_dimid(ncfile_id, "n_s", &var_id);
         report_nc_error();
         rcode = nc_inq_dimlen(ncfile_id, var_id, &num_weights);
         report_nc_error();
-		if (read_weight_values) {
-	        indexes_src = new long [num_weights];
-	        indexes_dst = new long [num_weights];
-	        tmp_indexes_src = new int [num_weights];
-	        tmp_indexes_dst = new int [num_weights];
-	        weight_values = new double [num_weights];
-	        rcode = nc_inq_varid(ncfile_id, "col", &var_id);
-	        report_nc_error();
-	        rcode = nc_get_var_int(ncfile_id, var_id, tmp_indexes_src);
-	        report_nc_error();
-	        rcode = nc_inq_varid(ncfile_id, "row", &var_id);
-	        report_nc_error();
-	        rcode = nc_get_var_int(ncfile_id, var_id, tmp_indexes_dst);
-	        report_nc_error();
-	        rcode = nc_inq_varid(ncfile_id, "S", &var_id);
-	        report_nc_error();
-	        rcode = nc_get_var_double(ncfile_id, var_id, weight_values);
-	        report_nc_error();
-	        for (i = 0; i < num_weights; i ++) {
-	            indexes_src[i] = tmp_indexes_src[i] - 1;
-	            indexes_dst[i] = tmp_indexes_dst[i] - 1;
-	        }
-	        duplicated_remap_operator = remap_strategy->get_remap_operator(0)->duplicate_remap_operator(false);
-	        weight_sparse_matrix = new Remap_weight_sparse_matrix(remap_strategy->get_remap_operator(0),
-	                                                              num_weights, indexes_src, indexes_dst, weight_values, 
-	                                                              0, NULL);
-	        duplicated_remap_operator->add_weight_sparse_matrix(weight_sparse_matrix);
-		}
-		else duplicated_remap_operator = NULL;
+        if (read_weight_values) {
+            indexes_src = new long [num_weights];
+            indexes_dst = new long [num_weights];
+            tmp_indexes_src = new int [num_weights];
+            tmp_indexes_dst = new int [num_weights];
+            weight_values = new double [num_weights];
+            rcode = nc_inq_varid(ncfile_id, "col", &var_id);
+            report_nc_error();
+            rcode = nc_get_var_int(ncfile_id, var_id, tmp_indexes_src);
+            report_nc_error();
+            rcode = nc_inq_varid(ncfile_id, "row", &var_id);
+            report_nc_error();
+            rcode = nc_get_var_int(ncfile_id, var_id, tmp_indexes_dst);
+            report_nc_error();
+            rcode = nc_inq_varid(ncfile_id, "S", &var_id);
+            report_nc_error();
+            rcode = nc_get_var_double(ncfile_id, var_id, weight_values);
+            report_nc_error();
+            for (i = 0; i < num_weights; i ++) {
+                indexes_src[i] = tmp_indexes_src[i] - 1;
+                indexes_dst[i] = tmp_indexes_dst[i] - 1;
+            }
+            duplicated_remap_operator = remap_strategy->get_remap_operator(0)->duplicate_remap_operator(false);
+            weight_sparse_matrix = new Remap_weight_sparse_matrix(remap_strategy->get_remap_operator(0),
+                                                                  num_weights, indexes_src, indexes_dst, weight_values, 
+                                                                  0, NULL);
+            duplicated_remap_operator->add_weight_sparse_matrix(weight_sparse_matrix);
+        }
+        else duplicated_remap_operator = NULL;
         remap_operator_instance = new Remap_weight_of_operator_instance_class(remap_weights->get_data_grid_src(),
                                                                      remap_weights->get_data_grid_dst(),
                                                                      0, remap_strategy->get_remap_operator(0),
                                                                      duplicated_remap_operator);
-        remap_weights->add_remap_weight_of_operator_instance(remap_operator_instance);
+        remap_weights->add_remap_weight_of_operator_instance(remap_operator_instance, remap_weights->get_data_grid_src(), remap_weights->get_data_grid_dst(), remap_strategy->get_remap_operator(0), remap_strategy->get_remap_operator(0)->get_src_grid(), remap_strategy->get_remap_operator(0)->get_dst_grid());
 
-		if (read_weight_values) {
-        	delete [] tmp_indexes_src;
-        	delete [] tmp_indexes_dst;
-		}
+        if (read_weight_values) {
+            delete [] tmp_indexes_src;
+            delete [] tmp_indexes_dst;
+        }
         delete [] area;
     }
 }
diff --git a/src/CoR/io_netcdf.h b/src/CoR/io_netcdf.h
old mode 100644
new mode 100755
index f56061c..63b2fc3
--- a/src/CoR/io_netcdf.h
+++ b/src/CoR/io_netcdf.h
@@ -32,16 +32,16 @@ class IO_netcdf: public IO_basis
         bool io_with_time_info;
         int time_dim_id;
         int time_count;
-		bool is_external_file;
+        bool is_external_file;
         
         void write_field_data(Remap_grid_data_class*, Remap_grid_class*, bool, const char*, int, bool, bool);
         void datatype_from_netcdf_to_application(nc_type, char*, const char*);
         void datatype_from_application_to_netcdf(const char*, nc_type*);
         void report_nc_error();
-		bool get_file_field_attribute(const char *, const char *, char *, char *);
+        bool get_file_field_attribute(const char *, const char *, char *, char *);
 
     public:
-		IO_netcdf(int);
+        IO_netcdf(int);
         IO_netcdf(const char*, const char*, const char*, bool);
         ~IO_netcdf();
         bool read_data(Remap_data_field*, int, bool);
@@ -50,8 +50,8 @@ class IO_netcdf: public IO_basis
         long get_dimension_size(const char*, MPI_Comm, bool);
         void read_remap_weights(Remap_weight_of_strategy_class*, Remap_strategy_class*, bool);
         void put_global_attr(const char*, const void*, const char *, const char *, int);
-		void read_file_field(const char*, void**, int*, char*, MPI_Comm, bool);
-		bool get_file_field_string_attribute(const char*, const char *, char*, char *, MPI_Comm, bool);
+        void read_file_field(const char*, void**, int*, char*, MPI_Comm, bool);
+        bool get_file_field_string_attribute(const char*, const char *, char*, char *, MPI_Comm, bool);
         void write_grid(Remap_grid_class*, bool, bool);
 };
 
diff --git a/src/CoR/parse_special_words.h b/src/CoR/parse_special_words.h
old mode 100644
new mode 100755
diff --git a/src/CoR/quick_sort.h b/src/CoR/quick_sort.h
old mode 100644
new mode 100755
index 51419aa..da20882
--- a/src/CoR/quick_sort.h
+++ b/src/CoR/quick_sort.h
@@ -28,16 +28,16 @@ template <class T1, class T2> void do_ins_sort(T1 *sorted_values,
                                                long segment_start, 
                                                long segment_end)
 {
-	long i, j;
+    long i, j;
     for (i = segment_start+1; i <= segment_end; i ++) {
         for (j = i; j > segment_start && (sorted_values[j] < sorted_values[j-1]); j--) {
             swap(sorted_values+j, sorted_values+j-1);
-			if (content_values != NULL)
-	            swap(content_values+j, content_values+j-1);
+            if (content_values != NULL)
+                swap(content_values+j, content_values+j-1);
         }
-		if (content_values != NULL)
-			for (; j > segment_start && (sorted_values[j] == sorted_values[j-1]) && (content_values[j] < content_values[j-1]); j--)
-				swap(content_values+j, content_values+j-1);
+        if (content_values != NULL)
+            for (; j > segment_start && (sorted_values[j] == sorted_values[j-1]) && (content_values[j] < content_values[j-1]); j--)
+                swap(content_values+j, content_values+j-1);
     }
 }
 
@@ -51,13 +51,13 @@ template <class T1, class T2> long partition(T1 *sorted_values,
     do {
         while (sorted_values[++segment_start] < pivot);
         while (segment_end > 0 && sorted_values[--segment_end] > pivot);
-		swap(sorted_values+segment_start, sorted_values+segment_end);
-		if (content_values != NULL)
-	        swap(content_values+segment_start, content_values+segment_end);
+        swap(sorted_values+segment_start, sorted_values+segment_end);
+        if (content_values != NULL)
+            swap(content_values+segment_start, content_values+segment_end);
     } while (segment_start < segment_end);
-	swap(sorted_values+segment_start, sorted_values+segment_end);
-	if (content_values != NULL)
-		swap(content_values+segment_start, content_values+segment_end);
+    swap(sorted_values+segment_start, sorted_values+segment_end);
+    if (content_values != NULL)
+        swap(content_values+segment_start, content_values+segment_end);
 
     return segment_start;
 }
@@ -76,22 +76,22 @@ template <class T1, class T2> void do_quick_sort(T1 *sorted_values,
     else {
         pivotindex = (segment_start+segment_end) / 2;
         swap(sorted_values+pivotindex, sorted_values+segment_end);
-		if (content_values != NULL)
-        	swap(content_values+pivotindex, content_values+segment_end);
+        if (content_values != NULL)
+            swap(content_values+pivotindex, content_values+segment_end);
         partition_pos = partition(sorted_values, content_values, segment_start-1, segment_end, sorted_values[segment_end]);
         swap(sorted_values+partition_pos, sorted_values+segment_end);
-		if (content_values != NULL)
-	        swap(content_values+partition_pos, content_values+segment_end);
+        if (content_values != NULL)
+            swap(content_values+partition_pos, content_values+segment_end);
         if(partition_pos - segment_start > 1) 
             do_quick_sort(sorted_values, content_values, segment_start, partition_pos-1);
         if(segment_end-partition_pos > 1) 
             do_quick_sort(sorted_values, content_values, partition_pos+1, segment_end);
-		if (content_values != NULL) {
-			for (i = partition_pos-1; i >= segment_start && sorted_values[i] == sorted_values[partition_pos]; i --);
-			for (j = partition_pos+1; j <= segment_end && sorted_values[j] == sorted_values[partition_pos]; j ++);
-			if ((++i) < (--j))
-				do_quick_sort(content_values, (long*)NULL, i, j);
-		}
+        if (content_values != NULL) {
+            for (i = partition_pos-1; i >= segment_start && sorted_values[i] == sorted_values[partition_pos]; i --);
+            for (j = partition_pos+1; j <= segment_end && sorted_values[j] == sorted_values[partition_pos]; j ++);
+            if ((++i) < (--j))
+                do_quick_sort(content_values, (long*)NULL, i, j);
+        }
     }
 }
 
diff --git a/src/CoR/radix_sort.h b/src/CoR/radix_sort.h
old mode 100644
new mode 100755
diff --git a/src/CoR/remap_common_utils.cxx b/src/CoR/remap_common_utils.cxx
old mode 100644
new mode 100755
index ea35fef..0b22831
--- a/src/CoR/remap_common_utils.cxx
+++ b/src/CoR/remap_common_utils.cxx
@@ -32,16 +32,16 @@ void match_degree_values(double &data_value1, double &data_value2)
 
 bool words_are_the_same(const char *word1, const char *word2)
 {
-	if (word1 == NULL)
-		if (word2 == NULL || strlen(word2) == 0)
-			return true;
-		else return false;
-
-	if (word2 == NULL)
-		if (strlen(word1) == 0)
-			return true;
-		else return false;
-	
+    if (word1 == NULL)
+        if (word2 == NULL || strlen(word2) == 0)
+            return true;
+        else return false;
+
+    if (word2 == NULL)
+        if (strlen(word1) == 0)
+            return true;
+        else return false;
+    
     return strcmp(word1, word2) == 0;
 }
 
@@ -56,11 +56,11 @@ double compute_three_3D_points_cross_product(double center_coord_value_x,
                                              double vertex2_coord_value_y,
                                              double vertex2_coord_value_z)
 {
-	double vector_x = vertex1_coord_value_y*vertex2_coord_value_z - vertex1_coord_value_z*vertex2_coord_value_y;
-	double vector_y = vertex1_coord_value_z*vertex2_coord_value_x - vertex1_coord_value_x*vertex2_coord_value_z;
-	double vector_z = vertex1_coord_value_x*vertex2_coord_value_y - vertex1_coord_value_y*vertex2_coord_value_x;
-	double module1 = sqrt(center_coord_value_x*center_coord_value_x+center_coord_value_y*center_coord_value_y+center_coord_value_z*center_coord_value_z);
-	double module2 = sqrt(vector_x*vector_x+vector_y*vector_y+vector_z*vector_z);
+    double vector_x = vertex1_coord_value_y*vertex2_coord_value_z - vertex1_coord_value_z*vertex2_coord_value_y;
+    double vector_y = vertex1_coord_value_z*vertex2_coord_value_x - vertex1_coord_value_x*vertex2_coord_value_z;
+    double vector_z = vertex1_coord_value_x*vertex2_coord_value_y - vertex1_coord_value_y*vertex2_coord_value_x;
+    double module1 = sqrt(center_coord_value_x*center_coord_value_x+center_coord_value_y*center_coord_value_y+center_coord_value_z*center_coord_value_z);
+    double module2 = sqrt(vector_x*vector_x+vector_y*vector_y+vector_z*vector_z);
     return (center_coord_value_x*vector_x + center_coord_value_y*vector_y + center_coord_value_z*vector_z) / (module1*module2);
 }
 
@@ -303,17 +303,17 @@ void rotate_sphere_coordinate(double lon_original, double lat_original, double &
     double lon_rotated_radian, lat_rotated_radian, temp1_value, temp2_value;
 
 
-	if (lon_original == 0.0 && lat_original == 0.0) {
-		lat_rotated = -90.0;
-		lon_rotated = 0.0;
-		return;
-	}
+    if (lon_original == 0.0 && lat_original == 0.0) {
+        lat_rotated = -90.0;
+        lon_rotated = 0.0;
+        return;
+    }
 
-	if (lon_original == 180 && lat_original == 0.0) {
-		lat_rotated = 90.0;
-		lon_rotated = 0.0;
-		return;
-	}
+    if (lon_original == 180 && lat_original == 0.0) {
+        lat_rotated = 90.0;
+        lon_rotated = 0.0;
+        return;
+    }
 
     temp1_value = cos(DEGREE_TO_RADIAN(lon_original))*cos(DEGREE_TO_RADIAN(lat_original));
     temp2_value = sin(DEGREE_TO_RADIAN(lon_original))*cos(DEGREE_TO_RADIAN(lat_original))/sqrt(1-temp1_value*temp1_value);
diff --git a/src/CoR/remap_common_utils.h b/src/CoR/remap_common_utils.h
old mode 100644
new mode 100755
diff --git a/src/CoR/remap_grid_class.cxx b/src/CoR/remap_grid_class.cxx
old mode 100644
new mode 100755
index afabbdf..09b35bf
--- a/src/CoR/remap_grid_class.cxx
+++ b/src/CoR/remap_grid_class.cxx
@@ -26,7 +26,7 @@ void Remap_grid_class::initialize_grid_class_data()
     strcpy(this->grid_name, "\0");
     strcpy(this->coord_label, "\0");
     strcpy(this->coord_unit, "\0");
-	strcpy(this->decomp_name, "\0");
+    strcpy(this->decomp_name, "\0");
     this->grid_size = 0;
     this->num_dimensions = 0;
     this->num_vertexes = 0;
@@ -35,13 +35,13 @@ void Remap_grid_class::initialize_grid_class_data()
     this->super_grid_of_setting_coord_values = NULL;
     this->first_super_grid_of_enable_setting_coord_value = NULL;
     this->duplicated_grid = NULL;
-	this->generated_from_duplication = false;
+    this->generated_from_duplication = false;
     this->original_grid = NULL;
     this->sub_grids.clear();
     this->grid_center_fields.clear();
     this->grid_vertex_fields.clear();
     this->grid_mask_field = NULL;
-	this->imported_area = NULL;
+    this->imported_area = NULL;
     this->super_grids_of_setting_mask_value.clear();
     this->original_grid_mask_field = NULL;
     this->masks_are_known = false;    
@@ -51,19 +51,20 @@ void Remap_grid_class::initialize_grid_class_data()
     this->redundant_cell_mark = NULL;
     this->redundant_cell_mark_field = NULL;
     this->area_or_volumn = NULL;
-	this->sigma_grid_scale_factor = 0;
-	this->sigma_grid_top_value = 0;
+    this->sigma_grid_scale_factor = 0;
+    this->sigma_grid_top_value = 0;
+	this->using_V3D_level_coord = false;
     this->boundary_min_lon = NULL_COORD_VALUE;
     this->boundary_max_lon = NULL_COORD_VALUE;
     this->boundary_min_lat = NULL_COORD_VALUE;
     this->boundary_max_lat = NULL_COORD_VALUE;
-	this->hybrid_grid_coefficient_field = NULL;
-	this->sigma_grid_sigma_value_field = NULL;
-	this->sigma_grid_surface_value_field = NULL;
-	this->sigma_grid_surface_value_field_specified = false;
-	this->sigma_grid_dynamic_surface_value_field = NULL;
-	this->mid_point_grid = NULL;
-	this->interface_level_grid = NULL;
+    this->hybrid_grid_coefficient_field = NULL;
+    this->sigma_grid_sigma_value_field = NULL;
+    this->level_V3D_coord_trigger_field = NULL;
+    this->level_V3D_coord_trigger_field_specified = false;
+    this->level_V3D_coord_dynamic_trigger_field = NULL;
+    this->mid_point_grid = NULL;
+    this->interface_level_grid = NULL;
 }
 
 
@@ -107,6 +108,9 @@ Remap_grid_class::Remap_grid_class(const char *grid_name,
         else if (words_are_the_same(cyclic_or_acyclic, COORD_BOUND_ACYCLIC))
             this->cyclic = false;
         else EXECUTION_REPORT(REPORT_ERROR, -1, false, "the cyclic label for coordinate lon must be \"cyclic\" or \"acyclic\"\n");
+
+	if (get_is_sphere_grid())
+		EXECUTION_REPORT_LOG(REPORT_LOG, -1, true, "Allocate H2D grid \"%s\" with size %ld", grid_name, grid_size);
 }
 
 
@@ -157,6 +161,9 @@ Remap_grid_class::Remap_grid_class(const char *grid_name,
 
     for (i = 0; i < num_leaf_grids; i ++)
         leaf_grids[i]->check_and_set_first_super_grid_of_enable_setting_coord_value(this);
+
+	if (get_is_sphere_grid())
+		EXECUTION_REPORT_LOG(REPORT_LOG, -1, true, "Allocate H2D grid \"%s\" with size %ld", grid_name, grid_size);
 }
 
 
@@ -186,7 +193,7 @@ Remap_grid_class::Remap_grid_class(Remap_grid_class *field_data_grid,
     this->num_dimensions = num_leaf_grids_field_data;
     this->grid_size = field_data_grid->grid_size / remap_src_grid->grid_size * remap_dst_grid->grid_size;
     this->enable_to_set_coord_values = false;
-    sprintf(this->grid_name, "TEMP_GRID_FIELD_DATA_DST %s from %s to %s\0", field_data_grid->grid_name, remap_src_grid->grid_name, remap_dst_grid->grid_name);
+    sprintf(this->grid_name, "REMAP_DST %s from %s to %s\0", field_data_grid->grid_name, remap_src_grid->grid_name, remap_dst_grid->grid_name);
     for (i = 0; i < num_leaf_grids_field_data; i ++)
         sub_grids.push_back(leaf_grids_field_data[i]);
     get_sized_sub_grids(&num_sized_grids_field_data, sized_grids_field_data);
@@ -194,8 +201,11 @@ Remap_grid_class::Remap_grid_class(Remap_grid_class *field_data_grid,
     for (i = 0; i < num_sized_grids_field_data; i ++)
         sub_grids.push_back(sized_grids_field_data[i]);
 
-	if (is_sigma_grid())
-		allocate_sigma_grid_specific_fields(NULL, NULL, NULL, 0, 0);
+    if (is_sigma_grid())
+        allocate_sigma_grid_specific_fields(NULL, NULL, NULL, 0, 0);
+
+	if (get_is_sphere_grid())
+		EXECUTION_REPORT_LOG(REPORT_LOG, -1, true, "Allocate H2D grid \"%s\" with size %ld", grid_name, grid_size);
 }
 
 
@@ -214,12 +224,15 @@ Remap_grid_class::Remap_grid_class(const char *grid_name, const char *whole_grid
     this->enable_to_set_coord_values = false;
     this->num_dimensions = whole_grid->num_dimensions;
     this->grid_size = whole_grid->grid_size;    
-	whole_grid->end_grid_definition_stage(NULL);
+    whole_grid->end_grid_definition_stage(NULL);
 }
 
 
 Remap_grid_class::~Remap_grid_class()
 {
+	if (get_is_sphere_grid())
+		EXECUTION_REPORT_LOG(REPORT_LOG, -1, true, "Deallocate H2D grid \"%s\" with size %ld", grid_name, grid_size);
+
     for (int i = 0; i < grid_center_fields.size(); i ++)
         delete grid_center_fields[i];
     for (int i = 0; i < grid_vertex_fields.size(); i ++)
@@ -240,14 +253,14 @@ Remap_grid_class::~Remap_grid_class()
     if (area_or_volumn != NULL)
         delete [] area_or_volumn;
 
-	if (sigma_grid_sigma_value_field != NULL)
-		delete sigma_grid_sigma_value_field;
+    if (sigma_grid_sigma_value_field != NULL)
+        delete sigma_grid_sigma_value_field;
 
-	if (hybrid_grid_coefficient_field != NULL)
-		delete hybrid_grid_coefficient_field;
+    if (hybrid_grid_coefficient_field != NULL)
+        delete hybrid_grid_coefficient_field;
 
-	if (sigma_grid_surface_value_field != NULL)
-		delete sigma_grid_surface_value_field;
+    if (level_V3D_coord_trigger_field != NULL)
+        delete level_V3D_coord_trigger_field;
 }
 
 
@@ -273,8 +286,8 @@ void Remap_grid_class::generate_interchange_grids(Remap_grid_class *remap_grid,
     Remap_grid_class *leaf_grids_remap[256];    
     int num_size_grids_this, num_size_grids_remap, num_size_grids_interchange;
     Remap_grid_class *size_grids_this[256], *size_grids_remap[256], *size_grids_interchange[256];   
-	Remap_grid_class *existing_grid;
-	char new_grid_name[256];
+    Remap_grid_class *existing_grid;
+    char new_grid_name[256];
     int i, j, k;
 
 
@@ -313,17 +326,21 @@ void Remap_grid_class::generate_interchange_grids(Remap_grid_class *remap_grid,
             size_grids_interchange[num_size_grids_interchange++] = size_grids_this[i];
     }
 
-	sprintf(new_grid_name, "%s", "TEMP_GRID_INTERCHANGE");
-	for (i = 0; i < num_size_grids_interchange; i ++)
-		sprintf(new_grid_name, "%s_%s", new_grid_name, size_grids_interchange[i]->get_grid_name());
-    *interchange_grid = new Remap_grid_class(new_grid_name, num_size_grids_interchange, size_grids_interchange, 0);
-	existing_grid = remap_grid_manager->search_same_remap_grid(*interchange_grid);
-	if (existing_grid != NULL) {
-		delete *interchange_grid;
-		*interchange_grid = existing_grid;
-	}
-	else remap_grid_manager->add_temp_grid(*interchange_grid);
-	
+    *interchange_grid = new Remap_grid_class(grid_name, num_size_grids_interchange, size_grids_interchange, 0);
+    existing_grid = remap_grid_manager->search_same_remap_grid(*interchange_grid);
+    if (existing_grid != NULL) {
+        delete *interchange_grid;
+        *interchange_grid = existing_grid;
+    }
+    else {
+		remap_grid_manager->add_temp_grid(*interchange_grid);
+		sprintf(new_grid_name, "%s_INTERCHANGE", grid_name);
+		(*interchange_grid)->get_leaf_grids(&num_leaf_grids_remap, leaf_grids_remap, *interchange_grid);
+		for (i = 0; i < num_leaf_grids_remap; i ++)
+			sprintf(new_grid_name, "%s_%s", new_grid_name, leaf_grids_remap[i]->get_coord_label());
+		strcpy((*interchange_grid)->grid_name, new_grid_name);
+    }
+    
     EXECUTION_REPORT(REPORT_ERROR, -1, this->is_similar_grid_with(*interchange_grid), "remap software error2 when generating interchange grids\n");
 }
 
@@ -369,7 +386,7 @@ Remap_grid_class *Remap_grid_class::duplicate_grid(Remap_grid_class *top_grid)
     duplicated_grid = new Remap_grid_class;
     duplicated_grid->initialize_grid_class_data();
     duplicated_grid->original_grid = this;
-	duplicated_grid->generated_from_duplication = true;
+    duplicated_grid->generated_from_duplication = true;
     this->duplicated_grid = duplicated_grid;
     for (i = 0; i < this->sub_grids.size(); i ++)
         duplicated_grid->sub_grids.push_back(this->sub_grids[i]->duplicate_grid(top_grid));
@@ -385,17 +402,18 @@ Remap_grid_class *Remap_grid_class::duplicate_grid(Remap_grid_class *top_grid)
     duplicated_grid->super_grid_of_setting_coord_values = this->super_grid_of_setting_coord_values;
     duplicated_grid->enable_to_set_coord_values = false;
     duplicated_grid->are_vertex_values_set_in_default = this->are_vertex_values_set_in_default;
-	duplicated_grid->sigma_grid_scale_factor = this->sigma_grid_scale_factor;
-	duplicated_grid->sigma_grid_top_value = this->sigma_grid_top_value;
-	duplicated_grid->boundary_min_lon = this->boundary_min_lon;
-	duplicated_grid->boundary_max_lon = this->boundary_max_lon;
-	duplicated_grid->boundary_min_lat = this->boundary_min_lat;
-	duplicated_grid->boundary_max_lat = this->boundary_max_lat;
-	duplicated_grid->whole_grid = this->whole_grid;
-	if (this->sigma_grid_sigma_value_field != NULL)
-		duplicated_grid->sigma_grid_sigma_value_field = this->sigma_grid_sigma_value_field->duplicate_grid_data_field(duplicated_grid, 1, true, true);
-	if (this->hybrid_grid_coefficient_field != NULL)
-		duplicated_grid->hybrid_grid_coefficient_field = this->hybrid_grid_coefficient_field->duplicate_grid_data_field(duplicated_grid, 1, true, true);
+    duplicated_grid->sigma_grid_scale_factor = this->sigma_grid_scale_factor;
+    duplicated_grid->sigma_grid_top_value = this->sigma_grid_top_value;
+    duplicated_grid->boundary_min_lon = this->boundary_min_lon;
+    duplicated_grid->boundary_max_lon = this->boundary_max_lon;
+    duplicated_grid->boundary_min_lat = this->boundary_min_lat;
+    duplicated_grid->boundary_max_lat = this->boundary_max_lat;
+    duplicated_grid->whole_grid = this->whole_grid;
+	duplicated_grid->using_V3D_level_coord = this->using_V3D_level_coord;
+    if (this->sigma_grid_sigma_value_field != NULL)
+        duplicated_grid->sigma_grid_sigma_value_field = this->sigma_grid_sigma_value_field->duplicate_grid_data_field(duplicated_grid, 1, true, true);
+    if (this->hybrid_grid_coefficient_field != NULL)
+        duplicated_grid->hybrid_grid_coefficient_field = this->hybrid_grid_coefficient_field->duplicate_grid_data_field(duplicated_grid, 1, true, true);
     if (this->redundant_cell_mark_field != NULL) {
         duplicated_grid->redundant_cell_mark_field = this->redundant_cell_mark_field->duplicate_grid_data_field(this, 1, true, true);
         duplicated_grid->redundant_cell_mark = (bool *) duplicated_grid->redundant_cell_mark_field->grid_data_field->data_buf;
@@ -415,13 +433,16 @@ Remap_grid_class *Remap_grid_class::duplicate_grid(Remap_grid_class *top_grid)
     }
 
     /* duplicate grid center and vertex data fields */
-	for (int i = 0; i < grid_center_fields.size(); i ++)
-		duplicated_grid->grid_center_fields.push_back(grid_center_fields[i]->duplicate_grid_data_field(duplicated_grid, 1, true, true));
-	for (int i = 0; i < grid_vertex_fields.size(); i ++)
-		duplicated_grid->grid_vertex_fields.push_back(grid_vertex_fields[i]->duplicate_grid_data_field(duplicated_grid, this->num_vertexes, true, true));
-	
+    for (int i = 0; i < grid_center_fields.size(); i ++)
+        duplicated_grid->grid_center_fields.push_back(grid_center_fields[i]->duplicate_grid_data_field(duplicated_grid, 1, true, true));
+    for (int i = 0; i < grid_vertex_fields.size(); i ++)
+        duplicated_grid->grid_vertex_fields.push_back(grid_vertex_fields[i]->duplicate_grid_data_field(duplicated_grid, this->num_vertexes, true, true));
+    
     this->duplicated_grid = NULL;
 
+	if (get_is_sphere_grid())
+		EXECUTION_REPORT_LOG(REPORT_LOG, -1, true, "Allocate H2D grid \"%s\" with size %ld from the grid \"%s\"", duplicated_grid->grid_name, grid_size, grid_name);
+
     return duplicated_grid;
 }
 
@@ -434,7 +455,7 @@ Remap_grid_class *Remap_grid_class::generate_remap_operator_runtime_grid(Remap_g
     long i;
     int num_leaf_grids;
     Remap_grid_class *leaf_grids[256], *super_grid, *runtime_remap_grid;
-    Remap_grid_data_class *center_value_field, *vertex_value_field, *duplicated_grid_data;
+    Remap_grid_data_class *vertex_value_field, *duplicated_grid_data;
     Remap_data_field *mask_data_field;
 
 
@@ -447,44 +468,63 @@ Remap_grid_class *Remap_grid_class::generate_remap_operator_runtime_grid(Remap_g
 
     runtime_remap_grid->get_leaf_grids(&num_leaf_grids, leaf_grids, runtime_remap_grid);
     for (i = 0; i < num_leaf_grids; i ++) {
-		if (leaf_grids[i]->has_grid_coord_label(COORD_LABEL_LEV) && leaf_grids[i]->get_sigma_grid_sigma_value_field() != NULL) {
-			center_value_field = leaf_grids[i]->get_sigma_grid_sigma_value_field();
-			leaf_grids[i]->num_vertexes = 2;
-			leaf_grids[i]->grid_center_fields.push_back(center_value_field->duplicate_grid_data_field(remap_grid, 1, false, false));
-			leaf_grids[i]->grid_vertex_fields.push_back(center_value_field->duplicate_grid_data_field(remap_grid, leaf_grids[i]->num_vertexes, false, false));
-		}
-		else {
-	        super_grid = leaf_grids[i]->super_grid_of_setting_coord_values;
-	        EXECUTION_REPORT(REPORT_ERROR, -1, super_grid != NULL && super_grid->is_subset_of_grid(runtime_remap_grid), "remap software error2 in generate_remap_operator_runtime_grid\n");
-		}
+        if (leaf_grids[i]->has_grid_coord_label(COORD_LABEL_LEV) && (leaf_grids[i]->get_sigma_grid_sigma_value_field() != NULL || leaf_grids[i]->does_use_V3D_level_coord())) {
+			if (leaf_grids[i]->grid_center_fields.size() > 0)
+				continue;
+			leaf_grids[i]->allocate_default_center_field();				
+            leaf_grids[i]->num_vertexes = 2;
+			for (int j = 0; j < leaf_grids[i]->grid_size; j ++)
+				 ((double*)leaf_grids[i]->grid_center_fields[0]->get_grid_data_field()->data_buf)[j] = j % 2 + 1;
+            leaf_grids[i]->grid_vertex_fields.push_back(leaf_grids[i]->grid_center_fields[0]->duplicate_grid_data_field(remap_grid, leaf_grids[i]->num_vertexes, false, false));
+        }
+        else {
+            super_grid = leaf_grids[i]->super_grid_of_setting_coord_values;
+            EXECUTION_REPORT_ERROR_OPTIONALLY(REPORT_ERROR, -1, super_grid != NULL && super_grid->is_subset_of_grid(runtime_remap_grid), "remap software error2 in generate_remap_operator_runtime_grid \"%s\"   \"%s\" %lx  \"%s\"\n", grid_name, leaf_grids[i]->get_grid_name(), leaf_grids[i], super_grid->get_grid_name());
+        }
     }
 
     if (runtime_mask != NULL) {
-        if (runtime_mask->get_coord_value_grid()->is_similar_grid_with(remap_grid)) 
+        if (runtime_mask->get_coord_value_grid()->is_similar_grid_with(remap_grid)) {
             runtime_remap_grid->grid_mask_field = runtime_mask->duplicate_grid_data_field(remap_grid, 1, true, true);
-        else {
+			EXECUTION_REPORT_LOG(REPORT_LOG, -1, true, "The runtime remap grid \"%s\" directly uses the runtime_mask when remapping the field with grid \"%s\"", runtime_remap_grid->get_grid_name(), grid_name);
+        }
+        else if (runtime_mask->get_coord_value_grid()->have_overlap_with_grid(remap_grid)) {
+			EXECUTION_REPORT(REPORT_ERROR, -1, remap_grid->is_subset_of_grid(runtime_mask->get_coord_value_grid()), "software error in generate_remap_operator_runtime_grid");
             runtime_remap_grid->original_grid_mask_field = runtime_mask;
             runtime_mask->interchange_grid_data(this);
             runtime_remap_grid->grid_mask_field = runtime_mask->duplicate_grid_data_field(remap_grid, 1, false, false);
+			EXECUTION_REPORT_LOG(REPORT_LOG, -1, true, "The runtime remap grid \"%s\" uses a super runtime_mask when remapping the field with grid \"%s\"", runtime_remap_grid->get_grid_name(), grid_name);
         }
-    }
-
-    if (runtime_remap_grid->redundant_cell_mark_field == NULL) {
-        mask_data_field = new Remap_data_field;
-        strcpy(mask_data_field->data_type_in_application, DATA_TYPE_BOOL);
-        mask_data_field->required_data_size = runtime_remap_grid->grid_size;    
-        mask_data_field->read_data_size = runtime_remap_grid->grid_size;
-        mask_data_field->data_buf = new char [mask_data_field->required_data_size];
-        runtime_remap_grid->redundant_cell_mark_field = new Remap_grid_data_class(runtime_remap_grid, mask_data_field);
-        runtime_remap_grid->redundant_cell_mark = (bool*) mask_data_field->data_buf;
-        for (i = 0; i < runtime_remap_grid->grid_size; i ++)
-            runtime_remap_grid->redundant_cell_mark[i] = false;
+		else {			
+			EXECUTION_REPORT_LOG(REPORT_LOG, -1, true, "The runtime remap grid \"%s\" uses a outer runtime_mask when remapping the field with grid \"%s\"", runtime_remap_grid->get_grid_name(), grid_name);
+			runtime_mask->interchange_grid_data(this);
+		}
     }
 
     return runtime_remap_grid;
 }
 
 
+void Remap_grid_class::allocate_default_center_field()
+{
+	Remap_data_field *remap_data_field;
+
+	
+	EXECUTION_REPORT_ERROR_OPTIONALLY(REPORT_ERROR, -1, num_dimensions == 1 && grid_center_fields.size() == 0, "Software error in Remap_grid_class::allocate_default_center_field");
+
+	remap_data_field = new Remap_data_field;	
+	strcpy(remap_data_field->field_name_in_application, coord_label);
+	strcpy(remap_data_field->field_name_in_IO_file, coord_label);
+	strcpy(remap_data_field->field_name_in_IO_file, coord_label);
+	strcpy(remap_data_field->data_type_in_application, DATA_TYPE_DOUBLE);
+	strcpy(remap_data_field->data_type_in_IO_file, DATA_TYPE_DOUBLE);
+	remap_data_field->required_data_size = remap_data_field->read_data_size = grid_size;
+	remap_data_field->data_buf = new double [grid_size];
+	remap_data_field->set_field_unit(coord_unit);
+	grid_center_fields.push_back(new Remap_grid_data_class(this, remap_data_field));
+}
+
+
 void Remap_grid_class::read_grid_data_through_span(char extension_names[16][256], 
                                                   const char *bound_start, 
                                                   const char *bound_end, 
@@ -778,288 +818,305 @@ void Remap_grid_class::gen_lev_coord_from_sigma_or_hybrid(char extension_names[1
                  lev_coord_bot_str, this->grid_name);
     EXECUTION_REPORT(REPORT_ERROR, -1, lev_sigma_coord->get_grid_data_field()->required_data_size == lev_leaf_grid->grid_size,
                  "the size of field %s must be the same with 1D level subgrid of grid %s\n", lev_sigma_coord_str, this->grid_name);
-	EXECUTION_REPORT(REPORT_ERROR, -1, lev_leaf_grid->grid_size >= 3, "the level subgrid %s of grid %s must have at least 3 levels. Please check.", lev_leaf_grid->get_grid_name(), this->get_grid_name());
+    EXECUTION_REPORT(REPORT_ERROR, -1, lev_leaf_grid->grid_size >= 3, "the level subgrid %s of grid %s must have at least 3 levels. Please check.", lev_leaf_grid->get_grid_name(), this->get_grid_name());
     EXECUTION_REPORT(REPORT_ERROR, -1, field_lev_coord_bot->have_data_content(), "the data value of field %s has not been set\n", lev_coord_bot_str);
 
-	lev_sigma_coord_values = (double*)lev_sigma_coord->get_grid_data_field()->data_buf;
-	for (i = 1; i < lev_leaf_grid->grid_size; i ++) {
-		if (lev_sigma_coord_values[i-1] < lev_sigma_coord_values[i]) {
-			ascending_order = true;
-			break;
-		}
-		if (lev_sigma_coord_values[i-1] > lev_sigma_coord_values[i]) {
-			ascending_order = false;
-			break;
-		}
-	}
-	EXECUTION_REPORT(REPORT_ERROR, -1, i < lev_leaf_grid->grid_size, "All sigma values in field %s for grid %s are the same. Please check.", lev_sigma_coord_str, grid_name);
-	for (i = 1; i < lev_leaf_grid->grid_size; i ++)
-		if (ascending_order)
-			EXECUTION_REPORT(REPORT_ERROR, -1, (ascending_order && (lev_sigma_coord_values[i-1] <= lev_sigma_coord_values[i])) || (!ascending_order && (lev_sigma_coord_values[i-1] >= lev_sigma_coord_values[i])), 
-			"sigma values in field %s for grid %s must be in ascending order or descending order. Please check.", lev_sigma_coord_str, grid_name);
-
-	if (hybrid_grid_coefficient_str != NULL) {
-		hybrid_grid_coefficient = remap_field_data_manager->search_remap_field_data(hybrid_grid_coefficient_str);
-		EXECUTION_REPORT(REPORT_ERROR, -1, hybrid_grid_coefficient->get_grid_data_field()->required_data_size == lev_leaf_grid->get_grid_size(), 
-						 "the size of field %s must be the same with 1D level subgrid of grid %s\n", hybrid_grid_coefficient_str, this->grid_name);
-	}
+    lev_sigma_coord_values = (double*)lev_sigma_coord->get_grid_data_field()->data_buf;
+    for (i = 1; i < lev_leaf_grid->grid_size; i ++) {
+        if (lev_sigma_coord_values[i-1] < lev_sigma_coord_values[i]) {
+            ascending_order = true;
+            break;
+        }
+        if (lev_sigma_coord_values[i-1] > lev_sigma_coord_values[i]) {
+            ascending_order = false;
+            break;
+        }
+    }
+    EXECUTION_REPORT(REPORT_ERROR, -1, i < lev_leaf_grid->grid_size, "All sigma values in field %s for grid %s are the same. Please check.", lev_sigma_coord_str, grid_name);
+    for (i = 1; i < lev_leaf_grid->grid_size; i ++)
+        if (ascending_order)
+            EXECUTION_REPORT(REPORT_ERROR, -1, (ascending_order && (lev_sigma_coord_values[i-1] <= lev_sigma_coord_values[i])) || (!ascending_order && (lev_sigma_coord_values[i-1] >= lev_sigma_coord_values[i])), 
+            "sigma values in field %s for grid %s must be in ascending order or descending order. Please check.", lev_sigma_coord_str, grid_name);
+
+    if (hybrid_grid_coefficient_str != NULL) {
+        hybrid_grid_coefficient = remap_field_data_manager->search_remap_field_data(hybrid_grid_coefficient_str);
+        EXECUTION_REPORT(REPORT_ERROR, -1, hybrid_grid_coefficient->get_grid_data_field()->required_data_size == lev_leaf_grid->get_grid_size(), 
+                         "the size of field %s must be the same with 1D level subgrid of grid %s\n", hybrid_grid_coefficient_str, this->grid_name);
+    }
     sscanf(lev_coord_top_str, "%lf", &data_top);
-	this->sigma_grid_surface_value_field_specified = true;
-	allocate_sigma_grid_specific_fields(hybrid_grid_coefficient, lev_sigma_coord, field_lev_coord_bot, data_top, scale_factor);
-	calculate_lev_sigma_values();
-	get_a_leaf_grid(COORD_LABEL_LEV)->super_grid_of_setting_coord_values = this;
+    this->level_V3D_coord_trigger_field_specified = true;
+    allocate_sigma_grid_specific_fields(hybrid_grid_coefficient, lev_sigma_coord, field_lev_coord_bot, data_top, scale_factor);
+    calculate_lev_sigma_values();
 }
 
 
 void Remap_grid_class::set_lev_grid_sigma_info(double top_value, const double *sigma_values, const double *hybrid_grid_coefficients, double scale_factor)
 {
-	Remap_grid_data_class *sigma_value_field = NULL, *hybrid_grid_coefficient_field = NULL;
-	Remap_data_field *remap_data_field;
+    Remap_grid_data_class *sigma_value_field = NULL, *hybrid_grid_coefficient_field = NULL;
+    Remap_data_field *remap_data_field;
 
-	
-	EXECUTION_REPORT(REPORT_ERROR, -1, num_dimensions == 1 && words_are_the_same(coord_label, COORD_LABEL_LEV), "Software error in Remap_grid_class::set_lev_grid_sigma_info: only lev grid can be set sigma information", grid_name);
-	remap_data_field = new Remap_data_field;    
-	strcpy(remap_data_field->field_name_in_application, "lev_sigma");
-	strcpy(remap_data_field->data_type_in_application, DATA_TYPE_DOUBLE);
-	strcpy(remap_data_field->data_type_in_IO_file, DATA_TYPE_DOUBLE);
-	remap_data_field->required_data_size = remap_data_field->read_data_size = grid_size;
-	remap_data_field->data_buf = new double [grid_size];
-	memcpy(remap_data_field->data_buf, sigma_values, grid_size*sizeof(double));
-	sigma_value_field = new Remap_grid_data_class(this, remap_data_field);
-	if (hybrid_grid_coefficients != NULL) {
-		strcpy(remap_data_field->field_name_in_application, "lev_hybrid_coefB");
-		remap_data_field = new Remap_data_field;	
-		strcpy(remap_data_field->field_name_in_application, "lev_hybrid_coefA");
-		strcpy(remap_data_field->data_type_in_application, DATA_TYPE_DOUBLE);
-		strcpy(remap_data_field->data_type_in_IO_file, DATA_TYPE_DOUBLE);
-		remap_data_field->required_data_size = remap_data_field->read_data_size = grid_size;
-		remap_data_field->data_buf = new double [grid_size];
-		memcpy(remap_data_field->data_buf, hybrid_grid_coefficients, grid_size*sizeof(double));
-		hybrid_grid_coefficient_field = new Remap_grid_data_class(this, remap_data_field);
-	}
-	allocate_sigma_grid_specific_fields(hybrid_grid_coefficient_field, sigma_value_field, NULL, top_value, scale_factor);
+    
+    EXECUTION_REPORT(REPORT_ERROR, -1, num_dimensions == 1 && words_are_the_same(coord_label, COORD_LABEL_LEV), "Software error in Remap_grid_class::set_lev_grid_sigma_info: only lev grid can be set sigma information", grid_name);
+    remap_data_field = new Remap_data_field;    
+    strcpy(remap_data_field->field_name_in_application, "lev_sigma");
+    strcpy(remap_data_field->data_type_in_application, DATA_TYPE_DOUBLE);
+    strcpy(remap_data_field->data_type_in_IO_file, DATA_TYPE_DOUBLE);
+    remap_data_field->required_data_size = remap_data_field->read_data_size = grid_size;
+    remap_data_field->data_buf = new double [grid_size];
+    memcpy(remap_data_field->data_buf, sigma_values, grid_size*sizeof(double));
+    sigma_value_field = new Remap_grid_data_class(this, remap_data_field);
+    if (hybrid_grid_coefficients != NULL) {
+        strcpy(remap_data_field->field_name_in_application, "lev_hybrid_coefB");
+        remap_data_field = new Remap_data_field;    
+        strcpy(remap_data_field->field_name_in_application, "lev_hybrid_coefA");
+        strcpy(remap_data_field->data_type_in_application, DATA_TYPE_DOUBLE);
+        strcpy(remap_data_field->data_type_in_IO_file, DATA_TYPE_DOUBLE);
+        remap_data_field->required_data_size = remap_data_field->read_data_size = grid_size;
+        remap_data_field->data_buf = new double [grid_size];
+        memcpy(remap_data_field->data_buf, hybrid_grid_coefficients, grid_size*sizeof(double));
+        hybrid_grid_coefficient_field = new Remap_grid_data_class(this, remap_data_field);
+    }
+    allocate_sigma_grid_specific_fields(hybrid_grid_coefficient_field, sigma_value_field, NULL, top_value, scale_factor);
 }
 
 
 void Remap_grid_class::set_lev_grid_sigma_info(const char *sigma_value_field_name, double top_value, double scale_factor, const char *hybrid_grid_coefficient_field_name)
 {
-	Remap_grid_data_class *sigma_value_field, *hybrid_grid_coefficient_field;
+    Remap_grid_data_class *sigma_value_field, *hybrid_grid_coefficient_field;
+
+    
+    EXECUTION_REPORT(REPORT_ERROR, -1, num_dimensions == 1 && words_are_the_same(coord_label, COORD_LABEL_LEV), 
+                     "Grid %s must be a 1D grid at vertical direction (the label of grid is \"lev\": only lev grid can be set sigma information", grid_name);
+    EXECUTION_REPORT(REPORT_ERROR, -1, enable_to_set_coord_values, "Grid %s has been used (for example, interpolation) before. It cannot be set with sigma information", grid_name);
+    sigma_value_field = remap_field_data_manager->search_remap_field_data(sigma_value_field_name);
+    if (hybrid_grid_coefficient_field_name != NULL) {
+        hybrid_grid_coefficient_field = remap_field_data_manager->search_remap_field_data(hybrid_grid_coefficient_field_name);
+        EXECUTION_REPORT(REPORT_ERROR, -1, hybrid_grid_coefficient_field != NULL, "C-Coupler error1 in set_lev_grid_sigma_info");
+    }
+    else hybrid_grid_coefficient_field = NULL;
+    EXECUTION_REPORT(REPORT_ERROR, -1, sigma_value_field != NULL, "C-Coupler error2 in set_lev_grid_sigma_info");
+    allocate_sigma_grid_specific_fields(hybrid_grid_coefficient_field, sigma_value_field, NULL, top_value, scale_factor);
+}
+
+
+bool Remap_grid_class::does_use_V3D_level_coord()
+{
+	if (!has_grid_coord_label(COORD_LABEL_LEV))
+		return false;
+	
+	return get_a_leaf_grid(COORD_LABEL_LEV)->using_V3D_level_coord;
+}
+
 
+void Remap_grid_class::set_using_V3D_level_coord()
+{
+	Remap_grid_class *leaf_grid = get_a_leaf_grid(COORD_LABEL_LEV);	
 	
-	EXECUTION_REPORT(REPORT_ERROR, -1, num_dimensions == 1 && words_are_the_same(coord_label, COORD_LABEL_LEV), 
-					 "Grid %s must be a 1D grid at vertical direction (the label of grid is \"lev\": only lev grid can be set sigma information", grid_name);
-	EXECUTION_REPORT(REPORT_ERROR, -1, enable_to_set_coord_values, "Grid %s has been used (for example, interpolation) before. It cannot be set with sigma information", grid_name);
-	sigma_value_field = remap_field_data_manager->search_remap_field_data(sigma_value_field_name);
-	if (hybrid_grid_coefficient_field_name != NULL) {
-		hybrid_grid_coefficient_field = remap_field_data_manager->search_remap_field_data(hybrid_grid_coefficient_field_name);
-		EXECUTION_REPORT(REPORT_ERROR, -1, hybrid_grid_coefficient_field != NULL, "C-Coupler error1 in set_lev_grid_sigma_info");
-	}
-	else hybrid_grid_coefficient_field = NULL;
-	EXECUTION_REPORT(REPORT_ERROR, -1, sigma_value_field != NULL, "C-Coupler error2 in set_lev_grid_sigma_info");
-	allocate_sigma_grid_specific_fields(hybrid_grid_coefficient_field, sigma_value_field, NULL, top_value, scale_factor);
+	EXECUTION_REPORT_ERROR_OPTIONALLY(REPORT_ERROR, -1, leaf_grid != NULL, "Software error in Remap_grid_class::set_using_V3D_level_coord");
+
+	leaf_grid->using_V3D_level_coord = true;
 }
 
 
 Remap_grid_class *Remap_grid_class::get_a_leaf_grid_of_sigma_or_hybrid()
 {
-	Remap_grid_class *leaf_grid;
+    Remap_grid_class *leaf_grid;
 
-	
-	leaf_grid = get_a_leaf_grid(COORD_LABEL_LEV);
-	if (leaf_grid->sigma_grid_sigma_value_field != NULL)
-		return leaf_grid;
+    
+    leaf_grid = get_a_leaf_grid(COORD_LABEL_LEV);
+    if (leaf_grid->sigma_grid_sigma_value_field != NULL)
+        return leaf_grid;
 
-	return NULL;
+    return NULL;
 }
 
 
 bool Remap_grid_class::is_sigma_grid()
 {
-	Remap_grid_class *leaf_grid;
+    Remap_grid_class *leaf_grid;
 
-	
-	if (num_dimensions != 3)
-		return false;
+    
+    if (num_dimensions != 3)
+        return false;
 
-	if (!has_grid_coord_label(COORD_LABEL_LON) || !has_grid_coord_label(COORD_LABEL_LAT) || !has_grid_coord_label(COORD_LABEL_LEV))
-		return false;
+    if (!has_grid_coord_label(COORD_LABEL_LON) || !has_grid_coord_label(COORD_LABEL_LAT) || !has_grid_coord_label(COORD_LABEL_LEV))
+        return false;
 
-	if (get_a_leaf_grid_of_sigma_or_hybrid() != NULL)
-		return true;
+    if (get_a_leaf_grid_of_sigma_or_hybrid() != NULL)
+        return true;
 
-	return false;
+    return false;
 }
 
 
-bool Remap_grid_class::is_sigma_grid_surface_value_field_updated()
+bool Remap_grid_class::is_level_V3D_coord_trigger_field_updated()
 {
-	bool result = false;
-	
+    bool result = false;
+    
 
-	EXECUTION_REPORT_ERROR_OPTIONALLY(REPORT_ERROR, -1, this->is_sigma_grid() && sigma_grid_dynamic_surface_value_field != NULL && sigma_grid_surface_value_field != NULL, "C-Coupler error1 in Remap_grid_class::is_sigma_grid_surface_value_field_updated: \"%s\" at %lx", this->grid_name, (char*)this); 
-	EXECUTION_REPORT_ERROR_OPTIONALLY(REPORT_ERROR, -1, sigma_grid_dynamic_surface_value_field->get_grid_data_field()->required_data_size == sigma_grid_surface_value_field->get_grid_data_field()->required_data_size, "C-Coupler error1 in Remap_grid_class::is_sigma_grid_surface_value_field_updated");
-	EXECUTION_REPORT_ERROR_OPTIONALLY(REPORT_ERROR, -1, words_are_the_same(sigma_grid_surface_value_field->get_grid_data_field()->data_type_in_application, DATA_TYPE_DOUBLE), "C-Coupler error in Remap_grid_class::is_sigma_grid_surface_value_field_updated: wrong data type");
-	
-	if (words_are_the_same(sigma_grid_dynamic_surface_value_field->get_grid_data_field()->data_type_in_application, DATA_TYPE_FLOAT)) {
-		for (int i = 0; i < sigma_grid_dynamic_surface_value_field->get_grid_data_field()->required_data_size; i ++) {
-			if (!sigma_grid_surface_value_field_specified || ((float*) sigma_grid_dynamic_surface_value_field->get_grid_data_field()->data_buf)[i] != ((double*) sigma_grid_surface_value_field->get_grid_data_field()->data_buf)[i])
-				result = true;
-			((double*) sigma_grid_surface_value_field->get_grid_data_field()->data_buf)[i] = ((float*) sigma_grid_dynamic_surface_value_field->get_grid_data_field()->data_buf)[i];
-		}
-	}
-	else {
-		for (int i = 0; i < sigma_grid_dynamic_surface_value_field->get_grid_data_field()->required_data_size; i ++) {
-			if (!sigma_grid_surface_value_field_specified || ((double*) sigma_grid_dynamic_surface_value_field->get_grid_data_field()->data_buf)[i] != ((double*) sigma_grid_surface_value_field->get_grid_data_field()->data_buf)[i])
-				result = true;
-			((double*) sigma_grid_surface_value_field->get_grid_data_field()->data_buf)[i] = ((double*) sigma_grid_dynamic_surface_value_field->get_grid_data_field()->data_buf)[i];
-		}
-	}
+    EXECUTION_REPORT_ERROR_OPTIONALLY(REPORT_ERROR, -1, (this->is_sigma_grid() || this->does_use_V3D_level_coord()) && level_V3D_coord_dynamic_trigger_field != NULL && level_V3D_coord_trigger_field != NULL, "C-Coupler error1 in Remap_grid_class::is_level_V3D_coord_trigger_field_updated: \"%s\" at %lx", this->grid_name, (char*)this); 
+    EXECUTION_REPORT_ERROR_OPTIONALLY(REPORT_ERROR, -1, level_V3D_coord_dynamic_trigger_field->get_grid_data_field()->required_data_size == level_V3D_coord_trigger_field->get_grid_data_field()->required_data_size, "C-Coupler error1 in Remap_grid_class::is_level_V3D_coord_trigger_field_updated");
+    EXECUTION_REPORT_ERROR_OPTIONALLY(REPORT_ERROR, -1, words_are_the_same(level_V3D_coord_trigger_field->get_grid_data_field()->data_type_in_application, DATA_TYPE_DOUBLE), "C-Coupler error in Remap_grid_class::is_level_V3D_coord_trigger_field_updated: wrong data type");
+    
+    if (words_are_the_same(level_V3D_coord_dynamic_trigger_field->get_grid_data_field()->data_type_in_application, DATA_TYPE_FLOAT)) {
+        for (int i = 0; i < level_V3D_coord_dynamic_trigger_field->get_grid_data_field()->required_data_size; i ++) {
+            if (!level_V3D_coord_trigger_field_specified || ((float*) level_V3D_coord_dynamic_trigger_field->get_grid_data_field()->data_buf)[i] != ((double*) level_V3D_coord_trigger_field->get_grid_data_field()->data_buf)[i])
+                result = true;
+            ((double*) level_V3D_coord_trigger_field->get_grid_data_field()->data_buf)[i] = ((float*) level_V3D_coord_dynamic_trigger_field->get_grid_data_field()->data_buf)[i];
+        }
+    }
+    else {
+        for (int i = 0; i < level_V3D_coord_dynamic_trigger_field->get_grid_data_field()->required_data_size; i ++) {
+            if (!level_V3D_coord_trigger_field_specified || ((double*) level_V3D_coord_dynamic_trigger_field->get_grid_data_field()->data_buf)[i] != ((double*) level_V3D_coord_trigger_field->get_grid_data_field()->data_buf)[i])
+                result = true;
+            ((double*) level_V3D_coord_trigger_field->get_grid_data_field()->data_buf)[i] = ((double*) level_V3D_coord_dynamic_trigger_field->get_grid_data_field()->data_buf)[i];
+        }
+    }
 
-	sigma_grid_surface_value_field_specified = true;
+    level_V3D_coord_trigger_field_specified = true;
 
-	if (result)
-		EXECUTION_REPORT_LOG(REPORT_LOG, -1, true, "surface field for sigma grid %s has been updated", grid_name);
-	
-	return result;
+    if (result)
+        EXECUTION_REPORT_LOG(REPORT_LOG, -1, true, "surface field for sigma grid %s has been updated", grid_name);
+    
+    return result;
 }
 
 
-void Remap_grid_class::set_sigma_grid_dynamic_surface_value_field(Remap_grid_data_class *value_field)
+void Remap_grid_class::set_level_V3D_coord_dynamic_trigger_field(Remap_grid_data_class *value_field)
 {
-	EXECUTION_REPORT(REPORT_ERROR, -1, this->is_sigma_grid(), "C-Coupler error1 in Remap_grid_class::set_sigma_grid_dynamic_surface_value_field");
-	EXECUTION_REPORT(REPORT_ERROR, -1, value_field->get_coord_value_grid()->is_subset_of_grid(this), "C-Coupler error2 in Remap_grid_class::set_sigma_grid_dynamic_surface_value_field");
-	EXECUTION_REPORT(REPORT_ERROR, -1, sigma_grid_dynamic_surface_value_field == NULL, "The surface field of grid %s has been specified by the models before. Please check.", grid_name);
+    EXECUTION_REPORT(REPORT_ERROR, -1, this->is_sigma_grid() || this->does_use_V3D_level_coord(), "C-Coupler error1 in Remap_grid_class::set_level_V3D_coord_dynamic_trigger_field");
+    EXECUTION_REPORT(REPORT_ERROR, -1, value_field->get_coord_value_grid()->is_subset_of_grid(this), "C-Coupler error2 in Remap_grid_class::set_level_V3D_coord_dynamic_trigger_field");
+    EXECUTION_REPORT(REPORT_ERROR, -1, level_V3D_coord_dynamic_trigger_field == NULL, "The surface field of grid %s has been specified by the models before. Please check.", grid_name);
 
-	sigma_grid_dynamic_surface_value_field = value_field;
-	if (sigma_grid_surface_value_field == NULL)
-		sigma_grid_surface_value_field = value_field->duplicate_grid_data_field(value_field->get_coord_value_grid(), 1, false, true);
-	EXECUTION_REPORT(REPORT_ERROR, -1, sigma_grid_surface_value_field->get_grid_data_field()->required_data_size == sigma_grid_dynamic_surface_value_field->get_grid_data_field()->required_data_size, "C-Coupler error in Remap_grid_class::set_sigma_grid_dynamic_surface_value_field: wrong field size");
-	if (words_are_the_same(sigma_grid_surface_value_field->get_grid_data_field()->data_type_in_application, DATA_TYPE_FLOAT)) {
-		strcpy(sigma_grid_surface_value_field->get_grid_data_field()->data_type_in_application, DATA_TYPE_DOUBLE);
-		strcpy(sigma_grid_surface_value_field->get_grid_data_field()->data_type_in_IO_file, DATA_TYPE_DOUBLE);
-		delete [] sigma_grid_surface_value_field->get_grid_data_field()->data_buf;
-		sigma_grid_surface_value_field->get_grid_data_field()->data_buf = new double [sigma_grid_surface_value_field->get_grid_data_field()->required_data_size];
-	}
-	if (grid_center_fields.size() == 0) {
-		grid_center_fields.push_back(sigma_grid_surface_value_field->duplicate_grid_data_field(this, 1, false, false));
-		strcpy(grid_center_fields[0]->get_grid_data_field()->field_name_in_application, COORD_LABEL_LEV);
-		strcpy(grid_center_fields[0]->get_grid_data_field()->field_name_in_IO_file, COORD_LABEL_LEV);
-	}
+    level_V3D_coord_dynamic_trigger_field = value_field;
+    if (level_V3D_coord_trigger_field == NULL)
+        level_V3D_coord_trigger_field = value_field->duplicate_grid_data_field(value_field->get_coord_value_grid(), 1, false, true);
+    EXECUTION_REPORT(REPORT_ERROR, -1, level_V3D_coord_trigger_field->get_grid_data_field()->required_data_size == level_V3D_coord_dynamic_trigger_field->get_grid_data_field()->required_data_size, "C-Coupler error in Remap_grid_class::set_level_V3D_coord_dynamic_trigger_field: wrong field size");
+    if (words_are_the_same(level_V3D_coord_trigger_field->get_grid_data_field()->data_type_in_application, DATA_TYPE_FLOAT)) {
+        strcpy(level_V3D_coord_trigger_field->get_grid_data_field()->data_type_in_application, DATA_TYPE_DOUBLE);
+        strcpy(level_V3D_coord_trigger_field->get_grid_data_field()->data_type_in_IO_file, DATA_TYPE_DOUBLE);
+        delete [] level_V3D_coord_trigger_field->get_grid_data_field()->data_buf;
+        level_V3D_coord_trigger_field->get_grid_data_field()->data_buf = new double [level_V3D_coord_trigger_field->get_grid_data_field()->required_data_size];
+    }
+    if (grid_center_fields.size() == 0) {
+        grid_center_fields.push_back(level_V3D_coord_trigger_field->duplicate_grid_data_field(this, 1, false, false));
+        strcpy(grid_center_fields[0]->get_grid_data_field()->field_name_in_application, COORD_LABEL_LEV);
+        strcpy(grid_center_fields[0]->get_grid_data_field()->field_name_in_IO_file, COORD_LABEL_LEV);
+    }
 }
 
 
-void Remap_grid_class::allocate_sigma_grid_specific_fields(Remap_grid_data_class *hybrid_grid_coefficient_field, Remap_grid_data_class *sigma_grid_sigma_value_field, Remap_grid_data_class *sigma_grid_surface_value_field, double data_top, double scale_factor)
+void Remap_grid_class::allocate_sigma_grid_specific_fields(Remap_grid_data_class *hybrid_grid_coefficient_field, Remap_grid_data_class *sigma_grid_sigma_value_field, Remap_grid_data_class *level_V3D_coord_trigger_field, double data_top, double scale_factor)
 {
-	int num_sized_sub_grids, i, j;
-	Remap_grid_class *sized_sub_grids[256];
-	Remap_grid_class *sphere_grid, *existing_grid;
+    int num_sized_sub_grids, i, j;
+    Remap_grid_class *sized_sub_grids[256];
+    Remap_grid_class *sphere_grid, *existing_grid;
 
 
-	if (this->sigma_grid_surface_value_field != NULL)
-		return;
+    if (this->level_V3D_coord_trigger_field != NULL)
+        return;
 
-	if (sigma_grid_sigma_value_field != NULL) {
-		EXECUTION_REPORT(REPORT_ERROR, -1, enable_to_set_coord_values && this->get_a_leaf_grid(COORD_LABEL_LEV)->enable_to_set_coord_values, "Grid %s cannot be set to a sigma grid. It may be because the grid has been used (for example, interpolation) before or its level subgrid is a level middle grid.", grid_name);
-		EXECUTION_REPORT(REPORT_ERROR, -1, this->get_a_leaf_grid(COORD_LABEL_LEV)->hybrid_grid_coefficient_field == NULL, "Hybrid coefficient of 1D grid %s has been set before", this->get_a_leaf_grid(COORD_LABEL_LEV)->get_grid_name());
-		EXECUTION_REPORT(REPORT_ERROR, -1, this->get_a_leaf_grid(COORD_LABEL_LEV)->sigma_grid_sigma_value_field == NULL, "Sigma information of 1D grid %s has been set before", this->get_a_leaf_grid(COORD_LABEL_LEV)->get_grid_name());
-		EXECUTION_REPORT(REPORT_ERROR, -1, this->get_a_leaf_grid(COORD_LABEL_LEV)->grid_center_fields.size() == 0, "1D grid %s has been set to non-sigma grid before. Therefore it cannot be set sigma information", this->get_a_leaf_grid(COORD_LABEL_LEV)->get_grid_name());
-		EXECUTION_REPORT(REPORT_ERROR, -1, this->grid_center_fields.size() == 0, "C-Coupler error5 in allocate_sigma_grid_specific_fields");
-		EXECUTION_REPORT(REPORT_ERROR, -1, sigma_grid_sigma_value_field->get_grid_data_field()->required_data_size == this->get_a_leaf_grid(COORD_LABEL_LEV)->get_grid_size(), 
-						 "The size of field %s is different from the size of grid %s. Field %s cannot be used for sigma or hybrid grid %s",
-						 sigma_grid_sigma_value_field->get_grid_data_field()->field_name_in_application, this->get_a_leaf_grid(COORD_LABEL_LEV)->get_grid_name(), sigma_grid_sigma_value_field->get_grid_data_field()->field_name_in_application);
-		this->get_a_leaf_grid(COORD_LABEL_LEV)->sigma_grid_sigma_value_field = sigma_grid_sigma_value_field->duplicate_grid_data_field(get_a_leaf_grid(COORD_LABEL_LEV), 1, true, true);
-		if (hybrid_grid_coefficient_field != NULL) {
-			EXECUTION_REPORT(REPORT_ERROR, -1, hybrid_grid_coefficient_field->get_grid_data_field()->required_data_size == this->get_a_leaf_grid(COORD_LABEL_LEV)->get_grid_size(), 
-							 "The size of field %s is different from the size of grid %s. Field %s cannot be used for sigma or hybrid grid %s",
-							 hybrid_grid_coefficient_field->get_grid_data_field()->field_name_in_application, this->get_a_leaf_grid(COORD_LABEL_LEV)->get_grid_name(), hybrid_grid_coefficient_field->get_grid_data_field()->field_name_in_application);
-			this->get_a_leaf_grid(COORD_LABEL_LEV)->hybrid_grid_coefficient_field = hybrid_grid_coefficient_field->duplicate_grid_data_field(get_a_leaf_grid(COORD_LABEL_LEV), 1, true, true);
-		}
-		if (sigma_grid_surface_value_field != NULL) {
-			this->sigma_grid_surface_value_field = sigma_grid_surface_value_field->duplicate_grid_data_field(sigma_grid_surface_value_field->get_coord_value_grid(), 1, true, true);
-			grid_center_fields.push_back(sigma_grid_sigma_value_field->duplicate_grid_data_field(this, 1, false, false));
-			strcpy(grid_center_fields[0]->get_grid_data_field()->field_name_in_application, COORD_LABEL_LEV);
-			strcpy(grid_center_fields[0]->get_grid_data_field()->field_name_in_IO_file, COORD_LABEL_LEV);
-		}
-		this->get_a_leaf_grid(COORD_LABEL_LEV)->sigma_grid_top_value = data_top;
-		this->get_a_leaf_grid(COORD_LABEL_LEV)->sigma_grid_scale_factor = scale_factor;		
-		this->get_a_leaf_grid(COORD_LABEL_LEV)->end_grid_definition_stage(NULL);
-		return;
-	}
+    if (sigma_grid_sigma_value_field != NULL) {
+        EXECUTION_REPORT(REPORT_ERROR, -1, enable_to_set_coord_values && this->get_a_leaf_grid(COORD_LABEL_LEV)->enable_to_set_coord_values, "Grid %s cannot be set to a sigma grid. It may be because the grid has been used (for example, interpolation) before or its level subgrid is a level middle grid.", grid_name);
+        EXECUTION_REPORT(REPORT_ERROR, -1, this->get_a_leaf_grid(COORD_LABEL_LEV)->hybrid_grid_coefficient_field == NULL, "Hybrid coefficient of 1D grid %s has been set before", this->get_a_leaf_grid(COORD_LABEL_LEV)->get_grid_name());
+        EXECUTION_REPORT(REPORT_ERROR, -1, this->get_a_leaf_grid(COORD_LABEL_LEV)->sigma_grid_sigma_value_field == NULL, "Sigma information of 1D grid %s has been set before", this->get_a_leaf_grid(COORD_LABEL_LEV)->get_grid_name());
+        EXECUTION_REPORT(REPORT_ERROR, -1, this->get_a_leaf_grid(COORD_LABEL_LEV)->grid_center_fields.size() == 0, "1D grid %s has been set to non-sigma grid before. Therefore it cannot be set sigma information", this->get_a_leaf_grid(COORD_LABEL_LEV)->get_grid_name());
+        EXECUTION_REPORT(REPORT_ERROR, -1, this->grid_center_fields.size() == 0, "C-Coupler error5 in allocate_sigma_grid_specific_fields");
+        EXECUTION_REPORT(REPORT_ERROR, -1, sigma_grid_sigma_value_field->get_grid_data_field()->required_data_size == this->get_a_leaf_grid(COORD_LABEL_LEV)->get_grid_size(), 
+                         "The size of field %s is different from the size of grid %s. Field %s cannot be used for sigma or hybrid grid %s",
+                         sigma_grid_sigma_value_field->get_grid_data_field()->field_name_in_application, this->get_a_leaf_grid(COORD_LABEL_LEV)->get_grid_name(), sigma_grid_sigma_value_field->get_grid_data_field()->field_name_in_application);
+        this->get_a_leaf_grid(COORD_LABEL_LEV)->sigma_grid_sigma_value_field = sigma_grid_sigma_value_field->duplicate_grid_data_field(get_a_leaf_grid(COORD_LABEL_LEV), 1, true, true);
+        if (hybrid_grid_coefficient_field != NULL) {
+            EXECUTION_REPORT(REPORT_ERROR, -1, hybrid_grid_coefficient_field->get_grid_data_field()->required_data_size == this->get_a_leaf_grid(COORD_LABEL_LEV)->get_grid_size(), 
+                             "The size of field %s is different from the size of grid %s. Field %s cannot be used for sigma or hybrid grid %s",
+                             hybrid_grid_coefficient_field->get_grid_data_field()->field_name_in_application, this->get_a_leaf_grid(COORD_LABEL_LEV)->get_grid_name(), hybrid_grid_coefficient_field->get_grid_data_field()->field_name_in_application);
+            this->get_a_leaf_grid(COORD_LABEL_LEV)->hybrid_grid_coefficient_field = hybrid_grid_coefficient_field->duplicate_grid_data_field(get_a_leaf_grid(COORD_LABEL_LEV), 1, true, true);
+        }
+        if (level_V3D_coord_trigger_field != NULL) {
+            this->level_V3D_coord_trigger_field = level_V3D_coord_trigger_field->duplicate_grid_data_field(level_V3D_coord_trigger_field->get_coord_value_grid(), 1, true, true);
+            grid_center_fields.push_back(sigma_grid_sigma_value_field->duplicate_grid_data_field(get_a_leaf_grid(COORD_LABEL_LEV), 1, false, false));  // temp level coord value field for global grid that should not be further used
+            strcpy(grid_center_fields[0]->get_grid_data_field()->field_name_in_application, COORD_LABEL_LEV);
+            strcpy(grid_center_fields[0]->get_grid_data_field()->field_name_in_IO_file, COORD_LABEL_LEV);
+        }
+        this->get_a_leaf_grid(COORD_LABEL_LEV)->sigma_grid_top_value = data_top;
+        this->get_a_leaf_grid(COORD_LABEL_LEV)->sigma_grid_scale_factor = scale_factor;        
+        this->get_a_leaf_grid(COORD_LABEL_LEV)->end_grid_definition_stage(NULL);
+        return;
+    }
 
-	EXECUTION_REPORT_LOG(REPORT_LOG, -1, true, "Allocate sigma grid specific fields for grid %s", grid_name);
-	EXECUTION_REPORT(REPORT_ERROR, -1, is_sigma_grid(), "C-Coupler error0 in allocate_sigma_grid_specific_fields");
-		
-	get_sized_sub_grids(&num_sized_sub_grids, sized_sub_grids);
-	for (i = 0, j = 0; i < num_sized_sub_grids; i ++)
-		if (!sized_sub_grids[i]->has_grid_coord_label(COORD_LABEL_LEV))
-			sized_sub_grids[j++] = sized_sub_grids[i];
-	sphere_grid = new Remap_grid_class("sphere_grid_for_sigma_grid_surface_value_field", j, sized_sub_grids, 0);
-	existing_grid = remap_grid_manager->search_same_remap_grid(sphere_grid);
-	if (existing_grid != NULL) {
-		delete sphere_grid;
-		sphere_grid = existing_grid;
-	}
-	else remap_grid_manager->add_temp_grid(sphere_grid);
-
-	this->sigma_grid_surface_value_field = this->get_a_leaf_grid_of_sigma_or_hybrid()->sigma_grid_sigma_value_field->duplicate_grid_data_field(sphere_grid, 1, false, false);
-	strcpy(this->sigma_grid_surface_value_field->get_grid_data_field()->field_name_in_application, COORD_LABEL_LEV);
-	strcpy(this->sigma_grid_surface_value_field->get_grid_data_field()->field_name_in_IO_file, COORD_LABEL_LEV);
-
-	if (this->grid_center_fields.size() != 0)
-		EXECUTION_REPORT(REPORT_ERROR, -1, this->grid_center_fields.size() == 1, "C-Coupler error5 in allocate_sigma_grid_specific_fields");
-	else {
-		grid_center_fields.push_back(this->get_a_leaf_grid_of_sigma_or_hybrid()->get_sigma_grid_sigma_value_field()->duplicate_grid_data_field(this, 1, false, false));
-	    strcpy(grid_center_fields[0]->get_grid_data_field()->field_name_in_application, COORD_LABEL_LEV);
-		strcpy(grid_center_fields[0]->get_grid_data_field()->field_name_in_IO_file, COORD_LABEL_LEV);
-	}
+    EXECUTION_REPORT_LOG(REPORT_LOG, -1, true, "Allocate sigma grid specific fields for grid %s", grid_name);
+    EXECUTION_REPORT(REPORT_ERROR, -1, is_sigma_grid(), "C-Coupler error0 in allocate_sigma_grid_specific_fields");
+        
+    get_sized_sub_grids(&num_sized_sub_grids, sized_sub_grids);
+    for (i = 0, j = 0; i < num_sized_sub_grids; i ++)
+        if (!sized_sub_grids[i]->has_grid_coord_label(COORD_LABEL_LEV))
+            sized_sub_grids[j++] = sized_sub_grids[i];
+    sphere_grid = new Remap_grid_class("sphere_grid_for_level_V3D_coord_trigger_field", j, sized_sub_grids, 0);
+    existing_grid = remap_grid_manager->search_same_remap_grid(sphere_grid);
+    if (existing_grid != NULL) {
+        delete sphere_grid;
+        sphere_grid = existing_grid;
+    }
+    else remap_grid_manager->add_temp_grid(sphere_grid);
+
+    this->level_V3D_coord_trigger_field = this->get_a_leaf_grid_of_sigma_or_hybrid()->sigma_grid_sigma_value_field->duplicate_grid_data_field(sphere_grid, 1, false, false);
+    strcpy(this->level_V3D_coord_trigger_field->get_grid_data_field()->field_name_in_application, COORD_LABEL_LEV);
+    strcpy(this->level_V3D_coord_trigger_field->get_grid_data_field()->field_name_in_IO_file, COORD_LABEL_LEV);
+
+    if (this->grid_center_fields.size() != 0)
+        EXECUTION_REPORT(REPORT_ERROR, -1, this->grid_center_fields.size() == 1, "C-Coupler error5 in allocate_sigma_grid_specific_fields");
+    else {
+        grid_center_fields.push_back(this->get_a_leaf_grid_of_sigma_or_hybrid()->get_sigma_grid_sigma_value_field()->duplicate_grid_data_field(get_a_leaf_grid(COORD_LABEL_LEV), 1, false, false));  // temp level coord value field for global grid that should not be further used
+        strcpy(grid_center_fields[0]->get_grid_data_field()->field_name_in_application, COORD_LABEL_LEV);
+        strcpy(grid_center_fields[0]->get_grid_data_field()->field_name_in_IO_file, COORD_LABEL_LEV);
+    }
 }
 
 
 Remap_grid_data_class *Remap_grid_class::get_sigma_grid_sigma_value_field()
 {
-	return sigma_grid_sigma_value_field;
+    return sigma_grid_sigma_value_field;
 }
 
 
-void Remap_grid_class::copy_sigma_grid_surface_value_field(Remap_grid_data_class *field_copy_in)
+void Remap_grid_class::update_grid_center_3D_level_field_from_external()
 {
-	EXECUTION_REPORT(REPORT_ERROR, -1, this->sigma_grid_surface_value_field != NULL, "C-Coupler error1 in copy_sigma_grid_surface_value_field");
-	EXECUTION_REPORT(REPORT_ERROR, -1, this->sigma_grid_surface_value_field->get_coord_value_grid()->get_grid_size() == field_copy_in->get_coord_value_grid()->get_grid_size(), 
-					 "C-Coupler error2 in copy_sigma_grid_surface_value_field");
-
-	memcpy(this->sigma_grid_surface_value_field->get_grid_data_field()->data_buf, field_copy_in->get_grid_data_field()->data_buf, sigma_grid_surface_value_field->get_coord_value_grid()->get_grid_size()*sizeof(double));
+	EXECUTION_REPORT_ERROR_OPTIONALLY(REPORT_ERROR, -1, this->num_dimensions == 3 && this->does_use_V3D_level_coord() && this->grid_center_fields.size() == 1, "Software error in Remap_grid_class::update_grid_center_3D_level_field_from_external");
+	EXECUTION_REPORT_ERROR_OPTIONALLY(REPORT_ERROR, -1, get_data_type_size(level_V3D_coord_trigger_field->get_grid_data_field()->data_type_in_application) == 8 && get_data_type_size(grid_center_fields[0]->get_grid_data_field()->data_type_in_application) == 8, "Software error in Remap_grid_class::update_grid_center_3D_level_field_from_external");
+	this->grid_center_fields[0]->interchange_grid_data(level_V3D_coord_trigger_field->get_coord_value_grid());
+	memcpy(this->grid_center_fields[0]->get_grid_data_field()->data_buf, level_V3D_coord_trigger_field->get_grid_data_field()->data_buf, this->grid_center_fields[0]->get_grid_data_field()->required_data_size*get_data_type_size(level_V3D_coord_trigger_field->get_grid_data_field()->data_type_in_application));	
 }
 
 
 void Remap_grid_class::calculate_lev_sigma_values()
 {
     long i, j, lev_grid_size;
-	Remap_grid_class *leaf_grids[256], *lev_leaf_grid_of_sigma_or_hybrid, *lev_leaf_grid, *interchanged_grid;
-	double *data_grid_field, *data_array_bot, *data_array_ptr, *data_sigma, data_bot, full_ratio, *hybrid_grid_coefficient_values, *tmp_vertical_coord_values;
-	bool *horizontal_grid_mask_values;
-	double local_sigma_grid_top_value, local_sigma_grid_scale_factor;
-	
+    Remap_grid_class *leaf_grids[256], *lev_leaf_grid_of_sigma_or_hybrid, *lev_leaf_grid, *interchanged_grid;
+    double *data_grid_field, *data_array_bot, *data_array_ptr, *data_sigma, data_bot, full_ratio, *hybrid_grid_coefficient_values, *tmp_vertical_coord_values;
+    bool *horizontal_grid_mask_values;
+    double local_sigma_grid_top_value, local_sigma_grid_scale_factor;
+    
 
-	EXECUTION_REPORT_ERROR_OPTIONALLY(REPORT_ERROR, -1, this->is_sigma_grid() && this->sigma_grid_surface_value_field != NULL, "C-Coupler error2 in calculate_lev_sigma_values %s", grid_name);	
-	EXECUTION_REPORT_ERROR_OPTIONALLY(REPORT_ERROR, -1, words_are_the_same(this->sigma_grid_surface_value_field->get_grid_data_field()->data_type_in_application, DATA_TYPE_DOUBLE),  "C-Coupler error in Remap_grid_class::calculate_lev_sigma_values: wrong data type of surface field");
+    EXECUTION_REPORT_ERROR_OPTIONALLY(REPORT_ERROR, -1, this->is_sigma_grid() && this->level_V3D_coord_trigger_field != NULL, "C-Coupler error2 in calculate_lev_sigma_values %s", grid_name);    
+    EXECUTION_REPORT_ERROR_OPTIONALLY(REPORT_ERROR, -1, words_are_the_same(this->level_V3D_coord_trigger_field->get_grid_data_field()->data_type_in_application, DATA_TYPE_DOUBLE),  "C-Coupler error in Remap_grid_class::calculate_lev_sigma_values: wrong data type of surface field");
 
-	lev_leaf_grid_of_sigma_or_hybrid = get_a_leaf_grid_of_sigma_or_hybrid();
-	lev_leaf_grid = get_a_leaf_grid(COORD_LABEL_LEV);
+    lev_leaf_grid_of_sigma_or_hybrid = get_a_leaf_grid_of_sigma_or_hybrid();
+    lev_leaf_grid = get_a_leaf_grid(COORD_LABEL_LEV);
 
-	hybrid_grid_coefficient_values = NULL;
-	if (lev_leaf_grid_of_sigma_or_hybrid->hybrid_grid_coefficient_field != NULL) {
-		hybrid_grid_coefficient_values = (double*) lev_leaf_grid_of_sigma_or_hybrid->hybrid_grid_coefficient_field->get_grid_data_field()->data_buf;
-		EXECUTION_REPORT_ERROR_OPTIONALLY(REPORT_ERROR, -1, words_are_the_same(lev_leaf_grid_of_sigma_or_hybrid->hybrid_grid_coefficient_field->get_grid_data_field()->data_type_in_application, DATA_TYPE_DOUBLE),  "C-Coupler error in Remap_grid_class::calculate_lev_sigma_values: wrong data type of hybrid coefficient");
-		EXECUTION_REPORT_LOG(REPORT_LOG, -1, true, "Sigma grid \"%s\" is a hybrid grid", grid_name);
-	}
+    hybrid_grid_coefficient_values = NULL;
+    if (lev_leaf_grid_of_sigma_or_hybrid->hybrid_grid_coefficient_field != NULL) {
+        hybrid_grid_coefficient_values = (double*) lev_leaf_grid_of_sigma_or_hybrid->hybrid_grid_coefficient_field->get_grid_data_field()->data_buf;
+        EXECUTION_REPORT_ERROR_OPTIONALLY(REPORT_ERROR, -1, words_are_the_same(lev_leaf_grid_of_sigma_or_hybrid->hybrid_grid_coefficient_field->get_grid_data_field()->data_type_in_application, DATA_TYPE_DOUBLE),  "C-Coupler error in Remap_grid_class::calculate_lev_sigma_values: wrong data type of hybrid coefficient");
+        EXECUTION_REPORT_LOG(REPORT_LOG, -1, true, "Sigma grid \"%s\" is a hybrid grid", grid_name);
+    }
 
-	EXECUTION_REPORT_ERROR_OPTIONALLY(REPORT_ERROR, -1, words_are_the_same(lev_leaf_grid_of_sigma_or_hybrid->get_sigma_grid_sigma_value_field()->get_grid_data_field()->data_type_in_application, DATA_TYPE_DOUBLE),	"C-Coupler error in Remap_grid_class::calculate_lev_sigma_values: wrong data type of sigma field");
+    EXECUTION_REPORT_ERROR_OPTIONALLY(REPORT_ERROR, -1, words_are_the_same(lev_leaf_grid_of_sigma_or_hybrid->get_sigma_grid_sigma_value_field()->get_grid_data_field()->data_type_in_application, DATA_TYPE_DOUBLE),    "C-Coupler error in Remap_grid_class::calculate_lev_sigma_values: wrong data type of sigma field");
 
     full_ratio = 0;
-	data_sigma = (double*) lev_leaf_grid_of_sigma_or_hybrid->get_sigma_grid_sigma_value_field()->get_grid_data_field()->data_buf;
-	lev_grid_size = lev_leaf_grid_of_sigma_or_hybrid->get_sigma_grid_sigma_value_field()->get_coord_value_grid()->grid_size;
-	local_sigma_grid_top_value = lev_leaf_grid_of_sigma_or_hybrid->sigma_grid_top_value;
-	local_sigma_grid_scale_factor = lev_leaf_grid_of_sigma_or_hybrid->sigma_grid_scale_factor;
+    data_sigma = (double*) lev_leaf_grid_of_sigma_or_hybrid->get_sigma_grid_sigma_value_field()->get_grid_data_field()->data_buf;
+    lev_grid_size = lev_leaf_grid_of_sigma_or_hybrid->get_sigma_grid_sigma_value_field()->get_coord_value_grid()->grid_size;
+    local_sigma_grid_top_value = lev_leaf_grid_of_sigma_or_hybrid->sigma_grid_top_value;
+    local_sigma_grid_scale_factor = lev_leaf_grid_of_sigma_or_hybrid->sigma_grid_scale_factor;
     for (i = 0; i < lev_grid_size; i ++) {
         EXECUTION_REPORT(REPORT_WARNING, -1, fabs(data_sigma[i]) <= 1.0, "the sigma value in grid %s should be between 0.0 and 1.0\n", lev_leaf_grid_of_sigma_or_hybrid->get_sigma_grid_sigma_value_field()->get_coord_value_grid()->get_grid_name());
         if (fabs(data_sigma[i]) > 1.0)
@@ -1076,60 +1133,61 @@ void Remap_grid_class::calculate_lev_sigma_values()
             full_ratio = -1.0;
     }
     EXECUTION_REPORT_ERROR_OPTIONALLY(REPORT_ERROR, -1, full_ratio == 1.0 || full_ratio == -1.0, "the sigma value in grid %s must be all positive or negative", lev_leaf_grid_of_sigma_or_hybrid->get_sigma_grid_sigma_value_field()->get_coord_value_grid()->get_grid_name());
+    EXECUTION_REPORT_ERROR_OPTIONALLY(REPORT_ERROR, -1, grid_center_fields.size() == 1 && grid_center_fields[0]->grid_data_field->required_data_size == grid_size, "Software error in ");
 
     leaf_grids[0] = lev_leaf_grid;
-    leaf_grids[1] = sigma_grid_surface_value_field->get_coord_value_grid();
+    leaf_grids[1] = level_V3D_coord_trigger_field->get_coord_value_grid();
     interchanged_grid = new Remap_grid_class("TEMP_GRID_INTERCHANGE", 2, leaf_grids, 0);
     grid_center_fields[0]->interchange_grid_data(interchanged_grid);
-	delete interchanged_grid;
+    delete interchanged_grid;
     data_grid_field = (double*) grid_center_fields[0]->get_grid_data_field()->data_buf;
-    sigma_grid_surface_value_field->interchange_grid_data(sigma_grid_surface_value_field->get_coord_value_grid());
-    data_array_bot = (double*) sigma_grid_surface_value_field->get_grid_data_field()->data_buf;
-    if (sigma_grid_surface_value_field->get_coord_value_grid()->get_grid_mask_field() != NULL)
-        horizontal_grid_mask_values = (bool*) (sigma_grid_surface_value_field->get_coord_value_grid()->get_grid_mask_field()->get_grid_data_field()->data_buf);
+    level_V3D_coord_trigger_field->interchange_grid_data(level_V3D_coord_trigger_field->get_coord_value_grid());
+    data_array_bot = (double*) level_V3D_coord_trigger_field->get_grid_data_field()->data_buf;
+    if (level_V3D_coord_trigger_field->get_coord_value_grid()->get_grid_mask_field() != NULL)
+        horizontal_grid_mask_values = (bool*) (level_V3D_coord_trigger_field->get_coord_value_grid()->get_grid_mask_field()->get_grid_data_field()->data_buf);
     else horizontal_grid_mask_values = NULL;
-	tmp_vertical_coord_values = new double [lev_leaf_grid_of_sigma_or_hybrid->grid_size];
-    for (i = 0; i < sigma_grid_surface_value_field->get_coord_value_grid()->get_grid_size(); i ++) {
+    tmp_vertical_coord_values = new double [lev_leaf_grid_of_sigma_or_hybrid->grid_size];
+    for (i = 0; i < level_V3D_coord_trigger_field->get_coord_value_grid()->get_grid_size(); i ++) {
         data_bot = data_array_bot[i];
         if (horizontal_grid_mask_values != NULL && !horizontal_grid_mask_values[i]) {
             for (j = 0; j < lev_leaf_grid_of_sigma_or_hybrid->grid_size; j ++)
                 tmp_vertical_coord_values[j] = data_array_bot[i];
         }
         else {
-			if (hybrid_grid_coefficient_values == NULL) {
-	            for (j = 0; j < lev_leaf_grid_of_sigma_or_hybrid->grid_size; j ++)
-    	            tmp_vertical_coord_values[j] = (fabs(data_sigma[j])*(data_bot-local_sigma_grid_top_value) + local_sigma_grid_top_value)*full_ratio*local_sigma_grid_scale_factor;
-			}
-			else {
-	            for (j = 0; j < lev_leaf_grid_of_sigma_or_hybrid->grid_size; j ++)
-    	            tmp_vertical_coord_values[j] = (local_sigma_grid_top_value*hybrid_grid_coefficient_values[j]+fabs(data_sigma[j])*data_bot)*full_ratio*local_sigma_grid_scale_factor;		
-			}
+            if (hybrid_grid_coefficient_values == NULL) {
+                for (j = 0; j < lev_leaf_grid_of_sigma_or_hybrid->grid_size; j ++)
+                    tmp_vertical_coord_values[j] = (fabs(data_sigma[j])*(data_bot-local_sigma_grid_top_value) + local_sigma_grid_top_value)*full_ratio*local_sigma_grid_scale_factor;
+            }
+            else {
+                for (j = 0; j < lev_leaf_grid_of_sigma_or_hybrid->grid_size; j ++)
+                    tmp_vertical_coord_values[j] = (local_sigma_grid_top_value*hybrid_grid_coefficient_values[j]+fabs(data_sigma[j])*data_bot)*full_ratio*local_sigma_grid_scale_factor;        
+            }
+        }
+        data_array_ptr = data_grid_field + i*lev_leaf_grid->grid_size;
+        if (lev_leaf_grid == lev_leaf_grid_of_sigma_or_hybrid) {
+            for (j = 0; j < lev_leaf_grid->grid_size; j ++)
+                data_array_ptr[j] = tmp_vertical_coord_values[j];
+        }
+        else {
+            for (j = 0; j < lev_leaf_grid->grid_size; j ++)
+                data_array_ptr[j] = (tmp_vertical_coord_values[j]+tmp_vertical_coord_values[j+1])/2;
         }
-		data_array_ptr = data_grid_field + i*lev_leaf_grid->grid_size;
-		if (lev_leaf_grid == lev_leaf_grid_of_sigma_or_hybrid) {
-			for (j = 0; j < lev_leaf_grid->grid_size; j ++)
-				data_array_ptr[j] = tmp_vertical_coord_values[j];
-		}
-		else {
-			for (j = 0; j < lev_leaf_grid->grid_size; j ++)
-				data_array_ptr[j] = (tmp_vertical_coord_values[j]+tmp_vertical_coord_values[j+1])/2;
-		}
     }
-	delete [] tmp_vertical_coord_values;	
+    delete [] tmp_vertical_coord_values;    
 }
 
 
 Remap_grid_data_class *Remap_grid_class::get_unique_center_field()
 {
-	EXECUTION_REPORT_ERROR_OPTIONALLY(REPORT_ERROR, -1, grid_center_fields.size() == 1 && is_sigma_grid(), "C-Coupler error in Remap_grid_class::get_unique_center_field");
-	return grid_center_fields[0];
+    EXECUTION_REPORT_ERROR_OPTIONALLY(REPORT_ERROR, -1, grid_center_fields.size() == 1 && (is_sigma_grid() || does_use_V3D_level_coord()), "C-Coupler error in Remap_grid_class::get_unique_center_field");
+    return grid_center_fields[0];
 }
 
 
 Remap_grid_data_class *Remap_grid_class::get_unique_vertex_field()
 {
-	EXECUTION_REPORT_ERROR_OPTIONALLY(REPORT_ERROR, -1, grid_vertex_fields.size() == 1 && is_sigma_grid() && num_vertexes == 2, "C-Coupler error in Remap_grid_class::get_unique_vertex_field");
-	return grid_vertex_fields[0];
+    EXECUTION_REPORT_ERROR_OPTIONALLY(REPORT_ERROR, -1, grid_vertex_fields.size() == 1 && is_sigma_grid() && num_vertexes == 2, "C-Coupler error in Remap_grid_class::get_unique_vertex_field");
+    return grid_vertex_fields[0];
 }
 
 
@@ -1155,37 +1213,37 @@ void Remap_grid_class::read_grid_data_from_array(const char *coord_label, const
         if (words_are_the_same(coord_label, GRID_VERTEX_LABEL))
             check_vertex_coord_value_can_be_set(coord_name);
         else if (words_are_the_same(coord_label, GRID_CENTER_LABEL))
-			check_center_coord_value_can_be_set(coord_name);
+            check_center_coord_value_can_be_set(coord_name);
         strcpy(remap_data_field->field_name_in_application, coord_name);
         strcpy(remap_data_field->data_type_in_application, DATA_TYPE_DOUBLE);
     }
     remap_data_field->required_data_size = grid_size;
     if (words_are_the_same(coord_label, GRID_VERTEX_LABEL))  
         remap_data_field->required_data_size *= num_vertexes;
-	remap_data_field->read_data_size = remap_data_field->required_data_size;
+    remap_data_field->read_data_size = remap_data_field->required_data_size;
     remap_data_field->data_buf = new char [remap_data_field->required_data_size*get_data_type_size(remap_data_field->data_type_in_application)];
-	if (words_are_the_same(coord_label, GRID_VERTEX_LABEL))
-		sprintf(remap_data_field->field_name_in_IO_file, "%s_%s", GRID_VERTEX_LABEL, coord_name);
-	else strcpy(remap_data_field->field_name_in_IO_file, coord_name);
-	if (words_are_the_same(coord_label, GRID_MASK_LABEL)) {
-		EXECUTION_REPORT(REPORT_ERROR, -1, words_are_the_same(data_type, DATA_TYPE_INT), "Software error in Remap_grid_class::read_grid_data_from_array: wrong data type for mask");
-		for (int i = 0; i < grid_size; i ++)
-			((bool*)remap_data_field->data_buf)[i] = ((int*) array_data)[i] == 1;
-	}
-	else {
-		int array_size = grid_size; 
-		if (num_vertexes > 0)
-			array_size *= num_vertexes;
-		EXECUTION_REPORT(REPORT_ERROR, -1, words_are_the_same(data_type, DATA_TYPE_FLOAT) || words_are_the_same(data_type, DATA_TYPE_DOUBLE), "Software error in Remap_grid_class::read_grid_data_from_array: wrong data type for others");
-		if (words_are_the_same(data_type, DATA_TYPE_FLOAT)) {
-			for (int i = 0; i < array_size; i ++)
-				((double*)remap_data_field->data_buf)[i] = ((float*) array_data)[i];
-		}
-		else {
-			for (int i = 0; i < array_size; i ++)
-				((double*)remap_data_field->data_buf)[i] = ((double*) array_data)[i];			
-		}
-	}
+    if (words_are_the_same(coord_label, GRID_VERTEX_LABEL))
+        sprintf(remap_data_field->field_name_in_IO_file, "%s_%s", GRID_VERTEX_LABEL, coord_name);
+    else strcpy(remap_data_field->field_name_in_IO_file, coord_name);
+    if (words_are_the_same(coord_label, GRID_MASK_LABEL)) {
+        EXECUTION_REPORT(REPORT_ERROR, -1, words_are_the_same(data_type, DATA_TYPE_INT), "Software error in Remap_grid_class::read_grid_data_from_array: wrong data type for mask");
+        for (int i = 0; i < grid_size; i ++)
+            ((bool*)remap_data_field->data_buf)[i] = ((int*) array_data)[i] == 1;
+    }
+    else {
+        int array_size = grid_size; 
+        if (num_vertexes > 0)
+            array_size *= num_vertexes;
+        EXECUTION_REPORT(REPORT_ERROR, -1, words_are_the_same(data_type, DATA_TYPE_FLOAT) || words_are_the_same(data_type, DATA_TYPE_DOUBLE), "Software error in Remap_grid_class::read_grid_data_from_array: wrong data type for others");
+        if (words_are_the_same(data_type, DATA_TYPE_FLOAT)) {
+            for (int i = 0; i < array_size; i ++)
+                ((double*)remap_data_field->data_buf)[i] = ((float*) array_data)[i];
+        }
+        else {
+            for (int i = 0; i < array_size; i ++)
+                ((double*)remap_data_field->data_buf)[i] = ((double*) array_data)[i];            
+        }
+    }
     remap_grid_data_field = new Remap_grid_data_class(this, remap_data_field);
     if (words_are_the_same(coord_label, GRID_MASK_LABEL))
         grid_mask_field = remap_grid_data_field;
@@ -1196,23 +1254,23 @@ void Remap_grid_class::read_grid_data_from_array(const char *coord_label, const
             grid_center_fields.push_back(remap_grid_data_field);
         else grid_vertex_fields.push_back(remap_grid_data_field);
     }
-	else imported_area = remap_grid_data_field;
-
-	if (words_are_the_same(coord_name, COORD_LABEL_LON) || words_are_the_same(coord_name, COORD_LABEL_LAT) || words_are_the_same(coord_name, COORD_LABEL_LAT)) {
-		Remap_grid_class *leaf_grids[256]; 
-		int num_leaf_grids;
-		get_leaf_grids(&num_leaf_grids, leaf_grids, this);
-		for (int i = 0; i < num_leaf_grids; i ++)
-			if (words_are_the_same(leaf_grids[i]->get_coord_label(), coord_name)) {
-				if (words_are_the_same(coord_name, COORD_LABEL_LON))
-					remap_grid_data_field->get_grid_data_field()->set_field_long_name("longitude");
-				else if (words_are_the_same(coord_name, COORD_LABEL_LAT))
-					remap_grid_data_field->get_grid_data_field()->set_field_long_name("latitude");
-				remap_grid_data_field->get_grid_data_field()->set_field_unit(leaf_grids[i]->get_coord_unit());
-			}
-	}
+    else imported_area = remap_grid_data_field;
+
+    if (words_are_the_same(coord_name, COORD_LABEL_LON) || words_are_the_same(coord_name, COORD_LABEL_LAT) || words_are_the_same(coord_name, COORD_LABEL_LAT)) {
+        Remap_grid_class *leaf_grids[256]; 
+        int num_leaf_grids;
+        get_leaf_grids(&num_leaf_grids, leaf_grids, this);
+        for (int i = 0; i < num_leaf_grids; i ++)
+            if (words_are_the_same(leaf_grids[i]->get_coord_label(), coord_name)) {
+                if (words_are_the_same(coord_name, COORD_LABEL_LON))
+                    remap_grid_data_field->get_grid_data_field()->set_field_long_name("longitude");
+                else if (words_are_the_same(coord_name, COORD_LABEL_LAT))
+                    remap_grid_data_field->get_grid_data_field()->set_field_long_name("latitude");
+                remap_grid_data_field->get_grid_data_field()->set_field_unit(leaf_grids[i]->get_coord_unit());
+            }
+    }
 
-	strcpy(remap_data_field->data_type_in_IO_file, data_type);
+    strcpy(remap_data_field->data_type_in_IO_file, data_type);
 }
 
 
@@ -1361,8 +1419,8 @@ bool Remap_grid_class::is_subset_of_grid(Remap_grid_class *another_grid)
             return false;
     }
 
-	if (this->get_num_dimensions() == another_grid->get_num_dimensions())
-		return this->grid_size == another_grid->grid_size;
+    if (this->get_num_dimensions() == another_grid->get_num_dimensions())
+        return this->grid_size == another_grid->grid_size;
 
     return true;
 }
@@ -1407,13 +1465,13 @@ Remap_grid_class *Remap_grid_class::get_a_leaf_grid(const char *coord_label)
 
 
     get_leaf_grids(&num_leaf_grids, leaf_grids, this);
-	for (i = 0; i < num_leaf_grids; i ++)
-		if (words_are_the_same(leaf_grids[i]->coord_label, coord_label))
-			return leaf_grids[i];
+    for (i = 0; i < num_leaf_grids; i ++)
+        if (words_are_the_same(leaf_grids[i]->coord_label, coord_label))
+            return leaf_grids[i];
 
-	EXECUTION_REPORT(REPORT_ERROR, -1, false, "C-Coupler error in get_a_leaf_grid");
+    EXECUTION_REPORT(REPORT_ERROR, -1, false, "C-Coupler error in get_a_leaf_grid");
 
-	return NULL;
+    return NULL;
 }
 
 
@@ -1538,19 +1596,19 @@ void Remap_grid_class::get_partial_grid_mask_fields(int *num_mask_fields_partial
 
 Remap_grid_data_class *Remap_grid_class::get_grid_center_field(const char *label) const
 {
-	int num_leaf_grids;
-	Remap_grid_class *leaf_grids[256];
-	
-	
-	get_leaf_grids(&num_leaf_grids, leaf_grids, this);
+    int num_leaf_grids;
+    Remap_grid_class *leaf_grids[256];
+    
+    
+    get_leaf_grids(&num_leaf_grids, leaf_grids, this);
 
-	for (int i = 0; i < num_leaf_grids; i ++)
-		if (words_are_the_same(leaf_grids[i]->get_coord_label(), label))
-			return leaf_grids[i]->get_grid_center_field();
+    for (int i = 0; i < num_leaf_grids; i ++)
+        if (words_are_the_same(leaf_grids[i]->get_coord_label(), label))
+            return leaf_grids[i]->get_grid_center_field();
 
-	EXECUTION_REPORT(REPORT_ERROR, -1, "Software error in Remap_grid_class::get_grid_center_field: fail to find a leaf grid with coordinate \"%s\"", label);
+    EXECUTION_REPORT(REPORT_ERROR, -1, "Software error in Remap_grid_class::get_grid_center_field: fail to find a leaf grid with coordinate \"%s\"", label);
 
-	return NULL;
+    return NULL;
 }
 
 
@@ -1786,14 +1844,16 @@ void Remap_grid_class::set_2D_coord_vertex_values_in_default(const double *cente
             if (box_vertex_end_dim2 >= grid_size_dim2)
                 box_vertex_end_dim2 = grid_size_dim2 - 1;
             if (!cyclic_dim1) {
-                while ((redundant_cell_mark[box_vertex_start_dim2*grid_size_dim1+box_vertex_start_dim1] ||
-                       redundant_cell_mark[box_vertex_end_dim2*grid_size_dim1+box_vertex_start_dim1]) &&
-                       box_vertex_start_dim1 >= 0)
-                    box_vertex_start_dim1 --;
-                while ((redundant_cell_mark[box_vertex_start_dim2*grid_size_dim1+box_vertex_end_dim1] ||
-                       redundant_cell_mark[box_vertex_end_dim2*grid_size_dim1+box_vertex_end_dim1]) &&
-                       box_vertex_end_dim1 < grid_size_dim1)
-                    box_vertex_end_dim1 ++;
+				if (redundant_cell_mark != NULL)
+	                while ((redundant_cell_mark[box_vertex_start_dim2*grid_size_dim1+box_vertex_start_dim1] ||
+    	                   redundant_cell_mark[box_vertex_end_dim2*grid_size_dim1+box_vertex_start_dim1]) &&
+        	               box_vertex_start_dim1 >= 0)
+            	        box_vertex_start_dim1 --;
+				if (redundant_cell_mark != NULL)
+	                while ((redundant_cell_mark[box_vertex_start_dim2*grid_size_dim1+box_vertex_end_dim1] ||
+    	                   redundant_cell_mark[box_vertex_end_dim2*grid_size_dim1+box_vertex_end_dim1]) &&
+        	               box_vertex_end_dim1 < grid_size_dim1)
+            	        box_vertex_end_dim1 ++;
                 if (box_vertex_start_dim1 < 0)
                     box_vertex_start_dim1 = box_vertex_end_dim1;
                 if (box_vertex_end_dim1 >= grid_size_dim1) 
@@ -1802,13 +1862,15 @@ void Remap_grid_class::set_2D_coord_vertex_values_in_default(const double *cente
             }
             else {
                 box_vertex_start_dim1 = (box_vertex_start_dim1+grid_size_dim1) % grid_size_dim1;
-                while (redundant_cell_mark[box_vertex_start_dim2*grid_size_dim1+box_vertex_start_dim1] ||
-                       redundant_cell_mark[box_vertex_end_dim2*grid_size_dim1+box_vertex_start_dim1])
-                    box_vertex_start_dim1 = (box_vertex_start_dim1+grid_size_dim1-1) % grid_size_dim1;
+				if (redundant_cell_mark != NULL)
+	                while (redundant_cell_mark[box_vertex_start_dim2*grid_size_dim1+box_vertex_start_dim1] ||
+    	                   redundant_cell_mark[box_vertex_end_dim2*grid_size_dim1+box_vertex_start_dim1])
+        	            box_vertex_start_dim1 = (box_vertex_start_dim1+grid_size_dim1-1) % grid_size_dim1;
                 box_vertex_end_dim1 = (box_vertex_end_dim1+grid_size_dim1) % grid_size_dim1;
-                while (redundant_cell_mark[box_vertex_start_dim2*grid_size_dim1+box_vertex_end_dim1] ||
-                       redundant_cell_mark[box_vertex_end_dim2*grid_size_dim1+box_vertex_end_dim1])
-                    box_vertex_end_dim1 = (box_vertex_end_dim1+grid_size_dim1+1) % grid_size_dim1;
+				if (redundant_cell_mark != NULL)
+	                while (redundant_cell_mark[box_vertex_start_dim2*grid_size_dim1+box_vertex_end_dim1] ||
+    	                   redundant_cell_mark[box_vertex_end_dim2*grid_size_dim1+box_vertex_end_dim1])
+        	            box_vertex_end_dim1 = (box_vertex_end_dim1+grid_size_dim1+1) % grid_size_dim1;
             }
             num_non_null_cells = 0;
             sum_value_dim1 = 0;
@@ -1823,7 +1885,7 @@ void Remap_grid_class::set_2D_coord_vertex_values_in_default(const double *cente
                     for (l = box_vertex_start_dim1; l <= box_vertex_end_dim1; l ++) {
                         indx1 = l%grid_size_dim1;
                         indx2 = k%grid_size_dim2;
-                        if (!redundant_cell_mark[indx2*grid_size_dim1+indx1]) {
+                        if (redundant_cell_mark == NULL || !redundant_cell_mark[indx2*grid_size_dim1+indx1]) {
                             if (max_coord_value < center_values_dim1[indx2*grid_size_dim1+indx1])
                                 max_coord_value = center_values_dim1[indx2*grid_size_dim1+indx1];
                             if (min_coord_value > center_values_dim1[indx2*grid_size_dim1+indx1])
@@ -1838,7 +1900,7 @@ void Remap_grid_class::set_2D_coord_vertex_values_in_default(const double *cente
                 for (l = box_vertex_start_dim1; l <= box_vertex_end_dim1; l ++) {
                     indx1 = l%grid_size_dim1;
                     indx2 = k%grid_size_dim2;
-                    if (!redundant_cell_mark[indx2*grid_size_dim1+indx1]) {
+                    if (redundant_cell_mark == NULL || !redundant_cell_mark[indx2*grid_size_dim1+indx1]) {
                         sum_value_dim1 += center_values_dim1[indx2*grid_size_dim1+indx1];
                         sum_value_dim2 += center_values_dim2[indx2*grid_size_dim1+indx1];
                         num_non_null_cells ++;
@@ -1901,7 +1963,7 @@ void Remap_grid_class::set_grid_boundary(double min_lon, double max_lon, double
 {
     int num_leaf_grids;
     Remap_grid_class *leaf_grids[256], *lon_sub_grid;
-	double eps = 1.0000001;
+    double eps = 1.0000001;
 
 
     EXECUTION_REPORT(REPORT_ERROR, -1, this->get_is_sphere_grid(), "%s is not a sphere grid, while only sphere grid can be set boundary", grid_name);
@@ -1912,10 +1974,10 @@ void Remap_grid_class::set_grid_boundary(double min_lon, double max_lon, double
     EXECUTION_REPORT(REPORT_ERROR, -1, max_lat >= -90*eps && max_lat <= 90*eps, "the maximum latitude (%lf) of the boundary of grid %s must be between -90 and +90 degrees", max_lat, grid_name);
     EXECUTION_REPORT(REPORT_ERROR, -1, min_lat < max_lat, "the minimum latitude (%lf) of the boundary must be smaller than the maximum latitude (%lf) of the boundary", min_lat, max_lat, grid_name);
 
-	if (are_floating_values_equal(min_lat, (double)-90))
-		min_lat = -90;
-	if (are_floating_values_equal(max_lat, (double)90))
-		max_lat = 90;
+    if (are_floating_values_equal(min_lat, (double)-90))
+        min_lat = -90;
+    if (are_floating_values_equal(max_lat, (double)90))
+        max_lat = 90;
 
     get_leaf_grids(&num_leaf_grids, leaf_grids, this);
     if (words_are_the_same(leaf_grids[0]->get_coord_label(), COORD_LABEL_LON))
@@ -1926,7 +1988,7 @@ void Remap_grid_class::set_grid_boundary(double min_lon, double max_lon, double
     boundary_max_lon = max_lon;
     boundary_min_lat = min_lat;
     boundary_max_lat = max_lat;
-	EXECUTION_REPORT_LOG(REPORT_LOG, -1, true, "Set boundary of grid \"%s\" to %lf %lf %lf %lf", grid_name, boundary_min_lon, boundary_max_lon, boundary_min_lat, boundary_max_lat);
+    EXECUTION_REPORT_LOG(REPORT_LOG, -1, true, "Set boundary of grid \"%s\" to %lf %lf %lf %lf", grid_name, boundary_min_lon, boundary_max_lon, boundary_min_lat, boundary_max_lat);
 }
 
 
@@ -1942,7 +2004,7 @@ void Remap_grid_class::generate_voronoi_grid()
     EXECUTION_REPORT(REPORT_ERROR, -1, this->get_is_sphere_grid(), "remap software error1 in generate_voronoi_grid\n");
     EXECUTION_REPORT(REPORT_ERROR, -1, !are_floating_values_equal(NULL_COORD_VALUE, boundary_min_lon), "remap software error2 in generate_voronoi_grid\n");
     EXECUTION_REPORT(REPORT_WARNING, -1, boundary_min_lon != NULL_COORD_VALUE, "the boundary of area of grid %s (%lx) has not been set by user. Default boundary area (global area) will be used to generate the voronoi grid\n", grid_name, this);
-	EXECUTION_REPORT_LOG(REPORT_LOG, -1, true, "Generate voronoi grid for \"%s\": %lf  %lf  %lf  %lf", grid_name, boundary_min_lon, boundary_max_lon, boundary_min_lat, boundary_max_lat);
+    EXECUTION_REPORT_LOG(REPORT_LOG, -1, true, "Generate voronoi grid for \"%s\": %lf  %lf  %lf  %lf", grid_name, boundary_min_lon, boundary_max_lon, boundary_min_lat, boundary_max_lat);
 
     are_vertex_values_set_in_default = true;
 
@@ -1989,8 +2051,8 @@ void Remap_grid_class::set_coord_vertex_values_in_default()
     if (grid_center_fields.size() == 0)
         return;
 
-	if (grid_vertex_fields.size() > 0)
-		return;
+    if (grid_vertex_fields.size() > 0)
+        return;
 
     get_leaf_grids(&num_leaf_grids, leaf_grids, this);
     for (i = 0; i < num_leaf_grids; i ++) {
@@ -2002,21 +2064,21 @@ void Remap_grid_class::set_coord_vertex_values_in_default()
     num_vertexes = 1;
     for (i = 0; i < grid_center_fields.size(); i ++)
         num_vertexes *= 2;
-	for (i = 0; i < grid_center_fields.size(); i ++) 
-		grid_vertex_fields.push_back(grid_center_fields[i]->duplicate_grid_data_field(this, num_vertexes, false, false));
+    for (i = 0; i < grid_center_fields.size(); i ++) 
+        grid_vertex_fields.push_back(grid_center_fields[i]->duplicate_grid_data_field(this, num_vertexes, false, false));
 
     if (grid_center_fields.size() == 1) {
         for (j = 0; j < num_leaf_grids; j ++)
-			if (is_sigma_grid()) {
-				if (leaf_grids[j]->has_grid_coord_label(COORD_LABEL_LEV)){
-					EXECUTION_REPORT(REPORT_ERROR, -1, words_are_the_same(grid_center_fields[0]->get_grid_data_field()->field_name_in_application, COORD_LABEL_LEV), "remap software error0 in set_coord_vertex_values_in_default\n");
-					break;
-				}
-			}
-			else {
-	            if (leaf_grids[j]->get_grid_center_field() == grid_center_fields[0])
-	                break;
-			}
+            if (is_sigma_grid()) {
+                if (leaf_grids[j]->has_grid_coord_label(COORD_LABEL_LEV)){
+                    EXECUTION_REPORT(REPORT_ERROR, -1, words_are_the_same(grid_center_fields[0]->get_grid_data_field()->field_name_in_application, COORD_LABEL_LEV), "remap software error0 in set_coord_vertex_values_in_default\n");
+                    break;
+                }
+            }
+            else {
+                if (leaf_grids[j]->get_grid_center_field() == grid_center_fields[0])
+                    break;
+            }
         EXECUTION_REPORT(REPORT_ERROR, -1, j < num_leaf_grids, "remap software error1 in set_coord_vertex_values_in_default\n");
         current_leaf_grid = leaf_grids[j];
         EXECUTION_REPORT(REPORT_ERROR, -1, current_leaf_grid->grid_size > 0, "remap software error2 in set_coord_vertex_values_in_default\n");
@@ -2478,6 +2540,8 @@ void Remap_grid_class::check_center_fields_sorting_order()
         if (words_are_the_same(grid_center_fields[i]->get_grid_data_field()->field_name_in_application, COORD_LABEL_LAT) || 
             words_are_the_same(grid_center_fields[i]->get_grid_data_field()->field_name_in_application, COORD_LABEL_LON))
             continue;
+		if (grid_center_fields[i]->get_grid_data_field()->required_data_size != grid_size)  // pseudo 3-D vertical center field
+			continue;
         get_sized_sub_grids(&num_sized_sub_grids, sized_sub_grids);
         for (j = 0, k = 0; j < num_sized_sub_grids; j ++)
             if (sized_sub_grids[j]->has_grid_coord_label(grid_center_fields[i]->get_grid_data_field()->field_name_in_application)) {
@@ -2495,10 +2559,10 @@ void Remap_grid_class::check_center_fields_sorting_order()
         for (j = 0; j < this->grid_size/sub_grids[0]->grid_size; j ++) {
             current_coord_values = (double*)(grid_center_fields[i]->get_grid_data_field()->data_buf) + j*sub_grids[0]->grid_size;
             for (k = 1; k < sub_grids[0]->grid_size; k ++) {
-				if (!have_set_sorting_order && current_coord_values[k-1] != current_coord_values[k]) {
-					have_set_sorting_order = true;
-					ascending_order = current_coord_values[k-1] < current_coord_values[k];
-				}
+                if (!have_set_sorting_order && current_coord_values[k-1] != current_coord_values[k]) {
+                    have_set_sorting_order = true;
+                    ascending_order = current_coord_values[k-1] < current_coord_values[k];
+                }
                 EXECUTION_REPORT(REPORT_ERROR, -1, current_coord_values[k-1] == current_coord_values[k] || ascending_order == current_coord_values[k-1] < current_coord_values[k], "the center coordinate values of subgrid %s of grid %s are not sorted in ascending or descending order\n", sub_grids[0]->get_grid_name(), this->grid_name);
             }
         }
@@ -2559,7 +2623,14 @@ void Remap_grid_class::check_center_vertex_values_consistency_2D()
                                  center_field1->is_unit_degree(),
                                  center_field2->is_unit_degree(),
                                  get_is_sphere_grid())) {
-            EXECUTION_REPORT(REPORT_ERROR, -1, false, "center coordinate values are not consistent with vertex coordinate values in grid \"%s\": each center point must be surrounded by the polygon determined by the corresponding vertex points\n", grid_name);
+            char error_string1[65536], error_string2[1024];
+			sprintf(error_string1, "( ");
+			for (j = 0; j < num_vertexes; j ++) {
+				sprintf(error_string2, "(lon=%lf,lat=%lf) ", vertex_coord1_values[j], vertex_coord2_values[j]); 
+				strcat(error_string1, error_string2);
+			}
+			strcat(error_string1,")");
+            EXECUTION_REPORT(REPORT_ERROR, -1, false, "At the %dth point of the grid \"%s\", the center coordinate values (lon=%lf,lat=%lf) are not consistent with vertex coordinate values (%s): each center point must be surrounded by the polygon determined by the corresponding vertex points.", i+1, grid_name, center_coord1_value, center_coord2_value, error_string1);
         }
     }
 }
@@ -2659,6 +2730,11 @@ void Remap_grid_class::compute_remap_field_data_runtime_mask(Remap_grid_class *f
         return;
     }
 
+    if ((*num_mask_sub_grids) == 1) {
+        *runtime_mask = sub_mask_fields[0]->duplicate_grid_data_field(sub_mask_fields[0]->get_coord_value_grid(), 1, true, true);
+        return;
+    }
+
     *runtime_mask = sub_mask_fields[0]->duplicate_grid_data_field(this, 1, false, false);
     runtime_mask_values = (bool*) (*runtime_mask)->grid_data_field->data_buf;
     for (i = 0; i < this->grid_size; i ++)
@@ -2683,6 +2759,7 @@ void Remap_grid_class::detect_redundant_cells()
     long *cell_index, i, next_i, j;
     Radix_sort<double, long> *radix_sort;
     Remap_data_field *mask_data_field;
+	bool has_redundant_cells = false;
 
 
     if (grid_center_fields.size() == 0)
@@ -2731,28 +2808,41 @@ void Remap_grid_class::detect_redundant_cells()
                 break;
         if (j == num_dimensions) {
             redundant_cell_mark[radix_sort->content[next_i]] = true;
+			has_redundant_cells = true;
         }
     }
 
     delete radix_sort;
     delete [] cell_index;    
 
-	if (get_is_sphere_grid()) {
-		int north_pole_cell_index = -1, south_pole_cell_index = -1;
-		for (i = 0; i < grid_size; i ++) {
-			if (((float)full_center_coord_values[1][i]) == (float)90.0)
-				if (north_pole_cell_index == -1)
-					north_pole_cell_index = i;
-				else redundant_cell_mark[i] = true;
-			if (((float)full_center_coord_values[1][i]) == (float)(-90.0))
-				if (south_pole_cell_index == -1)
-					south_pole_cell_index = i;
-				else redundant_cell_mark[i] = true;
-		}
-	}
+    if (get_is_sphere_grid()) {
+        int north_pole_cell_index = -1, south_pole_cell_index = -1;
+        for (i = 0; i < grid_size; i ++) {
+            if (((float)full_center_coord_values[1][i]) == (float)90.0)
+                if (north_pole_cell_index == -1)
+                    north_pole_cell_index = i;
+                else {
+					redundant_cell_mark[i] = true;
+					has_redundant_cells = true;
+                }
+            if (((float)full_center_coord_values[1][i]) == (float)(-90.0))
+                if (south_pole_cell_index == -1)
+                    south_pole_cell_index = i;
+                else {
+					redundant_cell_mark[i] = true;
+					has_redundant_cells = true;
+                }
+        }
+    }
+
+    for (i = 0; i < num_dimensions; i ++)
+        delete full_center_fields[i];
 
-	for (i = 0; i < num_dimensions; i ++)
-		delete full_center_fields[i];
+	if (!has_redundant_cells) {
+		delete redundant_cell_mark_field;
+		redundant_cell_mark_field = NULL;
+		redundant_cell_mark = NULL;
+	}
 }
 
 
@@ -2824,16 +2914,16 @@ void Remap_grid_class::transform_coord_values_from_radian_to_degrees(Remap_grid_
     if (!words_are_the_same(leaf_grids[i]->coord_unit, COORD_UNIT_RADIANS))
         return;
 
-	strcpy(leaf_grids[i]->coord_unit, COORD_UNIT_DEGREES);
+    strcpy(leaf_grids[i]->coord_unit, COORD_UNIT_DEGREES);
     coord_value_array = (double*) remap_grid_data->grid_data_field->data_buf;
     array_size = remap_grid_data->grid_data_field->required_data_size;    
     for (i = 0; i < array_size; i ++)
         if (coord_value_array[i] != NULL_COORD_VALUE) {
             coord_value_array[i] = RADIAN_TO_DEGREE(coord_value_array[i]);
-			if (are_floating_values_equal((double)90, coord_value_array[i]))
-				coord_value_array[i] = 90;
-			if (are_floating_values_equal((double)-90, coord_value_array[i]))
-				coord_value_array[i] = -90;
+            if (are_floating_values_equal((double)90, coord_value_array[i]))
+                coord_value_array[i] = 90;
+            if (are_floating_values_equal((double)-90, coord_value_array[i]))
+                coord_value_array[i] = -90;
         }
     for (i = 0; i < remap_grid_data->grid_data_field->field_attributes.size(); i ++)
         if (words_are_the_same(remap_grid_data->grid_data_field->field_attributes[i].attribute_name, GRID_FIELD_ATTRIBUTE_UNIT) ||
@@ -3008,7 +3098,7 @@ bool Remap_grid_class::get_is_sphere_grid() const
 
 void Remap_grid_class::set_decomp_name(const char *decomp_name)
 {
-	strcpy(this->decomp_name, decomp_name);
+    strcpy(this->decomp_name, decomp_name);
 }
 
 
@@ -3018,7 +3108,7 @@ Remap_grid_class *Remap_grid_class::generate_decomp_grid(const int *local_cell_i
     Remap_grid_class *decomp_leaf_grids[256];
     Remap_grid_class *decomp_grid;
     Remap_grid_data_class *original_center_field_lon, *original_center_field_lat;
-	char decomp_grid_name[NAME_STR_SIZE*2];
+    char decomp_grid_name[NAME_STR_SIZE*2];
     int num_leaf_grids;
     double *decomp_lon_center_values, *decomp_lat_center_values;
     double *this_lon_center_values, *this_lat_center_values;
@@ -3035,7 +3125,7 @@ Remap_grid_class *Remap_grid_class::generate_decomp_grid(const int *local_cell_i
         decomp_leaf_grids[0] = new Remap_grid_class(leaf_grids[0]->grid_name, leaf_grids[0]->coord_label, leaf_grids[0]->coord_unit, COORD_BOUND_CYCLIC, 0);
     else decomp_leaf_grids[0] = new Remap_grid_class(leaf_grids[0]->grid_name, leaf_grids[0]->coord_label, leaf_grids[0]->coord_unit, COORD_BOUND_ACYCLIC, 0);
     decomp_leaf_grids[1] = new Remap_grid_class(leaf_grids[1]->grid_name, leaf_grids[1]->coord_label, leaf_grids[1]->coord_unit, COORD_BOUND_ACYCLIC, 0);
-	sprintf(decomp_grid_name, "DECOMP_GRID_%s_at_%s", grid_name, decomp_name);
+    sprintf(decomp_grid_name, "%s_at_DECOMP_%s", grid_name, decomp_name);
     decomp_grid = new Remap_grid_class(decomp_grid_name, 2, decomp_leaf_grids, num_local_cells);
     decomp_leaf_grids[0]->super_grid_of_setting_coord_values = decomp_grid;
     decomp_leaf_grids[1]->super_grid_of_setting_coord_values = decomp_grid;
@@ -3091,12 +3181,12 @@ Remap_grid_class *Remap_grid_class::generate_decomp_grid(const int *local_cell_i
         delete original_center_field_lat;
     }
 
-	strcpy(decomp_grid->decomp_name, decomp_name);
-	decomp_grid->original_grid = this;
+    strcpy(decomp_grid->decomp_name, decomp_name);
+    decomp_grid->original_grid = this;
 
-	remap_grid_manager->add_temp_grid(decomp_leaf_grids[0]);
-	remap_grid_manager->add_temp_grid(decomp_leaf_grids[1]);
-	
+    remap_grid_manager->add_temp_grid(decomp_leaf_grids[0]);
+    remap_grid_manager->add_temp_grid(decomp_leaf_grids[1]);
+    
     return decomp_grid;
 }
 
@@ -3105,51 +3195,53 @@ void Remap_grid_class::generate_3D_grid_decomp_sigma_values(Remap_grid_class *or
 {
     Remap_grid_class *leaf_grids[256];
     int num_leaf_grids;
-	double *local_sigma_grid_surface_values;
+    double *local_sigma_grid_surface_values;
 
-	
-	EXECUTION_REPORT(REPORT_ERROR, -1, this->has_grid_coord_label(COORD_LABEL_LON) && this->has_grid_coord_label(COORD_LABEL_LAT) && this->has_grid_coord_label(COORD_LABEL_LEV),
-					 "C-Coupler error1 in generate_3D_grid_decomp_sigma_values\n");
+    
+    EXECUTION_REPORT(REPORT_ERROR, -1, this->has_grid_coord_label(COORD_LABEL_LON) && this->has_grid_coord_label(COORD_LABEL_LAT) && this->has_grid_coord_label(COORD_LABEL_LEV),
+                     "C-Coupler error1 in generate_3D_grid_decomp_sigma_values\n");
+
+    if (!original_3D_grid->is_sigma_grid())
+        return;
 
-	if (!original_3D_grid->is_sigma_grid())
-		return;
+    if (original_3D_grid->grid_center_fields.size() == 0)
+        return;
 
-	if (original_3D_grid->grid_center_fields.size() == 0)
-		return;
+    EXECUTION_REPORT(REPORT_ERROR, -1, original_3D_grid->grid_center_fields.size() == 1 && this->grid_center_fields.size() == 0, "C-Coupler error2 in generate_3D_grid_decomp_sigma_values\n");
+    
+    grid_center_fields.push_back(original_3D_grid->grid_center_fields[0]->duplicate_grid_data_field(this, 1, false, false));
+    level_V3D_coord_trigger_field = original_3D_grid->get_a_leaf_grid_of_sigma_or_hybrid()->get_sigma_grid_sigma_value_field()->duplicate_grid_data_field(decomp_grid, 1, false, false);
+    local_sigma_grid_surface_values = (double*) level_V3D_coord_trigger_field->get_grid_data_field()->data_buf;
+    for (int i = 0; i < num_local_cells; i ++)
+        local_sigma_grid_surface_values[i] = 0.0;
 
-	EXECUTION_REPORT(REPORT_ERROR, -1, original_3D_grid->grid_center_fields.size() == 1 && this->grid_center_fields.size() == 0, "C-Coupler error2 in generate_3D_grid_decomp_sigma_values\n");
-	
-	grid_center_fields.push_back(original_3D_grid->grid_center_fields[0]->duplicate_grid_data_field(this, 1, false, false));
-	sigma_grid_surface_value_field = original_3D_grid->get_a_leaf_grid_of_sigma_or_hybrid()->get_sigma_grid_sigma_value_field()->duplicate_grid_data_field(decomp_grid, 1, false, false);
-	local_sigma_grid_surface_values = (double*) sigma_grid_surface_value_field->get_grid_data_field()->data_buf;
-	for (int i = 0; i < num_local_cells; i ++)
-		local_sigma_grid_surface_values[i] = 0.0;
+    level_V3D_coord_trigger_field_specified = original_3D_grid->level_V3D_coord_trigger_field_specified;
+    
+    EXECUTION_REPORT_LOG(REPORT_LOG, -1, true, "generate decomp sigma values for 3D grid %s: %ld %ld %ld\n", grid_name, get_a_leaf_grid_of_sigma_or_hybrid()->get_sigma_grid_sigma_value_field()->get_coord_value_grid()->get_grid_size(),
+                     level_V3D_coord_trigger_field->get_coord_value_grid()->get_grid_size(), this->get_grid_size());
 
-	sigma_grid_surface_value_field_specified = original_3D_grid->sigma_grid_surface_value_field_specified;
-	
-	EXECUTION_REPORT_LOG(REPORT_LOG, -1, true, "generate decomp sigma values for 3D grid %s: %ld %ld %ld\n", grid_name, get_a_leaf_grid_of_sigma_or_hybrid()->get_sigma_grid_sigma_value_field()->get_coord_value_grid()->get_grid_size(),
-	                 sigma_grid_surface_value_field->get_coord_value_grid()->get_grid_size(), this->get_grid_size());
-
-	this->get_leaf_grids(&num_leaf_grids, leaf_grids, this);
-	for (int i = 0; i < num_leaf_grids; i ++)
-		if (leaf_grids[i]->has_grid_coord_label(COORD_LABEL_LEV)) {
-			EXECUTION_REPORT(REPORT_ERROR, -1, leaf_grids[i]->grid_size > 0 && leaf_grids[i]->grid_center_fields.size() == 0, "C-Coupler error3 in generate_3D_grid_decomp_sigma_values\n");			
-			leaf_grids[i]->super_grid_of_setting_coord_values = this;
-		}
-		
-	for (int i = 0; i < num_local_cells; i ++)
-		local_sigma_grid_surface_values[i] = ((double*)(original_3D_grid->sigma_grid_surface_value_field->get_grid_data_field()->data_buf))[local_cell_indexes[i]];
+    this->get_leaf_grids(&num_leaf_grids, leaf_grids, this);
+    for (int i = 0; i < num_leaf_grids; i ++)
+        if (leaf_grids[i]->has_grid_coord_label(COORD_LABEL_LEV)) {
+            EXECUTION_REPORT(REPORT_ERROR, -1, leaf_grids[i]->grid_size > 0 && leaf_grids[i]->grid_center_fields.size() == 0, "C-Coupler error3 in generate_3D_grid_decomp_sigma_values\n");            
+            leaf_grids[i]->super_grid_of_setting_coord_values = this;
+        }
+        
+    for (int i = 0; i < num_local_cells; i ++)
+        if (local_cell_indexes[i] != CCPL_NULL_INT)
+            local_sigma_grid_surface_values[i] = ((double*)(original_3D_grid->level_V3D_coord_trigger_field->get_grid_data_field()->data_buf))[local_cell_indexes[i]];
+        else local_sigma_grid_surface_values[i] = NULL_COORD_VALUE;
 }
 
 
 void Remap_grid_class::renew_lev_grid_coord_values(double *new_center_coord_values, double *new_vertex_coord_values)
 {
-	EXECUTION_REPORT(REPORT_ERROR, -1, grid_center_fields.size() == 1, "C-Coupler error in Remap_grid_class::renew_lev_grid_coord_value: NULL grid_center_fields");
-	for (int i = 0; i < grid_size; i ++)
-		((double*)grid_center_fields[0]->get_grid_data_field()->data_buf)[i] = new_center_coord_values[i];
-	if (new_vertex_coord_values != NULL)
-		for (int i = 0; i < grid_size*2; i ++)
-			((double*)grid_vertex_fields[0]->get_grid_data_field()->data_buf)[i] = new_vertex_coord_values[i];
+    EXECUTION_REPORT(REPORT_ERROR, -1, grid_center_fields.size() == 1, "C-Coupler error in Remap_grid_class::renew_lev_grid_coord_value: NULL grid_center_fields");
+    for (int i = 0; i < grid_size; i ++)
+        ((double*)grid_center_fields[0]->get_grid_data_field()->data_buf)[i] = new_center_coord_values[i];
+    if (new_vertex_coord_values != NULL)
+        for (int i = 0; i < grid_size*2; i ++)
+            ((double*)grid_vertex_fields[0]->get_grid_data_field()->data_buf)[i] = new_vertex_coord_values[i];
 }
 
 
@@ -3222,318 +3314,332 @@ bool Remap_grid_class::check_mask_values_consitency(const char *data_type, const
 
 void Remap_grid_class::write_grid_field_into_array(Remap_grid_data_class *grid_field, char **array, long &buffer_max_size, long &buffer_content_size)
 {
-	int temp_int;
+    int temp_int;
 
-	
-	if (grid_field != NULL) {
-		temp_int = grid_size;
-		grid_field->write_grid_data_into_array(array, buffer_max_size, buffer_content_size);
-	}
-	else temp_int = 0;
-	write_data_into_array_buffer(&temp_int, sizeof(int), array, buffer_max_size, buffer_content_size);
+    
+    if (grid_field != NULL) {
+        temp_int = grid_size;
+        grid_field->write_grid_data_into_array(array, buffer_max_size, buffer_content_size);
+    }
+    else temp_int = 0;
+    write_data_into_array_buffer(&temp_int, sizeof(int), array, buffer_max_size, buffer_content_size);
 }
 
 
 void Remap_grid_class::read_grid_field_from_array(Remap_grid_data_class **grid_field, const char *array, long &buffer_content_iter)
 {
-	int temp_int;
+    int temp_int;
 
 
-	read_data_from_array_buffer(&temp_int, sizeof(int), array, buffer_content_iter, true);
-	if (temp_int != 0)
-		*grid_field = new Remap_grid_data_class(this, array, buffer_content_iter);
+    read_data_from_array_buffer(&temp_int, sizeof(int), array, buffer_content_iter, true);
+    if (temp_int != 0)
+        *grid_field = new Remap_grid_data_class(this, array, buffer_content_iter);
 }
 
 
 void Remap_grid_class::write_grid_name_into_array(Remap_grid_class *grid, char **array, long &buffer_max_size, long &buffer_content_size)
 {
-	char temp_grid_name[NAME_STR_SIZE];
+    char temp_grid_name[NAME_STR_SIZE];
 
 
-	if (grid == NULL)
-		sprintf(temp_grid_name, "NULL");
-	else strcpy(temp_grid_name, grid->get_grid_name());
-	write_data_into_array_buffer(temp_grid_name, NAME_STR_SIZE, array, buffer_max_size, buffer_content_size);
+    if (grid == NULL)
+        sprintf(temp_grid_name, "NULL");
+    else strcpy(temp_grid_name, grid->get_grid_name());
+    write_data_into_array_buffer(temp_grid_name, NAME_STR_SIZE, array, buffer_max_size, buffer_content_size);
 }
 
 
 Remap_grid_class *Remap_grid_class::get_linked_grid_from_array(Remap_grid_class *top_grid, const char *grid_name_suffix, char *temp_grid_name)
 {
-	if (!words_are_the_same(temp_grid_name, "NULL")) {
-		strcat(temp_grid_name, grid_name_suffix);
-		if (words_are_the_same(this->grid_name, temp_grid_name))
-			return this;
-		Remap_grid_class *linked_grid = top_grid->search_sub_grid(temp_grid_name);
-		EXECUTION_REPORT(REPORT_ERROR, -1, linked_grid != NULL, "Software error in Remap_grid_class::Remap_grid_class: wrong linked grid");
-		return linked_grid;
-	}
-	
-	return NULL;
+    if (!words_are_the_same(temp_grid_name, "NULL")) {
+		strcat(temp_grid_name, "_FROM_");
+        strcat(temp_grid_name, grid_name_suffix);
+        if (words_are_the_same(this->grid_name, temp_grid_name))
+            return this;
+        Remap_grid_class *linked_grid = top_grid->search_sub_grid(temp_grid_name);
+        EXECUTION_REPORT(REPORT_ERROR, -1, linked_grid != NULL, "Software error in Remap_grid_class::Remap_grid_class: wrong linked grid");
+        return linked_grid;
+    }
+    
+    return NULL;
 }
 
 
 
 void Remap_grid_class::write_grid_into_array(char **array, long &buffer_max_size, long &buffer_content_size)
 {
-	int temp_int;
+    int temp_int;
 
-	
-	for (int i = sub_grids.size()-1; i >= 0 ; i --)
-		sub_grids[i]->write_grid_into_array(array, buffer_max_size, buffer_content_size);
-	temp_int = sub_grids.size();
-	write_data_into_array_buffer(&temp_int, sizeof(int), array, buffer_max_size, buffer_content_size);
-	write_grid_name_into_array(first_super_grid_of_enable_setting_coord_value, array, buffer_max_size, buffer_content_size);
-	write_grid_name_into_array(super_grid_of_setting_coord_values, array, buffer_max_size, buffer_content_size);
-	write_grid_field_into_array(sigma_grid_dynamic_surface_value_field, array, buffer_max_size, buffer_content_size);
-	write_grid_field_into_array(hybrid_grid_coefficient_field, array, buffer_max_size, buffer_content_size);
-	write_grid_field_into_array(sigma_grid_sigma_value_field, array, buffer_max_size, buffer_content_size);
-	write_grid_field_into_array(sigma_grid_surface_value_field, array, buffer_max_size, buffer_content_size);
-	write_grid_field_into_array(grid_mask_field, array, buffer_max_size, buffer_content_size);
-	write_grid_field_into_array(redundant_cell_mark_field, array, buffer_max_size, buffer_content_size);
-	for (int i = grid_vertex_fields.size()-1; i >= 0; i --)
-		grid_vertex_fields[i]->write_grid_data_into_array(array, buffer_max_size, buffer_content_size);
-	temp_int = grid_vertex_fields.size();
-	write_data_into_array_buffer(&temp_int, sizeof(int), array, buffer_max_size, buffer_content_size);
-	for (int i = grid_center_fields.size()-1; i >=0 ; i --)
-		grid_center_fields[i]->write_grid_data_into_array(array, buffer_max_size, buffer_content_size);
-	temp_int = grid_center_fields.size();
-	write_data_into_array_buffer(&temp_int, sizeof(int), array, buffer_max_size, buffer_content_size);
-	write_data_into_array_buffer(&sigma_grid_scale_factor, sizeof(double), array, buffer_max_size, buffer_content_size);
-	write_data_into_array_buffer(&sigma_grid_top_value, sizeof(double), array, buffer_max_size, buffer_content_size);
-	write_data_into_array_buffer(&sigma_grid_surface_value_field_specified, sizeof(bool), array, buffer_max_size, buffer_content_size);	
-	write_data_into_array_buffer(&are_vertex_values_set_in_default, sizeof(bool), array, buffer_max_size, buffer_content_size);
-	write_data_into_array_buffer(&cyclic, sizeof(bool), array, buffer_max_size, buffer_content_size);
-	write_data_into_array_buffer(&masks_are_known, sizeof(bool), array, buffer_max_size, buffer_content_size);
-	write_data_into_array_buffer(&num_vertexes, sizeof(int), array, buffer_max_size, buffer_content_size);
-	write_data_into_array_buffer(&num_dimensions, sizeof(int), array, buffer_max_size, buffer_content_size);
-	write_data_into_array_buffer(&boundary_min_lon, sizeof(double), array, buffer_max_size, buffer_content_size);
-	write_data_into_array_buffer(&boundary_max_lon, sizeof(double), array, buffer_max_size, buffer_content_size);
-	write_data_into_array_buffer(&boundary_min_lat, sizeof(double), array, buffer_max_size, buffer_content_size);
-	write_data_into_array_buffer(&boundary_max_lat, sizeof(double), array, buffer_max_size, buffer_content_size);
-	write_data_into_array_buffer(&grid_size, sizeof(long), array, buffer_max_size, buffer_content_size);
-	write_data_into_array_buffer(decomp_name, NAME_STR_SIZE, array, buffer_max_size, buffer_content_size);
-	write_data_into_array_buffer(coord_unit, NAME_STR_SIZE, array, buffer_max_size, buffer_content_size);
-	write_data_into_array_buffer(coord_label, NAME_STR_SIZE, array, buffer_max_size, buffer_content_size);
-	write_data_into_array_buffer(grid_name, NAME_STR_SIZE, array, buffer_max_size, buffer_content_size);
+	EXECUTION_REPORT_LOG(REPORT_LOG, -1, true, " write grid \"%s\"", grid_name);
+    
+    for (int i = sub_grids.size()-1; i >= 0 ; i --)
+        sub_grids[i]->write_grid_into_array(array, buffer_max_size, buffer_content_size);
+    temp_int = sub_grids.size();
+    write_data_into_array_buffer(&temp_int, sizeof(int), array, buffer_max_size, buffer_content_size);
+    write_grid_name_into_array(first_super_grid_of_enable_setting_coord_value, array, buffer_max_size, buffer_content_size);
+    write_grid_name_into_array(super_grid_of_setting_coord_values, array, buffer_max_size, buffer_content_size);
+    write_grid_field_into_array(level_V3D_coord_dynamic_trigger_field, array, buffer_max_size, buffer_content_size);
+    write_grid_field_into_array(hybrid_grid_coefficient_field, array, buffer_max_size, buffer_content_size);
+    write_grid_field_into_array(sigma_grid_sigma_value_field, array, buffer_max_size, buffer_content_size);
+    write_grid_field_into_array(level_V3D_coord_trigger_field, array, buffer_max_size, buffer_content_size);
+    write_grid_field_into_array(grid_mask_field, array, buffer_max_size, buffer_content_size);
+    write_grid_field_into_array(redundant_cell_mark_field, array, buffer_max_size, buffer_content_size);
+    for (int i = grid_vertex_fields.size()-1; i >= 0; i --)
+        grid_vertex_fields[i]->write_grid_data_into_array(array, buffer_max_size, buffer_content_size);
+    temp_int = grid_vertex_fields.size();
+    write_data_into_array_buffer(&temp_int, sizeof(int), array, buffer_max_size, buffer_content_size);
+    for (int i = grid_center_fields.size()-1; i >=0 ; i --)
+        grid_center_fields[i]->write_grid_data_into_array(array, buffer_max_size, buffer_content_size);
+    temp_int = grid_center_fields.size();
+    write_data_into_array_buffer(&temp_int, sizeof(int), array, buffer_max_size, buffer_content_size);
+    write_data_into_array_buffer(&sigma_grid_scale_factor, sizeof(double), array, buffer_max_size, buffer_content_size);
+    write_data_into_array_buffer(&sigma_grid_top_value, sizeof(double), array, buffer_max_size, buffer_content_size);
+    write_data_into_array_buffer(&level_V3D_coord_trigger_field_specified, sizeof(bool), array, buffer_max_size, buffer_content_size);    
+	write_data_into_array_buffer(&using_V3D_level_coord, sizeof(bool), array, buffer_max_size, buffer_content_size); 
+    write_data_into_array_buffer(&are_vertex_values_set_in_default, sizeof(bool), array, buffer_max_size, buffer_content_size);
+    write_data_into_array_buffer(&cyclic, sizeof(bool), array, buffer_max_size, buffer_content_size);
+    write_data_into_array_buffer(&masks_are_known, sizeof(bool), array, buffer_max_size, buffer_content_size);
+    write_data_into_array_buffer(&num_vertexes, sizeof(int), array, buffer_max_size, buffer_content_size);
+    write_data_into_array_buffer(&num_dimensions, sizeof(int), array, buffer_max_size, buffer_content_size);
+    write_data_into_array_buffer(&boundary_min_lon, sizeof(double), array, buffer_max_size, buffer_content_size);
+    write_data_into_array_buffer(&boundary_max_lon, sizeof(double), array, buffer_max_size, buffer_content_size);
+    write_data_into_array_buffer(&boundary_min_lat, sizeof(double), array, buffer_max_size, buffer_content_size);
+    write_data_into_array_buffer(&boundary_max_lat, sizeof(double), array, buffer_max_size, buffer_content_size);
+    write_data_into_array_buffer(&grid_size, sizeof(long), array, buffer_max_size, buffer_content_size);
+    write_data_into_array_buffer(decomp_name, NAME_STR_SIZE, array, buffer_max_size, buffer_content_size);
+    write_data_into_array_buffer(coord_unit, NAME_STR_SIZE, array, buffer_max_size, buffer_content_size);
+    write_data_into_array_buffer(coord_label, NAME_STR_SIZE, array, buffer_max_size, buffer_content_size);
+    write_data_into_array_buffer(grid_name, NAME_STR_SIZE, array, buffer_max_size, buffer_content_size);
+}
+
+
+void Remap_grid_class::reset_super_grids_of_setting_mask_value(Remap_grid_class *super_grid)
+{
+    for (int i = 0; i < super_grid->super_grids_of_setting_mask_value.size(); i ++)
+        this->super_grids_of_setting_mask_value.push_back(super_grid->super_grids_of_setting_mask_value[i]);
+    if (this->grid_mask_field != NULL)
+        this->super_grids_of_setting_mask_value.push_back(this);
+    for (int i = 0; i < sub_grids.size(); i ++)
+        sub_grids[i]->reset_super_grids_of_setting_mask_value(this);
 }
 
 
 Remap_grid_class::Remap_grid_class(Remap_grid_class *top_grid, const char *grid_name_suffix, const char *array, long &buffer_content_iter)
 {
-	int temp_int;
-	char temp_grid_name[NAME_STR_SIZE];
+    int temp_int;
+    char temp_grid_name[NAME_STR_SIZE];
 
-	
-	if (top_grid == NULL)
-		top_grid = this;
-	
-	initialize_grid_class_data();
+    
+    if (top_grid == NULL)
+        top_grid = this;
+    
+    initialize_grid_class_data();
 
-	read_data_from_array_buffer(grid_name, NAME_STR_SIZE, array, buffer_content_iter, true);
-	strcat(grid_name, grid_name_suffix);
-	if (remap_grid_manager->search_remap_grid_with_grid_name(grid_name) == NULL)
+    read_data_from_array_buffer(grid_name, NAME_STR_SIZE, array, buffer_content_iter, true);
+	strcat(grid_name, "_FROM_");
+    strcat(grid_name, grid_name_suffix);
+    if (remap_grid_manager->search_remap_grid_with_grid_name(grid_name) == NULL)
         remap_grid_manager->add_remap_grid(this);
-	else remap_grid_manager->add_temp_grid(this);
-	read_data_from_array_buffer(coord_label, NAME_STR_SIZE, array, buffer_content_iter, true);
-	read_data_from_array_buffer(coord_unit, NAME_STR_SIZE, array, buffer_content_iter, true);
-	read_data_from_array_buffer(decomp_name, NAME_STR_SIZE, array, buffer_content_iter, true);
-	read_data_from_array_buffer(&grid_size, sizeof(long), array, buffer_content_iter, true);
-	read_data_from_array_buffer(&boundary_max_lat, sizeof(double), array, buffer_content_iter, true);
-	read_data_from_array_buffer(&boundary_min_lat, sizeof(double), array, buffer_content_iter, true);
-	read_data_from_array_buffer(&boundary_max_lon, sizeof(double), array, buffer_content_iter, true);
-	read_data_from_array_buffer(&boundary_min_lon, sizeof(double), array, buffer_content_iter, true);
-	read_data_from_array_buffer(&num_dimensions, sizeof(int), array, buffer_content_iter, true);
-	read_data_from_array_buffer(&num_vertexes, sizeof(int), array, buffer_content_iter, true);
-	read_data_from_array_buffer(&masks_are_known, sizeof(bool), array, buffer_content_iter, true);
-	read_data_from_array_buffer(&cyclic, sizeof(bool), array, buffer_content_iter, true);
-	read_data_from_array_buffer(&are_vertex_values_set_in_default, sizeof(bool), array, buffer_content_iter, true);
-	read_data_from_array_buffer(&sigma_grid_surface_value_field_specified, sizeof(bool), array, buffer_content_iter, true);
-	read_data_from_array_buffer(&sigma_grid_top_value, sizeof(double), array, buffer_content_iter, true);
-	read_data_from_array_buffer(&sigma_grid_scale_factor, sizeof(double), array, buffer_content_iter, true);
-	read_data_from_array_buffer(&temp_int, sizeof(int), array, buffer_content_iter, true);
-	for (int i = 0; i < temp_int; i ++)
-		grid_center_fields.push_back(new Remap_grid_data_class(this, array, buffer_content_iter));
-	read_data_from_array_buffer(&temp_int, sizeof(int), array, buffer_content_iter, true);
-	for (int i = 0; i < temp_int; i ++)
-		grid_vertex_fields.push_back(new Remap_grid_data_class(this, array, buffer_content_iter));
-	read_grid_field_from_array(&redundant_cell_mark_field, array, buffer_content_iter);
-	read_grid_field_from_array(&grid_mask_field, array, buffer_content_iter);
-	read_grid_field_from_array(&sigma_grid_surface_value_field, array, buffer_content_iter);
-	read_grid_field_from_array(&sigma_grid_sigma_value_field, array, buffer_content_iter);
-	read_grid_field_from_array(&hybrid_grid_coefficient_field, array, buffer_content_iter);
-	read_grid_field_from_array(&sigma_grid_dynamic_surface_value_field, array, buffer_content_iter);
-	read_data_from_array_buffer(name_super_grid_of_setting_coord_values, NAME_STR_SIZE, array, buffer_content_iter, true);
-	read_data_from_array_buffer(name_first_super_grid_of_enable_setting_coord_value, NAME_STR_SIZE, array, buffer_content_iter, true);
-	read_data_from_array_buffer(&temp_int, sizeof(int), array, buffer_content_iter, true);
-	for (int i = 0; i < temp_int; i ++) {
-		Remap_grid_class *child_grid = new Remap_grid_class(top_grid, grid_name_suffix, array, buffer_content_iter);
-		Remap_grid_class *existing_grid = remap_grid_manager->search_remap_grid_with_grid_name(child_grid->get_grid_name());
-		sub_grids.push_back(existing_grid);
-	}
-	
-	if (this == top_grid)
-		link_grids(top_grid, grid_name_suffix);
+    else remap_grid_manager->add_temp_grid(this);
+    read_data_from_array_buffer(coord_label, NAME_STR_SIZE, array, buffer_content_iter, true);
+    read_data_from_array_buffer(coord_unit, NAME_STR_SIZE, array, buffer_content_iter, true);
+    read_data_from_array_buffer(decomp_name, NAME_STR_SIZE, array, buffer_content_iter, true);
+    read_data_from_array_buffer(&grid_size, sizeof(long), array, buffer_content_iter, true);
+    read_data_from_array_buffer(&boundary_max_lat, sizeof(double), array, buffer_content_iter, true);
+    read_data_from_array_buffer(&boundary_min_lat, sizeof(double), array, buffer_content_iter, true);
+    read_data_from_array_buffer(&boundary_max_lon, sizeof(double), array, buffer_content_iter, true);
+    read_data_from_array_buffer(&boundary_min_lon, sizeof(double), array, buffer_content_iter, true);
+    read_data_from_array_buffer(&num_dimensions, sizeof(int), array, buffer_content_iter, true);
+    read_data_from_array_buffer(&num_vertexes, sizeof(int), array, buffer_content_iter, true);
+    read_data_from_array_buffer(&masks_are_known, sizeof(bool), array, buffer_content_iter, true);
+    read_data_from_array_buffer(&cyclic, sizeof(bool), array, buffer_content_iter, true);
+    read_data_from_array_buffer(&are_vertex_values_set_in_default, sizeof(bool), array, buffer_content_iter, true);
+	read_data_from_array_buffer(&using_V3D_level_coord, sizeof(bool), array, buffer_content_iter, true);
+    read_data_from_array_buffer(&level_V3D_coord_trigger_field_specified, sizeof(bool), array, buffer_content_iter, true);
+    read_data_from_array_buffer(&sigma_grid_top_value, sizeof(double), array, buffer_content_iter, true);
+    read_data_from_array_buffer(&sigma_grid_scale_factor, sizeof(double), array, buffer_content_iter, true);
+    read_data_from_array_buffer(&temp_int, sizeof(int), array, buffer_content_iter, true);
+    for (int i = 0; i < temp_int; i ++)
+        grid_center_fields.push_back(new Remap_grid_data_class(this, array, buffer_content_iter));
+    read_data_from_array_buffer(&temp_int, sizeof(int), array, buffer_content_iter, true);
+    for (int i = 0; i < temp_int; i ++)
+        grid_vertex_fields.push_back(new Remap_grid_data_class(this, array, buffer_content_iter));
+    read_grid_field_from_array(&redundant_cell_mark_field, array, buffer_content_iter);
+    read_grid_field_from_array(&grid_mask_field, array, buffer_content_iter);
+    read_grid_field_from_array(&level_V3D_coord_trigger_field, array, buffer_content_iter);
+    read_grid_field_from_array(&sigma_grid_sigma_value_field, array, buffer_content_iter);
+    read_grid_field_from_array(&hybrid_grid_coefficient_field, array, buffer_content_iter);
+    read_grid_field_from_array(&level_V3D_coord_dynamic_trigger_field, array, buffer_content_iter);
+    read_data_from_array_buffer(name_super_grid_of_setting_coord_values, NAME_STR_SIZE, array, buffer_content_iter, true);
+    read_data_from_array_buffer(name_first_super_grid_of_enable_setting_coord_value, NAME_STR_SIZE, array, buffer_content_iter, true);
+    read_data_from_array_buffer(&temp_int, sizeof(int), array, buffer_content_iter, true);
+    for (int i = 0; i < temp_int; i ++) {
+        Remap_grid_class *child_grid = new Remap_grid_class(top_grid, grid_name_suffix, array, buffer_content_iter);
+        Remap_grid_class *existing_grid = remap_grid_manager->search_remap_grid_with_grid_name(child_grid->get_grid_name());
+        sub_grids.push_back(existing_grid);
+    }
+    
+    if (this == top_grid) {
+        link_grids(top_grid, grid_name_suffix);
+        reset_super_grids_of_setting_mask_value(top_grid);
+    }
 
-	EXECUTION_REPORT_LOG(REPORT_LOG, -1, true, "read boundary of grid \"%s\" (%lx) to %lf %lf %lf %lf", grid_name, this, boundary_min_lon, boundary_max_lon, boundary_min_lat, boundary_max_lat);
+    EXECUTION_REPORT_LOG(REPORT_LOG, -1, true, "read boundary of grid \"%s\" (%lx) to %lf %lf %lf %lf", grid_name, this, boundary_min_lon, boundary_max_lon, boundary_min_lat, boundary_max_lat);
 }
 
 
 void Remap_grid_class::link_grids(Remap_grid_class *top_grid, const char *grid_name_suffix)
 {
-	if (super_grid_of_setting_coord_values == NULL)
-		super_grid_of_setting_coord_values = get_linked_grid_from_array(top_grid, grid_name_suffix, name_super_grid_of_setting_coord_values);
-	if (first_super_grid_of_enable_setting_coord_value == NULL)
-		first_super_grid_of_enable_setting_coord_value = get_linked_grid_from_array(top_grid, grid_name_suffix, name_first_super_grid_of_enable_setting_coord_value);
-
-	if (num_dimensions == 1)
-		EXECUTION_REPORT(REPORT_ERROR, -1, first_super_grid_of_enable_setting_coord_value != NULL, "Software error in Remap_grid_class::link_grids");
-
-	for (int i = 0; i < sub_grids.size(); i ++)
-		sub_grids[i]->link_grids(top_grid, grid_name_suffix);	
-	for (int i = 0; i < grid_center_fields.size(); i ++)
-		grid_center_fields[i]->generate_grid_info(grid_center_fields[i]->coord_value_grid);
-	for (int i = 0; i < grid_vertex_fields.size(); i ++)
-		grid_vertex_fields[i]->generate_grid_info(grid_vertex_fields[i]->coord_value_grid);
-	if (grid_mask_field != NULL)
-		grid_mask_field->generate_grid_info(grid_mask_field->coord_value_grid);
-	if (imported_area != NULL)
-		imported_area->generate_grid_info(imported_area->coord_value_grid);
-	if (original_grid_mask_field != NULL)
-		original_grid_mask_field->generate_grid_info(original_grid_mask_field->coord_value_grid);
-	if (redundant_cell_mark_field != NULL)
-		redundant_cell_mark_field->generate_grid_info(redundant_cell_mark_field->coord_value_grid);
-	if (hybrid_grid_coefficient_field != NULL)
-		hybrid_grid_coefficient_field->generate_grid_info(hybrid_grid_coefficient_field->coord_value_grid);
-	if (sigma_grid_sigma_value_field != NULL)
-		sigma_grid_sigma_value_field->generate_grid_info(sigma_grid_sigma_value_field->coord_value_grid);
-	if (sigma_grid_surface_value_field != NULL)
-		sigma_grid_surface_value_field->generate_grid_info(sigma_grid_surface_value_field->coord_value_grid);
-	if (sigma_grid_dynamic_surface_value_field != NULL)
-		sigma_grid_dynamic_surface_value_field->generate_grid_info(sigma_grid_dynamic_surface_value_field->coord_value_grid);
+    if (super_grid_of_setting_coord_values == NULL)
+        super_grid_of_setting_coord_values = get_linked_grid_from_array(top_grid, grid_name_suffix, name_super_grid_of_setting_coord_values);
+    if (first_super_grid_of_enable_setting_coord_value == NULL)
+        first_super_grid_of_enable_setting_coord_value = get_linked_grid_from_array(top_grid, grid_name_suffix, name_first_super_grid_of_enable_setting_coord_value);
+
+    if (num_dimensions == 1)
+        EXECUTION_REPORT(REPORT_ERROR, -1, first_super_grid_of_enable_setting_coord_value != NULL, "Software error in Remap_grid_class::link_grids");
+
+    for (int i = 0; i < sub_grids.size(); i ++)
+        sub_grids[i]->link_grids(top_grid, grid_name_suffix);    
+    for (int i = 0; i < grid_center_fields.size(); i ++)
+        grid_center_fields[i]->generate_grid_info(grid_center_fields[i]->coord_value_grid);
+    for (int i = 0; i < grid_vertex_fields.size(); i ++)
+        grid_vertex_fields[i]->generate_grid_info(grid_vertex_fields[i]->coord_value_grid);
+    if (grid_mask_field != NULL)
+        grid_mask_field->generate_grid_info(grid_mask_field->coord_value_grid);
+    if (imported_area != NULL)
+        imported_area->generate_grid_info(imported_area->coord_value_grid);
+    if (original_grid_mask_field != NULL)
+        original_grid_mask_field->generate_grid_info(original_grid_mask_field->coord_value_grid);
+    if (redundant_cell_mark_field != NULL)
+        redundant_cell_mark_field->generate_grid_info(redundant_cell_mark_field->coord_value_grid);
+    if (hybrid_grid_coefficient_field != NULL)
+        hybrid_grid_coefficient_field->generate_grid_info(hybrid_grid_coefficient_field->coord_value_grid);
+    if (sigma_grid_sigma_value_field != NULL)
+        sigma_grid_sigma_value_field->generate_grid_info(sigma_grid_sigma_value_field->coord_value_grid);
+    if (level_V3D_coord_trigger_field != NULL)
+        level_V3D_coord_trigger_field->generate_grid_info(level_V3D_coord_trigger_field->coord_value_grid);
+    if (level_V3D_coord_dynamic_trigger_field != NULL)
+        level_V3D_coord_dynamic_trigger_field->generate_grid_info(level_V3D_coord_dynamic_trigger_field->coord_value_grid);
 }
 
 
 bool Remap_grid_class::is_sub_grid_of_grid(Remap_grid_class *another_grid)
 {
-	if (this == another_grid) {
-		EXECUTION_REPORT_LOG(REPORT_LOG, -1, true, "qiguai %s %lx", this->get_grid_name(), this);
-		return true;
-	}
+    if (this == another_grid)
+        return true;
 
-	EXECUTION_REPORT_LOG(REPORT_LOG, -1, true, "compare %s vs %s %d %d", this->get_grid_name(), another_grid->get_grid_name(), another_grid->sub_grids.size(), another_grid->get_num_dimensions());
+    EXECUTION_REPORT_LOG(REPORT_LOG, -1, true, "compare %s vs %s %d %d", this->get_grid_name(), another_grid->get_grid_name(), another_grid->sub_grids.size(), another_grid->get_num_dimensions());
 
-	for (int i = 0; i < another_grid->sub_grids.size(); i ++)
-		if (is_subset_of_grid(another_grid->sub_grids[i]))
-			return true;
-	return false;
+    for (int i = 0; i < another_grid->sub_grids.size(); i ++)
+        if (is_subset_of_grid(another_grid->sub_grids[i]))
+            return true;
+    return false;
 }
 
 
 bool Remap_grid_class::format_sub_grids(Remap_grid_class *top_grid)
 {
-	std::vector<Remap_grid_class *> formated_sub_grids;	
-	std::vector<int> last_grid_ids;
-	int i, j;
-	
+    std::vector<Remap_grid_class *> formated_sub_grids;    
+    std::vector<int> last_grid_ids;
+    int i, j;
+    
 
-	formated_sub_grids.clear();
-	last_grid_ids.clear();
-	for (i = 0; i < sub_grids.size(); i ++) {
-		for (j = 0; j < formated_sub_grids.size(); j ++)
-			if (sub_grids[i]->is_subset_of_grid(formated_sub_grids[j]))
-				break;
-		if (j < formated_sub_grids.size() && last_grid_ids[j]+1 != i)
-			return false;
-		if (j == formated_sub_grids.size()) {
-			if (sub_grids[i]->super_grid_of_setting_coord_values == NULL || sub_grids[i]->super_grid_of_setting_coord_values->is_sub_grid_of_grid(top_grid))
-				formated_sub_grids.push_back(sub_grids[i]);
-			else formated_sub_grids.push_back(sub_grids[i]->super_grid_of_setting_coord_values);
-			last_grid_ids.push_back(i);
-		}
-	}
+    formated_sub_grids.clear();
+    last_grid_ids.clear();
+    for (i = 0; i < sub_grids.size(); i ++) {
+        for (j = 0; j < formated_sub_grids.size(); j ++)
+            if (sub_grids[i]->is_subset_of_grid(formated_sub_grids[j]))
+                break;
+        if (j < formated_sub_grids.size() && last_grid_ids[j]+1 != i)
+            return false;
+        if (j == formated_sub_grids.size()) {
+            if (sub_grids[i]->super_grid_of_setting_coord_values == NULL || sub_grids[i]->super_grid_of_setting_coord_values->is_sub_grid_of_grid(top_grid))
+                formated_sub_grids.push_back(sub_grids[i]);
+            else formated_sub_grids.push_back(sub_grids[i]->super_grid_of_setting_coord_values);
+            last_grid_ids.push_back(i);
+        }
+    }
 
-	sub_grids.clear();
-	for (j = 0; j < formated_sub_grids.size(); j ++)
-		sub_grids.push_back(formated_sub_grids[j]);
+    sub_grids.clear();
+    for (j = 0; j < formated_sub_grids.size(); j ++)
+        sub_grids.push_back(formated_sub_grids[j]);
 
-	for (int i = 0; i < sub_grids.size(); i ++)
-		if (!sub_grids[i]->format_sub_grids(top_grid))
-			return false;
+    for (int i = 0; i < sub_grids.size(); i ++)
+        if (!sub_grids[i]->format_sub_grids(top_grid))
+            return false;
 
-	return true;
+    return true;
 }
 
 
 Remap_grid_class *Remap_grid_class::search_sub_grid(const char *grid_name)
 {
-	if (words_are_the_same(this->grid_name, grid_name))
-		return this;
+    if (words_are_the_same(this->grid_name, grid_name))
+        return this;
 
-	for (int i = 0; i < sub_grids.size(); i ++) {
-		Remap_grid_class *required_grid = sub_grids[i]->search_sub_grid(grid_name);
-		if (required_grid != NULL)
-			return required_grid;
-	}
+    for (int i = 0; i < sub_grids.size(); i ++) {
+        Remap_grid_class *required_grid = sub_grids[i]->search_sub_grid(grid_name);
+        if (required_grid != NULL)
+            return required_grid;
+    }
 
-	return NULL;
+    return NULL;
 }
 
 
 Remap_grid_class *Remap_grid_class::get_sphere_sub_grid()
 {
-	if (get_is_sphere_grid())
-		return this;
+    if (get_is_sphere_grid())
+        return this;
 
-	for (int i = 0; i < sub_grids.size(); i ++)
-		if (sub_grids[i]->get_sphere_sub_grid() != NULL)
-			return sub_grids[i]->get_sphere_sub_grid();
+    for (int i = 0; i < sub_grids.size(); i ++)
+        if (sub_grids[i]->get_sphere_sub_grid() != NULL)
+            return sub_grids[i]->get_sphere_sub_grid();
 
-	return NULL;
+    return NULL;
 }
 
 
 Remap_grid_data_class *Remap_grid_class::generate_mid_point_grid_field(Remap_grid_data_class *interface_level_grid_field)
 {
-	Remap_grid_data_class *mid_point_grid_field = interface_level_grid_field->duplicate_grid_data_field(mid_point_grid, 1, false, false);
-	EXECUTION_REPORT(REPORT_ERROR, -1, words_are_the_same(mid_point_grid_field->get_grid_data_field()->data_type_in_application, DATA_TYPE_DOUBLE), "Software error in Remap_grid_class::generate_mid_point_grid_field: wrong data type");
-	for (int i = 0; i < mid_point_grid->grid_size; i ++)
-		((double*)mid_point_grid_field->get_grid_data_field()->data_buf)[i] = (((double*)interface_level_grid_field->get_grid_data_field()->data_buf)[i]+((double*)interface_level_grid_field->get_grid_data_field()->data_buf)[i+1]) / 2; 
+    Remap_grid_data_class *mid_point_grid_field = interface_level_grid_field->duplicate_grid_data_field(mid_point_grid, 1, false, false);
+    EXECUTION_REPORT(REPORT_ERROR, -1, words_are_the_same(mid_point_grid_field->get_grid_data_field()->data_type_in_application, DATA_TYPE_DOUBLE), "Software error in Remap_grid_class::generate_mid_point_grid_field: wrong data type");
+    for (int i = 0; i < mid_point_grid->grid_size; i ++)
+        ((double*)mid_point_grid_field->get_grid_data_field()->data_buf)[i] = (((double*)interface_level_grid_field->get_grid_data_field()->data_buf)[i]+((double*)interface_level_grid_field->get_grid_data_field()->data_buf)[i+1]) / 2; 
 
-	return mid_point_grid_field;
+    return mid_point_grid_field;
 }
 
 
 Remap_grid_class *Remap_grid_class::generate_mid_point_grid()
 {
-	EXECUTION_REPORT(REPORT_ERROR, -1, this->num_dimensions == 1 && has_grid_coord_label(COORD_LABEL_LEV), "Software error in Remap_grid_class::generate_mid_point_grid: not a V1D grid");
-	EXECUTION_REPORT(REPORT_ERROR, -1, this->interface_level_grid == NULL, "Software error in Remap_grid_class::generate_mid_point_grid: for mid-point grid of a mid-point grid");
-	if (this->mid_point_grid != NULL)
-		return this->mid_point_grid;
+    EXECUTION_REPORT(REPORT_ERROR, -1, this->num_dimensions == 1 && has_grid_coord_label(COORD_LABEL_LEV), "Software error in Remap_grid_class::generate_mid_point_grid: not a V1D grid");
+    EXECUTION_REPORT(REPORT_ERROR, -1, this->interface_level_grid == NULL, "Software error in Remap_grid_class::generate_mid_point_grid: for mid-point grid of a mid-point grid");
+    if (this->mid_point_grid != NULL)
+        return this->mid_point_grid;
 
-	mid_point_grid = duplicate_grid(this);
-	mid_point_grid->interface_level_grid = this;
-	mid_point_grid->grid_size = this->grid_size - 1;
+    mid_point_grid = duplicate_grid(this);
+    mid_point_grid->interface_level_grid = this;
+    mid_point_grid->grid_size = this->grid_size - 1;
     mid_point_grid->first_super_grid_of_enable_setting_coord_value = mid_point_grid;
-	if (this->super_grid_of_setting_coord_values != NULL)
-	    mid_point_grid->super_grid_of_setting_coord_values = mid_point_grid;
-	sprintf(mid_point_grid->grid_name, "mid_point_grid_for_%s", this->grid_name);
-	if (this->grid_center_fields.size() == 1) {
-		delete mid_point_grid->grid_center_fields[0];
-		mid_point_grid->grid_center_fields[0] = this->generate_mid_point_grid_field(this->grid_center_fields[0]);
-	}
-	if (this->sigma_grid_sigma_value_field != NULL) {
-		delete mid_point_grid->sigma_grid_sigma_value_field;
-		mid_point_grid->sigma_grid_sigma_value_field = this->generate_mid_point_grid_field(this->sigma_grid_sigma_value_field);
-	}
-	if (this->hybrid_grid_coefficient_field != NULL) {
-		delete mid_point_grid->hybrid_grid_coefficient_field;
-		mid_point_grid->hybrid_grid_coefficient_field = this->generate_mid_point_grid_field(this->hybrid_grid_coefficient_field);
-	}
-	if (mid_point_grid->grid_vertex_fields.size() == 1) {
-		delete mid_point_grid->grid_vertex_fields[0];
-		mid_point_grid->grid_vertex_fields.clear();
-	}
+    sprintf(mid_point_grid->grid_name, "mid_point_grid_for_%s", this->grid_name);
+    if (this->grid_center_fields.size() == 1) {
+        delete mid_point_grid->grid_center_fields[0];
+        mid_point_grid->grid_center_fields[0] = this->generate_mid_point_grid_field(this->grid_center_fields[0]);
+    }
+    if (this->sigma_grid_sigma_value_field != NULL) {
+        delete mid_point_grid->sigma_grid_sigma_value_field;
+        mid_point_grid->sigma_grid_sigma_value_field = this->generate_mid_point_grid_field(this->sigma_grid_sigma_value_field);
+    }
+    if (this->hybrid_grid_coefficient_field != NULL) {
+        delete mid_point_grid->hybrid_grid_coefficient_field;
+        mid_point_grid->hybrid_grid_coefficient_field = this->generate_mid_point_grid_field(this->hybrid_grid_coefficient_field);
+    }
+    if (mid_point_grid->grid_vertex_fields.size() == 1) {
+        delete mid_point_grid->grid_vertex_fields[0];
+        mid_point_grid->grid_vertex_fields.clear();
+    }
 
-	return mid_point_grid;
+    return mid_point_grid;
 }
 
diff --git a/src/CoR/remap_grid_class.h b/src/CoR/remap_grid_class.h
old mode 100644
new mode 100755
index 9d49991..e48dc99
--- a/src/CoR/remap_grid_class.h
+++ b/src/CoR/remap_grid_class.h
@@ -39,6 +39,7 @@
 #define GRID_FIELD_ATTRIBUTE_UNIT             "unit"
 #define SPHERE_GRID_ROTATION_LAT_THRESHOLD    ((double) 70.0)
 
+#define V3D_GRID_3D_LEVEL_FIELD_NAME          "V3D_grid_3D_level_field"
 
 class Runtime_remap_function;
 class Remap_grid_data_class;
@@ -68,7 +69,7 @@ class Remap_grid_class
     private:
         friend class Runtime_remap_function;
         friend class Remap_operator_grid;
-		char decomp_name[NAME_STR_SIZE];
+        char decomp_name[NAME_STR_SIZE];
         char grid_name[NAME_STR_SIZE];
         char coord_label[NAME_STR_SIZE];
         char coord_unit[NAME_STR_SIZE];
@@ -76,21 +77,21 @@ class Remap_grid_class
         int num_dimensions;
         int num_vertexes;
         Remap_grid_class *whole_grid;
-		Remap_grid_class *mid_point_grid;
-		Remap_grid_class *interface_level_grid;
+        Remap_grid_class *mid_point_grid;
+        Remap_grid_class *interface_level_grid;
         std::vector<Partial_area *> partial_areas;
         Remap_grid_class *super_grid_of_setting_coord_values;
-		char name_super_grid_of_setting_coord_values[NAME_STR_SIZE];
+        char name_super_grid_of_setting_coord_values[NAME_STR_SIZE];
         Remap_grid_class *first_super_grid_of_enable_setting_coord_value;
-		char name_first_super_grid_of_enable_setting_coord_value[NAME_STR_SIZE];
+        char name_first_super_grid_of_enable_setting_coord_value[NAME_STR_SIZE];
         Remap_grid_class *duplicated_grid;
         Remap_grid_class *original_grid;
-		bool generated_from_duplication;
+        bool generated_from_duplication;
         std::vector<Remap_grid_class *> sub_grids;
         std::vector<Remap_grid_data_class *> grid_center_fields;
         std::vector<Remap_grid_data_class *> grid_vertex_fields;
         Remap_grid_data_class *grid_mask_field;
-		Remap_grid_data_class *imported_area;
+        Remap_grid_data_class *imported_area;
         std::vector<Remap_grid_class *> super_grids_of_setting_mask_value; 
         Remap_grid_data_class *original_grid_mask_field;
         bool masks_are_known;        
@@ -100,17 +101,18 @@ class Remap_grid_class
         Remap_grid_data_class *redundant_cell_mark_field;
         bool *redundant_cell_mark;
         double *area_or_volumn;
-		double boundary_min_lon;
-		double boundary_max_lon;
-		double boundary_max_lat;
-		double boundary_min_lat;
-		Remap_grid_data_class *hybrid_grid_coefficient_field;
-		Remap_grid_data_class *sigma_grid_sigma_value_field;
-		Remap_grid_data_class *sigma_grid_surface_value_field;
-		double sigma_grid_top_value;
-		double sigma_grid_scale_factor;
-		bool sigma_grid_surface_value_field_specified;
-		Remap_grid_data_class *sigma_grid_dynamic_surface_value_field;
+        double boundary_min_lon;
+        double boundary_max_lon;
+        double boundary_max_lat;
+        double boundary_min_lat;
+		bool using_V3D_level_coord;
+        Remap_grid_data_class *hybrid_grid_coefficient_field;
+        Remap_grid_data_class *sigma_grid_sigma_value_field;
+        Remap_grid_data_class *level_V3D_coord_trigger_field;
+        double sigma_grid_top_value;
+        double sigma_grid_scale_factor;
+        bool level_V3D_coord_trigger_field_specified;
+        Remap_grid_data_class *level_V3D_coord_dynamic_trigger_field;
         
 
         /* Functions of checking the coordinate values of grid */
@@ -127,7 +129,7 @@ class Remap_grid_class
         void formalize_sphere_grid();
 
         /* Functions of setting default coordinate values of grid */
-		void generate_voronoi_grid();
+        void generate_voronoi_grid();
         void set_1D_coord_vertex_values_in_default(const double*, double*, long, bool, bool);
         void set_2D_coord_vertex_values_in_default(const double*, double*, long, bool, bool, const double*, double*, long, bool, bool);
 
@@ -149,7 +151,8 @@ class Remap_grid_class
 
         void calculate_area_of_sphere_grid();
         void calculate_area_or_volumn();
-		void generate_default_grid_mask();
+        void generate_default_grid_mask();
+        void reset_super_grids_of_setting_mask_value(Remap_grid_class *);
 
     public:
 
@@ -159,7 +162,7 @@ class Remap_grid_class
         Remap_grid_class(const char*, int, Remap_grid_class**, long);
         Remap_grid_class(Remap_grid_class*, Remap_grid_class*, Remap_grid_class*, bool);
         Remap_grid_class(const char*, const char*);
-		Remap_grid_class(const char*, const char*, const char*);
+        Remap_grid_class(const char*, const char*, const char*);
         ~Remap_grid_class();
 
         /* Functions of getting grid properties or data */
@@ -169,25 +172,27 @@ class Remap_grid_class
         const char *get_grid_name() const { return grid_name; }
         const char *get_coord_label() const { return coord_label; }
         const char *get_coord_unit() const { return coord_unit; }
-		const char *get_decomp_name() const { return decomp_name; }
-		void set_decomp_name(const char*);
+        const char *get_decomp_name() const { return decomp_name; }
+        void set_decomp_name(const char*);
         bool get_grid_cyclic() const { return cyclic; }
+		void allocate_default_center_field();
         Remap_grid_data_class *get_grid_mask_field() const { return grid_mask_field; }
-		Remap_grid_data_class *get_grid_imported_area() const { return imported_area; }
+        Remap_grid_data_class *get_grid_imported_area() const { return imported_area; }
         bool get_are_vertex_values_set_in_default() const { return are_vertex_values_set_in_default; }
         const Remap_grid_class *get_whole_grid() const { return whole_grid; }
         Remap_grid_class *get_super_grid_of_setting_coord_values() const { return super_grid_of_setting_coord_values; }
+		void set_super_grid_of_setting_coord_values(Remap_grid_class *super_grid) { super_grid_of_setting_coord_values = super_grid; }
         Remap_grid_class *get_first_super_grid_of_enable_setting_coord_value() { return first_super_grid_of_enable_setting_coord_value; }
         void get_leaf_grids(int *, Remap_grid_class**, const Remap_grid_class*) const;
-		Remap_grid_class *get_a_leaf_grid_of_sigma_or_hybrid();
-		Remap_grid_class *get_a_leaf_grid(const char*);
+        Remap_grid_class *get_a_leaf_grid_of_sigma_or_hybrid();
+        Remap_grid_class *get_a_leaf_grid(const char*);
         void get_sized_sub_grids(int*, Remap_grid_class**);
         void get_masked_sub_grids(int*, Remap_grid_class**);
         void get_partial_grid_mask_fields(int*, Remap_grid_data_class**, Remap_grid_class*);
         void get_grid_index_interchange_table(Remap_grid_class*, int*);
         bool is_partial_grid() const;
-		Remap_grid_class *get_original_grid() { return original_grid; }
-		Remap_grid_data_class *get_grid_center_field(const char*) const;
+        Remap_grid_class *get_original_grid() { return original_grid; }
+        Remap_grid_data_class *get_grid_center_field(const char*) const;
         Remap_grid_data_class *get_grid_center_field() const;
         Remap_grid_data_class *get_grid_vertex_field() const;
         bool has_grid_coord_label(const char*) const;
@@ -197,9 +202,9 @@ class Remap_grid_class
 
         /* Functions of getting grids relation */
         bool match_grid(const char*) const;
-		bool match_grid(int, Remap_grid_class**);
+        bool match_grid(int, Remap_grid_class**);
         void read_grid_data_from_IO(char extension_names[16][256], const char*, const char*, int);
-		void read_grid_data_from_array(const char*, const char*, const char*, const char*, int);
+        void read_grid_data_from_array(const char*, const char*, const char*, const char*, int);
         void read_grid_data_through_span(char[16][256], const char*, const char*, long, const char*);
         void extract_mask(const char*, const char*, const char*);
         void compute_ocn_mask(const char*, double);
@@ -224,53 +229,57 @@ class Remap_grid_class
         void interchange_grid_fields_for_remapping(Remap_grid_class*, Remap_grid_class*, Remap_grid_data_class *);
         Remap_grid_class *duplicate_grid(Remap_grid_class*);
         Remap_grid_class *generate_decomp_grid(const int*, int, const char*);
-		void generate_3D_grid_decomp_sigma_values(Remap_grid_class*, Remap_grid_class*, const int*, int);
+        void generate_3D_grid_decomp_sigma_values(Remap_grid_class*, Remap_grid_class*, const int*, int);
         void gen_lev_coord_from_sigma_or_hybrid(char extension_names[16][256], const char*, const char*, const char*, const char*, double);
-		void calculate_lev_sigma_values();
-		bool is_sigma_grid();
-		Remap_grid_data_class *get_sigma_grid_sigma_value_field();
-		Remap_grid_data_class *get_hybrid_grid_coefficient_field() { return hybrid_grid_coefficient_field; }
-		Remap_grid_data_class *get_sigma_grid_surface_value_field() { return sigma_grid_surface_value_field; }
-		bool is_sigma_grid_surface_value_field_specified() { return sigma_grid_surface_value_field_specified; }
-		void allocate_sigma_grid_specific_fields(Remap_grid_data_class*, Remap_grid_data_class*, Remap_grid_data_class*, double, double);
-		void set_sigma_grid_dynamic_surface_value_field(Remap_grid_data_class *); 
-		Remap_grid_data_class *get_sigma_grid_dynamic_surface_value_field() { return sigma_grid_dynamic_surface_value_field; }
-		bool is_sigma_grid_surface_value_field_updated();
-		void copy_sigma_grid_surface_value_field(Remap_grid_data_class*);
-		void set_lev_grid_sigma_info(const char*, double, double, const char*);
-		void set_lev_grid_sigma_info(double, const double *, const double *, double);
-		double get_sigma_grid_top_value() { return sigma_grid_top_value; }
-		void renew_lev_grid_coord_values(double*, double*);
-		bool has_super_grids_of_setting_mask_value() { return super_grids_of_setting_mask_value.size() > 0; }
-		void set_original_grid(Remap_grid_class *grid) { original_grid = grid; }
+        void calculate_lev_sigma_values();
+		void update_grid_center_3D_level_field_from_external();
+        bool is_sigma_grid();
+		bool does_use_V3D_level_coord();
+		void set_using_V3D_level_coord();
+        Remap_grid_data_class *get_sigma_grid_sigma_value_field();
+        Remap_grid_data_class *get_hybrid_grid_coefficient_field() { return hybrid_grid_coefficient_field; }
+        Remap_grid_data_class *get_level_V3D_coord_trigger_field() { return level_V3D_coord_trigger_field; }
+        bool is_level_V3D_coord_trigger_field_specified() { return level_V3D_coord_trigger_field_specified; }
+        void allocate_sigma_grid_specific_fields(Remap_grid_data_class*, Remap_grid_data_class*, Remap_grid_data_class*, double, double);
+        void set_level_V3D_coord_dynamic_trigger_field(Remap_grid_data_class *); 
+        Remap_grid_data_class *get_level_V3D_coord_dynamic_trigger_field() { return level_V3D_coord_dynamic_trigger_field; }
+        bool is_level_V3D_coord_trigger_field_updated();
+        void set_lev_grid_sigma_info(const char*, double, double, const char*);
+        void set_lev_grid_sigma_info(double, const double *, const double *, double);
+        double get_sigma_grid_top_value() { return sigma_grid_top_value; }
+        void renew_lev_grid_coord_values(double*, double*);
+        bool has_super_grids_of_setting_mask_value() { return super_grids_of_setting_mask_value.size() > 0; }
+        void set_original_grid(Remap_grid_class *grid) { original_grid = grid; }
 
         /* Function for checking coordinate values consistency with coupler */
         bool check_coord_values_consistency(const char*, const char*, const void*);
         bool check_mask_values_consitency(const char*, const void*);
 
-		void set_grid_boundary(double, double, double, double);
-
-		Remap_grid_data_class *get_unique_center_field();
-		Remap_grid_data_class *get_unique_vertex_field();
-
-        void set_coord_vertex_values_in_default();		
-		void write_grid_field_into_array(Remap_grid_data_class *, char **, long&, long&);
-		void read_grid_field_from_array(Remap_grid_data_class **, const char *, long &);
-		Remap_grid_class *get_linked_grid_from_array(Remap_grid_class *, const char *, char *);
-		void link_grids(Remap_grid_class *, const char *);
-		void write_grid_name_into_array(Remap_grid_class *, char **, long &, long &);
-		void write_grid_into_array(char **, long &, long &);
-		bool format_sub_grids(Remap_grid_class *);
-		bool is_sub_grid_of_grid(Remap_grid_class *);
-		Remap_grid_class *search_sub_grid(const char*);
-		Remap_grid_class *get_sphere_sub_grid();
-		Remap_grid_class(Remap_grid_class*, const char *, const char *, long &);
-		Remap_grid_data_class *generate_mid_point_grid_field(Remap_grid_data_class *);
-		Remap_grid_class *generate_mid_point_grid();
-		double get_boundary_min_lon() { return boundary_min_lon; }
-		double get_boundary_max_lon() { return boundary_max_lon; }
-		double get_boundary_min_lat() { return boundary_min_lat; }
-		double get_boundary_max_lat() { return boundary_max_lat; }
+        void set_grid_boundary(double, double, double, double);
+
+        Remap_grid_data_class *get_unique_center_field();
+        Remap_grid_data_class *get_unique_vertex_field();
+
+        void set_coord_vertex_values_in_default();        
+        void write_grid_field_into_array(Remap_grid_data_class *, char **, long&, long&);
+        void read_grid_field_from_array(Remap_grid_data_class **, const char *, long &);
+        Remap_grid_class *get_linked_grid_from_array(Remap_grid_class *, const char *, char *);
+        void link_grids(Remap_grid_class *, const char *);
+        void write_grid_name_into_array(Remap_grid_class *, char **, long &, long &);
+        void write_grid_into_array(char **, long &, long &);
+        bool format_sub_grids(Remap_grid_class *);
+        bool is_sub_grid_of_grid(Remap_grid_class *);
+        Remap_grid_class *search_sub_grid(const char*);
+        Remap_grid_class *get_sphere_sub_grid();
+        Remap_grid_class(Remap_grid_class*, const char *, const char *, long &);
+        Remap_grid_data_class *generate_mid_point_grid_field(Remap_grid_data_class *);
+        Remap_grid_class *generate_mid_point_grid();
+		Remap_grid_class *get_mid_point_grid() { return mid_point_grid; }
+		void set_mid_point_grid(Remap_grid_class *mid_point_grid) { this->mid_point_grid = mid_point_grid; }
+        double get_boundary_min_lon() { return boundary_min_lon; }
+        double get_boundary_max_lon() { return boundary_max_lon; }
+        double get_boundary_min_lat() { return boundary_min_lat; }
+        double get_boundary_max_lat() { return boundary_max_lat; }
 };
 
 #endif
diff --git a/src/CoR/remap_grid_data_class.cxx b/src/CoR/remap_grid_data_class.cxx
old mode 100644
new mode 100755
index d1ee111..ee72e59
--- a/src/CoR/remap_grid_data_class.cxx
+++ b/src/CoR/remap_grid_data_class.cxx
@@ -31,6 +31,8 @@ Remap_grid_data_class::Remap_grid_data_class(Remap_grid_class *coord_value_grid,
 {
     this->grid_data_field = grid_data_field;
     generate_grid_info(coord_value_grid);
+	if (coord_value_grid != NULL)
+		EXECUTION_REPORT_LOG(REPORT_LOG, -1, true, "allocate field data regarding to grid \"%s\" with size %ld", coord_value_grid->get_grid_name(), grid_data_field->required_data_size*get_data_type_size(grid_data_field->data_type_in_application));
 }
 
 
@@ -73,7 +75,7 @@ Remap_grid_data_class::Remap_grid_data_class(const char *field_data_name,
     grid_data_field->data_buf = new char[num_value_points*get_data_type_size(grid_data_type)];
     grid_data_field->required_data_size = num_value_points;
     grid_data_field->read_data_size = num_value_points;
-	coord_value_grid = NULL;
+    coord_value_grid = NULL;
     if (grid_name != NULL) {
         EXECUTION_REPORT(REPORT_ERROR, -1, num_value_points == remap_grid_manager->search_remap_grid_with_grid_name(grid_name)->get_grid_size(),
                      "the size of span array must be the same as the size of grid \"%s\"\n",
@@ -136,8 +138,42 @@ void Remap_grid_data_class::generate_data_field_info(const char *field_data_name
 }
 
 
+void Remap_grid_data_class::set_masked_cell_to_missing_value()
+{
+    if (coord_value_grid == NULL || coord_value_grid->get_grid_mask_field() == NULL)
+        return;
+
+    if (!words_are_the_same(grid_data_field->data_type_in_application, DATA_TYPE_FLOAT) && !words_are_the_same(grid_data_field->data_type_in_application, DATA_TYPE_DOUBLE))
+        return;
+
+	coord_value_grid->get_grid_mask_field()->interchange_grid_data(coord_value_grid->get_grid_mask_field()->get_coord_value_grid());
+	this->interchange_grid_data(coord_value_grid->get_grid_mask_field()->get_coord_value_grid());
+
+	long mask_size = coord_value_grid->get_grid_mask_field()->grid_data_field->required_data_size;
+    bool *mask = (bool*) coord_value_grid->get_grid_mask_field()->grid_data_field->data_buf;
+    if (words_are_the_same(grid_data_field->data_type_in_application, DATA_TYPE_FLOAT)) {
+		for (int j = 0; j < grid_data_field->required_data_size/mask_size; j ++) {
+	        float *data_buf = ((float*) grid_data_field->data_buf) + mask_size*j;
+	        for (int i = 0; i < mask_size; i ++)
+    	        if (!mask[i])
+        	        data_buf[i] = (float) DEFAULT_FILL_VALUE;
+		}
+    }
+    else {
+		for (int j = 0; j < grid_data_field->required_data_size/mask_size; j ++) {
+	        double *data_buf = ((double*) grid_data_field->data_buf) + mask_size*j;
+	        for (int i = 0; i < mask_size; i ++)
+	            if (!mask[i])
+	                data_buf[i] = (double) DEFAULT_FILL_VALUE;        
+		}
+    }
+}
+
+
 Remap_grid_data_class::~Remap_grid_data_class()
 {
+	if (coord_value_grid != NULL)
+		EXECUTION_REPORT_LOG(REPORT_LOG, -1, true, "deallocate field data regarding to grid \"%s\" with size %ld", coord_value_grid->get_grid_name(), grid_data_field->required_data_size*get_data_type_size(grid_data_field->data_type_in_application));
     delete grid_data_field;
 }
 
@@ -152,13 +188,13 @@ Remap_grid_data_class *Remap_grid_data_class::duplicate_grid_data_field(Remap_gr
 
 
     if (copy_data) {
-		if (coord_value_grid != NULL)
-	        EXECUTION_REPORT(REPORT_ERROR, -1, associative_grid->get_grid_size() == coord_value_grid->get_grid_size(), "remap software error1 in duplicate_grid_data_field\n");
-		else {
-			EXECUTION_REPORT(REPORT_ERROR, -1, associative_grid->get_grid_size() == grid_data_field->required_data_size, "remap software error1 in duplicate_grid_data_field\n");
-			EXECUTION_REPORT(REPORT_ERROR, -1, associative_grid->get_num_dimensions() == 1, "When copy none-grided field %s to a grided field, the grid %s of the grided field must be 1D grid", 
-							 grid_data_field->field_name_in_application, associative_grid->get_grid_name());
-		}
+        if (coord_value_grid != NULL)
+            EXECUTION_REPORT(REPORT_ERROR, -1, associative_grid->get_grid_size() == coord_value_grid->get_grid_size(), "remap software error1 in duplicate_grid_data_field\n");
+        else {
+            EXECUTION_REPORT(REPORT_ERROR, -1, associative_grid->get_grid_size() == grid_data_field->required_data_size, "remap software error1 in duplicate_grid_data_field\n");
+            EXECUTION_REPORT(REPORT_ERROR, -1, associative_grid->get_num_dimensions() == 1, "When copy none-grided field %s to a grided field, the grid %s of the grided field must be 1D grid", 
+                             grid_data_field->field_name_in_application, associative_grid->get_grid_name());
+        }
     }
     EXECUTION_REPORT(REPORT_ERROR, -1, associative_grid->get_whole_grid() == NULL, "remap software error2 duplicate_grid_data_field\n");
 
@@ -248,7 +284,7 @@ void Remap_grid_data_class::reset_sized_grids(int num_sized_grids, Remap_grid_cl
         grid_size *= sized_grids[i]->get_grid_size();
     }
 
-    EXECUTION_REPORT(REPORT_ERROR, -1, grid_data_field->required_data_size%grid_size == 0, "remap software error2 in reset_sized_grids\n");    
+    EXECUTION_REPORT(REPORT_ERROR, -1, grid_data_field->required_data_size%grid_size == 0, "remap software error2 in reset_sized_grids %ld vs %ld\n", grid_data_field->required_data_size, grid_size);    
 }
 
 
@@ -282,11 +318,11 @@ void Remap_grid_data_class::transfer_field_attributes_to_another(Remap_grid_data
     if (another_field->have_data_content())
         return;
 
-	if (words_are_the_same(another_field->grid_data_field->field_name_in_IO_file, "\0"))
-	    strcpy(another_field->grid_data_field->field_name_in_IO_file, this->grid_data_field->field_name_in_IO_file);
+    if (words_are_the_same(another_field->grid_data_field->field_name_in_IO_file, "\0"))
+        strcpy(another_field->grid_data_field->field_name_in_IO_file, this->grid_data_field->field_name_in_IO_file);
     strcpy(another_field->grid_data_field->data_type_in_IO_file, this->grid_data_field->data_type_in_IO_file);
 
-	another_field->grid_data_field->field_attributes.clear();
+    another_field->grid_data_field->field_attributes.clear();
     for (int i = 0; i < this->grid_data_field->field_attributes.size(); i ++)
         another_field->grid_data_field->field_attributes.push_back(this->grid_data_field->field_attributes[i]);
 }
@@ -437,27 +473,27 @@ void Remap_grid_data_class::change_datatype_in_application(const char* new_datat
 
 void Remap_grid_data_class::write_grid_data_into_array(char **array, long &buffer_max_size, long &buffer_content_size)
 {
-	write_data_into_array_buffer(grid_data_field->data_buf, grid_data_field->required_data_size*get_data_type_size(grid_data_field->data_type_in_application), array, buffer_max_size, buffer_content_size);
-	write_data_into_array_buffer(&(grid_data_field->read_data_size), sizeof(long), array, buffer_max_size, buffer_content_size);
-	write_data_into_array_buffer(&(grid_data_field->required_data_size), sizeof(long), array, buffer_max_size, buffer_content_size);
-	write_data_into_array_buffer(grid_data_field->data_type_in_IO_file, NAME_STR_SIZE, array, buffer_max_size, buffer_content_size);
-	write_data_into_array_buffer(grid_data_field->data_type_in_application, NAME_STR_SIZE, array, buffer_max_size, buffer_content_size);
-	write_data_into_array_buffer(grid_data_field->field_name_in_IO_file, NAME_STR_SIZE, array, buffer_max_size, buffer_content_size);
-	write_data_into_array_buffer(grid_data_field->field_name_in_application, NAME_STR_SIZE, array, buffer_max_size, buffer_content_size);
+    write_data_into_array_buffer(grid_data_field->data_buf, grid_data_field->required_data_size*get_data_type_size(grid_data_field->data_type_in_application), array, buffer_max_size, buffer_content_size);
+    write_data_into_array_buffer(&(grid_data_field->read_data_size), sizeof(long), array, buffer_max_size, buffer_content_size);
+    write_data_into_array_buffer(&(grid_data_field->required_data_size), sizeof(long), array, buffer_max_size, buffer_content_size);
+    write_data_into_array_buffer(grid_data_field->data_type_in_IO_file, NAME_STR_SIZE, array, buffer_max_size, buffer_content_size);
+    write_data_into_array_buffer(grid_data_field->data_type_in_application, NAME_STR_SIZE, array, buffer_max_size, buffer_content_size);
+    write_data_into_array_buffer(grid_data_field->field_name_in_IO_file, NAME_STR_SIZE, array, buffer_max_size, buffer_content_size);
+    write_data_into_array_buffer(grid_data_field->field_name_in_application, NAME_STR_SIZE, array, buffer_max_size, buffer_content_size);
 }
 
 
 Remap_grid_data_class::Remap_grid_data_class(Remap_grid_class *grid, const char *array, long &buffer_content_iter)
 {
-	grid_data_field = new Remap_data_field;
-	read_data_from_array_buffer(grid_data_field->field_name_in_application, NAME_STR_SIZE, array, buffer_content_iter, true);
-	read_data_from_array_buffer(grid_data_field->field_name_in_IO_file, NAME_STR_SIZE, array, buffer_content_iter, true);
-	read_data_from_array_buffer(grid_data_field->data_type_in_application, NAME_STR_SIZE, array, buffer_content_iter, true);
-	read_data_from_array_buffer(grid_data_field->data_type_in_IO_file, NAME_STR_SIZE, array, buffer_content_iter, true);
-	read_data_from_array_buffer(&(grid_data_field->required_data_size), sizeof(long), array, buffer_content_iter, true);
-	read_data_from_array_buffer(&(grid_data_field->read_data_size), sizeof(long), array, buffer_content_iter, true);
-	grid_data_field->data_buf = new char [grid_data_field->required_data_size*get_data_type_size(grid_data_field->data_type_in_application)];
-	read_data_from_array_buffer(grid_data_field->data_buf, grid_data_field->required_data_size*get_data_type_size(grid_data_field->data_type_in_application), array, buffer_content_iter, true);
-	this->coord_value_grid = grid;
+    grid_data_field = new Remap_data_field;
+    read_data_from_array_buffer(grid_data_field->field_name_in_application, NAME_STR_SIZE, array, buffer_content_iter, true);
+    read_data_from_array_buffer(grid_data_field->field_name_in_IO_file, NAME_STR_SIZE, array, buffer_content_iter, true);
+    read_data_from_array_buffer(grid_data_field->data_type_in_application, NAME_STR_SIZE, array, buffer_content_iter, true);
+    read_data_from_array_buffer(grid_data_field->data_type_in_IO_file, NAME_STR_SIZE, array, buffer_content_iter, true);
+    read_data_from_array_buffer(&(grid_data_field->required_data_size), sizeof(long), array, buffer_content_iter, true);
+    read_data_from_array_buffer(&(grid_data_field->read_data_size), sizeof(long), array, buffer_content_iter, true);
+    grid_data_field->data_buf = new char [grid_data_field->required_data_size*get_data_type_size(grid_data_field->data_type_in_application)];
+    read_data_from_array_buffer(grid_data_field->data_buf, grid_data_field->required_data_size*get_data_type_size(grid_data_field->data_type_in_application), array, buffer_content_iter, true);
+    this->coord_value_grid = grid;
 }
 
diff --git a/src/CoR/remap_grid_data_class.h b/src/CoR/remap_grid_data_class.h
old mode 100644
new mode 100755
index 30d3d51..09f83d0
--- a/src/CoR/remap_grid_data_class.h
+++ b/src/CoR/remap_grid_data_class.h
@@ -54,8 +54,9 @@ class Remap_grid_data_class
         void generate_analytic_values(const char*);
         void evaluate_error(Remap_grid_data_class*, Remap_grid_data_class*);
         void change_datatype_in_application(const char*);
-		void write_grid_data_into_array(char **, long &, long &);
-		Remap_grid_data_class(Remap_grid_class *, const char *, long&);
+        void write_grid_data_into_array(char **, long &, long &);
+        Remap_grid_data_class(Remap_grid_class *, const char *, long&);
+        void set_masked_cell_to_missing_value();
 };
 
 
diff --git a/src/CoR/remap_grid_data_mgt.cxx b/src/CoR/remap_grid_data_mgt.cxx
old mode 100644
new mode 100755
index 037f0f6..fa9ec3f
--- a/src/CoR/remap_grid_data_mgt.cxx
+++ b/src/CoR/remap_grid_data_mgt.cxx
@@ -17,7 +17,7 @@
 void Remap_field_data_mgt::execute(const char*function, Remap_statement_operand **statement_operands, int num_operands)
 {
     int i;
-	char field_name_in_IO[256];
+    char field_name_in_IO[256];
 
 
     if (words_are_the_same(function, FUNCTION_WORD_READ_FIELD)) {
@@ -35,11 +35,11 @@ void Remap_field_data_mgt::execute(const char*function, Remap_statement_operand
         EXECUTION_REPORT(REPORT_ERROR, -1, num_operands == 2 || num_operands == 3, "function \"%s\" for reading field data must have one result parameter and one or two input parameters\n", function);
         check_is_parameter_object_type_field_data(function, 0, statement_operands[0], "the field allocated");
         check_is_parameter_object_type_grid(function, 1, statement_operands[1], "the grid corresponding to the field");
-		strcpy(field_name_in_IO, "\0");
-		if (num_operands == 3) {
-			check_is_parameter_string_type(function, 2, statement_operands[2], "the variable name of data in IO file");
-			strcpy(field_name_in_IO, statement_operands[2]->extension_names[0]);
-		}
+        strcpy(field_name_in_IO, "\0");
+        if (num_operands == 3) {
+            check_is_parameter_string_type(function, 2, statement_operands[2], "the variable name of data in IO file");
+            strcpy(field_name_in_IO, statement_operands[2]->extension_names[0]);
+        }
         all_field_data.push_back(new Remap_grid_data_class(statement_operands[0]->object->object_name,
                                                            remap_grid_manager->search_remap_grid_with_grid_name(statement_operands[1]->object->object_name),
                                                            NULL, field_name_in_IO));
diff --git a/src/CoR/remap_grid_data_mgt.h b/src/CoR/remap_grid_data_mgt.h
old mode 100644
new mode 100755
diff --git a/src/CoR/remap_grid_mgt.cxx b/src/CoR/remap_grid_mgt.cxx
old mode 100644
new mode 100755
index 21741cf..735f5c3
--- a/src/CoR/remap_grid_mgt.cxx
+++ b/src/CoR/remap_grid_mgt.cxx
@@ -90,14 +90,14 @@ void Remap_grid_mgt::execute(const char*function, Remap_statement_operand **stat
                                                    grid_size));
     }
     else if (words_are_the_same(function, FUNCIION_WORD_LEV_COORD_FROM_SIGMA)) {
-		double scale_factor = 1.0;
+        double scale_factor = 1.0;
         EXECUTION_REPORT(REPORT_ERROR, -1, num_operands == 4 || num_operands == 5, "function \"%s\" must have one result parameter and three or four input parameters\n", function);
         check_is_parameter_grid_center_field(function, statement_operands[0], NULL);
         check_is_parameter_object_type_field_data(function, 1, statement_operands[1], "the field with values at the bottom of 3D grid");
         get_float_value_from_parameter(function, 2, statement_operands[2], "the value corresponding to 3D grid top\n");
         check_is_parameter_object_type_field_data(function, 3, statement_operands[3], "the field with sigma coordinate");
-		if (num_operands == 5)
-	        scale_factor = get_float_value_from_parameter(function, 4, statement_operands[4], "the scale factor value\n");
+        if (num_operands == 5)
+            scale_factor = get_float_value_from_parameter(function, 4, statement_operands[4], "the scale factor value\n");
         search_remap_grid_with_grid_name(statement_operands[0]->object->object_name)->gen_lev_coord_from_sigma_or_hybrid(statement_operands[0]->extension_names, 
                                                                                                                          statement_operands[1]->object->object_name, 
                                                                                                                          statement_operands[2]->extension_names[0],
@@ -105,15 +105,15 @@ void Remap_grid_mgt::execute(const char*function, Remap_statement_operand **stat
                                                                                                                          NULL, scale_factor);
     }
     else if (words_are_the_same(function, FUNCIION_WORD_LEV_COORD_FROM_HYBRID)) {
-		double scale_factor = 1.0;
+        double scale_factor = 1.0;
         EXECUTION_REPORT(REPORT_ERROR, -1, num_operands == 5 || num_operands == 6, "function \"%s\" must have one result parameter and four or five input parameters\n", function);
         check_is_parameter_grid_center_field(function, statement_operands[0], NULL);
         check_is_parameter_object_type_field_data(function, 1, statement_operands[1], "the field with values at the bottom of 3D grid");
         get_float_value_from_parameter(function, 2, statement_operands[2], "the constant reference value corresponding to hybrid grid\n");
         check_is_parameter_object_type_field_data(function, 3, statement_operands[3], "the field with sigma coordinate");
-		check_is_parameter_object_type_field_data(function, 4, statement_operands[4], "the field with hybrid grid coefficient");
-		if (num_operands == 6)
-	        scale_factor = get_float_value_from_parameter(function, 5, statement_operands[5], "the scale factor value\n");
+        check_is_parameter_object_type_field_data(function, 4, statement_operands[4], "the field with hybrid grid coefficient");
+        if (num_operands == 6)
+            scale_factor = get_float_value_from_parameter(function, 5, statement_operands[5], "the scale factor value\n");
         search_remap_grid_with_grid_name(statement_operands[0]->object->object_name)->gen_lev_coord_from_sigma_or_hybrid(statement_operands[0]->extension_names, 
                                                                                                                          statement_operands[1]->object->object_name, 
                                                                                                                          statement_operands[2]->extension_names[0],
@@ -172,19 +172,19 @@ void Remap_grid_mgt::execute(const char*function, Remap_statement_operand **stat
         check_is_parameter_string_type(function, 2, statement_operands[1], "the name of partial area");
         search_remap_grid_with_grid_name(statement_operands[0]->object->object_name)->add_partial_grid_area(statement_operands[1]->extension_names[0]);
     }
-	else if (words_are_the_same(function, FUNCIION_WORD_SET_LEV_GRID_SIGMA_INFO)) {
-		char *hybrid_grid_coefficient_field_name = NULL;
-		EXECUTION_REPORT(REPORT_ERROR, -1, num_operands == 4 || num_operands == 5, "function \"%s\" has four input parameters\n", function);
-		check_is_parameter_object_type_grid(function, 1, statement_operands[0], "the level grid (vertical grid) to be set the sigma information");
-		check_is_parameter_object_type_field_data(function, 2, statement_operands[1], "the vector of sigma values");
-		double top_value = get_float_value_from_parameter(function, 3, statement_operands[2], "the vertical coordinate value of top layer in the sigma grid");
-		double scale_factor = get_float_value_from_parameter(function, 4, statement_operands[3], "the scale factor corresponding to the sigma grid");
-		if (num_operands == 5) {
-			check_is_parameter_object_type_field_data(function, 5, statement_operands[4], "the vector of coefficients for hybrid grid");
-			hybrid_grid_coefficient_field_name = statement_operands[4]->object->object_name;
-		}
-		search_remap_grid_with_grid_name(statement_operands[0]->object->object_name)->set_lev_grid_sigma_info(statement_operands[1]->object->object_name, top_value, scale_factor, hybrid_grid_coefficient_field_name);
-	}
+    else if (words_are_the_same(function, FUNCIION_WORD_SET_LEV_GRID_SIGMA_INFO)) {
+        char *hybrid_grid_coefficient_field_name = NULL;
+        EXECUTION_REPORT(REPORT_ERROR, -1, num_operands == 4 || num_operands == 5, "function \"%s\" has four input parameters\n", function);
+        check_is_parameter_object_type_grid(function, 1, statement_operands[0], "the level grid (vertical grid) to be set the sigma information");
+        check_is_parameter_object_type_field_data(function, 2, statement_operands[1], "the vector of sigma values");
+        double top_value = get_float_value_from_parameter(function, 3, statement_operands[2], "the vertical coordinate value of top layer in the sigma grid");
+        double scale_factor = get_float_value_from_parameter(function, 4, statement_operands[3], "the scale factor corresponding to the sigma grid");
+        if (num_operands == 5) {
+            check_is_parameter_object_type_field_data(function, 5, statement_operands[4], "the vector of coefficients for hybrid grid");
+            hybrid_grid_coefficient_field_name = statement_operands[4]->object->object_name;
+        }
+        search_remap_grid_with_grid_name(statement_operands[0]->object->object_name)->set_lev_grid_sigma_info(statement_operands[1]->object->object_name, top_value, scale_factor, hybrid_grid_coefficient_field_name);
+    }
     else if (words_are_the_same(function, FUNCTION_WORD_ADD_AREA_BOUND)) {
         EXECUTION_REPORT(REPORT_ERROR, -1, num_operands == 6, "function \"%s\" has six input parameters\n", function);
         check_is_parameter_object_type_grid(function, 1, statement_operands[0], "the partial grid");
@@ -202,15 +202,15 @@ void Remap_grid_mgt::execute(const char*function, Remap_statement_operand **stat
                                                                                                                    statement_operands[4]->extension_names[0],
                                                                                                                    statement_operands[5]->extension_names[0]);
     }
-	else if (words_are_the_same(function, FUNCTION_WORD_SET_BOUNDARY)) {
-		check_is_parameter_grid_boundary(function, statement_operands[0], NULL);
-		EXECUTION_REPORT(REPORT_ERROR, -1, num_operands == 5, "function \"%s\" must have one result parameter and four input parameters\n", function);
-		double min_lon = get_float_value_from_parameter(function, 1, statement_operands[1], "the minimum longitude of the grid boundary\n");
-		double max_lon = get_float_value_from_parameter(function, 2, statement_operands[2], "the maximum longitude of the grid boundary\n");
-		double min_lat = get_float_value_from_parameter(function, 3, statement_operands[3], "the minimum latitude of the grid boundary\n");
-		double max_lat = get_float_value_from_parameter(function, 4, statement_operands[4], "the maximum latitude of the grid boundary\n");
-		search_remap_grid_with_grid_name(statement_operands[0]->object->object_name)->set_grid_boundary(min_lon, max_lon, min_lat, max_lat);
-	}
+    else if (words_are_the_same(function, FUNCTION_WORD_SET_BOUNDARY)) {
+        check_is_parameter_grid_boundary(function, statement_operands[0], NULL);
+        EXECUTION_REPORT(REPORT_ERROR, -1, num_operands == 5, "function \"%s\" must have one result parameter and four input parameters\n", function);
+        double min_lon = get_float_value_from_parameter(function, 1, statement_operands[1], "the minimum longitude of the grid boundary\n");
+        double max_lon = get_float_value_from_parameter(function, 2, statement_operands[2], "the maximum longitude of the grid boundary\n");
+        double min_lat = get_float_value_from_parameter(function, 3, statement_operands[3], "the minimum latitude of the grid boundary\n");
+        double max_lat = get_float_value_from_parameter(function, 4, statement_operands[4], "the maximum latitude of the grid boundary\n");
+        search_remap_grid_with_grid_name(statement_operands[0]->object->object_name)->set_grid_boundary(min_lon, max_lon, min_lat, max_lat);
+    }
     else EXECUTION_REPORT(REPORT_ERROR, -1, false, "\"%s\" is an unspported function\n", function);
 }
 
@@ -241,7 +241,7 @@ Remap_grid_class *Remap_grid_mgt::search_remap_grid_with_sized_sub_grids(int num
         if (remap_grids[i]->match_grid(num_sized_sub_grids, sized_sub_grids))
             return remap_grids[i];
 
-    return NULL;	
+    return NULL;    
 }
 
 
@@ -256,16 +256,16 @@ void Remap_grid_mgt::get_all_leaf_remap_grids(int *num_leaf_grids, Remap_grid_cl
 
 void Remap_grid_mgt::add_remap_grid(Remap_grid_class *remap_grid)
 {
-	EXECUTION_REPORT(REPORT_ERROR, -1, search_remap_grid_with_grid_name(remap_grid->get_grid_name()) == NULL, "Software error in Remap_grid_mgt::add_remap_grid: grid \"%s\" has already been added into the grid manager", remap_grid->get_grid_name());
-	EXECUTION_REPORT_LOG(REPORT_LOG, -1, true, "add remap grid \"%s\" at %lx", remap_grid->get_grid_name(), remap_grid);
-	remap_grids.push_back(remap_grid);
+    EXECUTION_REPORT(REPORT_ERROR, -1, search_remap_grid_with_grid_name(remap_grid->get_grid_name()) == NULL, "Software error in Remap_grid_mgt::add_remap_grid: grid \"%s\" has already been added into the grid manager", remap_grid->get_grid_name());
+    EXECUTION_REPORT_LOG(REPORT_LOG, -1, true, "add remap grid \"%s\" at %lx", remap_grid->get_grid_name(), remap_grid);
+    remap_grids.push_back(remap_grid);
 }
 
 
 void Remap_grid_mgt::add_temp_grid(Remap_grid_class *temp_grid)
 {
-	temp_grids.push_back(temp_grid);
-	EXECUTION_REPORT_LOG(REPORT_LOG, -1, true, "add temp grid \"%s\" at %lx", temp_grid->get_grid_name(), temp_grid);
+    temp_grids.push_back(temp_grid);
+    EXECUTION_REPORT_LOG(REPORT_LOG, -1, true, "add temp grid \"%s\" at %lx", temp_grid->get_grid_name(), temp_grid);
 }
 
 
@@ -274,17 +274,17 @@ Remap_grid_mgt::~Remap_grid_mgt()
     for (int i = 0; i < remap_grids.size(); i ++)
         delete remap_grids[i];
 
-	for (int i = 0; i < temp_grids.size(); i ++)
-		delete temp_grids[i];
+    for (int i = 0; i < temp_grids.size(); i ++)
+        delete temp_grids[i];
 }
 
 
 Remap_grid_class *Remap_grid_mgt::search_same_remap_grid(Remap_grid_class *remap_grid)
 {
-	for (int i = 0; i < remap_grids.size(); i ++)
-		if (remap_grids[i]->is_the_same_grid_with(remap_grid))
-			return remap_grids[i];
-		
-	return NULL;
+    for (int i = 0; i < remap_grids.size(); i ++)
+        if (remap_grids[i]->is_the_same_grid_with(remap_grid))
+            return remap_grids[i];
+        
+    return NULL;
 }
 
diff --git a/src/CoR/remap_grid_mgt.h b/src/CoR/remap_grid_mgt.h
old mode 100644
new mode 100755
index c130d63..943311f
--- a/src/CoR/remap_grid_mgt.h
+++ b/src/CoR/remap_grid_mgt.h
@@ -23,7 +23,7 @@ class Remap_grid_mgt
     private:
         friend class Remap_grid_class; 
         std::vector<Remap_grid_class*> remap_grids;
-		std::vector<Remap_grid_class*> temp_grids;
+        std::vector<Remap_grid_class*> temp_grids;
 
     public:
         Remap_grid_mgt() {}
@@ -31,10 +31,10 @@ class Remap_grid_mgt
         void execute(const char*, Remap_statement_operand **, int);    
         Remap_grid_class *search_remap_grid_with_grid_name(const char*);
         Remap_grid_class *search_remap_grid_with_coord_name(const char*);
-		Remap_grid_class *search_remap_grid_with_sized_sub_grids(int, Remap_grid_class**);
-		Remap_grid_class *search_same_remap_grid(Remap_grid_class*);
-		void add_remap_grid(Remap_grid_class*);
-		void add_temp_grid(Remap_grid_class*);
+        Remap_grid_class *search_remap_grid_with_sized_sub_grids(int, Remap_grid_class**);
+        Remap_grid_class *search_same_remap_grid(Remap_grid_class*);
+        void add_remap_grid(Remap_grid_class*);
+        void add_temp_grid(Remap_grid_class*);
         void get_all_leaf_remap_grids(int*, Remap_grid_class **);
 };
 
diff --git a/src/CoR/remap_mgt.cxx b/src/CoR/remap_mgt.cxx
old mode 100644
new mode 100755
index 8e46cf3..f2555b9
--- a/src/CoR/remap_mgt.cxx
+++ b/src/CoR/remap_mgt.cxx
@@ -45,9 +45,9 @@ void Remap_mgt::push_back_all_words()
     push_back_words("function", FUNCTION_WORD_REMAP);
     push_back_words("function", FUNCTION_WORD_WRITE_FIELD);
     push_back_words("function", FUNCTION_WORD_READ_FIELD);
-	push_back_words("function", FUNCTION_WORD_SET_BOUNDARY);
+    push_back_words("function", FUNCTION_WORD_SET_BOUNDARY);
     push_back_words("function", FUNCIION_WORD_LEV_COORD_FROM_SIGMA);
-	push_back_words("function", FUNCIION_WORD_LEV_COORD_FROM_HYBRID);
+    push_back_words("function", FUNCIION_WORD_LEV_COORD_FROM_HYBRID);
     push_back_words("function", FUNCTION_WORD_EXTRACT_MASK);
     push_back_words("function", FUNCTION_WORD_COMPUTE_OCN_MASK);
     push_back_words("function", FUNCTION_WORD_ALLOC_FIELD);
@@ -58,7 +58,7 @@ void Remap_mgt::push_back_all_words()
     push_back_words("function", FUNCTION_WORD_EVALUATE_ERROR);
     push_back_words("function", FUNCTION_WORD_COMPUTE_REMAP_WEIGHTS);
     push_back_words("function", FUNCTION_WORD_SET_OPERATOR_PARA);
-	push_back_words("function", FUNCIION_WORD_SET_LEV_GRID_SIGMA_INFO);
+    push_back_words("function", FUNCIION_WORD_SET_LEV_GRID_SIGMA_INFO);
 
     push_back_words("reserved", RESERVED_WORD_QUOTE_MARK);
     push_back_words("reserved", RESERVED_WORD_EQUAL);
@@ -85,30 +85,30 @@ Remap_mgt::Remap_mgt(const char *cfg_file_name)
     remap_operator_manager = new Remap_operator_mgt();
     remap_field_data_manager = new Remap_field_data_mgt();    
     remap_weights_of_strategy_manager = new Remap_weight_of_strategy_mgt();
-	sequential_remap_weight_of_operator_manager = new Remap_weight_of_operator_mgt();
-	parallel_remap_weight_of_operator_manager = new Remap_weight_of_operator_mgt();
+    sequential_remap_weight_of_operator_manager = new Remap_weight_of_operator_mgt();
+    parallel_remap_weight_of_operator_manager = new Remap_weight_of_operator_mgt();
     push_back_all_words();
 
     /* Initialize the data structure to keep each word in a statement */
-	if (cfg_file_name != NULL) {
-	    remap_parser = new Remap_parser(cfg_file_name);
-	    words_in_statement = new char *[256];
-	    for (i = 0; i < 256; i ++)
-	        words_in_statement[i] = new char [256];
-
-	    /* For each statement, check its syntax, analyze its semantic, execute it and then release it */
-	    line_number = 1;
-	    while (remap_parser->get_next_parsed_statement(&num_words_in_statement, words_in_statement)) { 
-	        parse_statement(num_words_in_statement, words_in_statement);
-	        process_statement();
-	        release_statement();
-	        line_number ++;
-	    }
-	    delete remap_parser;
-	    for (i = 0; i < 256; i ++)
-	        delete [] words_in_statement[i];
-	    delete [] words_in_statement;
-	}
+    if (cfg_file_name != NULL) {
+        remap_parser = new Remap_parser(cfg_file_name);
+        words_in_statement = new char *[256];
+        for (i = 0; i < 256; i ++)
+            words_in_statement[i] = new char [256];
+
+        /* For each statement, check its syntax, analyze its semantic, execute it and then release it */
+        line_number = 1;
+        while (remap_parser->get_next_parsed_statement(&num_words_in_statement, words_in_statement)) { 
+            parse_statement(num_words_in_statement, words_in_statement);
+            process_statement();
+            release_statement();
+            line_number ++;
+        }
+        delete remap_parser;
+        for (i = 0; i < 256; i ++)
+            delete [] words_in_statement[i];
+        delete [] words_in_statement;
+    }
 }
 
 
@@ -294,7 +294,7 @@ void Remap_mgt::process_statement()
                      remap_statement->result_operand->object->object_name);    
         if (remap_statement->result_operand->num_extension_names > 0) {
             if (words_are_the_same(remap_statement->function, FUNCTION_WORD_READ_FIELD) || 
-				words_are_the_same(remap_statement->function, FUNCTION_WORD_SET_BOUNDARY) ||
+                words_are_the_same(remap_statement->function, FUNCTION_WORD_SET_BOUNDARY) ||
                 words_are_the_same(remap_statement->function, FUNCTION_WORD_COMPUTE_OCN_MASK) ||
                 words_are_the_same(remap_statement->function, FUNCIION_WORD_LEV_COORD_FROM_SIGMA) ||
                 words_are_the_same(remap_statement->function, FUNCIION_WORD_LEV_COORD_FROM_HYBRID) ||
@@ -357,7 +357,7 @@ void Remap_mgt::process_statement()
             check_is_parameter_object_type_IO(remap_statement->function, 1, remap_statement->src_operands[0], "the IO file to record the weight data");
         else if (words_are_the_same(remap_statement->function, FUNCTION_WORD_ADD_GRID_AREA)) 
             check_is_parameter_object_type_grid(remap_statement->function, 1, remap_statement->src_operands[0], "the partial grid to be added the area");   
-		else if (words_are_the_same(remap_statement->function, FUNCIION_WORD_SET_LEV_GRID_SIGMA_INFO)) 
+        else if (words_are_the_same(remap_statement->function, FUNCIION_WORD_SET_LEV_GRID_SIGMA_INFO)) 
             check_is_parameter_object_type_grid(remap_statement->function, 1, remap_statement->src_operands[0], "the level grid (vertical grid) to be set the sigma information");   
         else if (words_are_the_same(remap_statement->function, FUNCTION_WORD_ADD_AREA_BOUND))
             check_is_parameter_object_type_grid(remap_statement->function, 1, remap_statement->src_operands[0], "the partial grid to be added the area bounds");  
@@ -442,8 +442,8 @@ Remap_mgt::~Remap_mgt()
 
     delete io_manager;
     delete remap_weights_of_strategy_manager;
-	delete sequential_remap_weight_of_operator_manager;
-	delete parallel_remap_weight_of_operator_manager;
+    delete sequential_remap_weight_of_operator_manager;
+    delete parallel_remap_weight_of_operator_manager;
     delete remap_strategy_manager;
     delete remap_grid_manager;
     delete remap_operator_manager;
diff --git a/src/CoR/remap_mgt.h b/src/CoR/remap_mgt.h
old mode 100644
new mode 100755
diff --git a/src/CoR/remap_operator_1D_basis.cxx b/src/CoR/remap_operator_1D_basis.cxx
old mode 100644
new mode 100755
index f2b7310..c8d7308
--- a/src/CoR/remap_operator_1D_basis.cxx
+++ b/src/CoR/remap_operator_1D_basis.cxx
@@ -26,7 +26,7 @@ Remap_operator_1D_basis::Remap_operator_1D_basis(const char *object_name, const
                                                               num_remap_grids, 
                                                               remap_grids)
 {
-	initialize_1D_remap_operator();
+    initialize_1D_remap_operator();
 }
 
 
@@ -41,393 +41,393 @@ void Remap_operator_1D_basis::set_common_parameter(const char *parameter_name, c
                  "the parameter of remap operator object \"%s\" must be set before using it to build remap strategy\n",
                  object_name);
     if (words_are_the_same(parameter_name, "periodic")) {
-		EXECUTION_REPORT(REPORT_ERROR, -1, !set_periodic, 
-					     "The parameter \"%s\" of the 1D remapping operator \"%s\" has been set before. It can not been set more than once",
-						 parameter_name, operator_name);
-		if (words_are_the_same(parameter_value, "true"))
-	        periodic = true;
-		else if (words_are_the_same(parameter_value, "false"))
-			periodic = false;
-		else EXECUTION_REPORT(REPORT_ERROR, -1, false, 
+        EXECUTION_REPORT(REPORT_ERROR, -1, !set_periodic, 
+                         "The parameter \"%s\" of the 1D remapping operator \"%s\" has been set before. It can not been set more than once",
+                         parameter_name, operator_name);
+        if (words_are_the_same(parameter_value, "true"))
+            periodic = true;
+        else if (words_are_the_same(parameter_value, "false"))
+            periodic = false;
+        else EXECUTION_REPORT(REPORT_ERROR, -1, false, 
                       "The value of parameter \"%s\" of the 1D remapping operator \"%s\" must be \"true\" or \"false\"",
                       parameter_name, operator_name);
-		set_periodic = true;
-		if (periodic)
-			EXECUTION_REPORT(REPORT_ERROR, -1, !set_enable_extrapolation, 
-						     "The parameter \"extrapolation\" of the 1D remapping operator \"%s\" has been set before. This remapping operator can not be set to periodic",
-							 parameter_name, operator_name);
+        set_periodic = true;
+        if (periodic)
+            EXECUTION_REPORT(REPORT_ERROR, -1, !set_enable_extrapolation, 
+                             "The parameter \"extrapolation\" of the 1D remapping operator \"%s\" has been set before. This remapping operator can not be set to periodic",
+                             parameter_name, operator_name);
     }
-	else if (words_are_the_same(parameter_name, "period")) {
-		EXECUTION_REPORT(REPORT_ERROR, -1, set_periodic && periodic, 
-					     "The 1D remapping operator \"%s\" has not been set to periodic before. Its \"period\" can not be set",
-						 operator_name);
-		EXECUTION_REPORT(REPORT_ERROR, -1, !set_period,
-						 "The parameter \"%s\" of the 1D remapping operator \"%s\" has been set before. It can not been set more than once",
-						 parameter_name, operator_name);
-		sscanf(parameter_value, "%lf", &period);
-		set_period = true;
-		EXECUTION_REPORT(REPORT_ERROR, -1, period > 0,
-						 "The parameter \"%s\" of the 1D remapping operator \"%s\" must be bigger than 0",
-						 parameter_name, operator_name);
-	}
-	else if (words_are_the_same(parameter_name, "use_logarithmic_coordinate")) {
-		EXECUTION_REPORT(REPORT_ERROR, -1, !set_use_logarithmic_coordinate,
-						 "The parameter \"%s\" of the 1D spline remapping operator \"%s\" has been set before. It can not been set more than once",
-						 parameter_name, operator_name);
-		if (words_are_the_same(parameter_value, "true")) 
-			use_logarithmic_coordinate = true;
-		else if (words_are_the_same(parameter_value, "false"))
-			use_logarithmic_coordinate = false;
-		else EXECUTION_REPORT(REPORT_ERROR, -1, false, 
+    else if (words_are_the_same(parameter_name, "period")) {
+        EXECUTION_REPORT(REPORT_ERROR, -1, set_periodic && periodic, 
+                         "The 1D remapping operator \"%s\" has not been set to periodic before. Its \"period\" can not be set",
+                         operator_name);
+        EXECUTION_REPORT(REPORT_ERROR, -1, !set_period,
+                         "The parameter \"%s\" of the 1D remapping operator \"%s\" has been set before. It can not been set more than once",
+                         parameter_name, operator_name);
+        sscanf(parameter_value, "%lf", &period);
+        set_period = true;
+        EXECUTION_REPORT(REPORT_ERROR, -1, period > 0,
+                         "The parameter \"%s\" of the 1D remapping operator \"%s\" must be bigger than 0",
+                         parameter_name, operator_name);
+    }
+    else if (words_are_the_same(parameter_name, "use_logarithmic_coordinate")) {
+        EXECUTION_REPORT(REPORT_ERROR, -1, !set_use_logarithmic_coordinate,
+                         "The parameter \"%s\" of the 1D spline remapping operator \"%s\" has been set before. It can not been set more than once",
+                         parameter_name, operator_name);
+        if (words_are_the_same(parameter_value, "true")) 
+            use_logarithmic_coordinate = true;
+        else if (words_are_the_same(parameter_value, "false"))
+            use_logarithmic_coordinate = false;
+        else EXECUTION_REPORT(REPORT_ERROR, -1, false, 
                       "The value of parameter \"%s\" of the 1D spline remapping operator \"%s\" must be \"none\", \"overall\" or \"fragment\"",
                       parameter_name, operator_name);
-		set_use_logarithmic_coordinate = true;
-	}
-	else if (words_are_the_same(parameter_name, "use_exponent_coordinate")) {
-		EXECUTION_REPORT(REPORT_ERROR, -1, !set_use_exponent_coordinate,
-						 "The parameter \"%s\" of the 1D spline remapping operator \"%s\" has been set before. It can not been set more than once",
-						 parameter_name, operator_name);
-		if (words_are_the_same(parameter_value, "true")) 
-			use_exponent_coordinate = true;
-		else if (words_are_the_same(parameter_value, "false"))
-			use_exponent_coordinate = false;
-		else EXECUTION_REPORT(REPORT_ERROR, -1, false, 
+        set_use_logarithmic_coordinate = true;
+    }
+    else if (words_are_the_same(parameter_name, "use_exponent_coordinate")) {
+        EXECUTION_REPORT(REPORT_ERROR, -1, !set_use_exponent_coordinate,
+                         "The parameter \"%s\" of the 1D spline remapping operator \"%s\" has been set before. It can not been set more than once",
+                         parameter_name, operator_name);
+        if (words_are_the_same(parameter_value, "true")) 
+            use_exponent_coordinate = true;
+        else if (words_are_the_same(parameter_value, "false"))
+            use_exponent_coordinate = false;
+        else EXECUTION_REPORT(REPORT_ERROR, -1, false, 
                       "The value of parameter \"%s\" of the 1D spline remapping operator \"%s\" must be \"none\", \"overall\" or \"fragment\"",
                       parameter_name, operator_name);
-		set_use_exponent_coordinate = true;
-	}
-	else if (words_are_the_same(parameter_name, "enable_extrapolate")) {
-		EXECUTION_REPORT(REPORT_ERROR, -1, !periodic,
-						 "The parameter \"%s\" of the 1D remapping operator \"%s\" can not be set when the 1D remapping operator is periodic",
-						 parameter_name, operator_name);
-		EXECUTION_REPORT(REPORT_ERROR, -1, !set_enable_extrapolation,
-						 "Extrapolation of remapping operator %s has been enabled before. Extrapolation cannot be enabled again", operator_name);
-		if (words_are_the_same(parameter_value, "true"))
-	        enable_extrapolate = true;
-		else if (words_are_the_same(parameter_value, "false"))
-			enable_extrapolate = false;
-		else EXECUTION_REPORT(REPORT_ERROR, -1, false, 
+        set_use_exponent_coordinate = true;
+    }
+    else if (words_are_the_same(parameter_name, "enable_extrapolate")) {
+        EXECUTION_REPORT(REPORT_ERROR, -1, !periodic,
+                         "The parameter \"%s\" of the 1D remapping operator \"%s\" can not be set when the 1D remapping operator is periodic",
+                         parameter_name, operator_name);
+        EXECUTION_REPORT(REPORT_ERROR, -1, !set_enable_extrapolation,
+                         "Extrapolation of remapping operator %s has been enabled before. Extrapolation cannot be enabled again", operator_name);
+        if (words_are_the_same(parameter_value, "true"))
+            enable_extrapolate = true;
+        else if (words_are_the_same(parameter_value, "false"))
+            enable_extrapolate = false;
+        else EXECUTION_REPORT(REPORT_ERROR, -1, false, 
                       "The value of parameter \"%s\" of the 1D remapping operator \"%s\" must be \"true\" or \"false\"",
-                      parameter_name, operator_name);		
-		set_enable_extrapolation = true;
-	}
-	else if (words_are_the_same(parameter_name, "extrapolation_approach")) {
-		EXECUTION_REPORT(REPORT_ERROR, -1, set_enable_extrapolation,
-						 "Extrapolation of remapping operator %s is not set to enabled. Therefore, the approach of extrapolation cannot be set", operator_name);
-		EXECUTION_REPORT(REPORT_ERROR, -1, extrapolation_approach == 0,
-						 "Extrapolation approach of remapping operator %s has been set before. It cannot be set again", operator_name);
-		if (words_are_the_same(parameter_value, "with_boundary"))
-	        extrapolation_approach = 1;
-		else EXECUTION_REPORT(REPORT_ERROR, -1, false, 
+                      parameter_name, operator_name);        
+        set_enable_extrapolation = true;
+    }
+    else if (words_are_the_same(parameter_name, "extrapolation_approach")) {
+        EXECUTION_REPORT(REPORT_ERROR, -1, set_enable_extrapolation,
+                         "Extrapolation of remapping operator %s is not set to enabled. Therefore, the approach of extrapolation cannot be set", operator_name);
+        EXECUTION_REPORT(REPORT_ERROR, -1, extrapolation_approach == 0,
+                         "Extrapolation approach of remapping operator %s has been set before. It cannot be set again", operator_name);
+        if (words_are_the_same(parameter_value, "with_boundary"))
+            extrapolation_approach = 1;
+        else EXECUTION_REPORT(REPORT_ERROR, -1, false, 
                       "The value of parameter \"%s\" of the 1D remapping operator \"%s\" must be \"with_boundary\" currently",
-                      parameter_name, operator_name);		
-		set_enable_extrapolation = true;
-	}
+                      parameter_name, operator_name);        
+        set_enable_extrapolation = true;
+    }
     else EXECUTION_REPORT(REPORT_ERROR, -1, false, 
-	                      "\"%s\" is a illegal parameter of remapping operator \"%s\"\n",
-    	                  parameter_name, operator_name);	
-	EXECUTION_REPORT(REPORT_ERROR, -1, !use_logarithmic_coordinate || !use_exponent_coordinate, "The parameter \"use_logarithmic_coordinate\" and \"use_exponent_coordinate\" of the 1D spline remapping operator \"%s\" cannot be set to true at the same time. Please verify.", operator_name);
+                          "\"%s\" is a illegal parameter of remapping operator \"%s\"\n",
+                          parameter_name, operator_name);    
+    EXECUTION_REPORT(REPORT_ERROR, -1, !use_logarithmic_coordinate || !use_exponent_coordinate, "The parameter \"use_logarithmic_coordinate\" and \"use_exponent_coordinate\" of the 1D spline remapping operator \"%s\" cannot be set to true at the same time. Please verify.", operator_name);
 }
 
 
 int Remap_operator_1D_basis::check_common_parameter(const char *parameter_name, const char *parameter_value, char *error_string)
 {
-	int check_result = 0;
+    int check_result = 0;
 
-	
+    
     if (words_are_the_same(parameter_name, "periodic") || words_are_the_same(parameter_name, "use_exponent_coordinate") || 
-		words_are_the_same(parameter_name, "use_logarithmic_coordinate") || words_are_the_same(parameter_name, "enable_extrapolate")) {
-		check_result = 1;
-		if (words_are_the_same(parameter_value, "true") || words_are_the_same(parameter_value, "false"))
-	        check_result = 3;
-		else sprintf(error_string, "The parameter value must be \"true\" or \"false\""); 
+        words_are_the_same(parameter_name, "use_logarithmic_coordinate") || words_are_the_same(parameter_name, "enable_extrapolate")) {
+        check_result = 1;
+        if (words_are_the_same(parameter_value, "true") || words_are_the_same(parameter_value, "false"))
+            check_result = 3;
+        else sprintf(error_string, "The parameter value must be \"true\" or \"false\""); 
+    }
+    else if (words_are_the_same(parameter_name, "period")) {
+        check_result = 1;
+        sscanf(parameter_value, "%lf", &period);
+        if (period > 0)
+            check_result = 3;
+        else sprintf(error_string, "The parameter value must be a positive value"); 
+        
     }
-	else if (words_are_the_same(parameter_name, "period")) {
-		check_result = 1;
-		sscanf(parameter_value, "%lf", &period);
-		if (period > 0)
-			check_result = 3;
-		else sprintf(error_string, "The parameter value must be a positive value"); 
-		
-	}
-	else if (words_are_the_same(parameter_name, "extrapolation_approach")) {
-		check_result = 1;
-		if (words_are_the_same(parameter_name, "with_boundary"))
-			check_result = 3;
-		else sprintf(error_string, "The parameter value must be \"with_boundary\""); 
-	}
-
-	return check_result;
+    else if (words_are_the_same(parameter_name, "extrapolation_approach")) {
+        check_result = 1;
+        if (words_are_the_same(parameter_name, "with_boundary"))
+            check_result = 3;
+        else sprintf(error_string, "The parameter value must be \"with_boundary\""); 
+    }
+
+    return check_result;
 }
 
 
 
 void Remap_operator_1D_basis::allocate_1D_remap_operator_common_arrays_space()
 {
-	int required_size = (src_grid->get_grid_size()+2)*12+(dst_grid->get_grid_size()+2)*12;
-
-	if (size_common_buffer_for_1D_remap_operator < required_size) {
-		if (common_buffer_for_1D_remap_operator != NULL)
-			delete [] common_buffer_for_1D_remap_operator;
-		size_common_buffer_for_1D_remap_operator = required_size;
-		common_buffer_for_1D_remap_operator = new double [size_common_buffer_for_1D_remap_operator];
-	}
-	
-	coord_values_src = common_buffer_for_1D_remap_operator + 0*(src_grid->get_grid_size()+2);
-	packed_data_values_src = common_buffer_for_1D_remap_operator + 1*(src_grid->get_grid_size()+2);
-	useful_src_cells_global_index = (int*) (common_buffer_for_1D_remap_operator + 2*(src_grid->get_grid_size()+2));
-	coord_values_dst = common_buffer_for_1D_remap_operator + 12*(src_grid->get_grid_size()+2) + 0*(dst_grid->get_grid_size()+2);
-	src_cell_index_left = (int*) (common_buffer_for_1D_remap_operator + 12*(src_grid->get_grid_size()+2) + 1*(dst_grid->get_grid_size()+2));
-	src_cell_index_right = (int*) (common_buffer_for_1D_remap_operator + 12*(src_grid->get_grid_size()+2) + 2*(dst_grid->get_grid_size()+2));
+    int required_size = (src_grid->get_grid_size()+2)*12+(dst_grid->get_grid_size()+2)*12;
+
+    if (size_common_buffer_for_1D_remap_operator < required_size) {
+        if (common_buffer_for_1D_remap_operator != NULL)
+            delete [] common_buffer_for_1D_remap_operator;
+        size_common_buffer_for_1D_remap_operator = required_size;
+        common_buffer_for_1D_remap_operator = new double [size_common_buffer_for_1D_remap_operator];
+    }
+    
+    coord_values_src = common_buffer_for_1D_remap_operator + 0*(src_grid->get_grid_size()+2);
+    packed_data_values_src = common_buffer_for_1D_remap_operator + 1*(src_grid->get_grid_size()+2);
+    useful_src_cells_global_index = (int*) (common_buffer_for_1D_remap_operator + 2*(src_grid->get_grid_size()+2));
+    coord_values_dst = common_buffer_for_1D_remap_operator + 12*(src_grid->get_grid_size()+2) + 0*(dst_grid->get_grid_size()+2);
+    src_cell_index_left = (int*) (common_buffer_for_1D_remap_operator + 12*(src_grid->get_grid_size()+2) + 1*(dst_grid->get_grid_size()+2));
+    src_cell_index_right = (int*) (common_buffer_for_1D_remap_operator + 12*(src_grid->get_grid_size()+2) + 2*(dst_grid->get_grid_size()+2));
 }
 
 
 void Remap_operator_1D_basis::copy_1D_remap_operator_info(Remap_operator_1D_basis *original_grid)
 {
     periodic = original_grid->periodic;
-	set_periodic = original_grid->set_periodic;
-	set_period = original_grid->set_period;
-	set_enable_extrapolation = original_grid->set_enable_extrapolation;
-	enable_extrapolate = original_grid->enable_extrapolate;
-	extrapolation_approach = original_grid->extrapolation_approach;
-	period = original_grid->period;
-	num_useful_src_cells = original_grid->num_useful_src_cells;
-	use_logarithmic_coordinate = original_grid->use_logarithmic_coordinate;
-	set_use_logarithmic_coordinate = original_grid->set_use_logarithmic_coordinate;
-	use_exponent_coordinate = original_grid->use_exponent_coordinate;
-	set_use_exponent_coordinate = original_grid->set_use_exponent_coordinate;
+    set_periodic = original_grid->set_periodic;
+    set_period = original_grid->set_period;
+    set_enable_extrapolation = original_grid->set_enable_extrapolation;
+    enable_extrapolate = original_grid->enable_extrapolate;
+    extrapolation_approach = original_grid->extrapolation_approach;
+    period = original_grid->period;
+    num_useful_src_cells = original_grid->num_useful_src_cells;
+    use_logarithmic_coordinate = original_grid->use_logarithmic_coordinate;
+    set_use_logarithmic_coordinate = original_grid->set_use_logarithmic_coordinate;
+    use_exponent_coordinate = original_grid->use_exponent_coordinate;
+    set_use_exponent_coordinate = original_grid->set_use_exponent_coordinate;
 }
 
 
 void Remap_operator_1D_basis::initialize_1D_remap_operator()
 {
-	set_periodic = false;
-	set_period = false;
+    set_periodic = false;
+    set_period = false;
     periodic = false;
-	enable_extrapolate = false;
-	set_enable_extrapolation = false;
-	use_logarithmic_coordinate = false;
-	set_use_logarithmic_coordinate = false;
-	use_exponent_coordinate = false;
-	set_use_exponent_coordinate = false;
-	extrapolation_approach = 0;
-	period = -999;
-
-	allocate_1D_remap_operator_common_arrays_space();
+    enable_extrapolate = false;
+    set_enable_extrapolation = false;
+    use_logarithmic_coordinate = false;
+    set_use_logarithmic_coordinate = false;
+    use_exponent_coordinate = false;
+    set_use_exponent_coordinate = false;
+    extrapolation_approach = 0;
+    period = -999;
+
+    allocate_1D_remap_operator_common_arrays_space();
 }
 
 
 void Remap_operator_1D_basis::search_src_cells_around_dst_cell(double coord_value_dst, int src_index_start, int src_index_end, int &src_cell_index_left, int &src_cell_index_right)
 {
-	int src_index_mid;
-
-
-	if (coord_values_src[src_index_start] <= coord_values_src[src_index_end]) {
-		if (coord_values_src[src_index_start] > coord_value_dst) {
-			EXECUTION_REPORT(REPORT_ERROR, -1, !periodic, "software error1: can not find the location of dst cell in original grid");
-			src_cell_index_left = -1;
-			src_cell_index_right = src_index_start;
-			return;
-		}
-		if (coord_values_src[src_index_end] < coord_value_dst) {
-			EXECUTION_REPORT(REPORT_ERROR, -1, !periodic, "software error2: can not find the location of dst cell in original grid");
-			src_cell_index_left = src_index_end;
-			src_cell_index_right = -1;
-			return;
-		}
-	}
-	else {
-		if (coord_values_src[src_index_start] < coord_value_dst) {
-			EXECUTION_REPORT(REPORT_ERROR, -1, !periodic, "software error1: can not find the location of dst cell in original grid");
-			src_cell_index_left = -1;
-			src_cell_index_right = src_index_start;
-			return;
-		}
-		if (coord_values_src[src_index_end] > coord_value_dst) {
-			EXECUTION_REPORT(REPORT_ERROR, -1, !periodic, "software error2: can not find the location of dst cell in original grid");
-			src_cell_index_left = src_index_end;
-			src_cell_index_right = -1;
-			return;
-		}
-	}
-
-	if (coord_values_src[src_index_start] == coord_value_dst) {
-		src_cell_index_left = src_index_start;
-		src_cell_index_right = src_index_start + 1;
-		return;
-	}
-
-	if (coord_values_src[src_index_end] == coord_value_dst) {
-		src_cell_index_left = src_index_end-1;
-		src_cell_index_right = src_index_end;
-		return;
-	}
-
-	search_src_cells_around_dst_cell_recursively(coord_value_dst, src_index_start, src_index_end, src_cell_index_left, src_cell_index_right);
+    int src_index_mid;
+
+
+    if (coord_values_src[src_index_start] <= coord_values_src[src_index_end]) {
+        if (coord_values_src[src_index_start] > coord_value_dst) {
+            EXECUTION_REPORT(REPORT_ERROR, -1, !periodic, "software error1: can not find the location of dst cell in original grid");
+            src_cell_index_left = -1;
+            src_cell_index_right = src_index_start;
+            return;
+        }
+        if (coord_values_src[src_index_end] < coord_value_dst) {
+            EXECUTION_REPORT(REPORT_ERROR, -1, !periodic, "software error2: can not find the location of dst cell in original grid");
+            src_cell_index_left = src_index_end;
+            src_cell_index_right = -1;
+            return;
+        }
+    }
+    else {
+        if (coord_values_src[src_index_start] < coord_value_dst) {
+            EXECUTION_REPORT(REPORT_ERROR, -1, !periodic, "software error1: can not find the location of dst cell in original grid");
+            src_cell_index_left = -1;
+            src_cell_index_right = src_index_start;
+            return;
+        }
+        if (coord_values_src[src_index_end] > coord_value_dst) {
+            EXECUTION_REPORT(REPORT_ERROR, -1, !periodic, "software error2: can not find the location of dst cell in original grid");
+            src_cell_index_left = src_index_end;
+            src_cell_index_right = -1;
+            return;
+        }
+    }
+
+    if (coord_values_src[src_index_start] == coord_value_dst) {
+        src_cell_index_left = src_index_start;
+        src_cell_index_right = src_index_start + 1;
+        return;
+    }
+
+    if (coord_values_src[src_index_end] == coord_value_dst) {
+        src_cell_index_left = src_index_end-1;
+        src_cell_index_right = src_index_end;
+        return;
+    }
+
+    search_src_cells_around_dst_cell_recursively(coord_value_dst, src_index_start, src_index_end, src_cell_index_left, src_cell_index_right);
 }
 
 
 void Remap_operator_1D_basis::search_src_cells_around_dst_cell_recursively(double coord_value_dst, int src_index_start, int src_index_end, int &src_cell_index_left, int &src_cell_index_right)
 {
-	int src_index_mid;
-
-
-	if (src_index_start == src_index_end-1) {
-		src_cell_index_left = src_index_start;
-		src_cell_index_right = src_index_end;
-		EXECUTION_REPORT(REPORT_ERROR, -1, coord_values_src[src_cell_index_left] <= coord_value_dst && coord_values_src[src_cell_index_right] >= coord_value_dst, 
-			             "software error: can not find the location of dst cell in original grid recursively");
-		return;
-	}
-	
-	src_index_mid = (src_index_start+src_index_end) / 2;
-	if (coord_values_src[src_index_start] <= coord_values_src[src_index_end]) {
-		if (coord_values_src[src_index_mid] > coord_value_dst)
-			search_src_cells_around_dst_cell_recursively(coord_value_dst, src_index_start, src_index_mid, src_cell_index_left, src_cell_index_right);
-		else search_src_cells_around_dst_cell_recursively(coord_value_dst, src_index_mid, src_index_end, src_cell_index_left, src_cell_index_right);
-	}
-	else {
-		if (coord_values_src[src_index_mid] <= coord_value_dst)
-			search_src_cells_around_dst_cell_recursively(coord_value_dst, src_index_start, src_index_mid, src_cell_index_left, src_cell_index_right);
-		else search_src_cells_around_dst_cell_recursively(coord_value_dst, src_index_mid, src_index_end, src_cell_index_left, src_cell_index_right);		
-	}
+    int src_index_mid;
+
+
+    if (src_index_start == src_index_end-1) {
+        src_cell_index_left = src_index_start;
+        src_cell_index_right = src_index_end;
+        EXECUTION_REPORT(REPORT_ERROR, -1, coord_values_src[src_cell_index_left] <= coord_value_dst && coord_values_src[src_cell_index_right] >= coord_value_dst, 
+                         "software error: can not find the location of dst cell in original grid recursively");
+        return;
+    }
+    
+    src_index_mid = (src_index_start+src_index_end) / 2;
+    if (coord_values_src[src_index_start] <= coord_values_src[src_index_end]) {
+        if (coord_values_src[src_index_mid] > coord_value_dst)
+            search_src_cells_around_dst_cell_recursively(coord_value_dst, src_index_start, src_index_mid, src_cell_index_left, src_cell_index_right);
+        else search_src_cells_around_dst_cell_recursively(coord_value_dst, src_index_mid, src_index_end, src_cell_index_left, src_cell_index_right);
+    }
+    else {
+        if (coord_values_src[src_index_mid] <= coord_value_dst)
+            search_src_cells_around_dst_cell_recursively(coord_value_dst, src_index_start, src_index_mid, src_cell_index_left, src_cell_index_right);
+        else search_src_cells_around_dst_cell_recursively(coord_value_dst, src_index_mid, src_index_end, src_cell_index_left, src_cell_index_right);        
+    }
 }
 
 
 void Remap_operator_1D_basis::calculate_dst_src_mapping_info()
 {
-	int i, j;
-	bool ascending_order, src_cell_mask, dst_cell_mask;
-	
-
-	array_size_src = 0;
-
-	for (i = 0; i < dst_grid->get_grid_size(); i ++)
-		get_cell_center_coord_values_of_dst_grid(i, &coord_values_dst[i]);
-	for (i = 0; i < src_grid->get_grid_size(); i ++)
-		get_cell_center_coord_values_of_src_grid(i, &coord_values_src[i]);
-
-	ascending_order = coord_values_src[0] < coord_values_src[1];
-	for (i = 1; i < src_grid->get_grid_size() - 1; i ++) 
-		EXECUTION_REPORT(REPORT_ERROR, -1,ascending_order == coord_values_src[i] < coord_values_src[i+1] || coord_values_src[i] == coord_values_src[i+1], 
-						 "the center coordinate values corresponding to the 1D grid %s are not sorted into ascending or descending order",
-						 src_grid->get_grid_name());
-	ascending_order = coord_values_dst[0] < coord_values_dst[1];
-
-	for (i = 1; i < dst_grid->get_grid_size() - 1; i ++) 
-		EXECUTION_REPORT(REPORT_ERROR, -1, ascending_order == coord_values_dst[i] < coord_values_dst[i+1] || coord_values_dst[i] == coord_values_dst[i+1], 
-						 "the center coordinate values corresponding to the 1D grid %s are not sorted into ascending or descending order",
-						 dst_grid->get_grid_name());
-
-	if (periodic) {
-		EXECUTION_REPORT(REPORT_ERROR, -1,fabs(coord_values_src[0]-coord_values_dst[src_grid->get_grid_size()-1]) < period, 
-						 "The variation of center coordinate values corresponding to the 1D grid %s is larger than one period",
-						 src_grid->get_grid_name());
-		EXECUTION_REPORT(REPORT_ERROR, -1,fabs(coord_values_dst[0]-coord_values_dst[dst_grid->get_grid_size()-1]) < period, 
-						 "The variation of center coordinate values corresponding to the 1D grid %s is larger than one period",
-						 dst_grid->get_grid_name());
-	}
-	
-	num_useful_src_cells = 0;
-	ascending_order = coord_values_src[0] < coord_values_src[1];
-	if (ascending_order) {
-		for (i = 0; i < src_grid->get_grid_size(); i ++) {
-			get_cell_mask_of_src_grid(i, &src_cell_mask);
-			if (src_cell_mask) {
-				get_cell_center_coord_values_of_src_grid(i, &coord_values_src[num_useful_src_cells]);
-				useful_src_cells_global_index[num_useful_src_cells++] = i;
-			}
-		}	
-	}
-	else {
-		for (i = src_grid->get_grid_size()-1; i >= 0; i --) {
-			get_cell_mask_of_src_grid(i, &src_cell_mask);
-			if (src_cell_mask) {
-				get_cell_center_coord_values_of_src_grid(i, &coord_values_src[num_useful_src_cells]);
-				useful_src_cells_global_index[num_useful_src_cells++] = i;
-			}
-		}
-	}
-
-	if (num_useful_src_cells == 0)
-		return;
-	
-	if (periodic) {
-		coord_values_src[num_useful_src_cells] = coord_values_src[0] + period;
-		useful_src_cells_global_index[num_useful_src_cells] = useful_src_cells_global_index[0];
-		array_size_src = num_useful_src_cells + 1;
-	}
-	else array_size_src = num_useful_src_cells;
-
-	if (use_logarithmic_coordinate) {
-		for (i = 0; i < array_size_src; i ++) {
-			if (coord_values_src[i] <= 0)
-				EXECUTION_REPORT(REPORT_ERROR, -1, coord_values_src[i] > 0, "1D remapping operator %s cannot use logarithmic values of coodinate as new coordinate values because its source grid %s has non-positive coordinate values",
-								 object_name, src_grid->get_grid_name());
-			coord_values_src[i] = log(coord_values_src[i]);
-		}
-		for (i = 0; i < dst_grid->get_grid_size(); i ++) {
-			if (coord_values_dst[i] <= 0)
-				EXECUTION_REPORT(REPORT_ERROR, -1, coord_values_dst[i] > 0, "1D remapping operator %s cannot use logarithmic values of coodinate as new coordinate values because its source grid %s has non-positive coordinate values",
-								 object_name, dst_grid->get_grid_name());
-			coord_values_dst[i] = log(coord_values_dst[i]);
-		}			
-	}
-
-	if (use_exponent_coordinate) {
-		for (i = 0; i < array_size_src; i ++) {
-			if (coord_values_src[i] > 0)
-				EXECUTION_REPORT(REPORT_ERROR, -1, coord_values_src[i] <= 0, "1D remapping operator %s cannot use exponent values of coodinate as new coordinate values because its source grid %s has positive coordinate values",
-								 object_name, src_grid->get_grid_name());
-			coord_values_src[i] = exp(coord_values_src[i]);
-		}
-		for (i = 0; i < dst_grid->get_grid_size(); i ++) {
-			if (coord_values_dst[i] > 0)
-				EXECUTION_REPORT(REPORT_ERROR, -1, coord_values_dst[i] <= 0, "1D remapping operator %s cannot use exponent values of coodinate as new coordinate values because its source grid %s has positive coordinate values",
-								 object_name, dst_grid->get_grid_name());
-			coord_values_dst[i] = exp(coord_values_dst[i]);
-		}			
-	}
-
-	for (i = 0; i < dst_grid->get_grid_size(); i ++) {
-		src_cell_index_left[i] = -1;
-		src_cell_index_right[i] = -1;
-		get_cell_mask_of_dst_grid(i, &dst_cell_mask);
-		if (!dst_cell_mask)
-			continue;
-		search_src_cells_around_dst_cell(coord_values_dst[i], 0, array_size_src-1, src_cell_index_left[i], src_cell_index_right[i]);
-		for (j = 0; j < array_size_src && coord_values_src[j] <= coord_values_dst[i]; j ++);
-		if (j > 0 && j < array_size_src)
-			EXECUTION_REPORT(REPORT_ERROR, -1, src_cell_index_left[i] == j-1 && src_cell_index_right[i] == j, "error error3\n"); 
-		if ((src_cell_index_left[i] == -1 || src_cell_index_right[i] == -1) && !enable_extrapolate)
-			continue;
-		if (src_cell_index_right[i] == -1) {
-			src_cell_index_right[i] = src_cell_index_left[i];
-			if (extrapolation_approach == 0)
-				src_cell_index_left[i] --;
-			else if (extrapolation_approach == 1)
-				src_cell_index_left[i] = src_cell_index_left[i];
-		}
-		else if (src_cell_index_left[i] == -1) {
-			src_cell_index_left[i] = src_cell_index_right[i];
-			if (extrapolation_approach == 0)
-				src_cell_index_right[i] ++;
-			else if (extrapolation_approach == 1)
-				src_cell_index_right[i] = src_cell_index_right[i];
-		}
-	}
+    int i, j;
+    bool ascending_order, src_cell_mask, dst_cell_mask;
+    
+
+    array_size_src = 0;
+
+    for (i = 0; i < dst_grid->get_grid_size(); i ++)
+        get_cell_center_coord_values_of_dst_grid(i, &coord_values_dst[i]);
+    for (i = 0; i < src_grid->get_grid_size(); i ++)
+        get_cell_center_coord_values_of_src_grid(i, &coord_values_src[i]);
+
+    ascending_order = coord_values_src[0] < coord_values_src[1];
+    for (i = 1; i < src_grid->get_grid_size() - 1; i ++) 
+        EXECUTION_REPORT(REPORT_ERROR, -1,ascending_order == coord_values_src[i] < coord_values_src[i+1] || coord_values_src[i] == coord_values_src[i+1], 
+                         "the center coordinate values corresponding to the 1D grid %s are not sorted into ascending or descending order",
+                         src_grid->get_grid_name());
+    ascending_order = coord_values_dst[0] < coord_values_dst[1];
+
+    for (i = 1; i < dst_grid->get_grid_size() - 1; i ++) 
+        EXECUTION_REPORT(REPORT_ERROR, -1, ascending_order == coord_values_dst[i] < coord_values_dst[i+1] || coord_values_dst[i] == coord_values_dst[i+1], 
+                         "the center coordinate values corresponding to the 1D grid %s are not sorted into ascending or descending order",
+                         dst_grid->get_grid_name());
+
+    if (periodic) {
+        EXECUTION_REPORT(REPORT_ERROR, -1,fabs(coord_values_src[0]-coord_values_dst[src_grid->get_grid_size()-1]) < period, 
+                         "The variation of center coordinate values corresponding to the 1D grid %s is larger than one period",
+                         src_grid->get_grid_name());
+        EXECUTION_REPORT(REPORT_ERROR, -1,fabs(coord_values_dst[0]-coord_values_dst[dst_grid->get_grid_size()-1]) < period, 
+                         "The variation of center coordinate values corresponding to the 1D grid %s is larger than one period",
+                         dst_grid->get_grid_name());
+    }
+    
+    num_useful_src_cells = 0;
+    ascending_order = coord_values_src[0] < coord_values_src[1];
+    if (ascending_order) {
+        for (i = 0; i < src_grid->get_grid_size(); i ++) {
+            get_cell_mask_of_src_grid(i, &src_cell_mask);
+            if (src_cell_mask) {
+                get_cell_center_coord_values_of_src_grid(i, &coord_values_src[num_useful_src_cells]);
+                useful_src_cells_global_index[num_useful_src_cells++] = i;
+            }
+        }    
+    }
+    else {
+        for (i = src_grid->get_grid_size()-1; i >= 0; i --) {
+            get_cell_mask_of_src_grid(i, &src_cell_mask);
+            if (src_cell_mask) {
+                get_cell_center_coord_values_of_src_grid(i, &coord_values_src[num_useful_src_cells]);
+                useful_src_cells_global_index[num_useful_src_cells++] = i;
+            }
+        }
+    }
+
+    if (num_useful_src_cells == 0)
+        return;
+    
+    if (periodic) {
+        coord_values_src[num_useful_src_cells] = coord_values_src[0] + period;
+        useful_src_cells_global_index[num_useful_src_cells] = useful_src_cells_global_index[0];
+        array_size_src = num_useful_src_cells + 1;
+    }
+    else array_size_src = num_useful_src_cells;
+
+    if (use_logarithmic_coordinate) {
+        for (i = 0; i < array_size_src; i ++) {
+            if (coord_values_src[i] <= 0)
+                EXECUTION_REPORT(REPORT_ERROR, -1, coord_values_src[i] > 0, "1D remapping operator %s cannot use logarithmic values of coodinate as new coordinate values because its source grid %s has non-positive coordinate values",
+                                 object_name, src_grid->get_grid_name());
+            coord_values_src[i] = log(coord_values_src[i]);
+        }
+        for (i = 0; i < dst_grid->get_grid_size(); i ++) {
+            if (coord_values_dst[i] <= 0)
+                EXECUTION_REPORT(REPORT_ERROR, -1, coord_values_dst[i] > 0, "1D remapping operator %s cannot use logarithmic values of coodinate as new coordinate values because its source grid %s has non-positive coordinate values",
+                                 object_name, dst_grid->get_grid_name());
+            coord_values_dst[i] = log(coord_values_dst[i]);
+        }            
+    }
+
+    if (use_exponent_coordinate) {
+        for (i = 0; i < array_size_src; i ++) {
+            if (coord_values_src[i] > 0)
+                EXECUTION_REPORT(REPORT_ERROR, -1, coord_values_src[i] <= 0, "1D remapping operator %s cannot use exponent values of coodinate as new coordinate values because its source grid %s has positive coordinate values",
+                                 object_name, src_grid->get_grid_name());
+            coord_values_src[i] = exp(coord_values_src[i]);
+        }
+        for (i = 0; i < dst_grid->get_grid_size(); i ++) {
+            if (coord_values_dst[i] > 0)
+                EXECUTION_REPORT(REPORT_ERROR, -1, coord_values_dst[i] <= 0, "1D remapping operator %s cannot use exponent values of coodinate as new coordinate values because its source grid %s has positive coordinate values",
+                                 object_name, dst_grid->get_grid_name());
+            coord_values_dst[i] = exp(coord_values_dst[i]);
+        }            
+    }
+
+    for (i = 0; i < dst_grid->get_grid_size(); i ++) {
+        src_cell_index_left[i] = -1;
+        src_cell_index_right[i] = -1;
+        get_cell_mask_of_dst_grid(i, &dst_cell_mask);
+        if (!dst_cell_mask)
+            continue;
+        search_src_cells_around_dst_cell(coord_values_dst[i], 0, array_size_src-1, src_cell_index_left[i], src_cell_index_right[i]);
+        for (j = 0; j < array_size_src && coord_values_src[j] <= coord_values_dst[i]; j ++);
+        if (j > 0 && j < array_size_src)
+            EXECUTION_REPORT(REPORT_ERROR, -1, src_cell_index_left[i] == j-1 && src_cell_index_right[i] == j, "error error3\n"); 
+        if ((src_cell_index_left[i] == -1 || src_cell_index_right[i] == -1) && !enable_extrapolate)
+            continue;
+        if (src_cell_index_right[i] == -1) {
+            src_cell_index_right[i] = src_cell_index_left[i];
+            if (extrapolation_approach == 0)
+                src_cell_index_left[i] --;
+            else if (extrapolation_approach == 1)
+                src_cell_index_left[i] = src_cell_index_left[i];
+        }
+        else if (src_cell_index_left[i] == -1) {
+            src_cell_index_left[i] = src_cell_index_right[i];
+            if (extrapolation_approach == 0)
+                src_cell_index_right[i] ++;
+            else if (extrapolation_approach == 1)
+                src_cell_index_right[i] = src_cell_index_right[i];
+        }
+    }
 }
 
 
 void Remap_operator_1D_basis::preprocess_field_value(double *data_values_src)
 {
-	for (int i = 0; i < array_size_src; i ++)
-		packed_data_values_src[i] = data_values_src[useful_src_cells_global_index[i]];
+    for (int i = 0; i < array_size_src; i ++)
+        packed_data_values_src[i] = data_values_src[useful_src_cells_global_index[i]];
 }
 
 
 void Remap_operator_1D_basis::postprocess_field_value(double *data_values_dst)
 {
-	int i, dst_index;	
+    int i, dst_index;    
 }
 
diff --git a/src/CoR/remap_operator_1D_basis.h b/src/CoR/remap_operator_1D_basis.h
old mode 100644
new mode 100755
index 70ae6f4..5082abb
--- a/src/CoR/remap_operator_1D_basis.h
+++ b/src/CoR/remap_operator_1D_basis.h
@@ -22,44 +22,44 @@ class Remap_operator_1D_basis: public Remap_operator_basis
 {
     protected:
         bool periodic;
-		bool set_periodic;
-		bool set_period;
-		bool set_enable_extrapolation;
-		bool use_logarithmic_coordinate;
-		bool set_use_logarithmic_coordinate;
-		bool use_exponent_coordinate;
-		bool set_use_exponent_coordinate;
-		int extrapolation_approach;
-		double period;
-		double *coord_values_src;
-		double *coord_values_dst;
-		double *packed_data_values_src;
-		int num_useful_src_cells;
-		int array_size_src;
-		int *useful_src_cells_global_index;
-		int *src_cell_index_left;
-		int *src_cell_index_right;
+        bool set_periodic;
+        bool set_period;
+        bool set_enable_extrapolation;
+        bool use_logarithmic_coordinate;
+        bool set_use_logarithmic_coordinate;
+        bool use_exponent_coordinate;
+        bool set_use_exponent_coordinate;
+        int extrapolation_approach;
+        double period;
+        double *coord_values_src;
+        double *coord_values_dst;
+        double *packed_data_values_src;
+        int num_useful_src_cells;
+        int array_size_src;
+        int *useful_src_cells_global_index;
+        int *src_cell_index_left;
+        int *src_cell_index_right;
 
-		double base_field_value;
+        double base_field_value;
 
-		void initialize_1D_remap_operator();
-		void copy_1D_remap_operator_info(Remap_operator_1D_basis*);
-		void allocate_1D_remap_operator_common_arrays_space();
-		void search_src_cells_around_dst_cell(double, int, int, int&, int&);
-		void search_src_cells_around_dst_cell_recursively(double, int, int,  int&, int&);
-		void set_common_parameter(const char*, const char*);
-		int check_common_parameter(const char*, const char*, char*);
-		void calculate_dst_src_mapping_info();
-		void preprocess_field_value(double*);
-		void postprocess_field_value(double*);
+        void initialize_1D_remap_operator();
+        void copy_1D_remap_operator_info(Remap_operator_1D_basis*);
+        void allocate_1D_remap_operator_common_arrays_space();
+        void search_src_cells_around_dst_cell(double, int, int, int&, int&);
+        void search_src_cells_around_dst_cell_recursively(double, int, int,  int&, int&);
+        void set_common_parameter(const char*, const char*);
+        int check_common_parameter(const char*, const char*, char*);
+        void calculate_dst_src_mapping_info();
+        void preprocess_field_value(double*);
+        void postprocess_field_value(double*);
 
     public:
-		Remap_operator_1D_basis() {}
+        Remap_operator_1D_basis() {}
         Remap_operator_1D_basis(const char*, const char*, int, Remap_grid_class **);
         virtual ~Remap_operator_1D_basis();
         virtual void set_parameter(const char*, const char*) = 0;
-		virtual int check_parameter(const char*, const char*, char*) = 0;
-        virtual void do_remap_values_caculation(double*, double*) = 0;
+        virtual int check_parameter(const char*, const char*, char*) = 0;
+        virtual void do_remap_values_caculation(double*, double*, int) = 0;
         virtual void do_src_decomp_caculation(long*, const long*) = 0;
         virtual void calculate_remap_weights() = 0;
         virtual Remap_operator_basis *duplicate_remap_operator(bool) = 0;
diff --git a/src/CoR/remap_operator_basis.cxx b/src/CoR/remap_operator_basis.cxx
old mode 100644
new mode 100755
index e1c60fe..9563ecb
--- a/src/CoR/remap_operator_basis.cxx
+++ b/src/CoR/remap_operator_basis.cxx
@@ -8,6 +8,7 @@
 
 
 #include "cor_global_data.h"
+#include "global_data.h"
 #include "remap_operator_basis.h"
 #include "quick_sort.h"
 #include <string.h>
@@ -156,7 +157,7 @@ void Remap_operator_basis::calculate_grids_overlaping()
         if (!dst_cell_mask)
             continue;
         get_cell_center_coord_values_of_dst_grid(cell_index_dst, center_coord_values_dst);  
-		get_current_grid2D_search_engine(true)->search_overlapping_cells(num_overlapping_src_cells, overlapping_src_cells_indexes, get_current_grid2D_search_engine(false)->get_cell(cell_index_dst), true, false);
+        get_current_grid2D_search_engine(true)->search_overlapping_cells(num_overlapping_src_cells, overlapping_src_cells_indexes, get_current_grid2D_search_engine(false)->get_cell(cell_index_dst), true, false);
         displ_src_cells_overlap_with_dst_cells[cell_index_dst] = num_overlapping_src_cells;
         if (num_overlapping_src_cells+temp_array_iter >= size_index_src_cells_overlap_with_dst_cells) {
             size_index_src_cells_overlap_with_dst_cells *= 2;
@@ -168,7 +169,7 @@ void Remap_operator_basis::calculate_grids_overlaping()
         }
         for (i = 0; i < num_overlapping_src_cells; i ++)
             index_src_cells_overlap_with_dst_cells[temp_array_iter++] = overlapping_src_cells_indexes[i];
-		do_quick_sort(overlapping_src_cells_indexes, (long*)NULL, 0, num_overlapping_src_cells-1);
+        do_quick_sort(overlapping_src_cells_indexes, (long*)NULL, 0, num_overlapping_src_cells-1);
     }
     finalize_computing_remap_weights_of_one_cell();
 
@@ -212,21 +213,40 @@ void Remap_operator_basis::generate_parallel_remap_weights(Remap_operator_basis
 
 void Remap_operator_basis::change_remap_operator_info(const char *operator_name, Remap_grid_class *grid_src, Remap_grid_class *grid_dst)
 {
-	strcpy(this->operator_name, operator_name);
-	this->src_grid = grid_src;
-	this->dst_grid = grid_dst;
+    strcpy(this->operator_name, operator_name);
+    this->src_grid = grid_src;
+    this->dst_grid = grid_dst;
 }
 
 
 void Remap_operator_basis::update_unique_weight_sparse_matrix(Remap_weight_sparse_matrix *new_sparse_matrix)
 {
-	if (remap_weights_groups.size() > 0) {
-		EXECUTION_REPORT(REPORT_ERROR, -1, remap_weights_groups.size() == 1 && remap_weights_groups[0]->get_num_weights() == 0, "Software error in Remap_operator_basis::update_unique_weight_sparse_matrix");
-		delete remap_weights_groups[0];
-		remap_weights_groups.clear();
-	}
+    if (remap_weights_groups.size() > 0) {
+        EXECUTION_REPORT(REPORT_ERROR, -1, remap_weights_groups.size() == 1 && remap_weights_groups[0]->get_num_weights() == 0, "Software error in Remap_operator_basis::update_unique_weight_sparse_matrix");
+        delete remap_weights_groups[0];
+        remap_weights_groups.clear();
+    }
 
-	remap_weights_groups.push_back(new_sparse_matrix);
+    remap_weights_groups.push_back(new_sparse_matrix);
 }
 
 
+Remap_operator_basis *Remap_operator_basis::gather(int comp_id)
+{
+	Comp_comm_group_mgt_node *comp_node = comp_comm_group_mgt_mgr->search_global_node(comp_id);
+	Remap_operator_basis *overall_remap_operator = NULL;
+
+	
+	EXECUTION_REPORT_ERROR_OPTIONALLY(REPORT_ERROR, -1, remap_weights_groups.size() == 1, "software error in Remap_operator_basis::gather");
+	if (comp_node->get_current_proc_local_id() == 0)
+		overall_remap_operator = duplicate_remap_operator(false);
+
+	for (int i = 0; i < remap_weights_groups.size(); i ++) {
+		Remap_weight_sparse_matrix *overall_remap_weight_sparse_matrix = remap_weights_groups[i]->gather(comp_id);
+		if (comp_node->get_current_proc_local_id() == 0)
+			overall_remap_operator->remap_weights_groups.push_back(overall_remap_weight_sparse_matrix);
+	}
+	
+	return overall_remap_operator;
+}
+
diff --git a/src/CoR/remap_operator_basis.h b/src/CoR/remap_operator_basis.h
old mode 100644
new mode 100755
index 9dfd111..d863538
--- a/src/CoR/remap_operator_basis.h
+++ b/src/CoR/remap_operator_basis.h
@@ -47,22 +47,22 @@ class Remap_operator_basis
         long *displ_src_cells_overlap_with_dst_cells;
         long *index_src_cells_overlap_with_dst_cells;
         long size_index_src_cells_overlap_with_dst_cells;
-		bool enable_extrapolate;
+        bool enable_extrapolate;
 
     public:
         Remap_operator_basis(const char*, const char*, int, bool, bool, bool, int, Remap_grid_class **);
         Remap_operator_basis();
         virtual ~Remap_operator_basis();
         virtual void set_parameter(const char*, const char*) = 0;
-		virtual int check_parameter(const char*, const char*, char*) = 0;
-        virtual void do_remap_values_caculation(double*, double*) = 0;
+        virtual int check_parameter(const char*, const char*, char*) = 0;
+        virtual void do_remap_values_caculation(double*, double*, int) = 0;
         virtual void do_src_decomp_caculation(long*, const long*) = 0;
         virtual void calculate_remap_weights() = 0;
         virtual Remap_operator_basis *duplicate_remap_operator(bool) = 0;
         virtual Remap_operator_basis *generate_parallel_remap_operator(Remap_grid_class**, int**) = 0;
         virtual void compute_remap_weights_of_one_dst_cell(long) = 0;
         bool match_remap_operator(const char*);
-		bool match_remap_operator(Remap_grid_class*, Remap_grid_class*, const char*);
+        bool match_remap_operator(Remap_grid_class*, Remap_grid_class*, const char*);
         void calculate_grids_overlaping();
         void copy_remap_operator_basic_data(Remap_operator_basis*, bool);
         void generate_parallel_remap_weights(Remap_operator_basis*, Remap_grid_class**, int**);
@@ -79,10 +79,11 @@ class Remap_operator_basis
         int get_num_dimensions() { return num_dimensions; }
         bool get_is_sphere_grid() { return src_grid->get_is_sphere_grid(); }
         void add_weight_sparse_matrix(Remap_weight_sparse_matrix *sparse_matrix) { remap_weights_groups.push_back(sparse_matrix); }
-		void update_unique_weight_sparse_matrix(Remap_weight_sparse_matrix *);
-		void change_remap_operator_info(const char*, Remap_grid_class*, Remap_grid_class*);
-		void set_src_grid(Remap_grid_class *new_src_grid) { src_grid = new_src_grid; }
-		void set_dst_grid(Remap_grid_class *new_dst_grid) { dst_grid = new_dst_grid; }
+        void update_unique_weight_sparse_matrix(Remap_weight_sparse_matrix *);
+        void change_remap_operator_info(const char*, Remap_grid_class*, Remap_grid_class*);
+        void set_src_grid(Remap_grid_class *new_src_grid) { src_grid = new_src_grid; }
+        void set_dst_grid(Remap_grid_class *new_dst_grid) { dst_grid = new_dst_grid; }
+		Remap_operator_basis *gather(int);
 };
 
 
diff --git a/src/CoR/remap_operator_bilinear.cxx b/src/CoR/remap_operator_bilinear.cxx
old mode 100644
new mode 100755
index 3b8d48e..4bc6885
--- a/src/CoR/remap_operator_bilinear.cxx
+++ b/src/CoR/remap_operator_bilinear.cxx
@@ -21,27 +21,27 @@ void Remap_operator_bilinear::set_parameter(const char *parameter_name, const ch
     EXECUTION_REPORT(REPORT_ERROR, -1, enable_to_set_parameters, 
                  "the parameter of remap operator object \"%s\" must be set before using it to build remap strategy\n",
                  object_name);
-	if (words_are_the_same(parameter_name, "enable_extrapolate")) {
-		if (words_are_the_same(parameter_value, "true"))
-	        enable_extrapolate = true;
-		else if (words_are_the_same(parameter_value, "false"))
-	        enable_extrapolate = true;
-		else EXECUTION_REPORT(REPORT_ERROR, -1, false, "The parameter value must be \"true\" or \"false\"\n");
-	}
+    if (words_are_the_same(parameter_name, "enable_extrapolate")) {
+        if (words_are_the_same(parameter_value, "true"))
+            enable_extrapolate = true;
+        else if (words_are_the_same(parameter_value, "false"))
+            enable_extrapolate = false;
+        else EXECUTION_REPORT(REPORT_ERROR, -1, false, "The parameter value must be \"true\" or \"false\"\n");
+    }
     else EXECUTION_REPORT(REPORT_ERROR, -1, false, "bilinear algorithm does not have the parameter to be set\n");
 }
 
 
 int Remap_operator_bilinear::check_parameter(const char *parameter_name, const char *parameter_value, char *error_string)
 {
-	int check_result = 0;
-	if (words_are_the_same(parameter_name, "enable_extrapolate")) {
-		check_result = 1;
-		if (words_are_the_same(parameter_value, "true") || words_are_the_same(parameter_value, "false"))
-			check_result = 3;
-		else sprintf(error_string, "The parameter value must be \"true\" or \"false\"");
-	}
-	
+    int check_result = 0;
+    if (words_are_the_same(parameter_name, "enable_extrapolate")) {
+        check_result = 1;
+        if (words_are_the_same(parameter_value, "true") || words_are_the_same(parameter_value, "false"))
+            check_result = 3;
+        else sprintf(error_string, "The parameter value must be \"true\" or \"false\"");
+    }
+    
     return check_result;
 }
 
@@ -51,7 +51,7 @@ Remap_operator_bilinear::Remap_operator_bilinear()
     found_nearest_points_distance = NULL;
     found_nearest_points_src_indexes = NULL;
     weigt_values_of_one_dst_cell = NULL;
-	enable_extrapolate = false;
+    enable_extrapolate = false;
 }
 
 
@@ -72,7 +72,7 @@ Remap_operator_bilinear::Remap_operator_bilinear(const char *object_name, int nu
     found_nearest_points_distance = new double [src_grid->get_grid_size()];
     found_nearest_points_src_indexes = new long [src_grid->get_grid_size()];
     weigt_values_of_one_dst_cell = new double [max_num_found_nearest_points];
-	enable_extrapolate = false;
+    enable_extrapolate = false;
 }
 
 
@@ -94,8 +94,8 @@ void Remap_operator_bilinear::calculate_remap_weights()
     clear_remap_weight_info_in_sparse_matrix();
     
     for (long dst_cell_index = 0; dst_cell_index < dst_grid->get_grid_size(); dst_cell_index++) {
-		if (H2D_grid_decomp_mask != NULL && !H2D_grid_decomp_mask[dst_cell_index])
-			continue;
+        if (H2D_grid_decomp_mask != NULL && !H2D_grid_decomp_mask[dst_cell_index])
+            continue;
         initialize_computing_remap_weights_of_one_cell();
         compute_remap_weights_of_one_dst_cell(dst_cell_index);    
         finalize_computing_remap_weights_of_one_cell();
@@ -114,15 +114,15 @@ int Remap_operator_bilinear::search_at_least_16_nearnest_src_points_for_bilinear
 
     while (num_points_within_threshold_distance < 16) {
         num_points_within_threshold_distance = 0;
-		get_current_grid2D_search_engine(true)->search_nearest_points_var_distance(current_threshold_distance, dst_cell_center_values[0], dst_cell_center_values[1], 
-																								              num_points_within_threshold_distance, found_nearest_points_src_indexes, found_nearest_points_distance, true);
+        get_current_grid2D_search_engine(true)->search_nearest_points_var_distance(current_threshold_distance, dst_cell_center_values[0], dst_cell_center_values[1], 
+                                                                                                              num_points_within_threshold_distance, found_nearest_points_src_indexes, found_nearest_points_distance, true);
         if (num_points_within_threshold_distance >= 4 && near_optimal_threshold_distance == 0.0)
             near_optimal_threshold_distance = current_threshold_distance * sqrt(((double)4)/((double)num_points_within_threshold_distance));
         if (num_points_within_threshold_distance == 0)
             current_threshold_distance *= 2;
         else current_threshold_distance *= 1.1;     
-	if (num_points_within_threshold_distance > 0 && found_nearest_points_distance[0] <= eps)
-		break;
+    if (num_points_within_threshold_distance > 0 && found_nearest_points_distance[0] <= eps)
+        break;
 
     }
 
@@ -178,7 +178,7 @@ bool Remap_operator_bilinear::get_near_optimal_bilinear_box_recursively(double *
     bool have_points_on_the_same_line;
     int index_of_quadrant_id_for_distance_sorting[4];
     int new_iter_num_src_points_in_each_quadrant[4];
-	double eps = 2.0e-9;
+    double eps = 2.0e-9;
 
 
     for (i = 0; i < 4; i ++) {
@@ -194,7 +194,7 @@ bool Remap_operator_bilinear::get_near_optimal_bilinear_box_recursively(double *
                           bilinear_vertex_coord2_values,
                           index_of_selected_src_point_in_each_quadrant,
                           4);     
-	
+    
     if (is_point_in_2D_cell(dst_cell_center_values[0], 
                             dst_cell_center_values[1],
                             bilinear_vertex_coord1_values,
@@ -318,7 +318,7 @@ void Remap_operator_bilinear::compute_remap_weights_of_one_dst_cell(long dst_cel
     double eps = 2.0e-7;
     int num_vertexes_dst;
     double vertex_coord_values_dst[65536];
-	
+    
 
     initialize_computing_remap_weights_of_one_cell();
 
@@ -331,8 +331,8 @@ void Remap_operator_bilinear::compute_remap_weights_of_one_dst_cell(long dst_cel
     /* When no src cell contains the center of the dst cell, we use inverse distance weight to compute weight values
       */
     get_cell_center_coord_values_of_dst_grid(dst_cell_index, dst_cell_center_values);
-	get_cell_vertex_coord_values_of_dst_grid(dst_cell_index, &num_vertexes_dst, vertex_coord_values_dst, true);
-	EXECUTION_REPORT(REPORT_ERROR, -1, num_vertexes_dst <= 65536/2, "Software error in Remap_operator_bilinear::compute_remap_weights_of_one_dst_cell: too big number of num_vertexes_dst %d", num_vertexes_dst);
+    get_cell_vertex_coord_values_of_dst_grid(dst_cell_index, &num_vertexes_dst, vertex_coord_values_dst, true);
+    EXECUTION_REPORT(REPORT_ERROR, -1, num_vertexes_dst <= 65536/2, "Software error in Remap_operator_bilinear::compute_remap_weights_of_one_dst_cell: too big number of num_vertexes_dst %d", num_vertexes_dst);
 
     if (num_vertexes_dst > 0 && (!enable_extrapolate && !have_overlapped_src_cells_for_dst_cell(dst_cell_index)))
         return;
@@ -341,10 +341,12 @@ void Remap_operator_bilinear::compute_remap_weights_of_one_dst_cell(long dst_cel
     if (src_cell_index != -1)
         get_cell_mask_of_src_grid(src_cell_index, &src_cell_mask);
 
-	if (num_vertexes_dst == 0 && src_cell_index == -1 && (!enable_extrapolate))
-		return;
-	if (num_vertexes_dst == 0 && (!enable_extrapolate && !src_cell_mask))
-		return;
+    if (num_vertexes_dst == 0 && src_cell_index == -1 && (!enable_extrapolate))
+        return;
+    if (num_vertexes_dst == 0 && (!enable_extrapolate && !src_cell_mask))
+        return;
+    
+    iterative_threshold_distance = 1.0/6000.0;
 
     if (src_cell_index == -1 || !src_cell_mask) {
         compute_dist_remap_weights_of_one_dst_cell(dst_cell_index, 
@@ -380,11 +382,11 @@ void Remap_operator_bilinear::compute_remap_weights_of_one_dst_cell(long dst_cel
                                                                                                    src_cell_index, 
                                                                                                    current_threshold_distance, 
                                                                                                    near_optimal_threshold_distance);
-		if (found_nearest_points_distance[0] <= eps) {
-			weigt_values_of_one_dst_cell[0] = 1.0;
-			add_remap_weights_to_sparse_matrix(&found_nearest_points_src_indexes[0], dst_cell_index, weigt_values_of_one_dst_cell, 1, 0, true);
-			return;
-		}
+        if (found_nearest_points_distance[0] <= eps) {
+            weigt_values_of_one_dst_cell[0] = 1.0;
+            add_remap_weights_to_sparse_matrix(&found_nearest_points_src_indexes[0], dst_cell_index, weigt_values_of_one_dst_cell, 1, 0, true);
+            return;
+        }
         if (num_points_within_threshold_distance > max_num_found_nearest_points)
             break;        
         if (get_near_optimal_bilinear_box(dst_cell_center_values, 
@@ -469,7 +471,7 @@ void Remap_operator_bilinear::bilinear_ratios_solution1(double *dst_point_coord_
     y_diff_32 = compute_difference_of_two_coord_values(bilinear_box_vertexes_coord2_values[2], bilinear_box_vertexes_coord2_values[3], 1);
 
     ratio_u = (y_diff_03*x_diff_04-x_diff_03*y_diff_04)/(x_diff_01*y_diff_03-y_diff_01*x_diff_03);
-    EXECUTION_REPORT(REPORT_ERROR, -1, ratio_u > 0 && ratio_u < 1, "remap software error1 in bilinear_ratios_solution1\n");
+    EXECUTION_REPORT(REPORT_ERROR, -1, ratio_u >= 0 && ratio_u <= 1, "remap software error1 in bilinear_ratios_solution1\n");
     
     coord_values_P5[0] = bilinear_box_vertexes_coord1_values[0] + ratio_u*x_diff_01;
     coord_values_P5[1] = bilinear_box_vertexes_coord2_values[0] + ratio_u*y_diff_01;
@@ -486,7 +488,7 @@ void Remap_operator_bilinear::bilinear_ratios_solution1(double *dst_point_coord_
                                                   coord_values_P5[1],
                                                   false);
     ratio_v = dist_54 / dist_56;
-    EXECUTION_REPORT(REPORT_ERROR, -1, ratio_v > 0 && ratio_v < 1, "remap software error2 in bilinear_ratios_solution1\n");
+    EXECUTION_REPORT(REPORT_ERROR, -1, ratio_v >= 0 && ratio_v <= 1, "remap software error2 in bilinear_ratios_solution1\n");
 }
 
 
@@ -498,6 +500,7 @@ void Remap_operator_bilinear::bilinear_one_ratio_solution_of_quadratic_equation(
     double x_diff_01, y_diff_01, x_diff_32, y_diff_32, x_diff_04, y_diff_04, x_diff_43, y_diff_43;
     double coef_A, coef_B, coef_C;
     double ratio_u1, ratio_u2, ratio_u_false;
+	double eps = 1.0e-13;
         
     /*
           (x0,y0)                  (x1,y1)
@@ -533,7 +536,7 @@ void Remap_operator_bilinear::bilinear_one_ratio_solution_of_quadratic_equation(
     ratio_u2 = (-coef_B - sqrt(coef_B*coef_B-4*coef_A*coef_C))/(2*coef_A);
 
     ratio_u = -1.0;
-    if (ratio_u1 > 0 && ratio_u1 < 1) {
+    if (ratio_u1 >= 0 && ratio_u1 <= 1) {
         ratio_u = ratio_u1;
         ratio_u_false = ratio_u2;
     }
@@ -542,8 +545,12 @@ void Remap_operator_bilinear::bilinear_one_ratio_solution_of_quadratic_equation(
         ratio_u_false = ratio_u1;
     }
 
-    EXECUTION_REPORT(REPORT_ERROR, -1, ratio_u > 0 && ratio_u < 1, "remap software error3 in bilinear_one_ratio_solution_of_quadratic_equation");
-    EXECUTION_REPORT(REPORT_ERROR, -1, ratio_u_false < 0 || ratio_u_false > 1, "remap software error4 in bilinear_one_ratio_of_solution_quadratic_equation");
+	if (ratio_u < 0.0 && ratio_u > -eps)
+		ratio_u = 0.0;
+	if (ratio_u > 1.0 && ratio_u < 1.0+eps)
+		ratio_u = 1.0;
+    EXECUTION_REPORT(REPORT_WARNING, -1, ratio_u >= 0 && ratio_u <= 1, "remap software error3 in bilinear_one_ratio_solution_of_quadratic_equation: %0.18lf   %0.18lf  %0.18lf : (%lf %lf): (%lf %lf)  (%lf %lf)  (%lf %lf)  (%lf %lf)", ratio_u, ratio_u1, ratio_u2, dst_point_coord_values[0], dst_point_coord_values[1], bilinear_box_vertexes_coord1_values[0], bilinear_box_vertexes_coord2_values[0], bilinear_box_vertexes_coord1_values[1], bilinear_box_vertexes_coord2_values[1], bilinear_box_vertexes_coord1_values[2], bilinear_box_vertexes_coord2_values[2], bilinear_box_vertexes_coord1_values[3], bilinear_box_vertexes_coord2_values[3]);
+    //EXECUTION_REPORT(REPORT_ERROR, -1, ratio_u_false < eps || ratio_u_false > 1-eps, "remap software error4 in bilinear_one_ratio_of_solution_quadratic_equation");
 }
 
 
@@ -637,9 +644,9 @@ void Remap_operator_bilinear::solve_two_bilinear_ratios(long *bilinear_box_verte
 }
 
 
-void Remap_operator_bilinear::do_remap_values_caculation(double *data_values_src, double *data_values_dst)
+void Remap_operator_bilinear::do_remap_values_caculation(double *data_values_src, double *data_values_dst, int dst_array_size)
 {
-    remap_weights_groups[0]->remap_values(data_values_src, data_values_dst);
+    remap_weights_groups[0]->remap_values(data_values_src, data_values_dst, dst_array_size);
 }
 
 
@@ -653,10 +660,10 @@ Remap_operator_basis *Remap_operator_bilinear::duplicate_remap_operator(bool ful
 {
     Remap_operator_bilinear *duplicated_remap_operator = new Remap_operator_bilinear();
     copy_remap_operator_basic_data(duplicated_remap_operator, fully_copy);
-	duplicated_remap_operator->max_num_found_nearest_points = max_num_found_nearest_points;
-	duplicated_remap_operator->num_nearest_points = num_nearest_points;
-	duplicated_remap_operator->num_power = num_power;
-	duplicated_remap_operator->iterative_threshold_distance = iterative_threshold_distance;
+    duplicated_remap_operator->max_num_found_nearest_points = max_num_found_nearest_points;
+    duplicated_remap_operator->num_nearest_points = num_nearest_points;
+    duplicated_remap_operator->num_power = num_power;
+    duplicated_remap_operator->iterative_threshold_distance = iterative_threshold_distance;
     return duplicated_remap_operator;
 }
 
diff --git a/src/CoR/remap_operator_bilinear.h b/src/CoR/remap_operator_bilinear.h
old mode 100644
new mode 100755
index 42482c1..5a2538d
--- a/src/CoR/remap_operator_bilinear.h
+++ b/src/CoR/remap_operator_bilinear.h
@@ -43,9 +43,9 @@ class Remap_operator_bilinear: public Remap_operator_basis
         Remap_operator_bilinear();
         ~Remap_operator_bilinear();
         void set_parameter(const char *, const char *);
-		int check_parameter(const char*, const char*, char*);
+        int check_parameter(const char*, const char*, char*);
         void calculate_remap_weights();
-        void do_remap_values_caculation(double*, double*);
+        void do_remap_values_caculation(double*, double*, int);
         void do_src_decomp_caculation(long*, const long*);
         Remap_operator_basis *duplicate_remap_operator(bool);
         Remap_operator_basis *generate_parallel_remap_operator(Remap_grid_class**, int**);
diff --git a/src/CoR/remap_operator_c_interface.cxx b/src/CoR/remap_operator_c_interface.cxx
old mode 100644
new mode 100755
index dcbafe7..bb1028e
--- a/src/CoR/remap_operator_c_interface.cxx
+++ b/src/CoR/remap_operator_c_interface.cxx
@@ -91,16 +91,16 @@ void get_cell_center_coord_values_of_dst_grid(long cell_index, double *center_va
 
 H2D_grid_cell_search_engine *get_current_grid2D_search_engine(bool is_src_grid)
 {
-	if (is_src_grid) {
-		if (using_rotated_grid_data)
-			return current_runtime_remap_operator_grid_src->get_rotated_remap_operator_grid()->get_grid2D_search_engine();
-		return current_runtime_remap_operator_grid_src->get_grid2D_search_engine();
-	}
-	else {
-		if (using_rotated_grid_data)
-			return current_runtime_remap_operator_grid_dst->get_rotated_remap_operator_grid()->get_grid2D_search_engine();
-		return current_runtime_remap_operator_grid_dst->get_grid2D_search_engine();		
-	}
+    if (is_src_grid) {
+        if (using_rotated_grid_data)
+            return current_runtime_remap_operator_grid_src->get_rotated_remap_operator_grid()->get_grid2D_search_engine();
+        return current_runtime_remap_operator_grid_src->get_grid2D_search_engine();
+    }
+    else {
+        if (using_rotated_grid_data)
+            return current_runtime_remap_operator_grid_dst->get_rotated_remap_operator_grid()->get_grid2D_search_engine();
+        return current_runtime_remap_operator_grid_dst->get_grid2D_search_engine();        
+    }
 }
 
 
@@ -140,7 +140,7 @@ void get_cell_vertex_coord_values_of_src_grid(long cell_index, int *num_vertex,
     }
     else {
         get_cell_vertex_coord_values_of_grid(current_runtime_remap_operator_grid_src, cell_index, &temp_num_vertex, temp_vertex_values, check_consistency);
-		EXECUTION_REPORT(REPORT_ERROR, -1, temp_num_vertex <= 65536/2, "Software error in get_cell_vertex_coord_values_of_src_grid: too big number of vertexes: %d", temp_num_vertex);
+        EXECUTION_REPORT(REPORT_ERROR, -1, temp_num_vertex <= 65536/2, "Software error in get_cell_vertex_coord_values_of_src_grid: too big number of vertexes: %d", temp_num_vertex);
         should_rotate = false;
         for (int i = 0; i < temp_num_vertex; i ++)
             if (fabs(temp_vertex_values[i*2+1]) > SPHERE_GRID_ROTATION_LAT_THRESHOLD) {
@@ -168,7 +168,7 @@ void get_cell_vertex_coord_values_of_dst_grid(long cell_index, int *num_vertex,
     }
     else {
         get_cell_vertex_coord_values_of_grid(current_runtime_remap_operator_grid_dst, cell_index, &temp_num_vertex, temp_vertex_values, check_consistency);
-		EXECUTION_REPORT(REPORT_ERROR, -1, temp_num_vertex <= 65536/2, "Software error in get_cell_vertex_coord_values_of_dst_grid: too big number of vertexes: %d", temp_num_vertex);		
+        EXECUTION_REPORT(REPORT_ERROR, -1, temp_num_vertex <= 65536/2, "Software error in get_cell_vertex_coord_values_of_dst_grid: too big number of vertexes: %d", temp_num_vertex);        
         should_rotate = false;
         for (int i = 0; i < temp_num_vertex; i ++)
             if (fabs(temp_vertex_values[i*2+1]) > SPHERE_GRID_ROTATION_LAT_THRESHOLD) {
@@ -187,7 +187,7 @@ void search_cell_in_src_grid(double *point_coord_values, long *cell_index, bool
     EXECUTION_REPORT(REPORT_ERROR, -1, have_fetched_dst_grid_cell_coord_values, "remap software error search_cell_in_src_grid\n");
     if (using_rotated_grid_data)
         *cell_index = current_runtime_remap_operator_grid_src->get_rotated_remap_operator_grid()->search_cell_of_locating_point(point_coord_values, accurately_match);
-    else *cell_index = current_runtime_remap_operator_grid_src->get_rotated_remap_operator_grid()->search_cell_of_locating_point(point_coord_values, accurately_match);
+    else *cell_index = current_runtime_remap_operator_grid_src->search_cell_of_locating_point(point_coord_values, accurately_match);
 }
 
 
@@ -407,8 +407,8 @@ bool src_cell_and_dst_cell_have_overlap(long cell_index_src, long cell_index_dst
     get_cell_center_coord_values_of_src_grid(cell_index_src, center_coord_values_src);
     get_cell_vertex_coord_values_of_dst_grid(cell_index_dst, &num_vertexes_dst, vertex_coord_values_dst, true);
     get_cell_vertex_coord_values_of_src_grid(cell_index_src, &num_vertexes_src, vertex_coord_values_src, true);    
-	EXECUTION_REPORT(REPORT_ERROR, -1, num_vertexes_src <= 65536/2, "Software error in src_cell_and_dst_cell_have_overlap: too big number of src vertexes: %d", num_vertexes_src);
-	EXECUTION_REPORT(REPORT_ERROR, -1, num_vertexes_dst <= 65536/2, "Software error in src_cell_and_dst_cell_have_overlap: too big number of dst vertexes: %d", num_vertexes_dst);
+    EXECUTION_REPORT(REPORT_ERROR, -1, num_vertexes_src <= 65536/2, "Software error in src_cell_and_dst_cell_have_overlap: too big number of src vertexes: %d", num_vertexes_src);
+    EXECUTION_REPORT(REPORT_ERROR, -1, num_vertexes_dst <= 65536/2, "Software error in src_cell_and_dst_cell_have_overlap: too big number of dst vertexes: %d", num_vertexes_dst);
 
     num_grid_dimensions = current_runtime_remap_operator->get_num_dimensions();
 
@@ -422,15 +422,15 @@ bool src_cell_and_dst_cell_have_overlap(long cell_index_src, long cell_index_dst
 
 bool have_overlapped_src_cells_for_dst_cell(long cell_index_dst)
 {
-	int num_overlapping_cells;
-	long overlapping_cells_index[2];
+    int num_overlapping_cells;
+    long overlapping_cells_index[2];
 
-	
-	const H2D_grid_cell_search_cell *dst_cell = get_current_grid2D_search_engine(false)->get_cell(cell_index_dst);
-	get_current_grid2D_search_engine(true)->search_overlapping_cells(num_overlapping_cells, overlapping_cells_index, dst_cell, true, true);
-	EXECUTION_REPORT(REPORT_ERROR, -1, num_overlapping_cells == 0 || num_overlapping_cells == 1, "Software error1 in have_overlapped_src_cells_for_dst_cell");
+    
+    const H2D_grid_cell_search_cell *dst_cell = get_current_grid2D_search_engine(false)->get_cell(cell_index_dst);
+    get_current_grid2D_search_engine(true)->search_overlapping_cells(num_overlapping_cells, overlapping_cells_index, dst_cell, true, true);
+    EXECUTION_REPORT(REPORT_ERROR, -1, num_overlapping_cells == 0 || num_overlapping_cells == 1, "Software error1 in have_overlapped_src_cells_for_dst_cell");
 
-	return num_overlapping_cells > 0;
+    return num_overlapping_cells > 0;
 }
 
 
@@ -610,7 +610,7 @@ void get_all_vertexes_of_one_cell_in_other_cell(int num_vertexes_cell1,
     int i;
 
 
-	EXECUTION_REPORT(REPORT_ERROR, -1, num_vertexes_cell2 <= 65536/2, "Software error in get_all_vertexes_of_one_cell_in_other_cell: too big number of num_vertexes_cell2: %d", num_vertexes_cell2);
+    EXECUTION_REPORT(REPORT_ERROR, -1, num_vertexes_cell2 <= 65536/2, "Software error in get_all_vertexes_of_one_cell_in_other_cell: too big number of num_vertexes_cell2: %d", num_vertexes_cell2);
     num_vertexes_in_other_cell = 0;
     for (i = 0; i < num_vertexes_cell2; i ++) {
         temp_vertex_coord1_values[i] = vertex_coord_values_cell2[i*2];
@@ -767,7 +767,7 @@ double compute_angle_of_great_arcs(double lon_point1, double lat_point1,
     if (tmp < 0)
         angle = -angle;    
 
-//	printf("angle is %lf: %lf\n", angle, tmp);
+//    printf("angle is %lf: %lf\n", angle, tmp);
     
     if (check_angle)
         EXECUTION_REPORT(REPORT_ERROR, -1, angle >= 0, "remap software error in compute_angle_of_great_arcs\n");
@@ -786,7 +786,7 @@ void sort_vertexes_of_sphere_cell(int num_vertexes,
     bool cross_lon_360;
 
 
-	EXECUTION_REPORT(REPORT_ERROR, -1, num_vertexes <= 65536, "Software error in sort_vertexes_of_sphere_cell: too big number of num_vertexes: %d", num_vertexes);
+    EXECUTION_REPORT(REPORT_ERROR, -1, num_vertexes <= 65536, "Software error in sort_vertexes_of_sphere_cell: too big number of num_vertexes: %d", num_vertexes);
 
     for (i = 0; i < num_vertexes; i ++) 
         EXECUTION_REPORT(REPORT_ERROR, -1, vertexes_lons[i] != NULL_COORD_VALUE, "remap software error in sort_vertexes_of_sphere_cell\n");
@@ -846,7 +846,7 @@ double compute_area_of_sphere_cell(int num_vertexes,
 
     area = -(num_true_vertexes-2)*PI;
     for (i = 0; i < num_vertexes; i ++) {
-//		printf("okok %d\n", i);
+//        printf("okok %d\n", i);
         if (vertexes_lons[i] == NULL_COORD_VALUE)
             continue;
         next_i = (i+1) % num_vertexes;
@@ -889,8 +889,8 @@ void compute_common_sub_cell_of_src_cell_and_dst_cell_2D(long cell_index_src,
     get_cell_vertex_coord_values_of_dst_grid(cell_index_dst, &num_vertexes_dst, vertex_coord_values_dst, true);
     get_cell_vertex_coord_values_of_src_grid(cell_index_src, &num_vertexes_src, vertex_coord_values_src, true);
 
-	EXECUTION_REPORT(REPORT_ERROR, -1, num_vertexes_src <= 65536/2, "Software error in compute_common_sub_cell_of_src_cell_and_dst_cell_2D: too big number of num_vertexes_src: %d", num_vertexes_src);
-	EXECUTION_REPORT(REPORT_ERROR, -1, num_vertexes_dst <= 65536/2, "Software error in compute_common_sub_cell_of_src_cell_and_dst_cell_2D: too big number of num_vertexes_dst: %d", num_vertexes_dst);
+    EXECUTION_REPORT(REPORT_ERROR, -1, num_vertexes_src <= 65536/2, "Software error in compute_common_sub_cell_of_src_cell_and_dst_cell_2D: too big number of num_vertexes_src: %d", num_vertexes_src);
+    EXECUTION_REPORT(REPORT_ERROR, -1, num_vertexes_dst <= 65536/2, "Software error in compute_common_sub_cell_of_src_cell_and_dst_cell_2D: too big number of num_vertexes_dst: %d", num_vertexes_dst);
 
     num_grid_dimensions = current_runtime_remap_operator->get_num_dimensions();
 
diff --git a/src/CoR/remap_operator_c_interface.h b/src/CoR/remap_operator_c_interface.h
old mode 100644
new mode 100755
diff --git a/src/CoR/remap_operator_conserv_2D.cxx b/src/CoR/remap_operator_conserv_2D.cxx
old mode 100644
new mode 100755
index 5fcb246..7f654ea
--- a/src/CoR/remap_operator_conserv_2D.cxx
+++ b/src/CoR/remap_operator_conserv_2D.cxx
@@ -43,7 +43,7 @@ void Remap_operator_conserv_2D::compute_remap_weights_of_one_dst_cell(long cell_
 
     get_cell_center_coord_values_of_dst_grid(cell_index_dst, center_coord_values_dst);
     get_cell_vertex_coord_values_of_dst_grid(cell_index_dst, &num_vertexes_dst, vertex_coord_values_dst, false);    
-	EXECUTION_REPORT(REPORT_ERROR, -1, num_vertexes_dst <= 65536/2, "Software error in Remap_operator_conserv_2D::compute_remap_weights_of_one_dst_cell: too big num_vertexes_dst: %d", num_vertexes_dst);
+    EXECUTION_REPORT(REPORT_ERROR, -1, num_vertexes_dst <= 65536/2, "Software error in Remap_operator_conserv_2D::compute_remap_weights_of_one_dst_cell: too big num_vertexes_dst: %d", num_vertexes_dst);
     num_grid_dimensions_dst = current_runtime_remap_operator_grid_src->get_num_grid_dimensions();
 
     for (i = 0; i < num_vertexes_dst; i ++) {
@@ -65,7 +65,7 @@ void Remap_operator_conserv_2D::compute_remap_weights_of_one_dst_cell(long cell_
     for (i = 0, sum_area = 0, num_weights = 0; i < num_overlapping_src_cells; i ++) {
         compute_common_sub_cell_of_src_cell_and_dst_cell_2D(overlapping_src_cells_indexes[i], cell_index_dst, num_common_sub_cell_vertexes, 
                                                             common_sub_cell_vertexes_lons, common_sub_cell_vertexes_lats);
-		EXECUTION_REPORT(REPORT_ERROR, -1, num_common_sub_cell_vertexes <= 65536/2, "Software error in Remap_operator_conserv_2D::compute_remap_weights_of_one_dst_cell: too big num_common_sub_cell_vertexes: %d", num_common_sub_cell_vertexes);
+        EXECUTION_REPORT(REPORT_ERROR, -1, num_common_sub_cell_vertexes <= 65536/2, "Software error in Remap_operator_conserv_2D::compute_remap_weights_of_one_dst_cell: too big num_common_sub_cell_vertexes: %d", num_common_sub_cell_vertexes);
         if (num_common_sub_cell_vertexes > 0) {
             common_sub_cell_area[num_weights] = compute_area_of_sphere_cell(num_common_sub_cell_vertexes, common_sub_cell_vertexes_lons, common_sub_cell_vertexes_lats);
             overlapping_src_cells_indexes[num_weights] = overlapping_src_cells_indexes[i];
@@ -94,8 +94,8 @@ void Remap_operator_conserv_2D::calculate_remap_weights()
     clear_remap_weight_info_in_sparse_matrix();
 
     for (cell_index_dst = 0; cell_index_dst < dst_grid->get_grid_size(); cell_index_dst ++) {
-		if (H2D_grid_decomp_mask != NULL && !H2D_grid_decomp_mask[cell_index_dst])
-			continue;
+        if (H2D_grid_decomp_mask != NULL && !H2D_grid_decomp_mask[cell_index_dst])
+            continue;
         get_cell_mask_of_dst_grid(cell_index_dst, &dst_cell_mask);
         if (!dst_cell_mask)
             continue;
@@ -122,9 +122,9 @@ Remap_operator_conserv_2D::Remap_operator_conserv_2D(const char *object_name, in
 }
 
 
-void Remap_operator_conserv_2D::do_remap_values_caculation(double *data_values_src, double *data_values_dst)
+void Remap_operator_conserv_2D::do_remap_values_caculation(double *data_values_src, double *data_values_dst, int dst_array_size)
 {
-    remap_weights_groups[0]->remap_values(data_values_src, data_values_dst);
+    remap_weights_groups[0]->remap_values(data_values_src, data_values_dst, dst_array_size);
 }
 
 
@@ -138,7 +138,7 @@ Remap_operator_basis *Remap_operator_conserv_2D::duplicate_remap_operator(bool f
 {
     Remap_operator_conserv_2D *duplicated_remap_operator = new Remap_operator_conserv_2D();
     copy_remap_operator_basic_data(duplicated_remap_operator, fully_copy);
-	duplicated_remap_operator->num_order = num_order;
+    duplicated_remap_operator->num_order = num_order;
     return duplicated_remap_operator;
 }
 
diff --git a/src/CoR/remap_operator_conserv_2D.h b/src/CoR/remap_operator_conserv_2D.h
old mode 100644
new mode 100755
index 6cf6403..b277e57
--- a/src/CoR/remap_operator_conserv_2D.h
+++ b/src/CoR/remap_operator_conserv_2D.h
@@ -24,9 +24,9 @@ class Remap_operator_conserv_2D: public Remap_operator_basis
         Remap_operator_conserv_2D() {}
         ~Remap_operator_conserv_2D() {}
         void set_parameter(const char *, const char *);
-		int check_parameter(const char *, const char *, char*);
+        int check_parameter(const char *, const char *, char*);
         void calculate_remap_weights();
-        void do_remap_values_caculation(double*, double*);
+        void do_remap_values_caculation(double*, double*, int);
         void do_src_decomp_caculation(long*, const long*);
         Remap_operator_basis *duplicate_remap_operator(bool);
         Remap_operator_basis *generate_parallel_remap_operator(Remap_grid_class**, int**);
diff --git a/src/CoR/remap_operator_distwgt.cxx b/src/CoR/remap_operator_distwgt.cxx
old mode 100644
new mode 100755
index 25c8c59..c1b1d1a
--- a/src/CoR/remap_operator_distwgt.cxx
+++ b/src/CoR/remap_operator_distwgt.cxx
@@ -23,17 +23,17 @@ void Remap_operator_distwgt::set_parameter(const char *parameter_name, const cha
         sscanf(parameter_value, "%lf", &num_power);
     else if (words_are_the_same(parameter_name, "num_nearest_points")) {
         sscanf(parameter_value, "%d", &num_nearest_points);
-		if (weigt_values_of_one_dst_cell != NULL)
-	        delete [] weigt_values_of_one_dst_cell;
+        if (weigt_values_of_one_dst_cell != NULL)
+            delete [] weigt_values_of_one_dst_cell;
         weigt_values_of_one_dst_cell = new double [num_nearest_points];
     }
-	if (words_are_the_same(parameter_name, "enable_extrapolate")) {
-		if (words_are_the_same(parameter_value, "true"))
-	        enable_extrapolate = true;
-		else if (words_are_the_same(parameter_value, "false"))
-			enable_extrapolate = false;
-		else EXECUTION_REPORT(REPORT_ERROR, -1, false, "value of the parameter \"enable_extrapolate\" must be \"true\"\n");
-	}
+    if (words_are_the_same(parameter_name, "enable_extrapolate")) {
+        if (words_are_the_same(parameter_value, "true"))
+            enable_extrapolate = true;
+        else if (words_are_the_same(parameter_value, "false"))
+            enable_extrapolate = false;
+        else EXECUTION_REPORT(REPORT_ERROR, -1, false, "value of the parameter \"enable_extrapolate\" must be \"true\"\n");
+    }
     else EXECUTION_REPORT(REPORT_ERROR, -1, false, 
                       "\"%s\" is a illegal parameter of remap operator \"%s\"\n",
                       parameter_name,
@@ -43,29 +43,29 @@ void Remap_operator_distwgt::set_parameter(const char *parameter_name, const cha
 
 int Remap_operator_distwgt::check_parameter(const char *parameter_name, const char *parameter_value, char *error_string)
 {
-	int check_result = 0;
+    int check_result = 0;
     if (words_are_the_same(parameter_name, "num_power")) {
-		check_result = 1;
+        check_result = 1;
         sscanf(parameter_value, "%lf", &num_power);
-		if (num_power > 0) 
-			check_result = 3;
-		else sprintf(error_string, "The parameter value must be larger than 0");
+        if (num_power > 0) 
+            check_result = 3;
+        else sprintf(error_string, "The parameter value must be larger than 0");
     }
     else if (words_are_the_same(parameter_name, "num_nearest_points")) {
-		check_result = 1;
+        check_result = 1;
         sscanf(parameter_value, "%d", &num_nearest_points);
-		if (num_nearest_points> 0) 
-			check_result = 3;
-		else sprintf(error_string, "The parameter value must be larger than 0");
+        if (num_nearest_points> 0) 
+            check_result = 3;
+        else sprintf(error_string, "The parameter value must be larger than 0");
+    }
+    if (words_are_the_same(parameter_name, "enable_extrapolate")) {
+        check_result = 1;
+        if (words_are_the_same(parameter_value, "true") || words_are_the_same(parameter_value, "false"))
+            check_result = 3;
+        else sprintf(error_string, "The parameter value must be \"true\" or \"false\"");
     }
-	if (words_are_the_same(parameter_name, "enable_extrapolate")) {
-		check_result = 1;
-		if (words_are_the_same(parameter_value, "true") || words_are_the_same(parameter_value, "false"))
-			check_result = 3;
-		else sprintf(error_string, "The parameter value must be \"true\" or \"false\"");
-	}
-
-	return check_result;
+
+    return check_result;
 }
 
 
@@ -74,7 +74,7 @@ Remap_operator_distwgt::Remap_operator_distwgt()
     found_nearest_points_distance = NULL;
     found_nearest_points_src_indexes = NULL;
     weigt_values_of_one_dst_cell = NULL;
-	enable_extrapolate = false;
+    enable_extrapolate = false;
 }
 
 
@@ -90,7 +90,7 @@ Remap_operator_distwgt::Remap_operator_distwgt(const char *object_name, int num_
 {
     num_nearest_points = 4;
     num_power = 1;
-	enable_extrapolate = false;
+    enable_extrapolate = false;
     found_nearest_points_distance = new double [src_grid->get_grid_size()];
     found_nearest_points_src_indexes = new long [src_grid->get_grid_size()];
     weigt_values_of_one_dst_cell = new double [num_nearest_points];
@@ -120,8 +120,8 @@ void Remap_operator_distwgt::calculate_remap_weights()
     clear_remap_weight_info_in_sparse_matrix();
     
     for (long dst_cell_index = 0; dst_cell_index < dst_grid->get_grid_size(); dst_cell_index ++) {
-		if (H2D_grid_decomp_mask != NULL && !H2D_grid_decomp_mask[dst_cell_index])
-			continue;
+        if (H2D_grid_decomp_mask != NULL && !H2D_grid_decomp_mask[dst_cell_index])
+            continue;
         compute_remap_weights_of_one_dst_cell(dst_cell_index);
     }
 }
@@ -138,9 +138,9 @@ Remap_operator_distwgt::~Remap_operator_distwgt()
 }
 
 
-void Remap_operator_distwgt::do_remap_values_caculation(double *data_values_src, double *data_values_dst)
+void Remap_operator_distwgt::do_remap_values_caculation(double *data_values_src, double *data_values_dst, int dst_array_size)
 {
-    remap_weights_groups[0]->remap_values(data_values_src, data_values_dst);
+    remap_weights_groups[0]->remap_values(data_values_src, data_values_dst, dst_array_size);
 }
 
 
@@ -154,9 +154,9 @@ Remap_operator_basis *Remap_operator_distwgt::duplicate_remap_operator(bool full
 {
     Remap_operator_distwgt *duplicated_remap_operator = new Remap_operator_distwgt();
     copy_remap_operator_basic_data(duplicated_remap_operator, fully_copy);
-	duplicated_remap_operator->num_power = num_power;
-	duplicated_remap_operator->num_nearest_points = num_nearest_points;
-	duplicated_remap_operator->threshold_distance = threshold_distance;
+    duplicated_remap_operator->num_power = num_power;
+    duplicated_remap_operator->num_nearest_points = num_nearest_points;
+    duplicated_remap_operator->threshold_distance = threshold_distance;
 
     return duplicated_remap_operator;
 }
diff --git a/src/CoR/remap_operator_distwgt.h b/src/CoR/remap_operator_distwgt.h
old mode 100644
new mode 100755
index 03fb631..6438039
--- a/src/CoR/remap_operator_distwgt.h
+++ b/src/CoR/remap_operator_distwgt.h
@@ -31,9 +31,9 @@ class Remap_operator_distwgt: public Remap_operator_basis
         Remap_operator_distwgt();
         ~Remap_operator_distwgt();
         void set_parameter(const char*, const char*);
-		int check_parameter(const char*, const char*, char*);
+        int check_parameter(const char*, const char*, char*);
         void calculate_remap_weights();
-        void do_remap_values_caculation(double*, double*);
+        void do_remap_values_caculation(double*, double*, int);
         void do_src_decomp_caculation(long*, const long*);
         Remap_operator_basis *duplicate_remap_operator(bool);
         Remap_operator_basis *generate_parallel_remap_operator(Remap_grid_class**, int**);
diff --git a/src/CoR/remap_operator_grid.cxx b/src/CoR/remap_operator_grid.cxx
old mode 100644
new mode 100755
index 0aca15f..0a326d5
--- a/src/CoR/remap_operator_grid.cxx
+++ b/src/CoR/remap_operator_grid.cxx
@@ -109,7 +109,7 @@ Remap_operator_grid::Remap_operator_grid(Remap_grid_class *remap_grid, Remap_ope
     this->num_vertexes = 0;
     this->num_neighbors = 0;
     this->num_vertex_values_groups = 0;
-	this->grid2D_search_engine = NULL;
+    this->grid2D_search_engine = NULL;
     this->rotated_remap_operator_grid = NULL;
     this->is_src_grid = is_src_grid;
     this->is_rotated_grid = is_rotated_grid;
@@ -173,8 +173,8 @@ Remap_operator_grid::~Remap_operator_grid()
     for (int i = 0; i < num_vertex_values_groups; i ++)
         delete vertex_values_groups[i];
 
-	if (grid2D_search_engine != NULL)
-		delete grid2D_search_engine;
+    if (grid2D_search_engine != NULL)
+        delete grid2D_search_engine;
 
     if (rotated_remap_operator_grid != NULL)
         delete rotated_remap_operator_grid;
@@ -184,7 +184,7 @@ Remap_operator_grid::~Remap_operator_grid()
 void Remap_operator_grid::update_operator_grid_data()
 {
     if (require_vertex_fields) {
-		initialize_for_vertex_coord_values_generation();
+        initialize_for_vertex_coord_values_generation();
         generate_overall_vertex_coord_values();
     }
 
@@ -195,10 +195,10 @@ void Remap_operator_grid::update_operator_grid_data()
         rotate_sphere_grid();
     
     if (remap_operator->get_num_dimensions() > 1 && remap_operator->get_is_operator_regridding()) {
-		if (grid2D_search_engine == NULL)
-			grid2D_search_engine = new H2D_grid_cell_search_engine(remap_grid, center_coord_values[0], center_coord_values[1], mask_values, redundant_cell_mark,
-			                                                       num_vertexes, vertex_coord_values[0], vertex_coord_values[1], EDGE_TYPE_LATLON, is_src_grid);
-		else grid2D_search_engine->update(mask_values);
+        if (grid2D_search_engine == NULL)
+            grid2D_search_engine = new H2D_grid_cell_search_engine(remap_grid, center_coord_values[0], center_coord_values[1], mask_values, redundant_cell_mark,
+                                                                   num_vertexes, vertex_coord_values[0], vertex_coord_values[1], EDGE_TYPE_LATLON, is_src_grid);
+        else grid2D_search_engine->update(mask_values);
     }
 
     if (rotated_remap_operator_grid != NULL)
@@ -280,8 +280,8 @@ void Remap_operator_grid::initialize_for_vertex_coord_values_generation()
     Remap_grid_data_class *current_vertex_field;
 
 
-	if (grid_vertex_fields.size() > 0)
-		return;
+    if (grid_vertex_fields.size() > 0)
+        return;
 
     if (remap_grid->get_is_sphere_grid() && !remap_grid->check_vertex_fields_completeness(remap_operator)) {
         EXECUTION_REPORT(REPORT_WARNING, -1, false, "the vertex values corresponding to sphere grid \"%s\" will be generated automatically", remap_grid->get_grid_name());
@@ -293,9 +293,9 @@ void Remap_operator_grid::initialize_for_vertex_coord_values_generation()
         if (leaf_grids[i]->grid_vertex_fields.size() == 0)
             current_vertex_field = leaf_grids[i]->get_grid_vertex_field();
         else current_vertex_field = leaf_grids[i]->grid_vertex_fields[0];
-		EXECUTION_REPORT(REPORT_ERROR, -1, current_vertex_field != NULL, 
-						 "The vertex coordinate values of the grid %s are missing, which are not specified by users or generated automatically",
-						 remap_grid->get_grid_name());
+        EXECUTION_REPORT(REPORT_ERROR, -1, current_vertex_field != NULL, 
+                         "The vertex coordinate values of the grid %s are missing, which are not specified by users or generated automatically",
+                         remap_grid->get_grid_name());
         grid_vertex_fields.push_back(current_vertex_field);
     }
 
diff --git a/src/CoR/remap_operator_grid.h b/src/CoR/remap_operator_grid.h
old mode 100644
new mode 100755
index fc11ddf..2c9c942
--- a/src/CoR/remap_operator_grid.h
+++ b/src/CoR/remap_operator_grid.h
@@ -48,7 +48,7 @@ class Remap_operator_grid
         bool *mask_values;
         int num_vertex_values_groups;
         Vertex_values_group *vertex_values_groups[256];
-		H2D_grid_cell_search_engine *grid2D_search_engine;
+        H2D_grid_cell_search_engine *grid2D_search_engine;
         bool require_vertex_fields;
         bool is_grid_sphere;
         bool *cell_visiting_mark;
@@ -88,7 +88,7 @@ class Remap_operator_grid
         void visit_cell(long);
         void clear_cell_visiting_info();
         long search_cell_of_locating_point(double*, bool);
-		H2D_grid_cell_search_engine *get_grid2D_search_engine() const { return grid2D_search_engine; }
+        H2D_grid_cell_search_engine *get_grid2D_search_engine() const { return grid2D_search_engine; }
 };
 
 
diff --git a/src/CoR/remap_operator_linear.cxx b/src/CoR/remap_operator_linear.cxx
old mode 100644
new mode 100755
index 29ff559..200f4ff
--- a/src/CoR/remap_operator_linear.cxx
+++ b/src/CoR/remap_operator_linear.cxx
@@ -19,13 +19,13 @@ void Remap_operator_linear::set_parameter(const char *parameter_name, const char
                  "the parameter of remap operator object \"%s\" must be set before using it to build remap strategy\n",
                  object_name);
 
-	set_common_parameter(parameter_name, parameter_value);
+    set_common_parameter(parameter_name, parameter_value);
 }
 
 
 int Remap_operator_linear::check_parameter(const char *parameter_name, const char *parameter_value, char *error_string)
 {
-	return check_common_parameter(parameter_name, parameter_value, error_string);
+    return check_common_parameter(parameter_name, parameter_value, error_string);
 }
 
 
@@ -36,62 +36,62 @@ void Remap_operator_linear::compute_remap_weights_of_one_dst_cell(long dst_cell_
 
 void Remap_operator_linear::calculate_remap_weights()
 {
-	int i;
+    int i;
     double remap_weight_values[2], coord_differences[2];
-	long weight_src_indexes[2];
-	long temp_long_value = 0;
-	double temp_double_value = 0.0;
+    long weight_src_indexes[2];
+    long temp_long_value = 0;
+    double temp_double_value = 0.0;
 
-	
+    
     clear_remap_weight_info_in_sparse_matrix();
 
-	allocate_1D_remap_operator_common_arrays_space();
-	allocate_local_arrays();
+    allocate_1D_remap_operator_common_arrays_space();
+    allocate_local_arrays();
 
-	calculate_dst_src_mapping_info();
+    calculate_dst_src_mapping_info();
 
-	if (array_size_src == 0)
-		return;
+    if (array_size_src == 0)
+        return;
 
-	EXECUTION_REPORT(REPORT_ERROR, -1, array_size_src > 1, "Less than three source cells for linear interpolation are not enough");
+    EXECUTION_REPORT(REPORT_ERROR, -1, array_size_src > 1, "Less than three source cells for linear interpolation are not enough");
 
     for (i = 0; i < dst_grid->get_grid_size(); i ++) {
-		if (src_cell_index_left[i] == -1 || src_cell_index_right[i] == -1)
-			continue;
-		weight_src_indexes[0] = src_cell_index_left[i];
-		weight_src_indexes[1] = src_cell_index_right[i];
-		if (coord_values_src[src_cell_index_left[i]] == coord_values_src[src_cell_index_right[i]]) {
-			remap_weight_values[0] = 0.5;
-			remap_weight_values[1] = 0.5;
-		}
-		else if ((coord_values_dst[i] >= coord_values_src[src_cell_index_left[i]]) == (coord_values_dst[i] <= coord_values_src[src_cell_index_right[i]])) {
-			remap_weight_values[1] = (coord_values_dst[i]-coord_values_src[src_cell_index_left[i]]) / (coord_values_src[src_cell_index_right[i]]-coord_values_src[src_cell_index_left[i]]);
-			remap_weight_values[0] = 1 - remap_weight_values[1];
-		}
-		else {
-			coord_differences[0] = coord_values_dst[i] - coord_values_src[src_cell_index_left[i]];
-			coord_differences[1] = coord_values_dst[i] - coord_values_src[src_cell_index_right[i]];
-			if (fabs(coord_differences[0]) > fabs(coord_differences[1])) {
-				remap_weight_values[0] = -fabs(coord_differences[1])/fabs(coord_differences[0]-coord_differences[1]);
-				remap_weight_values[1] = fabs(coord_differences[0])/fabs(coord_differences[0]-coord_differences[1]);
-			}
-			else {
-				remap_weight_values[0] = fabs(coord_differences[1])/fabs(coord_differences[0]-coord_differences[1]);
-				remap_weight_values[1] = -fabs(coord_differences[0])/fabs(coord_differences[0]-coord_differences[1]);			 
-			}
-		}
-		add_remap_weights_to_sparse_matrix(weight_src_indexes, i, remap_weight_values, 2, 1, true);		
+        if (src_cell_index_left[i] == -1 || src_cell_index_right[i] == -1)
+            continue;
+        weight_src_indexes[0] = src_cell_index_left[i];
+        weight_src_indexes[1] = src_cell_index_right[i];
+        if (coord_values_src[src_cell_index_left[i]] == coord_values_src[src_cell_index_right[i]]) {
+            remap_weight_values[0] = 0.5;
+            remap_weight_values[1] = 0.5;
+        }
+        else if ((coord_values_dst[i] >= coord_values_src[src_cell_index_left[i]]) == (coord_values_dst[i] <= coord_values_src[src_cell_index_right[i]])) {
+            remap_weight_values[1] = (coord_values_dst[i]-coord_values_src[src_cell_index_left[i]]) / (coord_values_src[src_cell_index_right[i]]-coord_values_src[src_cell_index_left[i]]);
+            remap_weight_values[0] = 1 - remap_weight_values[1];
+        }
+        else {
+            coord_differences[0] = coord_values_dst[i] - coord_values_src[src_cell_index_left[i]];
+            coord_differences[1] = coord_values_dst[i] - coord_values_src[src_cell_index_right[i]];
+            if (fabs(coord_differences[0]) > fabs(coord_differences[1])) {
+                remap_weight_values[0] = -fabs(coord_differences[1])/fabs(coord_differences[0]-coord_differences[1]);
+                remap_weight_values[1] = fabs(coord_differences[0])/fabs(coord_differences[0]-coord_differences[1]);
+            }
+            else {
+                remap_weight_values[0] = fabs(coord_differences[1])/fabs(coord_differences[0]-coord_differences[1]);
+                remap_weight_values[1] = -fabs(coord_differences[0])/fabs(coord_differences[0]-coord_differences[1]);             
+            }
+        }
+        add_remap_weights_to_sparse_matrix(weight_src_indexes, i, remap_weight_values, 2, 1, true);        
     }
-	
-	if (remap_weights_groups[1]->get_num_weights() == 0) {
-		EXECUTION_REPORT_LOG(REPORT_LOG, -1, true, "Encounter an empty linear remapping operator instance"); 
-		return;
-	}
-
-	temp_long_value = 0; 
-	temp_double_value = 0.0;
-	for (i = 0; i < array_size_src; i ++)
-		add_remap_weights_to_sparse_matrix(&temp_long_value, useful_src_cells_global_index[i], &temp_double_value, 1, 0, false);
+    
+    if (remap_weights_groups[1]->get_num_weights() == 0) {
+        EXECUTION_REPORT_LOG(REPORT_LOG, -1, true, "Encounter an empty linear remapping operator instance"); 
+        return;
+    }
+
+    temp_long_value = 0; 
+    temp_double_value = 0.0;
+    for (i = 0; i < array_size_src; i ++)
+        add_remap_weights_to_sparse_matrix(&temp_long_value, useful_src_cells_global_index[i], &temp_double_value, 1, 0, false);
 }
 
 
@@ -99,14 +99,14 @@ Remap_operator_linear::Remap_operator_linear(const char *object_name, int num_re
                                        : Remap_operator_1D_basis(object_name, REMAP_OPERATOR_NAME_LINEAR, num_remap_grids, remap_grids)
 {
     remap_weights_groups.push_back(new Remap_weight_sparse_matrix(this));
-	remap_weights_groups.push_back(new Remap_weight_sparse_matrix(this));
-	
+    remap_weights_groups.push_back(new Remap_weight_sparse_matrix(this));
+    
 }
 
 
 void Remap_operator_linear::allocate_local_arrays()
 {
-	temp_decomp_map_src = (long*) (common_buffer_for_1D_remap_operator + 3*(src_grid->get_grid_size()+2));
+    temp_decomp_map_src = (long*) (common_buffer_for_1D_remap_operator + 3*(src_grid->get_grid_size()+2));
 }
 
 
@@ -115,37 +115,37 @@ Remap_operator_linear::~Remap_operator_linear()
 }
 
 
-void Remap_operator_linear::do_remap_values_caculation(double *data_values_src, double *data_values_dst)
+void Remap_operator_linear::do_remap_values_caculation(double *data_values_src, double *data_values_dst, int dst_array_size)
 {
-	int i;
-	long temp_long_value1, temp_long_value2;
-	double temp_double_value, base_value;
-	double eps = 1.0e-8;
-	
-	
-	array_size_src = remap_weights_groups[0]->get_num_weights();
-	if (array_size_src == 0)
-		return;
-
-	allocate_1D_remap_operator_common_arrays_space();
-	allocate_local_arrays();
-
-	for (i = 0; i < array_size_src; i ++) {
-		remap_weights_groups[0]->get_weight(&temp_long_value1, &temp_long_value2, &temp_double_value, i);
-		useful_src_cells_global_index[i] = temp_long_value2;
-	}
+    int i;
+    long temp_long_value1, temp_long_value2;
+    double temp_double_value, base_value;
+    double eps = 1.0e-8;
+    
+    
+    array_size_src = remap_weights_groups[0]->get_num_weights();
+    if (array_size_src == 0)
+        return;
+
+    allocate_1D_remap_operator_common_arrays_space();
+    allocate_local_arrays();
+
+    for (i = 0; i < array_size_src; i ++) {
+        remap_weights_groups[0]->get_weight(&temp_long_value1, &temp_long_value2, &temp_double_value, i);
+        useful_src_cells_global_index[i] = temp_long_value2;
+    }
 
-	preprocess_field_value(data_values_src);
+    preprocess_field_value(data_values_src);
 
-	remap_weights_groups[1]->remap_values(packed_data_values_src, data_values_dst);
+    remap_weights_groups[1]->remap_values(packed_data_values_src, data_values_dst, dst_array_size);
 
-	postprocess_field_value(data_values_dst);
+    postprocess_field_value(data_values_dst);
 }
 
 
 void Remap_operator_linear::do_src_decomp_caculation(long *decomp_map_src, const long *decomp_map_dst)
 {
-	EXECUTION_REPORT(REPORT_ERROR, -1, false, "Software error in Remap_operator_linear::do_src_decomp_caculation: 1-D remapping algorithm should not be used to calculate src decomp");
+    EXECUTION_REPORT(REPORT_ERROR, -1, false, "Software error in Remap_operator_linear::do_src_decomp_caculation: 1-D remapping algorithm should not be used to calculate src decomp");
 }
 
 
@@ -153,8 +153,8 @@ Remap_operator_basis *Remap_operator_linear::duplicate_remap_operator(bool fully
 {
     Remap_operator_basis *duplicated_remap_operator = new Remap_operator_linear();
     copy_remap_operator_basic_data(duplicated_remap_operator, fully_copy);
-	((Remap_operator_linear *) duplicated_remap_operator)->initialize_1D_remap_operator();
-	((Remap_operator_linear *) duplicated_remap_operator)->copy_1D_remap_operator_info(this);
+    ((Remap_operator_linear *) duplicated_remap_operator)->initialize_1D_remap_operator();
+    ((Remap_operator_linear *) duplicated_remap_operator)->copy_1D_remap_operator_info(this);
 
     return duplicated_remap_operator;
 }
diff --git a/src/CoR/remap_operator_linear.h b/src/CoR/remap_operator_linear.h
old mode 100644
new mode 100755
index 65e4526..cd8193c
--- a/src/CoR/remap_operator_linear.h
+++ b/src/CoR/remap_operator_linear.h
@@ -17,18 +17,18 @@
 class Remap_operator_linear: public Remap_operator_1D_basis
 {
     private:
-		long *temp_decomp_map_src;
+        long *temp_decomp_map_src;
         void compute_remap_weights_of_one_dst_cell(long);
-		void allocate_local_arrays();
+        void allocate_local_arrays();
 
     public:
         Remap_operator_linear(const char*, int, Remap_grid_class **);
         Remap_operator_linear() {}
         ~Remap_operator_linear();
         void set_parameter(const char *, const char *);
-		int check_parameter(const char *, const char *, char*);
+        int check_parameter(const char *, const char *, char*);
         void calculate_remap_weights();
-        void do_remap_values_caculation(double*, double*);
+        void do_remap_values_caculation(double*, double*, int);
         void do_src_decomp_caculation(long*, const long*);
         Remap_operator_basis *duplicate_remap_operator(bool);
         Remap_operator_basis *generate_parallel_remap_operator(Remap_grid_class**, int**);
diff --git a/src/CoR/remap_operator_mgt.cxx b/src/CoR/remap_operator_mgt.cxx
old mode 100644
new mode 100755
index 341477c..705dc1b
--- a/src/CoR/remap_operator_mgt.cxx
+++ b/src/CoR/remap_operator_mgt.cxx
@@ -62,7 +62,7 @@ void Remap_operator_mgt::execute(const char*function, Remap_statement_operand **
         }
         else if (words_are_the_same(statement_operands[1]->extension_names[0], REMAP_OPERATOR_NAME_SPLINE_1D)) {
             remap_operators.push_back(new Remap_operator_spline_1D(statement_operands[0]->object->object_name, num_remap_grids, remap_grids));
-        }		
+        }        
         else if (words_are_the_same(statement_operands[1]->extension_names[0], REMAP_OPERATOR_NAME_SMOOTH)) {
             remap_operators.push_back(new Remap_operator_smooth(statement_operands[0]->object->object_name, num_remap_grids, remap_grids));
         }
@@ -98,7 +98,7 @@ Remap_operator_basis *Remap_operator_mgt::search_remap_operator(const char *obje
 Remap_operator_basis *Remap_operator_mgt::search_remap_operator(Remap_grid_class *grid_src, Remap_grid_class *grid_dst, const char *operator_name)
 {
     for (int i = 0; i < remap_operators.size(); i ++)
-		if (remap_operators[i]->match_remap_operator(grid_src, grid_dst, operator_name))
+        if (remap_operators[i]->match_remap_operator(grid_src, grid_dst, operator_name))
             return remap_operators[i];
 
     return NULL;
@@ -107,7 +107,7 @@ Remap_operator_basis *Remap_operator_mgt::search_remap_operator(Remap_grid_class
 
 void Remap_operator_mgt::add_remap_operator(Remap_operator_basis *new_operator)
 {
-	remap_operators.push_back(new_operator);
+    remap_operators.push_back(new_operator);
 }
 
 
@@ -120,20 +120,20 @@ Remap_operator_mgt::~Remap_operator_mgt()
 
 int Remap_operator_mgt::get_remap_operator_num_dim(const char *operator_name)
 {
-	if (words_are_the_same(operator_name, REMAP_OPERATOR_NAME_BILINEAR) || words_are_the_same(operator_name, REMAP_OPERATOR_NAME_DISTWGT) ||
-		words_are_the_same(operator_name, REMAP_OPERATOR_NAME_CONSERV_2D))
-		return 2;
+    if (words_are_the_same(operator_name, REMAP_OPERATOR_NAME_BILINEAR) || words_are_the_same(operator_name, REMAP_OPERATOR_NAME_DISTWGT) ||
+        words_are_the_same(operator_name, REMAP_OPERATOR_NAME_CONSERV_2D))
+        return 2;
 
-	if (words_are_the_same(operator_name, REMAP_OPERATOR_NAME_LINEAR) || words_are_the_same(operator_name, REMAP_OPERATOR_NAME_SPLINE_1D))
-		return 1;
+    if (words_are_the_same(operator_name, REMAP_OPERATOR_NAME_LINEAR) || words_are_the_same(operator_name, REMAP_OPERATOR_NAME_SPLINE_1D))
+        return 1;
 
-	return -1;
+    return -1;
 }
 
 
 int Remap_operator_mgt::check_operator_parameter(const char *operator_name, const char *parameter_name, const char *parameter_value, char *error_string)
 {
-	Remap_operator_basis *remap_operator;
+    Remap_operator_basis *remap_operator;
     if (words_are_the_same(operator_name, REMAP_OPERATOR_NAME_BILINEAR))
         remap_operator = new Remap_operator_bilinear();
     else if (words_are_the_same(operator_name, REMAP_OPERATOR_NAME_CONSERV_2D))
@@ -144,12 +144,12 @@ int Remap_operator_mgt::check_operator_parameter(const char *operator_name, cons
         remap_operator = new Remap_operator_linear();
     else if (words_are_the_same(operator_name, REMAP_OPERATOR_NAME_SPLINE_1D))
         remap_operator = new Remap_operator_spline_1D();
-	else EXECUTION_REPORT(REPORT_ERROR, -1, false, "Software error in Remap_operator_mgt::check_operator_parameter");
+    else EXECUTION_REPORT(REPORT_ERROR, -1, false, "Software error in Remap_operator_mgt::check_operator_parameter");
 
-	int check_result = remap_operator->check_parameter(parameter_name, parameter_value, error_string);
-	delete remap_operator;
+    int check_result = remap_operator->check_parameter(parameter_name, parameter_value, error_string);
+    delete remap_operator;
 
-	return check_result;
+    return check_result;
 }
 
 
diff --git a/src/CoR/remap_operator_mgt.h b/src/CoR/remap_operator_mgt.h
old mode 100644
new mode 100755
index 68388c0..cf576e2
--- a/src/CoR/remap_operator_mgt.h
+++ b/src/CoR/remap_operator_mgt.h
@@ -24,10 +24,10 @@ class Remap_operator_mgt
         ~Remap_operator_mgt();
         void execute(const char*, Remap_statement_operand **, int);
         Remap_operator_basis *search_remap_operator(const char*);
-		Remap_operator_basis *search_remap_operator(Remap_grid_class*, Remap_grid_class*, const char*);
-		void add_remap_operator(Remap_operator_basis *);
-		int get_remap_operator_num_dim(const char*);
-		int check_operator_parameter(const char*, const char*, const char*, char*);
+        Remap_operator_basis *search_remap_operator(Remap_grid_class*, Remap_grid_class*, const char*);
+        void add_remap_operator(Remap_operator_basis *);
+        int get_remap_operator_num_dim(const char*);
+        int check_operator_parameter(const char*, const char*, const char*, char*);
 };
 
 
diff --git a/src/CoR/remap_operator_regrid.cxx b/src/CoR/remap_operator_regrid.cxx
old mode 100644
new mode 100755
index 9b025ae..37f2631
--- a/src/CoR/remap_operator_regrid.cxx
+++ b/src/CoR/remap_operator_regrid.cxx
@@ -22,7 +22,7 @@ void Remap_operator_regrid::set_parameter(const char *parameter_name, const char
 int Remap_operator_regrid::check_parameter(const char *parameter_name, const char *parameter_value, char *error_string)
 {
     EXECUTION_REPORT(REPORT_ERROR, -1, false, "remap software error in set_parameter of Remap_operator_regrid\n");
-	return 0;
+    return 0;
 }
 
 
@@ -45,7 +45,7 @@ Remap_operator_regrid::Remap_operator_regrid(const char *object_name, int num_re
 }
 
 
-void Remap_operator_regrid::do_remap_values_caculation(double *data_values_src, double *data_values_dst)
+void Remap_operator_regrid::do_remap_values_caculation(double *data_values_src, double *data_values_dst, int dst_array_size)
 {
     EXECUTION_REPORT(REPORT_ERROR, -1, false, "remap software error in do_remap_values_caculation of Remap_operator_regrid\n");
 }
diff --git a/src/CoR/remap_operator_regrid.h b/src/CoR/remap_operator_regrid.h
old mode 100644
new mode 100755
index ba3a28d..40a0ea6
--- a/src/CoR/remap_operator_regrid.h
+++ b/src/CoR/remap_operator_regrid.h
@@ -24,9 +24,9 @@ class Remap_operator_regrid: public Remap_operator_basis
         Remap_operator_regrid() {}
         ~Remap_operator_regrid() {}
         void set_parameter(const char *, const char *);
-		int check_parameter(const char *, const char *, char*);
+        int check_parameter(const char *, const char *, char*);
         void calculate_remap_weights();
-        void do_remap_values_caculation(double*, double*);
+        void do_remap_values_caculation(double*, double*, int);
         void do_src_decomp_caculation(long*, const long*);
         Remap_operator_basis *duplicate_remap_operator(bool);
         Remap_operator_basis *generate_parallel_remap_operator(Remap_grid_class**, int**);
diff --git a/src/CoR/remap_operator_smooth.cxx b/src/CoR/remap_operator_smooth.cxx
old mode 100644
new mode 100755
index 39d496a..08b7c07
--- a/src/CoR/remap_operator_smooth.cxx
+++ b/src/CoR/remap_operator_smooth.cxx
@@ -30,7 +30,7 @@ void Remap_operator_smooth::set_parameter(const char *parameter_name, const char
 int Remap_operator_smooth::check_parameter(const char *parameter_name, const char *parameter_value, char *error_string)
 {
     EXECUTION_REPORT(REPORT_ERROR, -1, false, "Software error in Remap_operator_smooth::check_parameter");
-	return 0;
+    return 0;
 }
 
 
@@ -58,9 +58,9 @@ Remap_operator_smooth::Remap_operator_smooth(const char *object_name, int num_re
 }
 
 
-void Remap_operator_smooth::do_remap_values_caculation(double *data_values_src, double *data_values_dst)
+void Remap_operator_smooth::do_remap_values_caculation(double *data_values_src, double *data_values_dst, int dst_array_size)
 {
-    remap_weights_groups[0]->remap_values(data_values_src, data_values_dst);
+    remap_weights_groups[0]->remap_values(data_values_src, data_values_dst, dst_array_size);
 }
 
 
diff --git a/src/CoR/remap_operator_smooth.h b/src/CoR/remap_operator_smooth.h
old mode 100644
new mode 100755
index 7e82916..572fb13
--- a/src/CoR/remap_operator_smooth.h
+++ b/src/CoR/remap_operator_smooth.h
@@ -24,9 +24,9 @@ class Remap_operator_smooth: public Remap_operator_basis
         Remap_operator_smooth() {}
         ~Remap_operator_smooth() {}
         void set_parameter(const char *, const char *);
-		int check_parameter(const char *, const char *, char*);
+        int check_parameter(const char *, const char *, char*);
         void calculate_remap_weights();
-        void do_remap_values_caculation(double*, double*);
+        void do_remap_values_caculation(double*, double*, int);
         void do_src_decomp_caculation(long*, const long*);
         Remap_operator_basis *duplicate_remap_operator(bool);
         Remap_operator_basis *generate_parallel_remap_operator(Remap_grid_class**, int**);
diff --git a/src/CoR/remap_operator_spline_1D.cxx b/src/CoR/remap_operator_spline_1D.cxx
old mode 100644
new mode 100755
index 91b74be..f28cff7
--- a/src/CoR/remap_operator_spline_1D.cxx
+++ b/src/CoR/remap_operator_spline_1D.cxx
@@ -18,64 +18,64 @@
 
 void Remap_operator_spline_1D::solve_aperiodic_tridiagonal_system(double *a, double *b, double *c, double *f, int n)
 {
-	double y;
+    double y;
 
 
-	for (int i = 1; i < n; i++) {
-		y = a[i]/b[i-1];
-		b[i] -= c[i-1]*y;
-		f[i] -= f[i-1]*y;
-	}
+    for (int i = 1; i < n; i++) {
+        y = a[i]/b[i-1];
+        b[i] -= c[i-1]*y;
+        f[i] -= f[i-1]*y;
+    }
 
-	f[n-1] /= b[n-1];
-	for (int i = n-2; i >=0; i--)
-		f[i] = (f[i]-f[i+1]*c[i])/b[i];
+    f[n-1] /= b[n-1];
+    for (int i = n-2; i >=0; i--)
+        f[i] = (f[i]-f[i+1]*c[i])/b[i];
 }
 
 
 void Remap_operator_spline_1D::solve_periodic_tridiagonal_system(double *a, double *b, double *c, double *f, int n)
 {
-	double y;
-	int i;
-
-
-	temp_array_column[0] = a[0];
-	temp_array_row[0] = c[n-1];
-	for (i = 1; i < n-2; i++) {
-		y = a[i]/b[i-1];
-		b[i] -= c[i-1]*y;
-		temp_array_column[i] = -temp_array_column[i-1]*y;
-		f[i] -= f[i-1]*y;
-		y = temp_array_row[i-1]/b[i-1];
-		temp_array_row[i] = -c[i-1]*y;
-		b[n-1] -= temp_array_column[i-1]*y;
-		f[n-1] -= f[i-1]*y;
-	}	
-
-	y = a[n-2]/b[n-3];
-	b[n-2] -= c[n-3]*y;
-	c[n-2] -= temp_array_column[n-3]*y;
-	f[n-2] -= f[n-3]*y;
-	y = temp_array_row[n-3]/b[n-3];
-	a[n-1] -= c[n-3]*y;
-	b[n-1] -= temp_array_column[n-3]*y;
-	f[n-1] -= f[n-3]*y;
-
-	y = a[n-1]/b[n-2];
-	b[n-1] -= c[n-2]*y;
-	f[n-1] -= f[n-2]*y;
-	
-	// back substitution
-	f[n-1] /= b[n-1];
-	b[n-1] = 1.0;
-	f[n-2] -= f[n-1]*c[n-2]/b[n-1];
-	f[n-2] /= b[n-2];
-	b[n-2] = 1.0;
-	for (i = n-3; i >= 0; i--) {
-		f[i] = f[i]-c[i]*f[i+1]-temp_array_column[i]*f[n-1];
-		f[i] /= b[i];
-		b[i] = 1.0;
-	}
+    double y;
+    int i;
+
+
+    temp_array_column[0] = a[0];
+    temp_array_row[0] = c[n-1];
+    for (i = 1; i < n-2; i++) {
+        y = a[i]/b[i-1];
+        b[i] -= c[i-1]*y;
+        temp_array_column[i] = -temp_array_column[i-1]*y;
+        f[i] -= f[i-1]*y;
+        y = temp_array_row[i-1]/b[i-1];
+        temp_array_row[i] = -c[i-1]*y;
+        b[n-1] -= temp_array_column[i-1]*y;
+        f[n-1] -= f[i-1]*y;
+    }    
+
+    y = a[n-2]/b[n-3];
+    b[n-2] -= c[n-3]*y;
+    c[n-2] -= temp_array_column[n-3]*y;
+    f[n-2] -= f[n-3]*y;
+    y = temp_array_row[n-3]/b[n-3];
+    a[n-1] -= c[n-3]*y;
+    b[n-1] -= temp_array_column[n-3]*y;
+    f[n-1] -= f[n-3]*y;
+
+    y = a[n-1]/b[n-2];
+    b[n-1] -= c[n-2]*y;
+    f[n-1] -= f[n-2]*y;
+    
+    // back substitution
+    f[n-1] /= b[n-1];
+    b[n-1] = 1.0;
+    f[n-2] -= f[n-1]*c[n-2]/b[n-1];
+    f[n-2] /= b[n-2];
+    b[n-2] = 1.0;
+    for (i = n-3; i >= 0; i--) {
+        f[i] = f[i]-c[i]*f[i+1]-temp_array_column[i]*f[n-1];
+        f[i] /= b[i];
+        b[i] = 1.0;
+    }
 }
 
 
@@ -85,19 +85,19 @@ void Remap_operator_spline_1D::set_parameter(const char *parameter_name, const c
                  "the parameter of remap operator object \"%s\" must be set before using it to build remap strategy\n",
                  object_name);
 
-	if (words_are_the_same(parameter_name, "keep_monotonicity")) {
-		EXECUTION_REPORT(REPORT_ERROR, -1, !set_keep_monotonicity,
-						 "The parameter \"%s\" of the 1D spline remapping operator \"%s\" has been set before. It can not been set more than once",
-						 parameter_name, operator_name);
-		if (words_are_the_same(parameter_value, "true")) 
-			keep_monotonicity = true;
-		else if (words_are_the_same(parameter_value, "false"))
-			keep_monotonicity = false;
-		else EXECUTION_REPORT(REPORT_ERROR, -1, false, 
+    if (words_are_the_same(parameter_name, "keep_monotonicity")) {
+        EXECUTION_REPORT(REPORT_ERROR, -1, !set_keep_monotonicity,
+                         "The parameter \"%s\" of the 1D spline remapping operator \"%s\" has been set before. It can not been set more than once",
+                         parameter_name, operator_name);
+        if (words_are_the_same(parameter_value, "true")) 
+            keep_monotonicity = true;
+        else if (words_are_the_same(parameter_value, "false"))
+            keep_monotonicity = false;
+        else EXECUTION_REPORT(REPORT_ERROR, -1, false, 
                       "The value of parameter \"%s\" of the 1D spline remapping operator \"%s\" must be \"none\", \"overall\" or \"fragment\"",
                       parameter_name, operator_name);
-		set_keep_monotonicity = true;
-	}
+        set_keep_monotonicity = true;
+    }
     else set_common_parameter(parameter_name, parameter_value);
 }
 
@@ -106,52 +106,52 @@ int Remap_operator_spline_1D::check_parameter(const char *parameter_name, const
 {
     int check_result = 0;
 
-	if (words_are_the_same(parameter_name, "keep_monotonicity")) {
-		if (words_are_the_same(parameter_value, "true") || words_are_the_same(parameter_value, "false"))
-	        check_result = 3;
-		else sprintf(error_string, "The parameter value must be \"true\" or \"false\"");
-		return check_result;
-	}
+    if (words_are_the_same(parameter_name, "keep_monotonicity")) {
+        if (words_are_the_same(parameter_value, "true") || words_are_the_same(parameter_value, "false"))
+            check_result = 3;
+        else sprintf(error_string, "The parameter value must be \"true\" or \"false\"");
+        return check_result;
+    }
     else return check_common_parameter(parameter_name, parameter_value, error_string);
 }
 
 
 void Remap_operator_spline_1D::allocate_local_arrays()
 {
-	array_alpha = common_buffer_for_1D_remap_operator + 3*(src_grid->get_grid_size()+2);
-	array_mu = common_buffer_for_1D_remap_operator + 4*(src_grid->get_grid_size()+2);;
-	array_lambda = common_buffer_for_1D_remap_operator + 5*(src_grid->get_grid_size()+2);;
-	array_h = common_buffer_for_1D_remap_operator + 6*(src_grid->get_grid_size()+2);;
-	array_d = common_buffer_for_1D_remap_operator + 7*(src_grid->get_grid_size()+2);;
-	temp_array_column = common_buffer_for_1D_remap_operator + 8*(src_grid->get_grid_size()+2);;
-	temp_array_row = common_buffer_for_1D_remap_operator + 9*(src_grid->get_grid_size()+2);
-
-	final_factor1 = common_buffer_for_1D_remap_operator + 12*(src_grid->get_grid_size()+2) + 3*(dst_grid->get_grid_size()+2);
-	final_factor2 = common_buffer_for_1D_remap_operator + 12*(src_grid->get_grid_size()+2) + 4*(dst_grid->get_grid_size()+2);
-	final_factor3 = common_buffer_for_1D_remap_operator + 12*(src_grid->get_grid_size()+2) + 5*(dst_grid->get_grid_size()+2);
-	final_factor4 = common_buffer_for_1D_remap_operator + 12*(src_grid->get_grid_size()+2) + 6*(dst_grid->get_grid_size()+2);
-	final_factor5 = common_buffer_for_1D_remap_operator + 12*(src_grid->get_grid_size()+2) + 7*(dst_grid->get_grid_size()+2);
-	data_in_monotonicity_range = common_buffer_for_1D_remap_operator + 12*(src_grid->get_grid_size()+2) + 8*(dst_grid->get_grid_size()+2);
-	dst_cell_indexes_in_monotonicity_ranges = (int*) (common_buffer_for_1D_remap_operator + 12*(src_grid->get_grid_size()+2) + 9*(dst_grid->get_grid_size()+2));
+    array_alpha = common_buffer_for_1D_remap_operator + 3*(src_grid->get_grid_size()+2);
+    array_mu = common_buffer_for_1D_remap_operator + 4*(src_grid->get_grid_size()+2);;
+    array_lambda = common_buffer_for_1D_remap_operator + 5*(src_grid->get_grid_size()+2);;
+    array_h = common_buffer_for_1D_remap_operator + 6*(src_grid->get_grid_size()+2);;
+    array_d = common_buffer_for_1D_remap_operator + 7*(src_grid->get_grid_size()+2);;
+    temp_array_column = common_buffer_for_1D_remap_operator + 8*(src_grid->get_grid_size()+2);;
+    temp_array_row = common_buffer_for_1D_remap_operator + 9*(src_grid->get_grid_size()+2);
+
+    final_factor1 = common_buffer_for_1D_remap_operator + 12*(src_grid->get_grid_size()+2) + 3*(dst_grid->get_grid_size()+2);
+    final_factor2 = common_buffer_for_1D_remap_operator + 12*(src_grid->get_grid_size()+2) + 4*(dst_grid->get_grid_size()+2);
+    final_factor3 = common_buffer_for_1D_remap_operator + 12*(src_grid->get_grid_size()+2) + 5*(dst_grid->get_grid_size()+2);
+    final_factor4 = common_buffer_for_1D_remap_operator + 12*(src_grid->get_grid_size()+2) + 6*(dst_grid->get_grid_size()+2);
+    final_factor5 = common_buffer_for_1D_remap_operator + 12*(src_grid->get_grid_size()+2) + 7*(dst_grid->get_grid_size()+2);
+    data_in_monotonicity_range = common_buffer_for_1D_remap_operator + 12*(src_grid->get_grid_size()+2) + 8*(dst_grid->get_grid_size()+2);
+    dst_cell_indexes_in_monotonicity_ranges = (int*) (common_buffer_for_1D_remap_operator + 12*(src_grid->get_grid_size()+2) + 9*(dst_grid->get_grid_size()+2));
 }
 
 
 Remap_operator_spline_1D::Remap_operator_spline_1D(const char *object_name, int num_remap_grids, Remap_grid_class **remap_grids)
                                        : Remap_operator_1D_basis(object_name, REMAP_OPERATOR_NAME_SPLINE_1D, num_remap_grids, remap_grids)
 {
-	set_periodic = false;
-	set_period = false;
+    set_periodic = false;
+    set_period = false;
     periodic = false;
-	enable_extrapolate = false;
-	set_enable_extrapolation = false;
-	keep_monotonicity = false;
-	set_keep_monotonicity = false;
-	allocate_local_arrays();
-	remap_weights_groups.push_back(new Remap_weight_sparse_matrix(this));
-	remap_weights_groups.push_back(new Remap_weight_sparse_matrix(this));
-	remap_weights_groups.push_back(new Remap_weight_sparse_matrix(this));
-	remap_weights_groups.push_back(new Remap_weight_sparse_matrix(this));
-	remap_weights_groups.push_back(new Remap_weight_sparse_matrix(this));
+    enable_extrapolate = false;
+    set_enable_extrapolation = false;
+    keep_monotonicity = false;
+    set_keep_monotonicity = false;
+    allocate_local_arrays();
+    remap_weights_groups.push_back(new Remap_weight_sparse_matrix(this));
+    remap_weights_groups.push_back(new Remap_weight_sparse_matrix(this));
+    remap_weights_groups.push_back(new Remap_weight_sparse_matrix(this));
+    remap_weights_groups.push_back(new Remap_weight_sparse_matrix(this));
+    remap_weights_groups.push_back(new Remap_weight_sparse_matrix(this));
 }
 
 
@@ -167,191 +167,191 @@ void Remap_operator_spline_1D::compute_remap_weights_of_one_dst_cell(long cell_i
 
 void Remap_operator_spline_1D::calculate_remap_weights()
 {
-	int i;
-	long temp_long_value = 0.0;
-
-
-
-	allocate_1D_remap_operator_common_arrays_space();
-	allocate_local_arrays();
-
-	clear_remap_weight_info_in_sparse_matrix();
-	calculate_dst_src_mapping_info();
-
-	if (num_useful_src_cells == 0)
-		return;
-	
-	EXECUTION_REPORT(REPORT_ERROR, -1, array_size_src > 2, "Less than three source cells for 1D spline interpolation are not enough");
-
-	for (i = 0; i < array_size_src-1; i ++)
-		array_h[i] = coord_values_src[i+1]-coord_values_src[i];
-
-	array_mu[0] = 0.0;
-	for (i = 1; i < array_size_src-1; i ++) {
-		array_mu[i] = array_h[i-1]/(array_h[i-1]+array_h[i]);
-		array_lambda[i] = 1.0-array_mu[i];
-	}
-
-	if (!periodic) {
-		array_lambda[0] = 0.0;
-		array_mu[array_size_src-1] = 0.0;
-	} else {
-		array_lambda[array_size_src-1] = array_h[0]/(array_h[array_size_src-2]+array_h[0]);
-		array_mu[array_size_src-1] = 1.0-array_lambda[array_size_src-1];
-	}
-
-	for (i = 0; i < dst_grid->get_grid_size(); i ++) {
-		final_factor1[i] = 0;
-		final_factor2[i] = 0;
-		final_factor3[i] = 0;
-		final_factor4[i] = 0;
-		final_factor5[i] = 0;
-		if (src_cell_index_left[i] == -1 || src_cell_index_right[i] == -1)
-			continue;
-	    final_factor1[i] = pow(coord_values_src[src_cell_index_right[i]]-coord_values_dst[i], 3.0)/(6.0*array_h[src_cell_index_left[i]]);
-		final_factor2[i] = pow(coord_values_dst[i]-coord_values_src[src_cell_index_left[i]], 3.0)/(6.0*array_h[src_cell_index_left[i]]);
-		final_factor3[i] = array_h[src_cell_index_left[i]]*array_h[src_cell_index_left[i]]/6.0;
-		final_factor4[i] = (coord_values_src[src_cell_index_right[i]]-coord_values_dst[i])/array_h[src_cell_index_left[i]];
-		final_factor5[i] = (coord_values_dst[i]-coord_values_src[src_cell_index_left[i]])/array_h[src_cell_index_left[i]];
-	}
-
-
-	for (i = 0; i < array_size_src; i ++) {
-		temp_long_value = 0;
-		add_remap_weights_to_sparse_matrix((long*)(&array_mu[i]), useful_src_cells_global_index[i], array_lambda+i, 1, 0, false);
-		add_remap_weights_to_sparse_matrix((long*)(&coord_values_src[i]), temp_long_value, array_h+i, 1, 1, false);
-	}
-	for (i = 0; i < dst_grid->get_grid_size(); i ++) {
-		add_remap_weights_to_sparse_matrix((long*)(&final_factor1[i]), *((long*)(&final_factor2[i])), final_factor3+i, 1, 2, false);
-		add_remap_weights_to_sparse_matrix((long*)(&final_factor4[i]), *((long*)(&final_factor5[i])), coord_values_dst+i, 1, 3, false);
-		temp_long_value = src_cell_index_left[i];
-		add_remap_weights_to_sparse_matrix(&temp_long_value, src_cell_index_right[i], final_factor5+i, 1, 4, false);
-	}
+    int i;
+    long temp_long_value = 0.0;
+
+
+
+    allocate_1D_remap_operator_common_arrays_space();
+    allocate_local_arrays();
+
+    clear_remap_weight_info_in_sparse_matrix();
+    calculate_dst_src_mapping_info();
+
+    if (num_useful_src_cells == 0)
+        return;
+    
+    EXECUTION_REPORT(REPORT_ERROR, -1, array_size_src > 2, "Less than three source cells for 1D spline interpolation are not enough");
+
+    for (i = 0; i < array_size_src-1; i ++)
+        array_h[i] = coord_values_src[i+1]-coord_values_src[i];
+
+    array_mu[0] = 0.0;
+    for (i = 1; i < array_size_src-1; i ++) {
+        array_mu[i] = array_h[i-1]/(array_h[i-1]+array_h[i]);
+        array_lambda[i] = 1.0-array_mu[i];
+    }
+
+    if (!periodic) {
+        array_lambda[0] = 0.0;
+        array_mu[array_size_src-1] = 0.0;
+    } else {
+        array_lambda[array_size_src-1] = array_h[0]/(array_h[array_size_src-2]+array_h[0]);
+        array_mu[array_size_src-1] = 1.0-array_lambda[array_size_src-1];
+    }
+
+    for (i = 0; i < dst_grid->get_grid_size(); i ++) {
+        final_factor1[i] = 0;
+        final_factor2[i] = 0;
+        final_factor3[i] = 0;
+        final_factor4[i] = 0;
+        final_factor5[i] = 0;
+        if (src_cell_index_left[i] == -1 || src_cell_index_right[i] == -1)
+            continue;
+        final_factor1[i] = pow(coord_values_src[src_cell_index_right[i]]-coord_values_dst[i], 3.0)/(6.0*array_h[src_cell_index_left[i]]);
+        final_factor2[i] = pow(coord_values_dst[i]-coord_values_src[src_cell_index_left[i]], 3.0)/(6.0*array_h[src_cell_index_left[i]]);
+        final_factor3[i] = array_h[src_cell_index_left[i]]*array_h[src_cell_index_left[i]]/6.0;
+        final_factor4[i] = (coord_values_src[src_cell_index_right[i]]-coord_values_dst[i])/array_h[src_cell_index_left[i]];
+        final_factor5[i] = (coord_values_dst[i]-coord_values_src[src_cell_index_left[i]])/array_h[src_cell_index_left[i]];
+    }
+
+
+    for (i = 0; i < array_size_src; i ++) {
+        temp_long_value = 0;
+        add_remap_weights_to_sparse_matrix((long*)(&array_mu[i]), useful_src_cells_global_index[i], array_lambda+i, 1, 0, false);
+        add_remap_weights_to_sparse_matrix((long*)(&coord_values_src[i]), temp_long_value, array_h+i, 1, 1, false);
+    }
+    for (i = 0; i < dst_grid->get_grid_size(); i ++) {
+        add_remap_weights_to_sparse_matrix((long*)(&final_factor1[i]), *((long*)(&final_factor2[i])), final_factor3+i, 1, 2, false);
+        add_remap_weights_to_sparse_matrix((long*)(&final_factor4[i]), *((long*)(&final_factor5[i])), coord_values_dst+i, 1, 3, false);
+        temp_long_value = src_cell_index_left[i];
+        add_remap_weights_to_sparse_matrix(&temp_long_value, src_cell_index_right[i], final_factor5+i, 1, 4, false);
+    }
 }
 
 
-void Remap_operator_spline_1D::do_remap_values_caculation(double *data_values_src, double *data_values_dst)
+void Remap_operator_spline_1D::do_remap_values_caculation(double *data_values_src, double *data_values_dst, int dst_array_size)
 {
-	int i, j, k, m, start_index_monotonicity_range, end_index_monotonicity_range;
-	int original_index1, original_index2, original_index3;
-	int num_dst_cells_in_monotonicity_ranges;
-	long temp_long_value1, temp_long_value2;
-	double temp_double_value;
-	double ratio;
-	bool check_monotonicity, next_in_same_monotonicity_range;
-
-
-	allocate_1D_remap_operator_common_arrays_space();
-	allocate_local_arrays();
-
-	array_size_src = remap_weights_groups[0]->get_num_weights();
-	if (array_size_src == 0)
-		return;
-	
-	for (i = 0; i < array_size_src; i ++) {
-		remap_weights_groups[0]->get_weight((long*)(&array_mu[i]), &temp_long_value1, array_lambda+i, i);
-		useful_src_cells_global_index[i] = temp_long_value1;
-		remap_weights_groups[1]->get_weight((long*)(&coord_values_src[i]), &temp_long_value2, array_h+i, i);
-	}
-	for (i = 0; i < dst_grid->get_grid_size(); i ++) {
-		remap_weights_groups[2]->get_weight((long*)(&final_factor1[i]), ((long*)(&final_factor2[i])), final_factor3+i, i);
-		remap_weights_groups[3]->get_weight((long*)(&final_factor4[i]), ((long*)(&final_factor5[i])), coord_values_dst+i, i);
-		remap_weights_groups[4]->get_weight(&temp_long_value1, &temp_long_value2, &temp_double_value, i);
-		src_cell_index_left[i] = temp_long_value1;
-		src_cell_index_right[i] = temp_long_value2;
-	}
-
-	for (i = 0; i < array_size_src; i++)
-		array_alpha[i] = 2.0;
-	
-	preprocess_field_value(data_values_src);
-
-	for (i = 1; i < array_size_src-1; i++)
-		array_d[i] = 6.0*((packed_data_values_src[i+1]-packed_data_values_src[i])/array_h[i]-(packed_data_values_src[i]-packed_data_values_src[i-1])/array_h[i-1])/(array_h[i-1]+array_h[i]);
-
-	if (!periodic) {
-		array_d[0] = 0.0;
-		array_d[array_size_src-1] = 0.0;
-		solve_aperiodic_tridiagonal_system(array_mu, array_alpha, array_lambda, array_d, array_size_src);
-	}
-	else {
-		array_lambda[array_size_src-1] = array_h[0]/(array_h[array_size_src-2]+array_h[0]);
-		array_mu[array_size_src-1] = 1.0-array_lambda[array_size_src-1];
-		array_d[array_size_src-1] = 6.0*((packed_data_values_src[1]-packed_data_values_src[0])/array_h[0]-(packed_data_values_src[array_size_src-1]-packed_data_values_src[array_size_src-2])/array_h[array_size_src-2])/(array_h[0]+array_h[array_size_src-2]);
-		solve_periodic_tridiagonal_system(array_mu+1, array_alpha+1, array_lambda+1, array_d+1, array_size_src-1);
-		array_d[0]=array_d[array_size_src-1];
-	}
-
-	for (i = 0; i < dst_grid->get_grid_size(); i ++) {
-		if (src_cell_index_left[i] == -1 || src_cell_index_right[i] == -1)
-			continue;
-		if (src_cell_index_left[i] == src_cell_index_right[i])
-			data_values_dst[i] = data_values_src[src_cell_index_left[i]];
-		else {
-			data_values_dst[i] = array_d[src_cell_index_left[i]]*final_factor1[i];
-			data_values_dst[i] += array_d[src_cell_index_right[i]]*final_factor2[i];
-			data_values_dst[i] += (data_values_src[src_cell_index_left[i]]-array_d[src_cell_index_left[i]]*final_factor3[i])*final_factor4[i];
-			data_values_dst[i] += (data_values_src[src_cell_index_right[i]]-array_d[src_cell_index_right[i]]*final_factor3[i])*final_factor5[i];
-		}
-	}
-
-	if (keep_monotonicity) {
-		for (i = 0, num_dst_cells_in_monotonicity_ranges = 0; i < dst_grid->get_grid_size(); i ++) {
-			if (src_cell_index_left[i] == -1 || src_cell_index_right[i] == -1)
-				continue;
-			if (!(coord_values_dst[i] > coord_values_src[src_cell_index_left[i]] && coord_values_dst[i] < coord_values_src[src_cell_index_right[i]]))
-				continue;
-			dst_cell_indexes_in_monotonicity_ranges[num_dst_cells_in_monotonicity_ranges ++] = i;
-		}
-		start_index_monotonicity_range = -1;
-		for (i = 0; i < num_dst_cells_in_monotonicity_ranges; i ++) {
-			if (start_index_monotonicity_range == -1) {
-				j = 0;
-				start_index_monotonicity_range = i;
-				data_in_monotonicity_range[j++] = data_values_src[src_cell_index_left[dst_cell_indexes_in_monotonicity_ranges[i]]];
-			}
-			end_index_monotonicity_range = i;
-			data_in_monotonicity_range[j++] = data_values_dst[dst_cell_indexes_in_monotonicity_ranges[i]];
-			if (i == num_dst_cells_in_monotonicity_ranges - 1)
-				next_in_same_monotonicity_range = false;
-			else {
-				original_index1 = dst_cell_indexes_in_monotonicity_ranges[start_index_monotonicity_range];
-				original_index2 = dst_cell_indexes_in_monotonicity_ranges[i+1];
-				next_in_same_monotonicity_range = (src_cell_index_left[original_index1] == src_cell_index_left[original_index2] && src_cell_index_right[original_index1] == src_cell_index_right[original_index2]);
-			}
-			if (!next_in_same_monotonicity_range) {
-				original_index1 = dst_cell_indexes_in_monotonicity_ranges[start_index_monotonicity_range];
-				original_index2 = dst_cell_indexes_in_monotonicity_ranges[end_index_monotonicity_range];
-				EXECUTION_REPORT(REPORT_ERROR, -1, src_cell_index_left[original_index1] == src_cell_index_left[original_index2] && src_cell_index_right[original_index1] == src_cell_index_right[original_index2], 
-								 "software error: in keep monotonicity"); 			
-				data_in_monotonicity_range[j++] = data_values_src[src_cell_index_right[original_index1]];
-				check_monotonicity = true;
-				for (k = 0; k < j - 1; k ++)
-					if ((data_in_monotonicity_range[k] >= data_in_monotonicity_range[k+1]) != (data_in_monotonicity_range[0] >= data_in_monotonicity_range[j-1])) {
-						check_monotonicity = false;
-						break;
-					}
-				if (!check_monotonicity) {
-					original_index1 = src_cell_index_left[dst_cell_indexes_in_monotonicity_ranges[start_index_monotonicity_range]];
-					original_index2 = src_cell_index_right[dst_cell_indexes_in_monotonicity_ranges[start_index_monotonicity_range]];
-					for (k = start_index_monotonicity_range; k <= end_index_monotonicity_range; k ++) {
-						original_index3 = dst_cell_indexes_in_monotonicity_ranges[k];
-						ratio = (coord_values_dst[original_index3]-coord_values_src[original_index1]) / (coord_values_src[original_index2]-coord_values_src[original_index1]);
-						data_values_dst[original_index3] = data_values_src[original_index1]*(1-ratio) + data_values_src[original_index2]*ratio;
-					}
-				}
-				start_index_monotonicity_range = -1;
-			}
-		}
-	}
-
-	postprocess_field_value(data_values_dst);
+    int i, j, k, m, start_index_monotonicity_range, end_index_monotonicity_range;
+    int original_index1, original_index2, original_index3;
+    int num_dst_cells_in_monotonicity_ranges;
+    long temp_long_value1, temp_long_value2;
+    double temp_double_value;
+    double ratio;
+    bool check_monotonicity, next_in_same_monotonicity_range;
+
+
+    allocate_1D_remap_operator_common_arrays_space();
+    allocate_local_arrays();
+
+    array_size_src = remap_weights_groups[0]->get_num_weights();
+    if (array_size_src == 0)
+        return;
+    
+    for (i = 0; i < array_size_src; i ++) {
+        remap_weights_groups[0]->get_weight((long*)(&array_mu[i]), &temp_long_value1, array_lambda+i, i);
+        useful_src_cells_global_index[i] = temp_long_value1;
+        remap_weights_groups[1]->get_weight((long*)(&coord_values_src[i]), &temp_long_value2, array_h+i, i);
+    }
+    for (i = 0; i < dst_grid->get_grid_size(); i ++) {
+        remap_weights_groups[2]->get_weight((long*)(&final_factor1[i]), ((long*)(&final_factor2[i])), final_factor3+i, i);
+        remap_weights_groups[3]->get_weight((long*)(&final_factor4[i]), ((long*)(&final_factor5[i])), coord_values_dst+i, i);
+        remap_weights_groups[4]->get_weight(&temp_long_value1, &temp_long_value2, &temp_double_value, i);
+        src_cell_index_left[i] = temp_long_value1;
+        src_cell_index_right[i] = temp_long_value2;
+    }
+
+    for (i = 0; i < array_size_src; i++)
+        array_alpha[i] = 2.0;
+    
+    preprocess_field_value(data_values_src);
+
+    for (i = 1; i < array_size_src-1; i++)
+        array_d[i] = 6.0*((packed_data_values_src[i+1]-packed_data_values_src[i])/array_h[i]-(packed_data_values_src[i]-packed_data_values_src[i-1])/array_h[i-1])/(array_h[i-1]+array_h[i]);
+
+    if (!periodic) {
+        array_d[0] = 0.0;
+        array_d[array_size_src-1] = 0.0;
+        solve_aperiodic_tridiagonal_system(array_mu, array_alpha, array_lambda, array_d, array_size_src);
+    }
+    else {
+        array_lambda[array_size_src-1] = array_h[0]/(array_h[array_size_src-2]+array_h[0]);
+        array_mu[array_size_src-1] = 1.0-array_lambda[array_size_src-1];
+        array_d[array_size_src-1] = 6.0*((packed_data_values_src[1]-packed_data_values_src[0])/array_h[0]-(packed_data_values_src[array_size_src-1]-packed_data_values_src[array_size_src-2])/array_h[array_size_src-2])/(array_h[0]+array_h[array_size_src-2]);
+        solve_periodic_tridiagonal_system(array_mu+1, array_alpha+1, array_lambda+1, array_d+1, array_size_src-1);
+        array_d[0]=array_d[array_size_src-1];
+    }
+
+    for (i = 0; i < dst_grid->get_grid_size(); i ++) {
+        if (src_cell_index_left[i] == -1 || src_cell_index_right[i] == -1)
+            continue;
+        if (src_cell_index_left[i] == src_cell_index_right[i])
+            data_values_dst[i] = packed_data_values_src[src_cell_index_left[i]];
+        else {
+            data_values_dst[i] = array_d[src_cell_index_left[i]]*final_factor1[i];
+            data_values_dst[i] += array_d[src_cell_index_right[i]]*final_factor2[i];
+            data_values_dst[i] += (packed_data_values_src[src_cell_index_left[i]]-array_d[src_cell_index_left[i]]*final_factor3[i])*final_factor4[i];
+            data_values_dst[i] += (packed_data_values_src[src_cell_index_right[i]]-array_d[src_cell_index_right[i]]*final_factor3[i])*final_factor5[i];
+        }
+    }
+
+    if (keep_monotonicity) {
+        for (i = 0, num_dst_cells_in_monotonicity_ranges = 0; i < dst_grid->get_grid_size(); i ++) {
+            if (src_cell_index_left[i] == -1 || src_cell_index_right[i] == -1)
+                continue;
+            if (!(coord_values_dst[i] > coord_values_src[src_cell_index_left[i]] && coord_values_dst[i] < coord_values_src[src_cell_index_right[i]]))
+                continue;
+            dst_cell_indexes_in_monotonicity_ranges[num_dst_cells_in_monotonicity_ranges ++] = i;
+        }
+        start_index_monotonicity_range = -1;
+        for (i = 0; i < num_dst_cells_in_monotonicity_ranges; i ++) {
+            if (start_index_monotonicity_range == -1) {
+                j = 0;
+                start_index_monotonicity_range = i;
+                data_in_monotonicity_range[j++] = packed_data_values_src[src_cell_index_left[dst_cell_indexes_in_monotonicity_ranges[i]]];
+            }
+            end_index_monotonicity_range = i;
+            data_in_monotonicity_range[j++] = data_values_dst[dst_cell_indexes_in_monotonicity_ranges[i]];
+            if (i == num_dst_cells_in_monotonicity_ranges - 1)
+                next_in_same_monotonicity_range = false;
+            else {
+                original_index1 = dst_cell_indexes_in_monotonicity_ranges[start_index_monotonicity_range];
+                original_index2 = dst_cell_indexes_in_monotonicity_ranges[i+1];
+                next_in_same_monotonicity_range = (src_cell_index_left[original_index1] == src_cell_index_left[original_index2] && src_cell_index_right[original_index1] == src_cell_index_right[original_index2]);
+            }
+            if (!next_in_same_monotonicity_range) {
+                original_index1 = dst_cell_indexes_in_monotonicity_ranges[start_index_monotonicity_range];
+                original_index2 = dst_cell_indexes_in_monotonicity_ranges[end_index_monotonicity_range];
+                EXECUTION_REPORT(REPORT_ERROR, -1, src_cell_index_left[original_index1] == src_cell_index_left[original_index2] && src_cell_index_right[original_index1] == src_cell_index_right[original_index2], 
+                                 "software error: in keep monotonicity");             
+                data_in_monotonicity_range[j++] = packed_data_values_src[src_cell_index_right[original_index1]];
+                check_monotonicity = true;
+                for (k = 0; k < j - 1; k ++)
+                    if ((data_in_monotonicity_range[k] >= data_in_monotonicity_range[k+1]) != (data_in_monotonicity_range[0] >= data_in_monotonicity_range[j-1])) {
+                        check_monotonicity = false;
+                        break;
+                    }
+                if (!check_monotonicity) {
+                    original_index1 = src_cell_index_left[dst_cell_indexes_in_monotonicity_ranges[start_index_monotonicity_range]];
+                    original_index2 = src_cell_index_right[dst_cell_indexes_in_monotonicity_ranges[start_index_monotonicity_range]];
+                    for (k = start_index_monotonicity_range; k <= end_index_monotonicity_range; k ++) {
+                        original_index3 = dst_cell_indexes_in_monotonicity_ranges[k];
+                        ratio = (coord_values_dst[original_index3]-coord_values_src[original_index1]) / (coord_values_src[original_index2]-coord_values_src[original_index1]);
+                        data_values_dst[original_index3] = packed_data_values_src[original_index1]*(1-ratio) + packed_data_values_src[original_index2]*ratio;
+                    }
+                }
+                start_index_monotonicity_range = -1;
+            }
+        }
+    }
+
+    postprocess_field_value(data_values_dst);
 }
 
 
 void Remap_operator_spline_1D::do_src_decomp_caculation(long *decomp_map_src, const long *decomp_map_dst)
 {
-	EXECUTION_REPORT(REPORT_ERROR, -1, false, "Software error in Remap_operator_spline_1D::do_src_decomp_caculation: 1-D remapping algorithm should not be used to calculate src decomp");
+    EXECUTION_REPORT(REPORT_ERROR, -1, false, "Software error in Remap_operator_spline_1D::do_src_decomp_caculation: 1-D remapping algorithm should not be used to calculate src decomp");
 }
 
 
@@ -359,19 +359,19 @@ Remap_operator_basis *Remap_operator_spline_1D::duplicate_remap_operator(bool fu
 {
     Remap_operator_basis *duplicated_remap_operator = new Remap_operator_spline_1D();
 
-	copy_remap_operator_basic_data(duplicated_remap_operator, fully_copy);
-	((Remap_operator_spline_1D*) duplicated_remap_operator)->initialize_1D_remap_operator();
-	((Remap_operator_spline_1D*) duplicated_remap_operator)->copy_1D_remap_operator_info(this);
-	((Remap_operator_spline_1D*) duplicated_remap_operator)->keep_monotonicity = this->keep_monotonicity;
-	((Remap_operator_spline_1D*) duplicated_remap_operator)->set_keep_monotonicity = this->set_keep_monotonicity;
-	
+    copy_remap_operator_basic_data(duplicated_remap_operator, fully_copy);
+    ((Remap_operator_spline_1D*) duplicated_remap_operator)->initialize_1D_remap_operator();
+    ((Remap_operator_spline_1D*) duplicated_remap_operator)->copy_1D_remap_operator_info(this);
+    ((Remap_operator_spline_1D*) duplicated_remap_operator)->keep_monotonicity = this->keep_monotonicity;
+    ((Remap_operator_spline_1D*) duplicated_remap_operator)->set_keep_monotonicity = this->set_keep_monotonicity;
+    
     return duplicated_remap_operator;
 }
 
 Remap_operator_basis *Remap_operator_spline_1D::generate_parallel_remap_operator(Remap_grid_class **decomp_original_grids, int **global_cells_local_indexes_in_decomps)
 {
-	EXECUTION_REPORT(REPORT_ERROR, -1, false, 
-		             "software error: can not generate the parallel remapping operator of the 1D spline remapping algorithm which is only used for vertical grid or time frame in the C-Coupler");	
-	return NULL;
+    EXECUTION_REPORT(REPORT_ERROR, -1, false, 
+                     "software error: can not generate the parallel remapping operator of the 1D spline remapping algorithm which is only used for vertical grid or time frame in the C-Coupler");    
+    return NULL;
 }
 
diff --git a/src/CoR/remap_operator_spline_1D.h b/src/CoR/remap_operator_spline_1D.h
old mode 100644
new mode 100755
index 3337b0e..ec3a18f
--- a/src/CoR/remap_operator_spline_1D.h
+++ b/src/CoR/remap_operator_spline_1D.h
@@ -17,36 +17,36 @@
 class Remap_operator_spline_1D: public Remap_operator_1D_basis
 {
     private:
-		bool set_keep_monotonicity;
-		bool keep_monotonicity;
-		double *data_in_monotonicity_range;
-		int *dst_cell_indexes_in_monotonicity_ranges;
-		double *array_alpha;
-		double *array_mu;
-		double *array_lambda;
-		double *array_h;
-		double *array_d;
-		double *temp_array_row;
-		double *temp_array_column;
-		double *final_factor1;
-		double *final_factor2;
-		double *final_factor3;
-		double *final_factor4;
-		double *final_factor5;
-
-		void solve_aperiodic_tridiagonal_system(double*, double*, double*, double*, int);
-		void solve_periodic_tridiagonal_system(double*, double*, double*, double*, int);
-		void compute_remap_weights_of_one_dst_cell(long);
-		void allocate_local_arrays();
+        bool set_keep_monotonicity;
+        bool keep_monotonicity;
+        double *data_in_monotonicity_range;
+        int *dst_cell_indexes_in_monotonicity_ranges;
+        double *array_alpha;
+        double *array_mu;
+        double *array_lambda;
+        double *array_h;
+        double *array_d;
+        double *temp_array_row;
+        double *temp_array_column;
+        double *final_factor1;
+        double *final_factor2;
+        double *final_factor3;
+        double *final_factor4;
+        double *final_factor5;
+
+        void solve_aperiodic_tridiagonal_system(double*, double*, double*, double*, int);
+        void solve_periodic_tridiagonal_system(double*, double*, double*, double*, int);
+        void compute_remap_weights_of_one_dst_cell(long);
+        void allocate_local_arrays();
 
     public:
-		Remap_operator_spline_1D() {}
+        Remap_operator_spline_1D() {}
         Remap_operator_spline_1D(const char*, int, Remap_grid_class **);
         ~Remap_operator_spline_1D();
         void set_parameter(const char *, const char *);
-		int check_parameter(const char *, const char *, char *);
-		void calculate_remap_weights();
-		void do_remap_values_caculation(double*, double*);
+        int check_parameter(const char *, const char *, char *);
+        void calculate_remap_weights();
+        void do_remap_values_caculation(double*, double*, int);
         void do_src_decomp_caculation(long*, const long*);
         Remap_operator_basis *duplicate_remap_operator(bool);
         Remap_operator_basis *generate_parallel_remap_operator(Remap_grid_class**, int**);
diff --git a/src/CoR/remap_parser.cxx b/src/CoR/remap_parser.cxx
old mode 100644
new mode 100755
diff --git a/src/CoR/remap_parser.h b/src/CoR/remap_parser.h
old mode 100644
new mode 100755
diff --git a/src/CoR/remap_statement_operand.cxx b/src/CoR/remap_statement_operand.cxx
old mode 100644
new mode 100755
index b10cee3..b6176a3
--- a/src/CoR/remap_statement_operand.cxx
+++ b/src/CoR/remap_statement_operand.cxx
@@ -10,6 +10,7 @@
 #include "cor_global_data.h"
 #include "remap_statement_operand.h"
 #include <string.h>
+#include <math.h>
 
 
 template <class T> void initialize_data_buf_to_fill_value(T *data_buf, long size, T fill_value)
@@ -25,8 +26,8 @@ long get_interchange_index(long index_iter_src,
                      long *sub_grid_sizes_interchange, 
                      long *sub_grid_indexes_src,
                      long *sub_grid_indexes_interchange,
-                     int *index_interchange_table, 
-                     int num_sub_grids)
+                     int *index_interchange_table_src_to_dst, 
+                     int num_sized_sub_grids_src)
 {
     int i;
     long iter;
@@ -34,7 +35,7 @@ long get_interchange_index(long index_iter_src,
 
     if (index_iter_src == 0) {
         interchange_first_dim_total_index_base = 1;
-        for (i = 0; i < index_interchange_table[0]; i ++)
+        for (i = 0; i < index_interchange_table_src_to_dst[0]; i ++)
             interchange_first_dim_total_index_base *= sub_grid_sizes_interchange[i];
         index_iter_interchange = -interchange_first_dim_total_index_base;
     }
@@ -42,17 +43,17 @@ long get_interchange_index(long index_iter_src,
     if (sub_grid_indexes_src[0] != 0)
         index_iter_interchange += interchange_first_dim_total_index_base;
     else
-        for (iter = 1, index_iter_interchange = 0, i = 0; i < num_sub_grids; i ++) {
+        for (iter = 1, index_iter_interchange = 0, i = 0; i < num_sized_sub_grids_src; i ++) {
             index_iter_interchange += sub_grid_indexes_interchange[i]*iter;
             iter *= sub_grid_sizes_interchange[i];
         }
 
-    for (i = 0; i < num_sub_grids; i ++) {
+    for (i = 0; i < num_sized_sub_grids_src; i ++) {
         sub_grid_indexes_src[i] ++;
-        sub_grid_indexes_interchange[index_interchange_table[i]] ++;
+        sub_grid_indexes_interchange[index_interchange_table_src_to_dst[i]] ++;
         if (sub_grid_indexes_src[i] == sub_grid_sizes_src[i]) {
             sub_grid_indexes_src[i] = 0;
-            sub_grid_indexes_interchange[index_interchange_table[i]] = 0;
+            sub_grid_indexes_interchange[index_interchange_table_src_to_dst[i]] = 0;
         }
         else break;
     }
@@ -66,36 +67,118 @@ template <class T> void interchange_array_data(int num_sized_sub_grids_src,
                                                     long *sub_grid_indexes_interchange,
                                                     long *sub_grid_sizes_src,
                                                     long *sub_grid_sizes_interchange,
-                                                    int *index_interchange_table,
+                                                    int *index_interchange_table_src_to_dst,
                                                     T *data_src,
                                                     T *data_interchange,
                                                     long array_size,
                                                     int num_point_per_cell)
 {
-    int i;
-    long index_iter_src, index_iter_interchange;
+    int i, j, k;
+    long index_iter_src, index_iter_interchange, interchange_first_dim_total_index_base, iter;
+    long lowest_dim_size_src, higher_dims_size_src;
+    long *tmp_interchange_index_map = NULL;
+    int sub_grid_tile_sizes_src[256], sub_grid_num_tiles_src[256], sub_grid_tile_iter_src[256], total_tile_size_iter, sub_grid_tile_current_start_index[256], sub_grid_tile_current_end_index[256], index_interchange_table_dst_to_src[256];
+    int interchange_block_num_elements, total_tile_size_in_each_direction, num_total_tiles, total_tile_iter;
 
 
-    for (i = 0; i < num_sized_sub_grids_src; i ++) {
-        sub_grid_indexes_src[i] = 0;
-        sub_grid_indexes_interchange[i] = 0;
+    for (i = 0; i < num_sized_sub_grids_src; i ++)
+        index_interchange_table_dst_to_src[index_interchange_table_src_to_dst[i]] = i;
+    interchange_block_num_elements = INTERCHANGE_BLOCK_SIZE / sizeof(T);
+    total_tile_size_in_each_direction = (int) sqrt((double)interchange_block_num_elements);
+    for (i = 0, total_tile_size_iter = 1; i < num_sized_sub_grids_src; i ++) {
+        if (sub_grid_sizes_src[i] <= ((int)(total_tile_size_in_each_direction/total_tile_size_iter)))
+            sub_grid_tile_sizes_src[i] = sub_grid_sizes_src[i];
+        else sub_grid_tile_sizes_src[i] = (int)(total_tile_size_in_each_direction/total_tile_size_iter);
+        total_tile_size_iter *= sub_grid_tile_sizes_src[i];
+        sub_grid_tile_iter_src[i] = 0;
+    }
+    EXECUTION_REPORT(REPORT_ERROR, -1, total_tile_size_iter <= total_tile_size_in_each_direction, "Software error in Remap_data_field::interchange_remap_data_field");
+    for (i = 0, num_total_tiles = 1; i < num_sized_sub_grids_src; i ++) {
+        total_tile_size_iter = total_tile_size_iter / sub_grid_tile_sizes_src[index_interchange_table_dst_to_src[i]];
+        if (sub_grid_sizes_src[index_interchange_table_dst_to_src[i]] < ((int)(interchange_block_num_elements / total_tile_size_iter)))
+            sub_grid_tile_sizes_src[index_interchange_table_dst_to_src[i]] = sub_grid_sizes_src[index_interchange_table_dst_to_src[i]];
+        else sub_grid_tile_sizes_src[index_interchange_table_dst_to_src[i]] = ((int)(interchange_block_num_elements / total_tile_size_iter));
+        total_tile_size_iter *= sub_grid_tile_sizes_src[index_interchange_table_dst_to_src[i]];
+        sub_grid_num_tiles_src[index_interchange_table_dst_to_src[i]] = (sub_grid_sizes_src[index_interchange_table_dst_to_src[i]]+sub_grid_tile_sizes_src[index_interchange_table_dst_to_src[i]]-1)/sub_grid_tile_sizes_src[index_interchange_table_dst_to_src[i]];
+        num_total_tiles *= sub_grid_num_tiles_src[index_interchange_table_dst_to_src[i]];
+    }
+    interchange_first_dim_total_index_base = 1;
+    for (i = 0; i < index_interchange_table_src_to_dst[0]; i ++)
+        interchange_first_dim_total_index_base *= sub_grid_sizes_interchange[i];
+
+    if (report_error_enabled)
+        tmp_interchange_index_map = new long [array_size];
+
+    for (total_tile_iter = 0; total_tile_iter < num_total_tiles; total_tile_iter ++) {
+        for (i = 0; i < num_sized_sub_grids_src; i ++) {
+            sub_grid_tile_current_start_index[i] = sub_grid_tile_iter_src[i]*sub_grid_tile_sizes_src[i];
+            if (sub_grid_tile_iter_src[i] < sub_grid_num_tiles_src[i] - 1)
+                sub_grid_tile_current_end_index[i] = (sub_grid_tile_iter_src[i]+1)*sub_grid_tile_sizes_src[i];
+            else sub_grid_tile_current_end_index[i] = sub_grid_sizes_src[i];
+            EXECUTION_REPORT_ERROR_OPTIONALLY(REPORT_ERROR, -1, sub_grid_tile_current_end_index[i] <= sub_grid_sizes_src[i], "Software error in interchange_array_data");
+        }
+        sub_grid_tile_iter_src[0] ++;
+        for (i = 0; i < num_sized_sub_grids_src; i ++) {
+            if (sub_grid_tile_iter_src[i] == sub_grid_num_tiles_src[i]) {
+                if (i+1 < num_sized_sub_grids_src)
+                    sub_grid_tile_iter_src[i+1] ++;
+                sub_grid_tile_iter_src[i] = 0;    
+            }
+        }
+        for (i = 1, higher_dims_size_src = 1; i < num_sized_sub_grids_src; i ++)
+            higher_dims_size_src *= sub_grid_tile_current_end_index[i]-sub_grid_tile_current_start_index[i];
+        for (i = 0; i < num_sized_sub_grids_src; i ++)
+            sub_grid_indexes_src[i] = sub_grid_tile_current_start_index[i];
+        for (j = 0; j < higher_dims_size_src; j ++) {
+            for (i = 0, index_iter_src = 0, iter = 1; i < num_sized_sub_grids_src; i ++) {
+                index_iter_src += sub_grid_indexes_src[i] * iter;
+                iter *= sub_grid_sizes_src[i];
+            }
+            for (iter = 1, index_iter_interchange = 0, i = 0; i < num_sized_sub_grids_src; i ++) {                
+                index_iter_interchange += sub_grid_indexes_src[index_interchange_table_dst_to_src[i]]*iter;
+                iter *= sub_grid_sizes_interchange[i];
+            }
+            for (i = sub_grid_tile_current_start_index[0]; i < sub_grid_tile_current_end_index[0]; i ++) {
+                for (k = 0; k < num_point_per_cell; k ++)
+                    data_interchange[index_iter_interchange*num_point_per_cell+k] = data_src[index_iter_src*num_point_per_cell+k];
+                if (report_error_enabled)
+                    tmp_interchange_index_map[index_iter_src] = index_iter_interchange;
+                index_iter_interchange += interchange_first_dim_total_index_base;
+                index_iter_src ++;
+            }
+            for (i = 1; i < num_sized_sub_grids_src; i ++) {
+                sub_grid_indexes_src[i] ++;
+                if (sub_grid_indexes_src[i] == sub_grid_tile_current_end_index[i])
+                    sub_grid_indexes_src[i] = sub_grid_tile_current_start_index[i];
+                else break;
+            }        
+        }
     }
-    for (index_iter_src = 0, index_iter_interchange = 0; index_iter_src < array_size; index_iter_src ++) {
-        index_iter_interchange = get_interchange_index(index_iter_src,
-                                                       index_iter_interchange,
-                                                       sub_grid_sizes_src, 
-                                                       sub_grid_sizes_interchange, 
-                                                       sub_grid_indexes_src,
-                                                       sub_grid_indexes_interchange,
-                                                       index_interchange_table, 
-                                                       num_sized_sub_grids_src);
-        for (i = 0; i < num_point_per_cell; i ++)
-            data_interchange[index_iter_interchange*num_point_per_cell+i] = data_src[index_iter_src*num_point_per_cell+i];
+
+    if (report_error_enabled) {
+        for (i = 0; i < num_sized_sub_grids_src; i ++) {
+            sub_grid_indexes_src[i] = 0;
+            sub_grid_indexes_interchange[i] = 0;
+        }
+        lowest_dim_size_src = sub_grid_sizes_src[0];
+        for (i = 1, higher_dims_size_src = 1; i < num_sized_sub_grids_src; i ++)
+            higher_dims_size_src *= sub_grid_sizes_src[i];
+        index_iter_src = 0;
+        for (index_iter_src = 0, index_iter_interchange = 0; index_iter_src < array_size; index_iter_src ++) {
+            index_iter_interchange = get_interchange_index(index_iter_src,
+                                                           index_iter_interchange,
+                                                           sub_grid_sizes_src, 
+                                                           sub_grid_sizes_interchange, 
+                                                           sub_grid_indexes_src,
+                                                           sub_grid_indexes_interchange,
+                                                           index_interchange_table_src_to_dst, 
+                                                           num_sized_sub_grids_src);
+            EXECUTION_REPORT(REPORT_ERROR, -1, tmp_interchange_index_map[index_iter_src] == index_iter_interchange, "Software error in T interchange_array_data %ld: %ld vs %ld", index_iter_src, tmp_interchange_index_map[index_iter_src], index_iter_interchange);
+        }
     }
 
-    for (i = 0; i < num_sized_sub_grids_src; i ++)
-        EXECUTION_REPORT(REPORT_ERROR, -1, sub_grid_indexes_src[i] == 0 && sub_grid_indexes_interchange[i] == 0,
-                     "remap software error2 when interchanging field data\n");
+    if (tmp_interchange_index_map != NULL)
+        delete [] tmp_interchange_index_map;
 }
 
 
@@ -147,7 +230,7 @@ void Remap_data_field::interchange_remap_data_field(Remap_data_field *field_data
     int num_sized_sub_grids_src, num_sized_sub_grids_interchange;
     Remap_grid_class *sized_sub_grids_src[256], *sized_sub_grids_interchange[256]; 
     long sub_grid_sizes_src[256], sub_grid_sizes_interchange[256];
-    int index_interchange_table[256];
+    int index_interchange_table_src_to_dst[256];
     long sub_grid_indexes_src[256], sub_grid_indexes_interchange[256];
     int i, j;
     int num_point_per_cell;
@@ -158,22 +241,21 @@ void Remap_data_field::interchange_remap_data_field(Remap_data_field *field_data
 
     grid_src->get_sized_sub_grids(&num_sized_sub_grids_src, sized_sub_grids_src);
     grid_interchange->get_sized_sub_grids(&num_sized_sub_grids_interchange, sized_sub_grids_interchange);
-    grid_src->get_grid_index_interchange_table(grid_interchange, index_interchange_table);
+    grid_src->get_grid_index_interchange_table(grid_interchange, index_interchange_table_src_to_dst);
     num_point_per_cell = this->required_data_size / grid_src->get_grid_size();
-    
     for (i = 0; i < num_sized_sub_grids_src; i ++)
         sub_grid_sizes_src[i] = sized_sub_grids_src[i]->get_grid_size();
     for (i = 0; i < num_sized_sub_grids_interchange; i ++)
         sub_grid_sizes_interchange[i] = sized_sub_grids_interchange[i]->get_grid_size();
 
     if (words_are_the_same(this->data_type_in_application, DATA_TYPE_DOUBLE) ||
-		words_are_the_same(this->data_type_in_application, DATA_TYPE_LONG))
+        words_are_the_same(this->data_type_in_application, DATA_TYPE_LONG))
         interchange_array_data(num_sized_sub_grids_src, 
                            sub_grid_indexes_src, 
                            sub_grid_indexes_interchange, 
                            sub_grid_sizes_src, 
                            sub_grid_sizes_interchange, 
-                           index_interchange_table,
+                           index_interchange_table_src_to_dst,
                            (double*) this->data_buf,
                            (double*) field_data_interchanged->data_buf,
                            grid_src->get_grid_size(),
@@ -185,7 +267,7 @@ void Remap_data_field::interchange_remap_data_field(Remap_data_field *field_data
                            sub_grid_indexes_interchange, 
                            sub_grid_sizes_src, 
                            sub_grid_sizes_interchange, 
-                           index_interchange_table,
+                           index_interchange_table_src_to_dst,
                            (int*) this->data_buf,
                            (int*) field_data_interchanged->data_buf,
                            grid_src->get_grid_size(),
@@ -197,7 +279,7 @@ void Remap_data_field::interchange_remap_data_field(Remap_data_field *field_data
                            sub_grid_indexes_interchange, 
                            sub_grid_sizes_src, 
                            sub_grid_sizes_interchange, 
-                           index_interchange_table,
+                           index_interchange_table_src_to_dst,
                            (char*) this->data_buf,
                            (char*) field_data_interchanged->data_buf,
                            grid_src->get_grid_size(),
@@ -208,7 +290,7 @@ void Remap_data_field::interchange_remap_data_field(Remap_data_field *field_data
                            sub_grid_indexes_interchange, 
                            sub_grid_sizes_src, 
                            sub_grid_sizes_interchange, 
-                           index_interchange_table,
+                           index_interchange_table_src_to_dst,
                            (short*) this->data_buf,
                            (short*) field_data_interchanged->data_buf,
                            grid_src->get_grid_size(),
@@ -311,7 +393,7 @@ void Remap_data_field::set_fill_value(void *given_fill_value)
             *((double*) attribute_value) = DEFAULT_FILL_VALUE;
         else EXECUTION_REPORT(REPORT_ERROR, -1, false, "remap software error2 in datatype_from_application_to_netcdf in set_fill_value \"%s\"\n", data_type_in_application);
     }
-	
+    
     strcpy(remap_field_attribute.attribute_name, FILL_VALUE_LABEL);
     strcpy(remap_field_attribute.attribute_type, data_type_in_application);
     remap_field_attribute.attribute_size = 1;
diff --git a/src/CoR/remap_statement_operand.h b/src/CoR/remap_statement_operand.h
old mode 100644
new mode 100755
index 8e6228e..c78e7e1
--- a/src/CoR/remap_statement_operand.h
+++ b/src/CoR/remap_statement_operand.h
@@ -13,6 +13,8 @@
 
 #include "common_utils.h"
 #include <vector>
+  
+#define INTERCHANGE_BLOCK_SIZE ((int)64*1024)
 
 
 class Remap_grid_class;
diff --git a/src/CoR/remap_strategy_class.cxx b/src/CoR/remap_strategy_class.cxx
old mode 100644
new mode 100755
index be933b8..a2b5b6a
--- a/src/CoR/remap_strategy_class.cxx
+++ b/src/CoR/remap_strategy_class.cxx
@@ -90,32 +90,31 @@ void Remap_strategy_class::check_field_data_grid_center_values_for_remapping(Rem
 
     for (i = 0; i < num_leaf_grids_field_data; i ++)
         if (leaf_grids_field_data[i]->get_super_grid_of_setting_coord_values() != NULL) {
-			if (!leaf_grids_field_data[i]->get_super_grid_of_setting_coord_values()->is_sigma_grid())
-	            EXECUTION_REPORT(REPORT_ERROR, -1, leaf_grids_field_data[i]->get_super_grid_of_setting_coord_values()->is_subset_of_grid(field_data_grid), 
-	                         "The grid of setting coordinate values of 1D grid \"%s\" is \"%s\", it must be a sub grid of field data grid\n",
-	                         leaf_grids_field_data[i]->get_coord_label(), leaf_grids_field_data[i]->get_super_grid_of_setting_coord_values()->get_grid_name());
+            if (!leaf_grids_field_data[i]->get_super_grid_of_setting_coord_values()->is_sigma_grid())
+                EXECUTION_REPORT(REPORT_ERROR, -1, leaf_grids_field_data[i]->get_super_grid_of_setting_coord_values()->is_subset_of_grid(field_data_grid), 
+                             "The grid of setting coordinate values of 1D grid \"%s\" is \"%s\", it must be a sub grid of field data grid\n",
+                             leaf_grids_field_data[i]->get_coord_label(), leaf_grids_field_data[i]->get_super_grid_of_setting_coord_values()->get_grid_name());
         }
     if (is_remap_operator_regriding)
         for (i = 0; i < num_leaf_grids_remap_operator; i ++) {
-			if (leaf_grids_remap_operator[i]->has_grid_coord_label(COORD_LABEL_LEV) && field_data_grid->is_sigma_grid()) {
-				EXECUTION_REPORT(REPORT_ERROR, -1, field_data_grid->get_sigma_grid_surface_value_field() != NULL, "C-Coupler error in check_field_data_grid_center_values_for_remapping");
-			}
-			else {	
-	            EXECUTION_REPORT(REPORT_ERROR, -1, leaf_grids_remap_operator[i]->get_super_grid_of_setting_coord_values() != NULL,
-	                         "The coordinate values of \"%s\" defined in grid \"%s\" must be set for regriding\n",
-	                         leaf_grids_remap_operator[i]->get_coord_label(),
-	                         leaf_grids_remap_operator[i]->get_grid_name());
-	            if (!leaf_grids_remap_operator[i]->get_super_grid_of_setting_coord_values()->is_subset_of_grid(remap_operator_grid))
-	                EXECUTION_REPORT(REPORT_ERROR, -1, remap_operator_grid->get_num_dimensions() == 1,
-	                             "the coordinate values of %s are set in grid %s, it must be used in 1D remapping\n",
-	                             leaf_grids_remap_operator[i]->get_coord_label(),
-	                             leaf_grids_remap_operator[i]->get_super_grid_of_setting_coord_values()->get_grid_name());
+			if (leaf_grids_remap_operator[i]->does_use_V3D_level_coord()) {
 			}
+            else if (!(leaf_grids_remap_operator[i]->has_grid_coord_label(COORD_LABEL_LEV) && field_data_grid->is_sigma_grid())) {    
+                EXECUTION_REPORT(REPORT_ERROR, -1, leaf_grids_remap_operator[i]->get_super_grid_of_setting_coord_values() != NULL,
+                             "The coordinate values of \"%s\" defined in grid \"%s\" must be set for regriding\n",
+                             leaf_grids_remap_operator[i]->get_coord_label(),
+                             leaf_grids_remap_operator[i]->get_grid_name());
+                if (!leaf_grids_remap_operator[i]->get_super_grid_of_setting_coord_values()->is_subset_of_grid(remap_operator_grid))
+                    EXECUTION_REPORT(REPORT_ERROR, -1, remap_operator_grid->get_num_dimensions() == 1,
+                                 "the coordinate values of %s are set in grid %s, it must be used in 1D remapping\n",
+                                 leaf_grids_remap_operator[i]->get_coord_label(),
+                                 leaf_grids_remap_operator[i]->get_super_grid_of_setting_coord_values()->get_grid_name());
+            }
         }
 }
 
 
-void Remap_strategy_class::calculate_remapping_weights(Remap_weight_of_strategy_class *remap_weight_of_strategy, const char *H2D_remapping_wgt_file)
+void Remap_strategy_class::calculate_remapping_weights(Remap_weight_of_strategy_class *remap_weight_of_strategy, const char *H2D_remapping_wgt_file, int wgt_cal_wgt_id)
 {
     int i, j;
     Remap_grid_class *remap_src_data_grid, *remap_dst_data_grid, *current_remap_src_data_grid;
@@ -123,63 +122,46 @@ void Remap_strategy_class::calculate_remapping_weights(Remap_weight_of_strategy_
     Remap_grid_class *current_remap_src_data_grid_interchanged;
     int num_leaf_grids, num_sized_grids;
     Remap_grid_class *leaf_grids[256], *sized_grids[256];
-    Remap_grid_data_class *field_data_src, *field_data_dst;
-    Remap_grid_data_class *interchanged_field_data_src, *remap_operator_dst_field_data = NULL;
     Remap_grid_class *runtime_remap_grid_src, *runtime_remap_grid_dst;
     Remap_grid_data_class *runtime_mask_src, *runtime_mask_dst;
     Remap_grid_class *runtime_mask_sub_grids_src[256], *runtime_mask_sub_grids_dst[256];
+	bool *outer_mask;
     int num_runtime_mask_sub_grids_src, num_runtime_mask_sub_grids_dst;
     long runtime_remap_times_iter;
     double last_time, current_time;
 
 
-
-    field_data_src = NULL;
-    field_data_dst = NULL;
     remap_src_data_grid = remap_weight_of_strategy->get_data_grid_src();
     remap_dst_data_grid = remap_weight_of_strategy->get_data_grid_dst();
 
     remap_src_data_grid->end_grid_definition_stage(NULL);
     remap_dst_data_grid->end_grid_definition_stage(NULL);
 
-	if (remap_src_data_grid->is_sigma_grid() || remap_dst_data_grid->is_sigma_grid()) {
-		for (i = 0; i < remap_operators.size(); i ++)
-			if (remap_operators[i]->get_src_grid()->has_grid_coord_label(COORD_LABEL_LEV))
-				break;
-		EXECUTION_REPORT(REPORT_ERROR, -1, i < remap_operators.size(), "One grid in %s or %s is a sigma grid. The interpolation between them must have vertical interpolation", remap_src_data_grid->get_grid_name(), remap_dst_data_grid->get_grid_name());
-	}
+    if (remap_src_data_grid->is_sigma_grid() || remap_dst_data_grid->is_sigma_grid()) {
+        for (i = 0; i < remap_operators.size(); i ++)
+            if (remap_operators[i]->get_src_grid()->has_grid_coord_label(COORD_LABEL_LEV))
+                break;
+        EXECUTION_REPORT(REPORT_ERROR, -1, i < remap_operators.size(), "One grid in %s or %s is a sigma grid. The interpolation between them must have vertical interpolation", remap_src_data_grid->get_grid_name(), remap_dst_data_grid->get_grid_name());
+    }
 
- 	j = 1;
+     j = 1;
     
     current_remap_src_data_grid = remap_src_data_grid;
     for (i = 0; i < remap_operators.size(); i ++) {
         EXECUTION_REPORT_LOG(REPORT_LOG, -1, true, "execute remap operator %s  %s %s %lx %s", remap_operators[i]->get_object_name(), remap_operators[i]->get_operator_name(), remap_operators[i]->get_dst_grid()->get_grid_name(), remap_operators[i]->get_dst_grid(), remap_dst_data_grid->get_grid_name());
-		EXECUTION_REPORT(REPORT_ERROR, -1, remap_operators[i]->get_dst_grid()->is_sub_grid_of_grid(remap_dst_data_grid), "Software error: the dst grid \"%s\" of an remapping operator is not a sub grid of \"%s\"", remap_operators[i]->get_dst_grid()->get_grid_name(), remap_dst_data_grid->get_grid_name());
-		current_remap_src_data_grid_interchanged = remap_weight_of_strategy->get_field_data_grid_in_remapping_process(j);
-		runtime_mask_src = remap_weight_of_strategy->get_runtime_mask_field_in_remapping_process(j++);
-		current_remap_dst_data_grid = remap_weight_of_strategy->get_field_data_grid_in_remapping_process(j);
+        EXECUTION_REPORT(REPORT_ERROR, -1, remap_operators[i]->get_dst_grid()->is_sub_grid_of_grid(remap_dst_data_grid), "Software error: the dst grid \"%s\" of an remapping operator is not a sub grid of \"%s\"", remap_operators[i]->get_dst_grid()->get_grid_name(), remap_dst_data_grid->get_grid_name());
+        current_remap_src_data_grid_interchanged = remap_weight_of_strategy->get_field_data_grid_in_remapping_process(j);
+        runtime_mask_src = remap_weight_of_strategy->get_runtime_mask_field_in_remapping_process(j++);
+        current_remap_dst_data_grid = remap_weight_of_strategy->get_field_data_grid_in_remapping_process(j);
         check_field_data_grid_center_values_for_remapping(current_remap_src_data_grid, get_remap_operator(i)->get_src_grid(), get_remap_operator(i)->get_is_operator_regridding());
-        check_field_data_grid_center_values_for_remapping(current_remap_dst_data_grid, get_remap_operator(i)->get_dst_grid(), get_remap_operator(i)->get_is_operator_regridding());	
-		runtime_mask_dst = remap_weight_of_strategy->get_runtime_mask_field_in_remapping_process(j++);
+        check_field_data_grid_center_values_for_remapping(current_remap_dst_data_grid, get_remap_operator(i)->get_dst_grid(), get_remap_operator(i)->get_is_operator_regridding());    
+        runtime_mask_dst = remap_weight_of_strategy->get_runtime_mask_field_in_remapping_process(j++);
         current_remap_src_data_grid->interchange_grid_fields_for_remapping(current_remap_src_data_grid_interchanged,
                                                                            remap_operators[i]->get_src_grid(),
                                                                            runtime_mask_src);
         current_remap_dst_data_grid->interchange_grid_fields_for_remapping(current_remap_dst_data_grid,
                                                                            remap_operators[i]->get_dst_grid(),
                                                                            runtime_mask_dst);
-        if (field_data_src != NULL) {
-            field_data_src->interchange_grid_data(current_remap_src_data_grid_interchanged);
-            if (i == remap_operators.size()-1) {
-                remap_operator_dst_field_data = field_data_dst;
-                if (field_data_dst->have_data_content())
-                    field_data_dst->interchange_grid_data(current_remap_dst_data_grid);
-                else {
-                    current_remap_dst_data_grid->get_sized_sub_grids(&num_sized_grids, sized_grids);
-                    field_data_dst->reset_sized_grids(num_sized_grids, sized_grids);
-                }
-            }
-            else remap_operator_dst_field_data = field_data_src->duplicate_grid_data_field(current_remap_dst_data_grid, 1, false, false);
-        }
         runtime_remap_grid_src = current_remap_src_data_grid_interchanged->generate_remap_operator_runtime_grid(remap_operators[i]->get_src_grid(), 
                                                                                                                 remap_operators[i], 
                                                                                                                 runtime_mask_src);
@@ -191,30 +173,29 @@ void Remap_strategy_class::calculate_remapping_weights(Remap_weight_of_strategy_
                                                                     runtime_remap_grid_src,
                                                                     runtime_remap_grid_dst,
                                                                     remap_operators[i],
-                                                                    field_data_src,
-                                                                    remap_operator_dst_field_data,
-                                                                    remap_weight_of_strategy);
+                                                                    NULL,
+                                                                    NULL,
+                                                                    remap_weight_of_strategy,
+                                                                    H2D_remapping_wgt_file);
         if (execution_phase_number == 1) {
+			outer_mask = NULL;
+			if (runtime_remap_grid_src->get_grid_mask_field() == NULL && (runtime_mask_src != NULL || runtime_mask_dst != NULL)) {
+				EXECUTION_REPORT_ERROR_OPTIONALLY(REPORT_ERROR, -1, runtime_mask_src != NULL && runtime_mask_dst != NULL, "Software error in Remap_strategy_class::calculate_remapping_weights");
+				EXECUTION_REPORT_ERROR_OPTIONALLY(REPORT_ERROR, -1, runtime_mask_src->get_coord_value_grid() == runtime_mask_dst->get_coord_value_grid(), "Software error in Remap_strategy_class::calculate_remapping_weights");				
+				EXECUTION_REPORT_ERROR_OPTIONALLY(REPORT_ERROR, -1, runtime_mask_src->get_grid_data_field()->required_data_size == current_remap_src_data_grid_interchanged->get_grid_size()/runtime_remap_grid_src->get_grid_size(), "Software error in Remap_strategy_class::calculate_remapping_weights");
+				outer_mask = (bool*) runtime_mask_src->get_grid_data_field()->data_buf;
+			}
             for (runtime_remap_times_iter = 0; runtime_remap_times_iter < current_remap_src_data_grid_interchanged->get_grid_size()/runtime_remap_grid_src->get_grid_size(); runtime_remap_times_iter ++) {
-                current_runtime_remap_function->calculate_static_remapping_weights(runtime_remap_times_iter, H2D_remapping_wgt_file);
+                current_runtime_remap_function->calculate_static_remapping_weights(runtime_remap_times_iter, H2D_remapping_wgt_file, wgt_cal_wgt_id, outer_mask == NULL? true:outer_mask[runtime_remap_times_iter]);
             }
         }
-		if (remap_operators[i]->get_src_grid()->has_grid_coord_label(COORD_LABEL_LEV))
-			if (remap_operators[i]->get_src_grid()->get_a_leaf_grid_of_sigma_or_hybrid() || remap_operators[i]->get_dst_grid()->get_a_leaf_grid_of_sigma_or_hybrid())
-				remap_weight_of_strategy->mark_empty_remap_weight();
+        if (remap_operators[i]->get_src_grid()->has_grid_coord_label(COORD_LABEL_LEV))
+            if (remap_operators[i]->get_src_grid()->get_a_leaf_grid_of_sigma_or_hybrid() || remap_operators[i]->get_dst_grid()->get_a_leaf_grid_of_sigma_or_hybrid())
+                remap_weight_of_strategy->mark_empty_remap_weight();
 
         delete runtime_remap_grid_src;
         delete runtime_remap_grid_dst;
-        if (field_data_src != NULL)
-            delete current_remap_src_data_grid_interchanged;
         delete current_runtime_remap_function;
-        if (i > 0 && field_data_src != NULL) {
-            delete field_data_src;
-            delete current_remap_src_data_grid;
-        }
-
-        if (field_data_src != NULL)
-            field_data_src = remap_operator_dst_field_data;
         current_remap_src_data_grid = current_remap_dst_data_grid;
 
         if (runtime_mask_src != NULL)
@@ -224,12 +205,7 @@ void Remap_strategy_class::calculate_remapping_weights(Remap_weight_of_strategy_
             delete runtime_mask_dst;
     }
 
-    if (field_data_src != NULL) {
-	    field_data_dst->get_grid_data_field()->read_data_size = field_data_dst->get_grid_data_field()->required_data_size;
-        delete current_remap_src_data_grid;
-    }
-
-	EXECUTION_REPORT(REPORT_ERROR, -1, j+1 == remap_weight_of_strategy->get_num_field_data_grids_in_remapping_process(), "C-Coupler error in calculate_remapping_weights\n");
+    EXECUTION_REPORT(REPORT_ERROR, -1, j+1 == remap_weight_of_strategy->get_num_field_data_grids_in_remapping_process(), "C-Coupler error in calculate_remapping_weights\n");
 }
 
 
@@ -238,12 +214,12 @@ void Remap_strategy_class::remap_fields(const char *field_data_name_src, const c
     int i;
     Remap_grid_class *remap_src_data_grid, *remap_dst_data_grid;
     Remap_grid_data_class *field_data_src, *field_data_dst;
-	Remap_weight_of_strategy_class *remap_weight_of_strategy;
+    Remap_weight_of_strategy_class *remap_weight_of_strategy;
 
 
     field_data_src = remap_field_data_manager->search_remap_field_data(field_data_name_src);
     field_data_dst = remap_field_data_manager->search_remap_field_data(field_data_name_dst);
-	field_data_src->transfer_field_attributes_to_another(field_data_dst);
+    field_data_src->transfer_field_attributes_to_another(field_data_dst);
     EXECUTION_REPORT(REPORT_ERROR, -1, field_data_src != NULL && field_data_dst != NULL, "remap software error1 in Remap_strategy_class::remap_fields\n");
     EXECUTION_REPORT(REPORT_WARNING, -1, field_data_src->have_data_content(), 
                      "source field data \"%s\" does not have essential data; before the current remapping calculation, its data should have been read from IO or calculated by remapping\n",
@@ -263,15 +239,15 @@ void Remap_strategy_class::remap_fields(const char *field_data_name_src, const c
     remap_src_data_grid->end_grid_definition_stage(NULL);
     remap_dst_data_grid->end_grid_definition_stage(NULL);
 
-	if (remap_src_data_grid->is_sigma_grid() || remap_dst_data_grid->is_sigma_grid()) {
-		for (i = 0; i < remap_operators.size(); i ++)
-			if (remap_operators[i]->get_src_grid()->has_grid_coord_label(COORD_LABEL_LEV))
-				break;
-		EXECUTION_REPORT(REPORT_ERROR, -1, i < remap_operators.size(), "One grid in %s or %s is a sigma grid. The interpolation between them must have vertical interpolation", remap_src_data_grid->get_grid_name(), remap_dst_data_grid->get_grid_name());
-	}
+    if (remap_src_data_grid->is_sigma_grid() || remap_dst_data_grid->is_sigma_grid()) {
+        for (i = 0; i < remap_operators.size(); i ++)
+            if (remap_operators[i]->get_src_grid()->has_grid_coord_label(COORD_LABEL_LEV))
+                break;
+        EXECUTION_REPORT(REPORT_ERROR, -1, i < remap_operators.size(), "One grid in %s or %s is a sigma grid. The interpolation between them must have vertical interpolation", remap_src_data_grid->get_grid_name(), remap_dst_data_grid->get_grid_name());
+    }
 
-	remap_weight_of_strategy = remap_weights_of_strategy_manager->search_or_add_remap_weight_of_strategy(remap_src_data_grid, remap_dst_data_grid, this, NULL, NULL, NULL, false);
-	remap_weight_of_strategy->do_remap(field_data_src, field_data_dst);
+    remap_weight_of_strategy = remap_weights_of_strategy_manager->search_or_add_remap_weight_of_strategy(remap_src_data_grid, remap_dst_data_grid, this, NULL, NULL, NULL, false);
+    remap_weight_of_strategy->do_remap(-1, field_data_src, field_data_dst);
 }
 
 
diff --git a/src/CoR/remap_strategy_class.h b/src/CoR/remap_strategy_class.h
old mode 100644
new mode 100755
index 09b5b4f..2b42595
--- a/src/CoR/remap_strategy_class.h
+++ b/src/CoR/remap_strategy_class.h
@@ -27,12 +27,12 @@ class Remap_strategy_class
         Remap_strategy_class(const char*, int, Remap_operator_basis**);
         ~Remap_strategy_class() {}
         bool match_remap_strategy(const char*);
-        void calculate_remapping_weights(Remap_weight_of_strategy_class*, const char *);
+        void calculate_remapping_weights(Remap_weight_of_strategy_class*, const char *, int);
         int get_num_remap_operator() { return remap_operators.size(); }
         Remap_operator_basis *get_remap_operator(int i) { return remap_operators[i]; }
         void check_field_data_grid_center_values_for_remapping(Remap_grid_class*, Remap_grid_class*, bool);
-		const char *get_strategy_name() { return strategy_name; }
-		void remap_fields(const char*, const char*);
+        const char *get_strategy_name() { return strategy_name; }
+        void remap_fields(const char*, const char*);
 };
 
 
diff --git a/src/CoR/remap_strategy_mgt.cxx b/src/CoR/remap_strategy_mgt.cxx
old mode 100644
new mode 100755
index 431095e..ec6f187
--- a/src/CoR/remap_strategy_mgt.cxx
+++ b/src/CoR/remap_strategy_mgt.cxx
@@ -61,6 +61,6 @@ Remap_strategy_mgt::~Remap_strategy_mgt()
 
 void Remap_strategy_mgt::add_remap_strategy(Remap_strategy_class *remap_strategy)
 {
-	remap_strategies.push_back(remap_strategy);
+    remap_strategies.push_back(remap_strategy);
 }
 
diff --git a/src/CoR/remap_strategy_mgt.h b/src/CoR/remap_strategy_mgt.h
old mode 100644
new mode 100755
index 7f5d1dc..80787d9
--- a/src/CoR/remap_strategy_mgt.h
+++ b/src/CoR/remap_strategy_mgt.h
@@ -26,7 +26,7 @@ class Remap_strategy_mgt
         ~Remap_strategy_mgt();
         void execute(const char*, Remap_statement_operand **, int);
         Remap_strategy_class *search_remap_strategy(const char*);
-		void add_remap_strategy(Remap_strategy_class*);
+        void add_remap_strategy(Remap_strategy_class*);
 };
 
 #endif
diff --git a/src/CoR/remap_utils_nearest_points.cxx b/src/CoR/remap_utils_nearest_points.cxx
old mode 100644
new mode 100755
index 8223a04..ba75e8b
--- a/src/CoR/remap_utils_nearest_points.cxx
+++ b/src/CoR/remap_utils_nearest_points.cxx
@@ -42,7 +42,7 @@ double calculate_distance_of_two_points_2D(double point1_coord1_value,
         if (temp_value > 1)
             temp_value = 1;
         if (temp_value < -1)
-            temp_value = 1;
+            temp_value = -1.0;
         distance = acos(temp_value);
     }
     else {
@@ -69,7 +69,7 @@ void compute_dist_remap_weights_of_one_dst_cell(long dst_cell_index,
     long src_cell_index;
     double sum_wgt_values, src_cell_center_values[256], dst_cell_center_values[256], dst_cell_vertex_values[65536];
     int i, num_points_within_threshold_dist, num_vertexes_dst;
-	double current_dist;
+    double current_dist;
 
     
     get_cell_mask_of_dst_grid(dst_cell_index, &dst_cell_mask);
@@ -77,24 +77,24 @@ void compute_dist_remap_weights_of_one_dst_cell(long dst_cell_index,
         return;
 
     get_cell_center_coord_values_of_dst_grid(dst_cell_index, dst_cell_center_values);
-	get_cell_vertex_coord_values_of_dst_grid(dst_cell_index, &num_vertexes_dst, dst_cell_vertex_values, true);
-	EXECUTION_REPORT(REPORT_ERROR, -1, num_vertexes_dst <= 65536/2, "Software error in compute_dist_remap_weights_of_one_dst_cell: too big number of dst vertexes: %d", num_vertexes_dst);
-	
+    get_cell_vertex_coord_values_of_dst_grid(dst_cell_index, &num_vertexes_dst, dst_cell_vertex_values, true);
+    EXECUTION_REPORT(REPORT_ERROR, -1, num_vertexes_dst <= 65536/2, "Software error in compute_dist_remap_weights_of_one_dst_cell: too big number of dst vertexes: %d", num_vertexes_dst);
+    
     if (num_vertexes_dst > 0 && (!enable_extrapolate && !have_overlapped_src_cells_for_dst_cell(dst_cell_index)))
         return;
 
-	if (num_vertexes_dst == 0) {
-	    search_cell_in_src_grid(dst_cell_center_values, &src_cell_index, false);
-		if (src_cell_index == -1 && (!enable_extrapolate))
-			return;
-	}
+    if (num_vertexes_dst == 0) {
+        search_cell_in_src_grid(dst_cell_center_values, &src_cell_index, false);
+        if (src_cell_index == -1 && (!enable_extrapolate))
+            return;
+    }
 
-	get_current_grid2D_search_engine(true)->search_nearest_points_var_number(num_nearest_points, dst_cell_center_values[0], dst_cell_center_values[1], 
-																									  num_points_within_threshold_dist, found_nearest_points_src_indexes, found_nearest_points_distance, true);
+    get_current_grid2D_search_engine(true)->search_nearest_points_var_number(num_nearest_points, dst_cell_center_values[0], dst_cell_center_values[1], 
+                                                                                                      num_points_within_threshold_dist, found_nearest_points_src_indexes, found_nearest_points_distance, true);
 
-	if (num_nearest_points > num_points_within_threshold_dist)
-		num_nearest_points = num_points_within_threshold_dist;
-	
+    if (num_nearest_points > num_points_within_threshold_dist)
+        num_nearest_points = num_points_within_threshold_dist;
+    
     if (found_nearest_points_distance[0] == 0.0) {
         weigt_values_of_one_dst_cell[0] = 1.0;
         add_remap_weights_to_sparse_matrix(found_nearest_points_src_indexes, dst_cell_index, weigt_values_of_one_dst_cell, 1, 0, true);
diff --git a/src/CoR/remap_utils_nearest_points.h b/src/CoR/remap_utils_nearest_points.h
old mode 100644
new mode 100755
diff --git a/src/CoR/remap_weight_of_strategy_class.cxx b/src/CoR/remap_weight_of_strategy_class.cxx
old mode 100644
new mode 100755
index 5e618d8..039baf6
--- a/src/CoR/remap_weight_of_strategy_class.cxx
+++ b/src/CoR/remap_weight_of_strategy_class.cxx
@@ -13,34 +13,31 @@
 #include "remap_operator_basis.h"
 #include "io_binary.h"
 #include "io_netcdf.h"
+#include "performance_timing_mgt.h"
+#include "global_data.h"
 #include <string.h>
 
 
 Remap_weight_of_operator_instance_class::Remap_weight_of_operator_instance_class(Remap_grid_class *field_data_grid_src, Remap_grid_class *field_data_grid_dst, 
                                                                long remap_beg_iter, Remap_operator_basis *remap_operator)
 {
-    this->field_data_grid_src = field_data_grid_src;
-    this->field_data_grid_dst = field_data_grid_dst;
+	this->remap_weight_of_operator = NULL;
     this->remap_beg_iter = remap_beg_iter;
     this->remap_end_iter = remap_beg_iter + 1;
-    this->original_remap_operator = remap_operator;
-    this->duplicated_remap_operator = remap_operator->duplicate_remap_operator(true);
-    this->operator_grid_src = remap_operator->src_grid;
-    this->operator_grid_dst = remap_operator->dst_grid;
+	this->duplicated_remap_operator = NULL;
+    if (remap_operator->get_src_grid()->get_is_sphere_grid()) {
+		this->duplicated_remap_operator = remap_operator->duplicate_remap_operator(true);
+    }
 }
 
 
 Remap_weight_of_operator_instance_class::Remap_weight_of_operator_instance_class(Remap_grid_class *field_data_grid_src, Remap_grid_class *field_data_grid_dst, 
                                                                long remap_beg_iter, Remap_operator_basis *remap_operator, Remap_operator_basis *duplicated_remap_operator)
 {
-    this->field_data_grid_src = field_data_grid_src;
-    this->field_data_grid_dst = field_data_grid_dst;
+	this->remap_weight_of_operator = NULL;
     this->remap_beg_iter = remap_beg_iter;
     this->remap_end_iter = remap_beg_iter + 1;
-    this->original_remap_operator = remap_operator;
     this->duplicated_remap_operator = duplicated_remap_operator;
-    this->operator_grid_src = remap_operator->src_grid;
-    this->operator_grid_dst = remap_operator->dst_grid;
 }
 
 
@@ -51,25 +48,29 @@ Remap_weight_of_operator_instance_class *Remap_weight_of_operator_instance_class
 
 
     parallel_remap_weights_of_operator_instance = new Remap_weight_of_operator_instance_class();
-    parallel_remap_weights_of_operator_instance->original_remap_operator = this->original_remap_operator;
+	parallel_remap_weights_of_operator_instance->remap_weight_of_operator = this->remap_weight_of_operator;
 
     for (int i = 0; i < 2; i ++)
-        if (this->original_remap_operator->get_src_grid()->have_overlap_with_grid(decomp_original_grids[i])) {
-            EXECUTION_REPORT(REPORT_ERROR, -1, decomp_original_grids[i]->is_subset_of_grid(this->original_remap_operator->get_src_grid()),
+        if (this->get_original_remap_operator()->get_src_grid()->have_overlap_with_grid(decomp_original_grids[i])) {
+            EXECUTION_REPORT(REPORT_ERROR, -1, decomp_original_grids[i]->is_subset_of_grid(this->get_original_remap_operator()->get_src_grid()),
                          "C-Coupler error1 in generate_parallel_remap_weights of Remap_weight_of_operator_instance_class\n");
             overlap_with_decomp_counter ++;
         }
     for (int i = 0; i < 2; i ++)
-        if (this->original_remap_operator->get_dst_grid()->have_overlap_with_grid(decomp_original_grids[i])) {
-            EXECUTION_REPORT(REPORT_ERROR, -1, decomp_original_grids[i]->is_subset_of_grid(this->original_remap_operator->get_dst_grid()),
+        if (this->get_original_remap_operator()->get_dst_grid()->have_overlap_with_grid(decomp_original_grids[i])) {
+            EXECUTION_REPORT(REPORT_ERROR, -1, decomp_original_grids[i]->is_subset_of_grid(this->get_original_remap_operator()->get_dst_grid()),
                          "C-Coupler error2 in generate_parallel_remap_weights of Remap_weight_of_operator_instance_class\n");
             overlap_with_decomp_counter ++;
         }
-	EXECUTION_REPORT(REPORT_ERROR, -1, this->duplicated_remap_operator != NULL, "C-Coupler error4 in generate_parallel_remap_weights of Remap_weight_of_operator_instance_class\n");
 
-    if (overlap_with_decomp_counter > 0)
+    if (overlap_with_decomp_counter > 0) {
+		EXECUTION_REPORT_ERROR_OPTIONALLY(REPORT_ERROR, -1, this->duplicated_remap_operator != NULL, "C-Coupler error4 in generate_parallel_remap_weights of Remap_weight_of_operator_instance_class\n");
         parallel_remap_weights_of_operator_instance->duplicated_remap_operator = this->duplicated_remap_operator->generate_parallel_remap_operator(decomp_original_grids, global_cells_local_indexes_in_decomps);
-    else parallel_remap_weights_of_operator_instance->duplicated_remap_operator = this->duplicated_remap_operator->duplicate_remap_operator(true);
+    }
+    else {
+		EXECUTION_REPORT_ERROR_OPTIONALLY(REPORT_ERROR, -1, this->get_original_remap_operator() != NULL && parallel_remap_weights_of_operator_instance->duplicated_remap_operator == NULL, "C-Coupler error4 in generate_parallel_remap_weights of Remap_weight_of_operator_instance_class\n");
+		parallel_remap_weights_of_operator_instance->duplicated_remap_operator = this->get_original_remap_operator()->duplicate_remap_operator(true);
+    }
 
     return parallel_remap_weights_of_operator_instance;
 }
@@ -77,50 +78,82 @@ Remap_weight_of_operator_instance_class *Remap_weight_of_operator_instance_class
 
 Remap_weight_of_operator_instance_class::~Remap_weight_of_operator_instance_class()
 {
-	if (duplicated_remap_operator != NULL)
-	    delete duplicated_remap_operator;
+    if (duplicated_remap_operator != NULL)
+        delete duplicated_remap_operator;
 }
 
 
 void Remap_weight_of_operator_instance_class::renew_remapping_time_end_iter(long time_end_iter)
 {
-	EXECUTION_REPORT(REPORT_ERROR, -1, remap_end_iter == time_end_iter, "C-Coupler error in Remap_weight_of_operator_instance_class::renew_remapping_time_end_iter");
-	remap_end_iter = time_end_iter + 1;
+    EXECUTION_REPORT(REPORT_ERROR, -1, remap_end_iter == time_end_iter, "C-Coupler error in Remap_weight_of_operator_instance_class::renew_remapping_time_end_iter");
+    remap_end_iter = time_end_iter + 1;
+}
+
+
+Remap_grid_class *Remap_weight_of_operator_instance_class::get_field_data_grid_src() 
+{
+	EXECUTION_REPORT_ERROR_OPTIONALLY(REPORT_ERROR, -1, remap_weight_of_operator != NULL, "Software error in Remap_weight_of_operator_instance_class::get_field_data_grid_src");
+	return remap_weight_of_operator->get_field_data_grid_src(); 
+}
+
+
+Remap_grid_class *Remap_weight_of_operator_instance_class::get_field_data_grid_dst() 
+{
+	EXECUTION_REPORT_ERROR_OPTIONALLY(REPORT_ERROR, -1, remap_weight_of_operator != NULL, "Software error in Remap_weight_of_operator_instance_class::get_field_data_grid_dst");
+	return remap_weight_of_operator->get_field_data_grid_dst(); 
+}
+
+
+Remap_operator_basis *Remap_weight_of_operator_instance_class::get_original_remap_operator()
+{
+	EXECUTION_REPORT_ERROR_OPTIONALLY(REPORT_ERROR, -1, remap_weight_of_operator != NULL, "Software error in Remap_weight_of_operator_instance_class::get_original_remap_operator");
+	return remap_weight_of_operator->get_original_remap_operator(); 
+}
+
+
+Remap_grid_class *Remap_weight_of_operator_instance_class::get_operator_grid_src()
+{
+	EXECUTION_REPORT_ERROR_OPTIONALLY(REPORT_ERROR, -1, remap_weight_of_operator != NULL, "Software error in Remap_weight_of_operator_instance_class::get_operator_grid_src");
+	return remap_weight_of_operator->get_operator_grid_src();
+}
+
+
+Remap_grid_class *Remap_weight_of_operator_instance_class::get_operator_grid_dst()
+{
+	EXECUTION_REPORT_ERROR_OPTIONALLY(REPORT_ERROR, -1, remap_weight_of_operator != NULL, "Software error in Remap_weight_of_operator_instance_class::get_operator_grid_dst");
+	return remap_weight_of_operator->get_operator_grid_dst();
 }
 
 
 Remap_weight_of_operator_class::Remap_weight_of_operator_class(Remap_grid_class *field_data_grid_src, Remap_grid_class *field_data_grid_dst, Remap_operator_basis *remap_operator,
-																	  Remap_grid_class *operator_grid_src, Remap_grid_class *operator_grid_dst)
+                                                                      Remap_grid_class *operator_grid_src, Remap_grid_class *operator_grid_dst)
 {
     this->field_data_grid_src = field_data_grid_src;
     this->field_data_grid_dst = field_data_grid_dst;
     this->original_remap_operator = remap_operator;
     this->operator_grid_src = operator_grid_src;
     this->operator_grid_dst = operator_grid_dst;
-	empty_remap_weight = false;
+    empty_remap_weight = false;
 }
 
 
 void Remap_weight_of_operator_class::calculate_src_decomp(long *decomp_map_src, const long *decomp_map_dst)
 {
     long remap_beg_iter, remap_end_iter;
-	
+    
 
-	for (int i = 0; i < remap_weights_of_operator_instances.size(); i ++) {
-        EXECUTION_REPORT(REPORT_ERROR, -1, remap_weights_of_operator_instances[i]->field_data_grid_src == this->field_data_grid_src && remap_weights_of_operator_instances[i]->field_data_grid_dst == this->field_data_grid_dst &&
-						 remap_weights_of_operator_instances[i]->operator_grid_src == this->operator_grid_src && remap_weights_of_operator_instances[i]->operator_grid_dst == this->operator_grid_dst,
-                     	 "remap software error1 in generate_parallel_remap_weights of Remap_weight_of_operator_class\n");
-	    remap_beg_iter = remap_weights_of_operator_instances[i]->remap_beg_iter;
-	    if (remap_weights_of_operator_instances[i]->remap_end_iter != -1)
-	        remap_end_iter = remap_weights_of_operator_instances[i]->remap_end_iter;
-	    else if (i+1 < remap_weights_of_operator_instances.size())
-	        remap_end_iter = remap_weights_of_operator_instances[i+1]->remap_beg_iter;
-	    else remap_end_iter = field_data_grid_src->get_grid_size()/operator_grid_src->get_grid_size();
-	    for (int j = remap_beg_iter; j < remap_end_iter; j ++) {
-			EXECUTION_REPORT(REPORT_ERROR, -1, remap_weights_of_operator_instances[i]->duplicated_remap_operator != NULL, "C-Coupler error3 in do_remap of Remap_weight_of_operator_class");
-	        remap_weights_of_operator_instances[i]->duplicated_remap_operator->do_src_decomp_caculation(decomp_map_src, decomp_map_dst);
-	    }
-	}
+    for (int i = 0; i < remap_weights_of_operator_instances.size(); i ++) {
+        remap_beg_iter = remap_weights_of_operator_instances[i]->remap_beg_iter;
+        if (remap_weights_of_operator_instances[i]->remap_end_iter != -1)
+            remap_end_iter = remap_weights_of_operator_instances[i]->remap_end_iter;
+        else if (i+1 < remap_weights_of_operator_instances.size())
+            remap_end_iter = remap_weights_of_operator_instances[i+1]->remap_beg_iter;
+        else remap_end_iter = field_data_grid_src->get_grid_size()/operator_grid_src->get_grid_size();
+        for (int j = remap_beg_iter; j < remap_end_iter; j ++) {
+            EXECUTION_REPORT(REPORT_ERROR, -1, remap_weights_of_operator_instances[i]->duplicated_remap_operator != NULL, "C-Coupler error3 in do_remap of Remap_weight_of_operator_class");
+            remap_weights_of_operator_instances[i]->duplicated_remap_operator->do_src_decomp_caculation(decomp_map_src, decomp_map_dst);
+        }
+    }
 }
 
 
@@ -133,93 +166,92 @@ Remap_weight_of_operator_class *Remap_weight_of_operator_class::generate_paralle
     int i, j, k;
     Remap_weight_of_operator_instance_class *parallel_remap_weights_of_operator_instance;
     long remap_beg_iter, remap_end_iter, global_field_array_offset, local_field_array_offset;
+	Remap_grid_class *field_data_grid_src, *field_data_grid_dst, *operator_grid_src, *operator_grid_dst;
 
 
-	EXECUTION_REPORT_LOG(REPORT_LOG, -1, true, "Remap_weight_of_operator has %ld instances", remap_weights_of_operator_instances.size());
+    EXECUTION_REPORT_LOG(REPORT_LOG, -1, true, "Remap_weight_of_operator has %ld instances", remap_weights_of_operator_instances.size());
 
     for (i = 0; i < remap_weights_of_operator_instances.size(); i ++) {
-        EXECUTION_REPORT(REPORT_ERROR, -1, remap_weights_of_operator_instances[i]->field_data_grid_src == this->field_data_grid_src && remap_weights_of_operator_instances[i]->field_data_grid_dst == this->field_data_grid_dst &&
-						 remap_weights_of_operator_instances[i]->operator_grid_src == this->operator_grid_src && remap_weights_of_operator_instances[i]->operator_grid_dst == this->operator_grid_dst,
-                     	 "remap software error1 in generate_parallel_remap_weights of Remap_weight_of_operator_class\n");
         remap_beg_iter = remap_weights_of_operator_instances[i]->remap_beg_iter;
         if (remap_weights_of_operator_instances[i]->remap_end_iter != -1)
             remap_end_iter = remap_weights_of_operator_instances[i]->remap_end_iter;
         else {
             if (i+1 < remap_weights_of_operator_instances.size())
                 remap_end_iter = remap_weights_of_operator_instances[i+1]->remap_beg_iter;
-            else remap_end_iter = remap_weights_of_operator_instances[i]->get_field_data_grid_src()->get_grid_size()/remap_weights_of_operator_instances[i]->operator_grid_src->get_grid_size();
+            else remap_end_iter = remap_weights_of_operator_instances[i]->get_field_data_grid_src()->get_grid_size()/remap_weights_of_operator_instances[i]->get_operator_grid_src()->get_grid_size();
         }
 
-        if (remap_weights_of_operator_instances[i]->operator_grid_src->get_is_sphere_grid()) {
+        if (remap_weights_of_operator_instances[i]->get_operator_grid_src()->get_is_sphere_grid()) {
             parallel_remap_weights_of_operator_instance = remap_weights_of_operator_instances[i]->generate_parallel_remap_weights(decomp_original_grids, global_cells_local_indexes_in_decomps);
-            parallel_remap_weights_of_operator_instance->field_data_grid_src = remap_related_decomp_grids[field_data_grids_iter+0];
-            parallel_remap_weights_of_operator_instance->field_data_grid_dst = remap_related_decomp_grids[field_data_grids_iter+1];
-            parallel_remap_weights_of_operator_instance->operator_grid_src = remap_related_decomp_grids[field_data_grids_iter+2];
-            parallel_remap_weights_of_operator_instance->operator_grid_dst = remap_related_decomp_grids[field_data_grids_iter+3];
+            field_data_grid_src = remap_related_decomp_grids[field_data_grids_iter+0];
+            field_data_grid_dst = remap_related_decomp_grids[field_data_grids_iter+1];
+            operator_grid_src = remap_related_decomp_grids[field_data_grids_iter+2];
+            operator_grid_dst = remap_related_decomp_grids[field_data_grids_iter+3];
             parallel_remap_weights_of_operator_instance->remap_beg_iter = remap_weights_of_operator_instances[i]->remap_beg_iter; 
             parallel_remap_weights_of_operator_instance->remap_end_iter = remap_weights_of_operator_instances[i]->remap_end_iter;
-			parallel_remap_weights_of_strategy->add_remap_weight_of_operator_instance(parallel_remap_weights_of_operator_instance);			
+            parallel_remap_weights_of_strategy->add_remap_weight_of_operator_instance(parallel_remap_weights_of_operator_instance, field_data_grid_src, field_data_grid_dst, parallel_remap_weights_of_operator_instance->get_original_remap_operator(), operator_grid_src, operator_grid_dst);
             EXECUTION_REPORT(REPORT_ERROR, -1, remap_weights_of_operator_instances[i]->remap_beg_iter == 0, "C-Coupler error3 in generate_parallel_remap_weights of Remap_weight_of_strategy_class\n");
         }
         else {
             for (j = remap_beg_iter; j < remap_end_iter; j ++) {
                 global_field_array_offset = j;
-				if (remap_weights_of_operator_instances[i]->field_data_grid_src->have_overlap_with_grid(decomp_original_grids[0])) {
-					EXECUTION_REPORT(REPORT_ERROR, -1, false);
-					local_field_array_offset = global_cells_local_indexes_in_decomps[0][global_field_array_offset];
-				}
-				else if (remap_weights_of_operator_instances[i]->field_data_grid_src->have_overlap_with_grid(decomp_original_grids[1]))
-					local_field_array_offset = global_cells_local_indexes_in_decomps[1][global_field_array_offset];
+				if (remap_weights_of_operator_instances[i]->get_field_data_grid_src()->have_overlap_with_grid(decomp_original_grids[1])) // horizontal remapping is at the first constantly
+                    local_field_array_offset = global_cells_local_indexes_in_decomps[1][global_field_array_offset];
+                else if (remap_weights_of_operator_instances[i]->get_field_data_grid_src()->have_overlap_with_grid(decomp_original_grids[0])) {
+                    EXECUTION_REPORT(REPORT_ERROR, -1, false);
+                    local_field_array_offset = global_cells_local_indexes_in_decomps[0][global_field_array_offset];
+                }
                 else EXECUTION_REPORT(REPORT_ERROR, -1, false, "C-Coupler error4 in generate_parallel_remap_weights of Remap_weight_of_strategy_class\n");
-				if (local_field_array_offset == -1)
-					continue;
+                if (local_field_array_offset == -1)
+                    continue;
                 parallel_remap_weights_of_operator_instance = remap_weights_of_operator_instances[i]->generate_parallel_remap_weights(decomp_original_grids, global_cells_local_indexes_in_decomps);
-                parallel_remap_weights_of_operator_instance->field_data_grid_src = remap_related_decomp_grids[field_data_grids_iter+0];
-                parallel_remap_weights_of_operator_instance->field_data_grid_dst = remap_related_decomp_grids[field_data_grids_iter+1];
-                parallel_remap_weights_of_operator_instance->operator_grid_src = remap_related_decomp_grids[field_data_grids_iter+2];
-                parallel_remap_weights_of_operator_instance->operator_grid_dst = remap_related_decomp_grids[field_data_grids_iter+3];
+                field_data_grid_src = remap_related_decomp_grids[field_data_grids_iter+0];
+                field_data_grid_dst = remap_related_decomp_grids[field_data_grids_iter+1];
+                operator_grid_src = remap_related_decomp_grids[field_data_grids_iter+2];
+                operator_grid_dst = remap_related_decomp_grids[field_data_grids_iter+3];
                 parallel_remap_weights_of_operator_instance->remap_beg_iter = local_field_array_offset; 
-                parallel_remap_weights_of_operator_instance->remap_end_iter = local_field_array_offset+1;				
-				parallel_remap_weights_of_strategy->add_remap_weight_of_operator_instance(parallel_remap_weights_of_operator_instance);
+                parallel_remap_weights_of_operator_instance->remap_end_iter = local_field_array_offset+1;                
+                parallel_remap_weights_of_strategy->add_remap_weight_of_operator_instance(parallel_remap_weights_of_operator_instance, field_data_grid_src, field_data_grid_dst, parallel_remap_weights_of_operator_instance->get_original_remap_operator(), operator_grid_src, operator_grid_dst);
             }
         }
-
-        field_data_grids_iter += 4;
     }
+	field_data_grids_iter += 4;
 }
 
 
 Remap_weight_of_operator_class::~Remap_weight_of_operator_class()
 {
-	for (int i = 0; i < remap_weights_of_operator_instances.size(); i ++)
-		delete remap_weights_of_operator_instances[i];
+    for (int i = 0; i < remap_weights_of_operator_instances.size(); i ++)
+        delete remap_weights_of_operator_instances[i];
 }
 
 
-void Remap_weight_of_operator_class::do_remap(Remap_grid_data_class *field_data_src, Remap_grid_data_class *field_data_dst)
+void Remap_weight_of_operator_class::do_remap(int comp_id, Remap_grid_data_class *field_data_src, Remap_grid_data_class *field_data_dst)
 {
 
     double *data_value_src, *data_value_dst;
     int i, j, k;
     long remap_beg_iter, remap_end_iter;
     long field_array_offset;
-	long field_data_size_src, field_data_size_dst;
+    long field_data_size_src, field_data_size_dst;
 
     
     EXECUTION_REPORT_ERROR_OPTIONALLY(REPORT_ERROR, -1, field_data_src->get_coord_value_grid()->is_similar_grid_with(field_data_grid_src), "C-Coupler error1 in do_remap of Remap_weight_of_operator_class");
     EXECUTION_REPORT_ERROR_OPTIONALLY(REPORT_ERROR, -1, field_data_dst->get_coord_value_grid()->is_similar_grid_with(field_data_grid_dst), "C-Coupler error2 in do_remap of Remap_weight_of_operator_class");
-	field_data_src->interchange_grid_data(field_data_grid_src);
-	field_data_dst->interchange_grid_data(field_data_grid_dst);
 
-	field_data_size_src = field_data_src->get_grid_data_field()->read_data_size;
-	field_data_size_dst = field_data_dst->get_grid_data_field()->read_data_size;
+    if (comp_id != -1)          
+        comp_comm_group_mgt_mgr->get_global_node_of_local_comp(comp_id,false,"")->get_performance_timing_mgr()->performance_timing_start(TIMING_TYPE_COMPUTATION, -1, -1, "interchange data");
+    field_data_src->interchange_grid_data(field_data_grid_src);
+    field_data_dst->interchange_grid_data(field_data_grid_dst);
+    if (comp_id != -1)          
+        comp_comm_group_mgt_mgr->get_global_node_of_local_comp(comp_id,false,"")->get_performance_timing_mgr()->performance_timing_stop(TIMING_TYPE_COMPUTATION, -1, -1, "interchange data");
 
-	EXECUTION_REPORT_ERROR_OPTIONALLY(REPORT_ERROR, -1, !is_remap_weight_empty(), "Software error in Remap_weight_of_operator_class::do_remap: empty remap weights");
-	
+    field_data_size_src = field_data_src->get_grid_data_field()->read_data_size;
+    field_data_size_dst = field_data_dst->get_grid_data_field()->read_data_size;
+
+    EXECUTION_REPORT_ERROR_OPTIONALLY(REPORT_ERROR, -1, !is_remap_weight_empty(), "Software error in Remap_weight_of_operator_class::do_remap: empty remap weights");
+    
     for (i = 0; i < remap_weights_of_operator_instances.size(); i ++) {
-        EXECUTION_REPORT_ERROR_OPTIONALLY(REPORT_ERROR, -1, remap_weights_of_operator_instances[i]->field_data_grid_src == this->field_data_grid_src && remap_weights_of_operator_instances[i]->field_data_grid_dst == this->field_data_grid_dst &&
-						 remap_weights_of_operator_instances[i]->operator_grid_src == this->operator_grid_src && remap_weights_of_operator_instances[i]->operator_grid_dst == this->operator_grid_dst,
-                     	 "remap software error3 in do_remap of Remap_weight_of_strategy_class\n");
         remap_beg_iter = remap_weights_of_operator_instances[i]->remap_beg_iter;
         if (remap_weights_of_operator_instances[i]->remap_end_iter != -1)
             remap_end_iter = remap_weights_of_operator_instances[i]->remap_end_iter;
@@ -227,17 +259,17 @@ void Remap_weight_of_operator_class::do_remap(Remap_grid_data_class *field_data_
                 remap_end_iter = remap_weights_of_operator_instances[i+1]->remap_beg_iter;
         else remap_end_iter = field_data_grid_src->get_grid_size()/operator_grid_src->get_grid_size();
         for (j = remap_beg_iter; j < remap_end_iter; j ++) {
-			field_array_offset = j;
-			if (report_error_enabled) {
-		        EXECUTION_REPORT_ERROR_OPTIONALLY(REPORT_ERROR, -1, field_array_offset >= 0 && (field_array_offset+1)*remap_weights_of_operator_instances[i]->operator_grid_src->get_grid_size() <= field_data_size_src,
-	    	    				 "remap software error4 in do_remap of Remap_weight_of_strategy_class");
-				EXECUTION_REPORT_ERROR_OPTIONALLY(REPORT_ERROR, -1, field_array_offset >= 0 && (field_array_offset+1)*remap_weights_of_operator_instances[i]->operator_grid_dst->get_grid_size() <= field_data_size_dst,
-					 			 "remap software error5 in do_remap of Remap_weight_of_strategy_class");
-			}    
-            data_value_src = ((double*) field_data_src->get_grid_data_field()->data_buf) + field_array_offset*remap_weights_of_operator_instances[i]->operator_grid_src->get_grid_size();
-            data_value_dst = ((double*) field_data_dst->get_grid_data_field()->data_buf) + field_array_offset*remap_weights_of_operator_instances[i]->operator_grid_dst->get_grid_size();
-			EXECUTION_REPORT_ERROR_OPTIONALLY(REPORT_ERROR, -1, remap_weights_of_operator_instances[i]->duplicated_remap_operator != NULL, "C-Coupler error3 in do_remap of Remap_weight_of_operator_class");
-            remap_weights_of_operator_instances[i]->duplicated_remap_operator->do_remap_values_caculation(data_value_src, data_value_dst);
+            field_array_offset = j;
+            if (report_error_enabled) {
+                EXECUTION_REPORT_ERROR_OPTIONALLY(REPORT_ERROR, -1, field_array_offset >= 0 && (field_array_offset+1)*remap_weights_of_operator_instances[i]->get_operator_grid_src()->get_grid_size() <= field_data_size_src,
+                                 "remap software error4 in do_remap of Remap_weight_of_strategy_class");
+                EXECUTION_REPORT_ERROR_OPTIONALLY(REPORT_ERROR, -1, field_array_offset >= 0 && (field_array_offset+1)*remap_weights_of_operator_instances[i]->get_operator_grid_dst()->get_grid_size() <= field_data_size_dst,
+                                  "remap software error5 in do_remap of Remap_weight_of_strategy_class");
+            }    
+            data_value_src = ((double*) field_data_src->get_grid_data_field()->data_buf) + field_array_offset*remap_weights_of_operator_instances[i]->get_operator_grid_src()->get_grid_size();
+            data_value_dst = ((double*) field_data_dst->get_grid_data_field()->data_buf) + field_array_offset*remap_weights_of_operator_instances[i]->get_operator_grid_dst()->get_grid_size();
+            EXECUTION_REPORT_ERROR_OPTIONALLY(REPORT_ERROR, -1, remap_weights_of_operator_instances[i]->duplicated_remap_operator != NULL, "C-Coupler error3 in do_remap of Remap_weight_of_operator_class %s", remap_weights_of_operator_instances[i]->get_operator_grid_src()->get_grid_name());
+            remap_weights_of_operator_instances[i]->duplicated_remap_operator->do_remap_values_caculation(data_value_src, data_value_dst, field_data_dst->get_grid_data_field()->required_data_size);
         }
     }
 }
@@ -245,94 +277,125 @@ void Remap_weight_of_operator_class::do_remap(Remap_grid_data_class *field_data_
 
 void Remap_weight_of_operator_class::add_remap_weight_of_operator_instance(Remap_weight_of_operator_instance_class *operator_instance)
 {
-	remap_weights_of_operator_instances.push_back(operator_instance);
+    remap_weights_of_operator_instances.push_back(operator_instance);
+	remap_weights_of_operator_instances[remap_weights_of_operator_instances.size()-1]->set_remap_weight_of_operator(this);
 }
 
 
 void Remap_weight_of_operator_class::renew_vertical_remap_weights(Remap_grid_class *runtime_remap_grid_src, Remap_grid_class *runtime_remap_grid_dst)
 {
-	long i;
-	Remap_grid_data_class *lev_center_field_in_3D_src_grid = NULL, *lev_center_field_in_3D_dst_grid = NULL;
-	Remap_operator_grid *runtime_remap_operator_grid_src = NULL, *runtime_remap_operator_grid_dst = NULL;
-	Remap_operator_basis *new_remap_operator;
-	double *lev_center_values_in_3D_src_grid = NULL, *lev_center_values_in_3D_dst_grid = NULL;
-	long lev_grid_size_src, lev_grid_size_dst, offset;
+    long i;
+    Remap_grid_data_class *lev_center_field_in_3D_src_grid = NULL, *lev_center_field_in_3D_dst_grid = NULL;
+    Remap_operator_grid *runtime_remap_operator_grid_src = NULL, *runtime_remap_operator_grid_dst = NULL;
+    Remap_operator_basis *new_remap_operator;
+    double *lev_center_values_in_3D_src_grid = NULL, *lev_center_values_in_3D_dst_grid = NULL;
+    long lev_grid_size_src, lev_grid_size_dst, offset;
 
-	
-	EXECUTION_REPORT_ERROR_OPTIONALLY(REPORT_ERROR, -1, runtime_remap_grid_src->get_num_dimensions() == 1 && runtime_remap_grid_src->has_grid_coord_label(COORD_LABEL_LEV) && runtime_remap_grid_dst->get_num_dimensions() == 1 && runtime_remap_grid_dst->has_grid_coord_label(COORD_LABEL_LEV),
-					 "C-Coupler error1 in renew_vertical_remap_weights of Remap_weight_of_operator_class");
-	EXECUTION_REPORT_ERROR_OPTIONALLY(REPORT_ERROR, -1, runtime_remap_grid_src->get_num_dimensions() == 1 && runtime_remap_grid_src->has_grid_coord_label(COORD_LABEL_LEV) && runtime_remap_grid_dst->get_num_dimensions() == 1 && runtime_remap_grid_dst->has_grid_coord_label(COORD_LABEL_LEV),
-					 "C-Coupler error2 in renew_vertical_remap_weights of Remap_weight_of_operator_class");
-	EXECUTION_REPORT_ERROR_OPTIONALLY(REPORT_ERROR, -1, original_remap_operator->get_src_grid()->get_num_dimensions() == 1 && original_remap_operator->get_src_grid()->has_grid_coord_label(COORD_LABEL_LEV) && original_remap_operator->get_dst_grid()->get_num_dimensions() == 1 && original_remap_operator->get_dst_grid()->has_grid_coord_label(COORD_LABEL_LEV),
-					 "C-Coupler error3 in renew_vertical_remap_weights of Remap_weight_of_operator_class");
-	EXECUTION_REPORT_ERROR_OPTIONALLY(REPORT_ERROR, -1, original_remap_operator->get_src_grid()->get_num_dimensions() == 1 && original_remap_operator->get_src_grid()->has_grid_coord_label(COORD_LABEL_LEV) && original_remap_operator->get_dst_grid()->get_num_dimensions() == 1 && original_remap_operator->get_dst_grid()->has_grid_coord_label(COORD_LABEL_LEV),
-					 "C-Coupler error4 in renew_vertical_remap_weights of Remap_weight_of_operator_class");
-	EXECUTION_REPORT_ERROR_OPTIONALLY(REPORT_ERROR, -1, field_data_grid_src->is_sigma_grid() || field_data_grid_dst->is_sigma_grid(), "C-Coupler error4 in renew_vertical_remap_weights of Remap_weight_of_operator_class");
-	
-	if (field_data_grid_src->is_sigma_grid()) {
-		EXECUTION_REPORT_ERROR_OPTIONALLY(REPORT_ERROR, -1, runtime_remap_grid_src->is_subset_of_grid(field_data_grid_src), "C-Coupler error5 in renew_vertical_remap_weights of Remap_weight_of_operator_class"); 
-		lev_center_field_in_3D_src_grid = field_data_grid_src->get_unique_center_field();
-		lev_center_field_in_3D_src_grid->interchange_grid_data(field_data_grid_src);
-		lev_center_values_in_3D_src_grid = (double*) lev_center_field_in_3D_src_grid->get_grid_data_field()->data_buf;
-	}
-	if (field_data_grid_dst->is_sigma_grid()) {
-		EXECUTION_REPORT_ERROR_OPTIONALLY(REPORT_ERROR, -1, runtime_remap_grid_dst->is_subset_of_grid(field_data_grid_dst), "C-Coupler error6 in renew_vertical_remap_weights of Remap_weight_of_operator_class"); 
-		lev_center_field_in_3D_dst_grid = field_data_grid_dst->get_unique_center_field();
-		lev_center_field_in_3D_dst_grid->interchange_grid_data(field_data_grid_dst);
-		lev_center_values_in_3D_dst_grid = (double*) lev_center_field_in_3D_dst_grid->get_grid_data_field()->data_buf;
-	}
-	lev_grid_size_src = runtime_remap_grid_src->get_grid_size();
-	lev_grid_size_dst = runtime_remap_grid_dst->get_grid_size();
-
-	for (i = 0; i < remap_weights_of_operator_instances.size(); i ++) {
-		EXECUTION_REPORT_ERROR_OPTIONALLY(REPORT_ERROR, -1, remap_weights_of_operator_instances[i]->duplicated_remap_operator != NULL, "C-Coupler error7 in renew_vertical_remap_weights of Remap_weight_of_operator_class"); 
-		new_remap_operator = remap_weights_of_operator_instances[i]->duplicated_remap_operator->duplicate_remap_operator(true);
-		new_remap_operator->set_src_grid(runtime_remap_grid_src);
-		new_remap_operator->set_dst_grid(runtime_remap_grid_dst);
-		offset = remap_weights_of_operator_instances[i]->remap_beg_iter;
-		if (lev_center_field_in_3D_src_grid != NULL) {
-			EXECUTION_REPORT_ERROR_OPTIONALLY(REPORT_ERROR, -1, offset >= 0 && offset*lev_grid_size_src+lev_grid_size_src<= lev_center_field_in_3D_src_grid->get_grid_data_field()->required_data_size, "C-Coupler error7 in renew_vertical_remap_weights of Remap_weight_of_operator_class"); 
-		}	
-		if (lev_center_values_in_3D_src_grid != NULL)
-			runtime_remap_grid_src->renew_lev_grid_coord_values(lev_center_values_in_3D_src_grid+offset*lev_grid_size_src, NULL);
-		if (lev_center_values_in_3D_dst_grid != NULL) {
-			runtime_remap_grid_dst->renew_lev_grid_coord_values(lev_center_values_in_3D_dst_grid+offset*lev_grid_size_dst, NULL);
-		}
-		if (runtime_remap_operator_grid_src == NULL) {
-			runtime_remap_operator_grid_src = new Remap_operator_grid(runtime_remap_grid_src, new_remap_operator, true, false);
-			runtime_remap_operator_grid_dst = new Remap_operator_grid(runtime_remap_grid_dst, new_remap_operator, false, false);
-			current_runtime_remap_operator_grid_src = runtime_remap_operator_grid_src;
-			current_runtime_remap_operator_grid_dst = runtime_remap_operator_grid_dst;
-		}
-		if (lev_center_values_in_3D_src_grid != NULL)
-			runtime_remap_operator_grid_src->update_operator_grid_data();
-		if (lev_center_values_in_3D_dst_grid != NULL)
-			runtime_remap_operator_grid_dst->update_operator_grid_data();
-		current_runtime_remap_operator = new_remap_operator;
-		new_remap_operator->calculate_remap_weights();
-//		new_remap_operator->get_remap_weights_group(0)->compare_to_another_sparse_matrix(remap_weights_of_operator_instances[i]->duplicated_remap_operator->get_remap_weights_group(0));
-//		new_remap_operator->get_remap_weights_group(1)->compare_to_another_sparse_matrix(remap_weights_of_operator_instances[i]->duplicated_remap_operator->get_remap_weights_group(1));
-//		new_remap_operator->get_remap_weights_group(2)->compare_to_another_sparse_matrix(remap_weights_of_operator_instances[i]->duplicated_remap_operator->get_remap_weights_group(2));
-//		new_remap_operator->get_remap_weights_group(3)->compare_to_another_sparse_matrix(remap_weights_of_operator_instances[i]->duplicated_remap_operator->get_remap_weights_group(3));
-		delete remap_weights_of_operator_instances[i]->duplicated_remap_operator;
-		remap_weights_of_operator_instances[i]->duplicated_remap_operator = new_remap_operator;
-	}
+    
+    EXECUTION_REPORT_ERROR_OPTIONALLY(REPORT_ERROR, -1, runtime_remap_grid_src->get_num_dimensions() == 1 && runtime_remap_grid_src->has_grid_coord_label(COORD_LABEL_LEV) && runtime_remap_grid_dst->get_num_dimensions() == 1 && runtime_remap_grid_dst->has_grid_coord_label(COORD_LABEL_LEV),
+                     "C-Coupler error1 in renew_vertical_remap_weights of Remap_weight_of_operator_class");
+    EXECUTION_REPORT_ERROR_OPTIONALLY(REPORT_ERROR, -1, runtime_remap_grid_src->get_num_dimensions() == 1 && runtime_remap_grid_src->has_grid_coord_label(COORD_LABEL_LEV) && runtime_remap_grid_dst->get_num_dimensions() == 1 && runtime_remap_grid_dst->has_grid_coord_label(COORD_LABEL_LEV),
+                     "C-Coupler error2 in renew_vertical_remap_weights of Remap_weight_of_operator_class");
+    EXECUTION_REPORT_ERROR_OPTIONALLY(REPORT_ERROR, -1, original_remap_operator->get_src_grid()->get_num_dimensions() == 1 && original_remap_operator->get_src_grid()->has_grid_coord_label(COORD_LABEL_LEV) && original_remap_operator->get_dst_grid()->get_num_dimensions() == 1 && original_remap_operator->get_dst_grid()->has_grid_coord_label(COORD_LABEL_LEV),
+                     "C-Coupler error3 in renew_vertical_remap_weights of Remap_weight_of_operator_class");
+    EXECUTION_REPORT_ERROR_OPTIONALLY(REPORT_ERROR, -1, original_remap_operator->get_src_grid()->get_num_dimensions() == 1 && original_remap_operator->get_src_grid()->has_grid_coord_label(COORD_LABEL_LEV) && original_remap_operator->get_dst_grid()->get_num_dimensions() == 1 && original_remap_operator->get_dst_grid()->has_grid_coord_label(COORD_LABEL_LEV),
+                     "C-Coupler error4 in renew_vertical_remap_weights of Remap_weight_of_operator_class");
+    EXECUTION_REPORT_ERROR_OPTIONALLY(REPORT_ERROR, -1, field_data_grid_src->is_sigma_grid() || field_data_grid_dst->is_sigma_grid() || field_data_grid_src->does_use_V3D_level_coord() || field_data_grid_dst->does_use_V3D_level_coord(), "C-Coupler error4 in renew_vertical_remap_weights of Remap_weight_of_operator_class");
+    
+    if (field_data_grid_src->is_sigma_grid() || field_data_grid_src->does_use_V3D_level_coord()) {
+        EXECUTION_REPORT_ERROR_OPTIONALLY(REPORT_ERROR, -1, runtime_remap_grid_src->is_subset_of_grid(field_data_grid_src), "C-Coupler error5 in renew_vertical_remap_weights of Remap_weight_of_operator_class"); 
+        lev_center_field_in_3D_src_grid = field_data_grid_src->get_unique_center_field();
+        lev_center_field_in_3D_src_grid->interchange_grid_data(field_data_grid_src);
+        lev_center_values_in_3D_src_grid = (double*) lev_center_field_in_3D_src_grid->get_grid_data_field()->data_buf;
+    }
+    if (field_data_grid_dst->is_sigma_grid() || field_data_grid_dst->does_use_V3D_level_coord()) {
+        EXECUTION_REPORT_ERROR_OPTIONALLY(REPORT_ERROR, -1, runtime_remap_grid_dst->is_subset_of_grid(field_data_grid_dst), "C-Coupler error6 in renew_vertical_remap_weights of Remap_weight_of_operator_class"); 
+        lev_center_field_in_3D_dst_grid = field_data_grid_dst->get_unique_center_field();
+        lev_center_field_in_3D_dst_grid->interchange_grid_data(field_data_grid_dst);
+        lev_center_values_in_3D_dst_grid = (double*) lev_center_field_in_3D_dst_grid->get_grid_data_field()->data_buf;
+    }
+    lev_grid_size_src = runtime_remap_grid_src->get_grid_size();
+    lev_grid_size_dst = runtime_remap_grid_dst->get_grid_size();
+
+    for (i = 0; i < remap_weights_of_operator_instances.size(); i ++) {
+        EXECUTION_REPORT_ERROR_OPTIONALLY(REPORT_ERROR, -1, remap_weights_of_operator_instances[i]->get_original_remap_operator() != NULL, "C-Coupler error7 in renew_vertical_remap_weights of Remap_weight_of_operator_class"); 
+        new_remap_operator = remap_weights_of_operator_instances[i]->get_original_remap_operator()->duplicate_remap_operator(true);
+        new_remap_operator->set_src_grid(runtime_remap_grid_src);
+        new_remap_operator->set_dst_grid(runtime_remap_grid_dst);
+        offset = remap_weights_of_operator_instances[i]->remap_beg_iter;
+        if (lev_center_field_in_3D_src_grid != NULL) {
+            EXECUTION_REPORT_ERROR_OPTIONALLY(REPORT_ERROR, -1, offset >= 0 && offset*lev_grid_size_src+lev_grid_size_src<= lev_center_field_in_3D_src_grid->get_grid_data_field()->required_data_size, "C-Coupler error7 in renew_vertical_remap_weights of Remap_weight_of_operator_class"); 
+        }    
+        if (lev_center_values_in_3D_src_grid != NULL)
+            runtime_remap_grid_src->renew_lev_grid_coord_values(lev_center_values_in_3D_src_grid+offset*lev_grid_size_src, NULL);
+        if (lev_center_values_in_3D_dst_grid != NULL) {
+            runtime_remap_grid_dst->renew_lev_grid_coord_values(lev_center_values_in_3D_dst_grid+offset*lev_grid_size_dst, NULL);
+        }
+        if (runtime_remap_operator_grid_src == NULL) {
+            runtime_remap_operator_grid_src = new Remap_operator_grid(runtime_remap_grid_src, new_remap_operator, true, false);
+            runtime_remap_operator_grid_dst = new Remap_operator_grid(runtime_remap_grid_dst, new_remap_operator, false, false);
+            current_runtime_remap_operator_grid_src = runtime_remap_operator_grid_src;
+            current_runtime_remap_operator_grid_dst = runtime_remap_operator_grid_dst;
+        }
+        if (lev_center_values_in_3D_src_grid != NULL)
+            runtime_remap_operator_grid_src->update_operator_grid_data();
+        if (lev_center_values_in_3D_dst_grid != NULL)
+            runtime_remap_operator_grid_dst->update_operator_grid_data();
+        current_runtime_remap_operator = new_remap_operator;
+        new_remap_operator->calculate_remap_weights();
+//        new_remap_operator->get_remap_weights_group(0)->compare_to_another_sparse_matrix(remap_weights_of_operator_instances[i]->duplicated_remap_operator->get_remap_weights_group(0));
+//        new_remap_operator->get_remap_weights_group(1)->compare_to_another_sparse_matrix(remap_weights_of_operator_instances[i]->duplicated_remap_operator->get_remap_weights_group(1));
+//        new_remap_operator->get_remap_weights_group(2)->compare_to_another_sparse_matrix(remap_weights_of_operator_instances[i]->duplicated_remap_operator->get_remap_weights_group(2));
+//        new_remap_operator->get_remap_weights_group(3)->compare_to_another_sparse_matrix(remap_weights_of_operator_instances[i]->duplicated_remap_operator->get_remap_weights_group(3));
+		if (remap_weights_of_operator_instances[i]->duplicated_remap_operator != NULL)
+	        delete remap_weights_of_operator_instances[i]->duplicated_remap_operator;
+        remap_weights_of_operator_instances[i]->duplicated_remap_operator = new_remap_operator;
+    }
+
+    if (runtime_remap_operator_grid_src != NULL) {
+        delete runtime_remap_operator_grid_src;
+        delete runtime_remap_operator_grid_dst;
+    }
+    
+    empty_remap_weight = false;
+}
+
+
+void Remap_weight_of_operator_class::write_overall_remapping_weights(int comp_id)
+{
+	char default_wgt_file_name[NAME_STR_SIZE], full_default_wgt_file_name[NAME_STR_SIZE*2];
+	Remap_operator_basis *overall_remap_operator;
+	Comp_comm_group_mgt_node *comp_node = comp_comm_group_mgt_mgr->search_global_node(comp_id);
 
-	if (runtime_remap_operator_grid_src != NULL) {
-		delete runtime_remap_operator_grid_src;
-		delete runtime_remap_operator_grid_dst;
-	}
 	
-	empty_remap_weight = false;
+	EXECUTION_REPORT_ERROR_OPTIONALLY(REPORT_ERROR, -1, remap_weights_of_operator_instances.size() == 1, "Software error in Remap_weight_of_operator_class::write_overall_remapping_weights");
+	sprintf(default_wgt_file_name, "DEFAULT_WGT_of___%s___FROM___%s___TO___%s___AT___%s.nc", remap_weights_of_operator_instances[0]->get_original_remap_operator()->get_operator_name(), remap_weights_of_operator_instances[0]->get_operator_grid_src()->get_grid_name(), remap_weights_of_operator_instances[0]->get_operator_grid_dst()->get_grid_name(), comp_node->get_full_name());
+	sprintf(full_default_wgt_file_name, "%s/%s", comp_comm_group_mgt_mgr->get_internal_remapping_weights_dir(), default_wgt_file_name);
+	EXECUTION_REPORT_LOG(REPORT_LOG, comp_id, true, "The default H2D weight file name is \"%s\"", default_wgt_file_name);
+	overall_remap_operator = remap_weights_of_operator_instances[0]->duplicated_remap_operator->gather(comp_id);
+	if (comp_node->get_current_proc_local_id() == 0) {
+		Remap_weight_of_operator_instance_class *overall_remap_weight_of_operator_instance = new Remap_weight_of_operator_instance_class(operator_grid_src, operator_grid_dst, 0, remap_weights_of_operator_instances[0]->get_original_remap_operator(), overall_remap_operator);
+		Remap_weight_of_operator_class *overall_remap_weight_of_operator = new Remap_weight_of_operator_class(operator_grid_src, operator_grid_dst, original_remap_operator, operator_grid_src, operator_grid_dst);
+		overall_remap_weight_of_operator->remap_weights_of_operator_instances.push_back(overall_remap_weight_of_operator_instance);
+		Remap_weight_of_strategy_class *overall_remap_weights = new Remap_weight_of_strategy_class("overall_remapping_weights", NULL, operator_grid_src, operator_grid_dst, NULL, false, comp_id);
+		overall_remap_weights->add_remap_weights_of_operator(overall_remap_weight_of_operator);
+		IO_netcdf *io_netcdf = new IO_netcdf(default_wgt_file_name, full_default_wgt_file_name, "w", true);
+		int last_execution_phase_number = execution_phase_number;
+		execution_phase_number = 1;
+		io_netcdf->write_remap_weights(overall_remap_weights);
+		execution_phase_number = last_execution_phase_number;
+		delete io_netcdf;
+		delete overall_remap_weights;
+	}
 }
 
 
 void Remap_weight_of_strategy_class::initialize_object()
 {
-	dynamic_vertical_remapping_weights_src = false;
-	dynamic_vertical_remapping_weights_dst = false;
-	public_remap_weights_of_operators = false;
-	num_field_data_grids_in_remapping_process = 0;
+    dynamic_vertical_remapping_weights_src = false;
+    dynamic_vertical_remapping_weights_dst = false;
+    public_remap_weights_of_operators = false;
+    num_field_data_grids_in_remapping_process = 0;
 }
 
 
@@ -341,59 +404,63 @@ Remap_weight_of_strategy_class::Remap_weight_of_strategy_class(const char *objec
                                                                const char *input_IO_file_name, const char *weight_IO_format,
                                                                bool read_from_io)
 {
-	initialize_object();
+    initialize_object();
     strcpy(this->object_name, object_name);
     remap_strategy = remap_strategy_manager->search_remap_strategy(remap_strategy_name);
     data_grid_src = remap_grid_manager->search_remap_grid_with_grid_name(data_grid_name_src);
     data_grid_dst = remap_grid_manager->search_remap_grid_with_grid_name(data_grid_name_dst);
 
-	EXECUTION_REPORT(REPORT_ERROR, -1, remap_strategy != NULL && data_grid_src != NULL && data_grid_dst != NULL, "C-Coupler error in Remap_weight_of_strategy_class::Remap_weight_of_strategy_class");
+    EXECUTION_REPORT(REPORT_ERROR, -1, remap_strategy != NULL && data_grid_src != NULL && data_grid_dst != NULL, "C-Coupler error in Remap_weight_of_strategy_class::Remap_weight_of_strategy_class");
 
-	generate_remapping_related_grids();
+    generate_remapping_related_grids();
 
-	if (!read_from_io)
-		remap_strategy->calculate_remapping_weights(this, NULL);
-	else {
-		if (words_are_the_same(weight_IO_format, "SCRIP")) 
-			((IO_netcdf*) (io_manager->search_IO_object(input_IO_file_name)))->read_remap_weights(this, remap_strategy, is_master_process_in_computing_node);
-		else ((IO_binary*) (io_manager->search_IO_object(input_IO_file_name)))->read_remap_weights(this, remap_strategy, is_master_process_in_computing_node);
-	}
+    if (!read_from_io)
+        remap_strategy->calculate_remapping_weights(this, NULL, -1);
+    else {
+        if (words_are_the_same(weight_IO_format, "SCRIP")) 
+            ((IO_netcdf*) (io_manager->search_IO_object(input_IO_file_name)))->read_remap_weights(this, remap_strategy, is_master_process_in_computing_node);
+        else ((IO_binary*) (io_manager->search_IO_object(input_IO_file_name)))->read_remap_weights(this, remap_strategy, is_master_process_in_computing_node);
+    }
 
     EXECUTION_REPORT(REPORT_ERROR, -1, data_grid_src->get_num_dimensions() == data_grid_dst->get_num_dimensions(), 
-    	             "grid %s and %s must have the same number of dimensions\n", data_grid_name_src, data_grid_name_dst);
+                     "grid %s and %s must have the same number of dimensions\n", data_grid_name_src, data_grid_name_dst);
 }
 
 
 Remap_weight_of_strategy_class::Remap_weight_of_strategy_class(const char *object_name, Remap_strategy_class *remap_strategy, 
-                                                               Remap_grid_class *data_grid_src, Remap_grid_class *data_grid_dst, const char *H2D_remapping_wgt_file)
+                                                               Remap_grid_class *data_grid_src, Remap_grid_class *data_grid_dst, const char *H2D_remapping_wgt_file, bool calculate_wgts, int wgt_cal_comp_id)
 {
-	initialize_object();
+    initialize_object();
     strcpy(this->object_name, object_name);
     this->remap_strategy = remap_strategy;
     this->data_grid_src = data_grid_src;
     this->data_grid_dst = data_grid_dst;
 
-	EXECUTION_REPORT(REPORT_ERROR, -1, remap_strategy != NULL && data_grid_src != NULL && data_grid_dst != NULL, "C-Coupler error in Remap_weight_of_strategy_class::Remap_weight_of_strategy_class");
+    EXECUTION_REPORT(REPORT_ERROR, -1, (!calculate_wgts || remap_strategy != NULL) && data_grid_src != NULL && data_grid_dst != NULL, "C-Coupler error in Remap_weight_of_strategy_class::Remap_weight_of_strategy_class");
 
-	generate_remapping_related_grids();
-	remap_strategy->calculate_remapping_weights(this, H2D_remapping_wgt_file);
+	if (calculate_wgts) {
+		EXECUTION_REPORT_LOG(REPORT_LOG, -1, true, "before generate_remapping_related_grids");
+	    generate_remapping_related_grids();
+		EXECUTION_REPORT_LOG(REPORT_LOG, -1, true, "After generate_remapping_related_grids, before generate_remapping_related_grids");
+	    remap_strategy->calculate_remapping_weights(this, H2D_remapping_wgt_file, wgt_cal_comp_id);
+	}
 }
 
 
 int Remap_weight_of_strategy_class::generate_remapping_related_grids()
 {
-	int i, j;
+    int i, j;
     Remap_grid_class *current_remap_src_data_grid, *current_remap_src_data_grid_interchanged, *current_remap_dst_data_grid, *existing_grid;
     Remap_grid_class *runtime_mask_sub_grids_src[256], *runtime_mask_sub_grids_dst[256];
     int num_runtime_mask_sub_grids_src, num_runtime_mask_sub_grids_dst;
     Remap_grid_data_class *runtime_mask_src, *runtime_mask_dst;
-	Remap_grid_class *leaf_grids[256];
-	int num_leaf_grids;
+    Remap_grid_class *leaf_grids[256];
+    int num_leaf_grids;
 
-	
-	num_field_data_grids_in_remapping_process = 0;
-	field_data_grids_in_remapping_process[num_field_data_grids_in_remapping_process] = data_grid_src;
-	runtime_mask_fields_in_remapping_process[num_field_data_grids_in_remapping_process++] = NULL;
+    
+    num_field_data_grids_in_remapping_process = 0;
+    field_data_grids_in_remapping_process[num_field_data_grids_in_remapping_process] = data_grid_src;
+    runtime_mask_fields_in_remapping_process[num_field_data_grids_in_remapping_process++] = NULL;
     current_remap_src_data_grid = data_grid_src;
     for (i = 0; i < remap_strategy->get_num_remap_operator(); i ++) {
         if (i == 0)
@@ -413,18 +480,18 @@ int Remap_weight_of_strategy_class::generate_remapping_related_grids()
                                                            remap_strategy->get_remap_operator(i)->get_src_grid(), 
                                                            remap_strategy->get_remap_operator(i)->get_dst_grid(),
                                                            remap_strategy->get_remap_operator(i)->get_is_operator_regridding()); 
-		existing_grid = remap_grid_manager->search_same_remap_grid(current_remap_dst_data_grid);
-		if (existing_grid != NULL) {
-			delete current_remap_dst_data_grid;
-			current_remap_dst_data_grid = existing_grid;
-		}
+        existing_grid = remap_grid_manager->search_same_remap_grid(current_remap_dst_data_grid);
+        if (existing_grid != NULL) {
+            delete current_remap_dst_data_grid;
+            current_remap_dst_data_grid = existing_grid;
+        }
 
         if (i == remap_strategy->get_num_remap_operator()-1 && !current_remap_dst_data_grid->is_similar_grid_with(data_grid_dst)) {
             data_grid_dst->get_leaf_grids(&num_leaf_grids, leaf_grids, data_grid_dst);
             for (j = 0; j < num_leaf_grids; j ++) 
                 EXECUTION_REPORT(REPORT_ERROR, -1, leaf_grids[j]->is_subset_of_grid(current_remap_dst_data_grid), 
-   	    	                     "this remap caculation can not get 1D grid %s, which is a sub grid of the grid of destination field data. Please check the %dth remapping operator of the remapping strategy", 
-       	    	                 leaf_grids[j]->get_grid_name(), i+1);
+                                    "this remap caculation can not get 1D grid %s, which is a sub grid of the grid of destination field data. Please check the %dth remapping operator of the remapping strategy", 
+                                    leaf_grids[j]->get_grid_name(), i+1);
         }
         if (i == remap_strategy->get_num_remap_operator()-1)
             current_remap_dst_data_grid->compute_remap_field_data_runtime_mask(data_grid_dst,
@@ -434,17 +501,17 @@ int Remap_weight_of_strategy_class::generate_remapping_related_grids()
         else current_remap_dst_data_grid->compute_remap_field_data_runtime_mask(NULL,runtime_mask_sub_grids_dst,
                                                                                 &num_runtime_mask_sub_grids_dst,
                                                                                 &runtime_mask_dst);
-		field_data_grids_in_remapping_process[num_field_data_grids_in_remapping_process] = current_remap_src_data_grid_interchanged;
-		runtime_mask_fields_in_remapping_process[num_field_data_grids_in_remapping_process++] = runtime_mask_src;
-		field_data_grids_in_remapping_process[num_field_data_grids_in_remapping_process] = current_remap_dst_data_grid;
-		runtime_mask_fields_in_remapping_process[num_field_data_grids_in_remapping_process++] = runtime_mask_dst;		
+        field_data_grids_in_remapping_process[num_field_data_grids_in_remapping_process] = current_remap_src_data_grid_interchanged;
+        runtime_mask_fields_in_remapping_process[num_field_data_grids_in_remapping_process++] = runtime_mask_src;
+        field_data_grids_in_remapping_process[num_field_data_grids_in_remapping_process] = current_remap_dst_data_grid;
+        runtime_mask_fields_in_remapping_process[num_field_data_grids_in_remapping_process++] = runtime_mask_dst;        
         current_remap_src_data_grid = current_remap_dst_data_grid;
     }
 
-	field_data_grids_in_remapping_process[num_field_data_grids_in_remapping_process] = data_grid_dst;
-	runtime_mask_fields_in_remapping_process[num_field_data_grids_in_remapping_process++] = NULL;
+    field_data_grids_in_remapping_process[num_field_data_grids_in_remapping_process] = data_grid_dst;
+    runtime_mask_fields_in_remapping_process[num_field_data_grids_in_remapping_process++] = NULL;
 
-	return num_field_data_grids_in_remapping_process;
+    return num_field_data_grids_in_remapping_process;
 }
 
 
@@ -465,33 +532,34 @@ bool Remap_weight_of_strategy_class::match_object_name(const char*object_name)
 
 Remap_weight_of_strategy_class::~Remap_weight_of_strategy_class()
 {
-	if (!public_remap_weights_of_operators)
-	    for (int i = 0; i < remap_weights_of_operators.size(); i ++)
-    	    delete remap_weights_of_operators[i];
+    if (!public_remap_weights_of_operators)
+        for (int i = 0; i < remap_weights_of_operators.size(); i ++)
+            delete remap_weights_of_operators[i];
 }
 
 
 Remap_weight_of_operator_instance_class *Remap_weight_of_strategy_class::add_remap_weight_of_operator_instance(Remap_grid_class *field_data_grid_src, Remap_grid_class *field_data_grid_dst,
                                                                   long remap_beg_iter, Remap_operator_basis *remap_operator)
 {
-	Remap_weight_of_operator_instance_class *remap_weight_of_operator_instance = new Remap_weight_of_operator_instance_class(field_data_grid_src, field_data_grid_dst, remap_beg_iter, remap_operator);
-    add_remap_weight_of_operator_instance(remap_weight_of_operator_instance);
-	return remap_weight_of_operator_instance;
+    Remap_weight_of_operator_instance_class *remap_weight_of_operator_instance = new Remap_weight_of_operator_instance_class(field_data_grid_src, field_data_grid_dst, remap_beg_iter, remap_operator);
+    add_remap_weight_of_operator_instance(remap_weight_of_operator_instance, field_data_grid_src, field_data_grid_dst, remap_operator, remap_operator->get_src_grid(), remap_operator->get_dst_grid());
+    return remap_weight_of_operator_instance;
 }
 
 
-void Remap_weight_of_strategy_class::add_remap_weight_of_operator_instance(Remap_weight_of_operator_instance_class *weight_of_operator_instance) 
+void Remap_weight_of_strategy_class::add_remap_weight_of_operator_instance(Remap_weight_of_operator_instance_class *weight_of_operator_instance, Remap_grid_class *field_data_grid_src, Remap_grid_class *field_data_grid_dst, Remap_operator_basis *original_remap_operator,
+                                                                           Remap_grid_class *operator_grid_src, Remap_grid_class *operator_grid_dst) 
 { 
-	if (remap_weights_of_operators.size() == 0 || remap_weights_of_operators[remap_weights_of_operators.size()-1]->field_data_grid_src != weight_of_operator_instance->field_data_grid_src) {
-		Remap_weight_of_operator_class *remap_weight_of_operator = new Remap_weight_of_operator_class(weight_of_operator_instance->field_data_grid_src, weight_of_operator_instance->field_data_grid_dst, weight_of_operator_instance->original_remap_operator,
-																									  weight_of_operator_instance->operator_grid_src, weight_of_operator_instance->operator_grid_dst);
-		remap_weights_of_operators.push_back(remap_weight_of_operator);
-	}
-	remap_weights_of_operators[remap_weights_of_operators.size()-1]->add_remap_weight_of_operator_instance(weight_of_operator_instance);
+    if (remap_weights_of_operators.size() == 0 || remap_weights_of_operators[remap_weights_of_operators.size()-1]->field_data_grid_src != field_data_grid_src) {
+        Remap_weight_of_operator_class *remap_weight_of_operator = new Remap_weight_of_operator_class(field_data_grid_src, field_data_grid_dst, original_remap_operator,
+                                                                                                      operator_grid_src, operator_grid_dst);
+        remap_weights_of_operators.push_back(remap_weight_of_operator);
+    }
+    remap_weights_of_operators[remap_weights_of_operators.size()-1]->add_remap_weight_of_operator_instance(weight_of_operator_instance);
 }
 
 
-void Remap_weight_of_strategy_class::do_remap(Remap_grid_data_class *field_data_src, Remap_grid_data_class *field_data_dst)
+void Remap_weight_of_strategy_class::do_remap(int comp_id, Remap_grid_data_class *field_data_src, Remap_grid_data_class *field_data_dst)
 {
     Remap_grid_class *sized_sub_grids[256];
     Remap_grid_class *field_data_grid_src, *field_data_grid_dst;
@@ -502,113 +570,122 @@ void Remap_weight_of_strategy_class::do_remap(Remap_grid_data_class *field_data_
     int i, j, k;
     long remap_beg_iter, remap_end_iter;
     long field_array_offset;
-	Remap_grid_class *original_lev_grid_src = NULL, *original_lev_grid_dst = NULL;
+    Remap_grid_class *original_lev_grid_src = NULL, *original_lev_grid_dst = NULL;
 
     
     EXECUTION_REPORT_ERROR_OPTIONALLY(REPORT_ERROR, -1, field_data_src->get_coord_value_grid()->is_similar_grid_with(data_grid_src),
                  "the grid of field data \"%s\" can not match the src grid of remap weight object \"%s\"",
                  field_data_src->get_grid_data_field()->field_name_in_application, object_name);
-    EXECUTION_REPORT_ERROR_OPTIONALLY(REPORT_ERROR, -1, field_data_dst->get_coord_value_grid()->is_similar_grid_with(data_grid_dst),
-                 "the grid of field data \"%s\" can not match the dst grid of remap weight object \"%s\"",
-                 field_data_dst->get_grid_data_field()->field_name_in_application, object_name);
+	if (!words_are_the_same(field_data_dst->get_grid_data_field()->field_name_in_application, V3D_GRID_3D_LEVEL_FIELD_NAME))
+    	EXECUTION_REPORT_ERROR_OPTIONALLY(REPORT_ERROR, -1, field_data_dst->get_coord_value_grid()->is_similar_grid_with(data_grid_dst),
+        	         "the grid of field data \"%s\" can not match the dst grid of remap weight object \"%s\"",
+            	     field_data_dst->get_grid_data_field()->field_name_in_application, object_name);
 
     field_data_src->transfer_field_attributes_to_another(field_data_dst);
     if (!field_data_dst->have_data_content())
         field_data_dst->get_grid_data_field()->initialize_to_fill_value();
 
-	tmp_field_data_dst = field_data_src;
-	tmp_field_data_src = NULL;
-	for (i = 0; i < remap_weights_of_operators.size(); i ++) {
-		if (tmp_field_data_src != NULL && tmp_field_data_src != field_data_src)
-			delete tmp_field_data_src;
-		tmp_field_data_src = tmp_field_data_dst;
-		if (i == remap_weights_of_operators.size()-1) {
-			tmp_field_data_dst = field_data_dst;
-			EXECUTION_REPORT_ERROR_OPTIONALLY(REPORT_ERROR, -1, remap_weights_of_operators[i]->field_data_grid_dst->is_similar_grid_with(tmp_field_data_dst->get_coord_value_grid()), 
-						 "remap software error1 in do_remap of Remap_weight_of_strategy_class\n");
-		}	
-		else tmp_field_data_dst = field_data_src->duplicate_grid_data_field(remap_weights_of_operators[i]->field_data_grid_dst, 1, false, false);
-		remap_weights_of_operators[i]->do_remap(tmp_field_data_src, tmp_field_data_dst);
-	}
+    tmp_field_data_dst = field_data_src;
+    tmp_field_data_src = NULL;
+    for (i = 0; i < remap_weights_of_operators.size(); i ++) {
+        if (comp_id != -1)        
+            comp_comm_group_mgt_mgr->get_global_node_of_local_comp(comp_id,false,"")->get_performance_timing_mgr()->performance_timing_start(TIMING_TYPE_COMPUTATION, -1, -1, remap_weights_of_operators[i]->get_original_remap_operator()->get_operator_name());
+        if (tmp_field_data_src != NULL && tmp_field_data_src != field_data_src)
+            delete tmp_field_data_src;
+        tmp_field_data_src = tmp_field_data_dst;
+        if (i == remap_weights_of_operators.size()-1 || remap_weights_of_operators[i]->field_data_grid_dst->is_similar_grid_with(field_data_dst->get_coord_value_grid())) {
+            tmp_field_data_dst = field_data_dst;
+            EXECUTION_REPORT_ERROR_OPTIONALLY(REPORT_ERROR, -1, remap_weights_of_operators[i]->field_data_grid_dst->is_similar_grid_with(tmp_field_data_dst->get_coord_value_grid()), 
+                         "remap software error1 in do_remap of Remap_weight_of_strategy_class\n");
+			if (i != remap_weights_of_operators.size()-1 && remap_weights_of_operators[i]->field_data_grid_dst->is_similar_grid_with(field_data_dst->get_coord_value_grid()))
+				EXECUTION_REPORT_ERROR_OPTIONALLY(REPORT_ERROR, -1, words_are_the_same(field_data_dst->get_grid_data_field()->field_name_in_application, V3D_GRID_3D_LEVEL_FIELD_NAME), "Software error in Remap_weight_of_strategy_class::do_remap");
+        }    
+        else tmp_field_data_dst = field_data_src->duplicate_grid_data_field(remap_weights_of_operators[i]->field_data_grid_dst, 1, false, false);
+        remap_weights_of_operators[i]->do_remap(comp_id, tmp_field_data_src, tmp_field_data_dst);
+        if (comp_id != -1)        
+            comp_comm_group_mgt_mgr->get_global_node_of_local_comp(comp_id,false,"")->get_performance_timing_mgr()->performance_timing_stop(TIMING_TYPE_COMPUTATION, -1, -1, remap_weights_of_operators[i]->get_original_remap_operator()->get_operator_name());
+		if (i != remap_weights_of_operators.size()-1 && tmp_field_data_dst == field_data_dst) {
+			EXECUTION_REPORT_ERROR_OPTIONALLY(REPORT_ERROR, -1, words_are_the_same(field_data_dst->get_grid_data_field()->field_name_in_application, V3D_GRID_3D_LEVEL_FIELD_NAME), "Software error in Remap_weight_of_strategy_class::do_remap");
+			break;
+		}
+    }
 
-	if (tmp_field_data_src != NULL && tmp_field_data_src != field_data_src)
-		delete tmp_field_data_src;
-	field_data_src->interchange_grid_data(field_data_src->get_coord_value_grid());
+    if (tmp_field_data_src != NULL && tmp_field_data_src != field_data_src)
+        delete tmp_field_data_src;
+    if (comp_id != -1)          
+        comp_comm_group_mgt_mgr->get_global_node_of_local_comp(comp_id,false,"")->get_performance_timing_mgr()->performance_timing_start(TIMING_TYPE_COMPUTATION, -1, -1, "interchange data");
+    field_data_src->interchange_grid_data(field_data_src->get_coord_value_grid());
     field_data_dst->interchange_grid_data(field_data_dst->get_coord_value_grid());
-	field_data_dst->get_grid_data_field()->read_data_size = field_data_dst->get_grid_data_field()->required_data_size;
+    field_data_dst->get_grid_data_field()->read_data_size = field_data_dst->get_grid_data_field()->required_data_size;
+    if (comp_id != -1)          
+        comp_comm_group_mgt_mgr->get_global_node_of_local_comp(comp_id,false,"")->get_performance_timing_mgr()->performance_timing_stop(TIMING_TYPE_COMPUTATION, -1, -1, "interchange data");
 }
 
 
 void Remap_weight_of_strategy_class::calculate_src_decomp(Remap_grid_class *grid_src, Remap_grid_class *grid_dst, long *decomp_map_src, const long *decomp_map_dst)
 {
     long i, j;
-	Remap_weight_of_operator_class *H2D_operator_weights = NULL;
+    Remap_weight_of_operator_class *H2D_operator_weights = NULL;
 
 
     for (i = 0; i < grid_src->get_grid_size(); i ++)
         decomp_map_src[i] = 0;
-	
- 	for (i = 0; i < remap_weights_of_operators.size(); i ++) {
-		if (remap_weights_of_operators[i]->get_original_remap_operator()->get_src_grid()->has_grid_coord_label(COORD_LABEL_LON) || remap_weights_of_operators[i]->get_original_remap_operator()->get_src_grid()->has_grid_coord_label(COORD_LABEL_LON)) {
-			EXECUTION_REPORT_ERROR_OPTIONALLY(REPORT_ERROR, -1, remap_weights_of_operators[i]->get_original_remap_operator()->get_src_grid()->get_is_sphere_grid(), "Software error in Remap_weight_of_strategy_class::calculate_src_decomp: 1-D remapping operator for lon or lat");
-		}	
-		if (remap_weights_of_operators[i]->get_original_remap_operator()->get_src_grid()->get_is_sphere_grid()) {
-			EXECUTION_REPORT_ERROR_OPTIONALLY(REPORT_ERROR, -1, H2D_operator_weights == NULL, "Software error in Remap_weight_of_strategy_class::calculate_src_decomp: multiple H2D remapping operator");
-			H2D_operator_weights = remap_weights_of_operators[i];
-		}
- 	}
-	if (H2D_operator_weights == NULL) {
-		EXECUTION_REPORT_ERROR_OPTIONALLY(REPORT_ERROR, -1, grid_src == grid_dst, "Software error in Remap_weight_of_strategy_class::calculate_src_decomp: src and dst grids are different when there are no H2D operator");
-		for (i = 0; i < grid_src->get_grid_size(); i ++)
-			decomp_map_src[i] = decomp_map_dst[i];
-		return;
-	}	
+    
+     for (i = 0; i < remap_weights_of_operators.size(); i ++) {
+        if (remap_weights_of_operators[i]->get_original_remap_operator()->get_src_grid()->has_grid_coord_label(COORD_LABEL_LON) || remap_weights_of_operators[i]->get_original_remap_operator()->get_src_grid()->has_grid_coord_label(COORD_LABEL_LON)) {
+            EXECUTION_REPORT_ERROR_OPTIONALLY(REPORT_ERROR, -1, remap_weights_of_operators[i]->get_original_remap_operator()->get_src_grid()->get_is_sphere_grid(), "Software error in Remap_weight_of_strategy_class::calculate_src_decomp: 1-D remapping operator for lon or lat");
+        }    
+        if (remap_weights_of_operators[i]->get_original_remap_operator()->get_src_grid()->get_is_sphere_grid()) {
+            EXECUTION_REPORT_ERROR_OPTIONALLY(REPORT_ERROR, -1, H2D_operator_weights == NULL, "Software error in Remap_weight_of_strategy_class::calculate_src_decomp: multiple H2D remapping operator");
+            H2D_operator_weights = remap_weights_of_operators[i];
+        }
+     }
+    if (H2D_operator_weights == NULL) {
+        EXECUTION_REPORT_ERROR_OPTIONALLY(REPORT_ERROR, -1, grid_src == grid_dst, "Software error in Remap_weight_of_strategy_class::calculate_src_decomp: src and dst grids are different when there are no H2D operator");
+        for (i = 0; i < grid_src->get_grid_size(); i ++)
+            decomp_map_src[i] = decomp_map_dst[i];
+        return;
+    }    
 
-	EXECUTION_REPORT_ERROR_OPTIONALLY(REPORT_ERROR, -1, grid_src == H2D_operator_weights->get_original_remap_operator()->get_src_grid() && grid_dst == H2D_operator_weights->get_original_remap_operator()->get_dst_grid(), "Software error in Remap_weight_of_strategy_class::calculate_src_decomp: H2D operator grids do not match decomp grids");
+    EXECUTION_REPORT_ERROR_OPTIONALLY(REPORT_ERROR, -1, grid_src == H2D_operator_weights->get_original_remap_operator()->get_src_grid() && grid_dst == H2D_operator_weights->get_original_remap_operator()->get_dst_grid(), "Software error in Remap_weight_of_strategy_class::calculate_src_decomp: H2D operator grids do not match decomp grids");
 
-	H2D_operator_weights->calculate_src_decomp(decomp_map_src, decomp_map_dst);
+    H2D_operator_weights->calculate_src_decomp(decomp_map_src, decomp_map_dst);
 }
 
 
-Remap_grid_class **Remap_weight_of_strategy_class::get_remap_related_grids(int &num_operator_field_data_grids)
+void Remap_weight_of_strategy_class::add_remap_related_grid(std::vector<std::pair<Remap_grid_class *, bool> > &all_remap_related_grids_info, Remap_grid_class *remap_grid, bool on_dst_decomp)
 {
-    Remap_operator_basis *current_remap_operator;
-    Remap_grid_class **all_remap_related_grids, **temp_grids;
-    int array_size = 100;
-	int i, j, k;
+	std::pair<Remap_grid_class *, bool> remap_related_grid_info;
 	
+	remap_related_grid_info.first = remap_grid;
+	remap_related_grid_info.second = on_dst_decomp;
+	all_remap_related_grids_info.push_back(remap_related_grid_info);
+}
 
-    num_operator_field_data_grids = 0;
-    current_remap_operator = NULL;
-    all_remap_related_grids = new Remap_grid_class *[array_size];
-
-    all_remap_related_grids[num_operator_field_data_grids++] = data_grid_src;
-    all_remap_related_grids[num_operator_field_data_grids++] = data_grid_dst;
-    for (i = 0; i < remap_weights_of_operators.size(); i ++) 
-		for (j = 0; j < remap_weights_of_operators[i]->remap_weights_of_operator_instances.size(); j ++) {
-	        if (num_operator_field_data_grids + 4 > array_size) {
-	            temp_grids = all_remap_related_grids;
-	            all_remap_related_grids = new Remap_grid_class *[array_size*2];
-	            for (k = 0; k < array_size; k ++)
-	                all_remap_related_grids[k] = temp_grids[k];
-	            delete [] temp_grids;
-	            array_size *= 2;
-	        }
-	        all_remap_related_grids[num_operator_field_data_grids++] = remap_weights_of_operators[i]->remap_weights_of_operator_instances[j]->field_data_grid_src;
-	        all_remap_related_grids[num_operator_field_data_grids++] = remap_weights_of_operators[i]->remap_weights_of_operator_instances[j]->field_data_grid_dst;
-	        all_remap_related_grids[num_operator_field_data_grids++] = remap_weights_of_operators[i]->remap_weights_of_operator_instances[j]->operator_grid_src;
-	        all_remap_related_grids[num_operator_field_data_grids++] = remap_weights_of_operators[i]->remap_weights_of_operator_instances[j]->operator_grid_dst;
-	    }
-
-    return all_remap_related_grids;
+
+void Remap_weight_of_strategy_class::get_remap_related_grids(std::vector<std::pair<Remap_grid_class *, bool> > &all_remap_related_grids_info)
+{   
+	
+	bool after_H2D_remapping = false;
+
+	add_remap_related_grid(all_remap_related_grids_info, data_grid_src, false);
+	add_remap_related_grid(all_remap_related_grids_info, data_grid_dst, true);
+    for (int i = 0; i < remap_weights_of_operators.size(); i ++) {
+		add_remap_related_grid(all_remap_related_grids_info, remap_weights_of_operators[i]->get_field_data_grid_src(), after_H2D_remapping);
+		add_remap_related_grid(all_remap_related_grids_info, remap_weights_of_operators[i]->get_field_data_grid_dst(), remap_weights_of_operators[i]->get_operator_grid_src()->get_is_sphere_grid() || after_H2D_remapping);
+		add_remap_related_grid(all_remap_related_grids_info, remap_weights_of_operators[i]->get_operator_grid_src(), after_H2D_remapping);
+		if (remap_weights_of_operators[i]->get_operator_grid_src()->get_is_sphere_grid())
+			after_H2D_remapping = true;
+		add_remap_related_grid(all_remap_related_grids_info, remap_weights_of_operators[i]->get_operator_grid_dst(), after_H2D_remapping);	
+    }
 }
 
 
-Remap_weight_of_strategy_class *Remap_weight_of_strategy_class::generate_parallel_remap_weights(Remap_grid_class **remap_related_decomp_grids, 
+Remap_weight_of_strategy_class *Remap_weight_of_strategy_class::generate_parallel_remap_weights(Remap_grid_class **remap_related_decomp_grids,
                                                                                                  Remap_grid_class **decomp_original_grids, 
                                                                                                  int **global_cells_local_indexes_in_decomps)
 {
-    int i, j, k, field_data_grids_iter;
+    int i, j, k, field_data_grids_iter = 0;
     Remap_operator_basis *current_remap_operator;
     Remap_weight_of_strategy_class *parallel_remap_weights_of_strategy = new Remap_weight_of_strategy_class;
     Remap_weight_of_operator_instance_class *parallel_remap_weights_of_operator_instance;
@@ -621,18 +698,17 @@ Remap_weight_of_strategy_class *Remap_weight_of_strategy_class::generate_paralle
     EXECUTION_REPORT(REPORT_ERROR, -1, this->data_grid_src->get_num_dimensions() >= 2 && this->data_grid_src->get_num_dimensions() <= 3,
                  "C-Coupler error2 in generate_parallel_remap_weights of Remap_weight_of_strategy_class\n");
 
-    field_data_grids_iter = 0;
     strcpy(parallel_remap_weights_of_strategy->object_name, this->object_name);
     parallel_remap_weights_of_strategy->remap_strategy = this->remap_strategy;
     parallel_remap_weights_of_strategy->data_grid_src = remap_related_decomp_grids[field_data_grids_iter++];
     parallel_remap_weights_of_strategy->data_grid_dst = remap_related_decomp_grids[field_data_grids_iter++];
 
-	for (i = 0; i < remap_weights_of_operators.size(); i ++)
-		remap_weights_of_operators[i]->generate_parallel_remap_weights(remap_related_decomp_grids, decomp_original_grids, global_cells_local_indexes_in_decomps, field_data_grids_iter, parallel_remap_weights_of_strategy);
+    for (i = 0; i < remap_weights_of_operators.size(); i ++)
+        remap_weights_of_operators[i]->generate_parallel_remap_weights(remap_related_decomp_grids, decomp_original_grids, global_cells_local_indexes_in_decomps, field_data_grids_iter, parallel_remap_weights_of_strategy);
 
-	for (i = 0; i < remap_weights_of_operators.size(); i ++)
-		if (remap_weights_of_operators[i]->is_remap_weight_empty())
-			parallel_remap_weights_of_strategy->remap_weights_of_operators[i]->mark_empty_remap_weight();
+    for (i = 0; i < remap_weights_of_operators.size(); i ++)
+        if (remap_weights_of_operators[i]->is_remap_weight_empty())
+            parallel_remap_weights_of_strategy->remap_weights_of_operators[i]->mark_empty_remap_weight();
 
     return parallel_remap_weights_of_strategy;
 }
@@ -640,21 +716,21 @@ Remap_weight_of_strategy_class *Remap_weight_of_strategy_class::generate_paralle
 
 void Remap_weight_of_strategy_class::write_data_into_array(void *data, int data_size, char **array, long &current_array_size, long &max_array_size)
 {
-	char *new_array;
+    char *new_array;
 
-	
-	if (data_size + current_array_size > max_array_size) {
-		max_array_size = (data_size+current_array_size)*2;
-		new_array = new char [max_array_size];
-		for (long i = 0; i < current_array_size; i ++)
-			new_array[i] = (*array)[i];
-		delete [] (*array);
-		(*array) = new_array;
-	}
+    
+    if (data_size + current_array_size > max_array_size) {
+        max_array_size = (data_size+current_array_size)*2;
+        new_array = new char [max_array_size];
+        for (long i = 0; i < current_array_size; i ++)
+            new_array[i] = (*array)[i];
+        delete [] (*array);
+        (*array) = new_array;
+    }
 
-	for (long i = 0; i < data_size; i ++)
-		(*array)[current_array_size+i] = ((char*)data)[i];
-	current_array_size += data_size;
+    for (long i = 0; i < data_size; i ++)
+        (*array)[current_array_size+i] = ((char*)data)[i];
+    current_array_size += data_size;
 }
 
 
@@ -666,9 +742,9 @@ void Remap_weight_of_strategy_class::write_grid_info_into_array(Remap_grid_class
     
     
     grid_size = grid->get_grid_size();
-	write_data_into_array(&grid_size, sizeof(long), array, current_array_size, max_array_size);
+    write_data_into_array(&grid_size, sizeof(long), array, current_array_size, max_array_size);
     grid_num_dimensions = grid->get_num_dimensions();
-	write_data_into_array(&grid_num_dimensions, sizeof(int), array, current_array_size, max_array_size);
+    write_data_into_array(&grid_num_dimensions, sizeof(int), array, current_array_size, max_array_size);
     grid->get_leaf_grids(&num_leaf_grids, leaf_grids, grid);
     for (i = 0; i < num_leaf_grids; i ++) {
         if (words_are_the_same(leaf_grids[i]->get_coord_label(), COORD_LABEL_LON))
@@ -679,18 +755,18 @@ void Remap_weight_of_strategy_class::write_grid_info_into_array(Remap_grid_class
             id = 3;
         else if (words_are_the_same(leaf_grids[i]->get_coord_label(), COORD_LABEL_TIME))
             id = 4;
-		write_data_into_array(&id, sizeof(int), array, current_array_size, max_array_size);
+        write_data_into_array(&id, sizeof(int), array, current_array_size, max_array_size);
     }
 
     if (consider_area_or_volumn) {
         if (grid->get_area_or_volumn() != NULL) {
             tmp_int_value = 1;
-			write_data_into_array(&tmp_int_value, sizeof(int), array, current_array_size, max_array_size);
-			write_data_into_array(grid->get_area_or_volumn(), sizeof(double)*grid->get_grid_size(), array, current_array_size, max_array_size);
+            write_data_into_array(&tmp_int_value, sizeof(int), array, current_array_size, max_array_size);
+            write_data_into_array(grid->get_area_or_volumn(), sizeof(double)*grid->get_grid_size(), array, current_array_size, max_array_size);
         }
         else {
             tmp_int_value = 0;
-			write_data_into_array(&tmp_int_value, sizeof(int), array, current_array_size, max_array_size);
+            write_data_into_array(&tmp_int_value, sizeof(int), array, current_array_size, max_array_size);
         }
     }
 }
@@ -707,79 +783,79 @@ void Remap_weight_of_strategy_class::write_remap_weights_into_array(char **array
     Remap_weight_of_operator_instance_class *remap_weight_of_operator_instance;
     Remap_weight_sparse_matrix *remap_weights_group;
     char operator_name[256];
-	char *output_array;
-	long max_array_size;
+    char *output_array;
+    long max_array_size;
 
-	
-	array_size = 0;
-	max_array_size = 1024*1024;
-	output_array = new char [max_array_size];
+    
+    array_size = 0;
+    max_array_size = 1024*1024;
+    output_array = new char [max_array_size];
 
     remap_grid_src = get_data_grid_src();
     remap_grid_dst = get_data_grid_dst();
 
-	if (write_grid) {
-	    write_grid_info_into_array(remap_grid_src, true, &output_array, array_size, max_array_size);
-    	write_grid_info_into_array(remap_grid_dst, true, &output_array, array_size, max_array_size);
-	}
-	for (i = 0, num_remap_operator_instances = 0; i < remap_weights_of_operators.size(); i ++)
-		num_remap_operator_instances += remap_weights_of_operators[i]->remap_weights_of_operator_instances.size();
-	write_data_into_array(&num_remap_operator_instances, sizeof(int), &output_array, array_size, max_array_size);
-	for (k = 0; k < remap_weights_of_operators.size(); k ++)
-	    for (i = 0; i < remap_weights_of_operators[k]->remap_weights_of_operator_instances.size(); i ++) {
-	        remap_weight_of_operator_instance = remap_weights_of_operators[k]->remap_weights_of_operator_instances[i];
-	        tmp_long_value = remap_weight_of_operator_instance->get_remap_begin_iter();
-			write_data_into_array(&tmp_long_value, sizeof(long), &output_array, array_size, max_array_size);
-			tmp_long_value = remap_weight_of_operator_instance->get_remap_end_iter();
-			write_data_into_array(&tmp_long_value, sizeof(long), &output_array, array_size, max_array_size);
-	        remap_operator_of_one_instance = remap_weights_of_operators[k]->remap_weights_of_operator_instances[i]->duplicated_remap_operator;
-		    EXECUTION_REPORT(REPORT_ERROR, -1, remap_operator_of_one_instance != NULL, "C-Coupler software error1 in write_remap_weights_into_array");
-	        memset(operator_name, 0, 256);
-			if (write_grid) {
-				strcpy(operator_name, remap_operator_of_one_instance->get_operator_name());
-				write_data_into_array(operator_name, sizeof(char)*256, &output_array, array_size, max_array_size);
-		        write_grid_info_into_array(remap_weight_of_operator_instance->get_field_data_grid_src(), false, &output_array, array_size, max_array_size);
-		        write_grid_info_into_array(remap_weight_of_operator_instance->get_field_data_grid_dst(), false, &output_array, array_size, max_array_size);
-		        write_grid_info_into_array(remap_operator_of_one_instance->get_src_grid(), false, &output_array, array_size, max_array_size);
-		        write_grid_info_into_array(remap_operator_of_one_instance->get_dst_grid(), false, &output_array, array_size, max_array_size);
-			}
-			else {
-				strcpy(operator_name, remap_operator_of_one_instance->get_object_name());
-				write_data_into_array(operator_name, sizeof(char)*256, &output_array, array_size, max_array_size);
-			}
-	        tmp_int_value = remap_operator_of_one_instance->get_num_remap_weights_groups();
-			write_data_into_array(&tmp_int_value, sizeof(int), &output_array, array_size, max_array_size);
-	        for (j = 0; j < remap_operator_of_one_instance->get_num_remap_weights_groups(); j ++) {
-	            remap_weights_group = remap_operator_of_one_instance->get_remap_weights_group(j);
-	            tmp_long_value = remap_weights_group->get_num_weights();
-				write_data_into_array(&tmp_long_value, sizeof(long), &output_array, array_size, max_array_size);
-				write_data_into_array(remap_weights_group->get_indexes_src_grid(), sizeof(long)*tmp_long_value, &output_array, array_size, max_array_size);
-				write_data_into_array(remap_weights_group->get_indexes_dst_grid(), sizeof(long)*tmp_long_value, &output_array, array_size, max_array_size);
-				write_data_into_array(remap_weights_group->get_weight_values(), sizeof(double)*tmp_long_value, &output_array, array_size, max_array_size);
-	            tmp_long_value = remap_weights_group->get_num_remaped_dst_cells_indexes();
-				write_data_into_array(&tmp_long_value, sizeof(long), &output_array, array_size, max_array_size);
-				write_data_into_array(remap_weights_group->get_remaped_dst_cells_indexes(), sizeof(long)*tmp_long_value, &output_array, array_size, max_array_size);
-	        }
-	    }
-
-	*array = output_array;
+    if (write_grid) {
+        write_grid_info_into_array(remap_grid_src, true, &output_array, array_size, max_array_size);
+        write_grid_info_into_array(remap_grid_dst, true, &output_array, array_size, max_array_size);
+    }
+    for (i = 0, num_remap_operator_instances = 0; i < remap_weights_of_operators.size(); i ++)
+        num_remap_operator_instances += remap_weights_of_operators[i]->remap_weights_of_operator_instances.size();
+    write_data_into_array(&num_remap_operator_instances, sizeof(int), &output_array, array_size, max_array_size);
+    for (k = 0; k < remap_weights_of_operators.size(); k ++)
+        for (i = 0; i < remap_weights_of_operators[k]->remap_weights_of_operator_instances.size(); i ++) {
+            remap_weight_of_operator_instance = remap_weights_of_operators[k]->remap_weights_of_operator_instances[i];
+            tmp_long_value = remap_weight_of_operator_instance->get_remap_begin_iter();
+            write_data_into_array(&tmp_long_value, sizeof(long), &output_array, array_size, max_array_size);
+            tmp_long_value = remap_weight_of_operator_instance->get_remap_end_iter();
+            write_data_into_array(&tmp_long_value, sizeof(long), &output_array, array_size, max_array_size);
+            remap_operator_of_one_instance = remap_weights_of_operators[k]->remap_weights_of_operator_instances[i]->duplicated_remap_operator;
+            EXECUTION_REPORT(REPORT_ERROR, -1, remap_operator_of_one_instance != NULL, "C-Coupler software error1 in write_remap_weights_into_array");
+            memset(operator_name, 0, 256);
+            if (write_grid) {
+                strcpy(operator_name, remap_operator_of_one_instance->get_operator_name());
+                write_data_into_array(operator_name, sizeof(char)*256, &output_array, array_size, max_array_size);
+                write_grid_info_into_array(remap_weight_of_operator_instance->get_field_data_grid_src(), false, &output_array, array_size, max_array_size);
+                write_grid_info_into_array(remap_weight_of_operator_instance->get_field_data_grid_dst(), false, &output_array, array_size, max_array_size);
+                write_grid_info_into_array(remap_operator_of_one_instance->get_src_grid(), false, &output_array, array_size, max_array_size);
+                write_grid_info_into_array(remap_operator_of_one_instance->get_dst_grid(), false, &output_array, array_size, max_array_size);
+            }
+            else {
+                strcpy(operator_name, remap_operator_of_one_instance->get_object_name());
+                write_data_into_array(operator_name, sizeof(char)*256, &output_array, array_size, max_array_size);
+            }
+            tmp_int_value = remap_operator_of_one_instance->get_num_remap_weights_groups();
+            write_data_into_array(&tmp_int_value, sizeof(int), &output_array, array_size, max_array_size);
+            for (j = 0; j < remap_operator_of_one_instance->get_num_remap_weights_groups(); j ++) {
+                remap_weights_group = remap_operator_of_one_instance->get_remap_weights_group(j);
+                tmp_long_value = remap_weights_group->get_num_weights();
+                write_data_into_array(&tmp_long_value, sizeof(long), &output_array, array_size, max_array_size);
+                write_data_into_array(remap_weights_group->get_indexes_src_grid(), sizeof(long)*tmp_long_value, &output_array, array_size, max_array_size);
+                write_data_into_array(remap_weights_group->get_indexes_dst_grid(), sizeof(long)*tmp_long_value, &output_array, array_size, max_array_size);
+                write_data_into_array(remap_weights_group->get_weight_values(), sizeof(double)*tmp_long_value, &output_array, array_size, max_array_size);
+                tmp_long_value = remap_weights_group->get_num_remaped_dst_cells_indexes();
+                write_data_into_array(&tmp_long_value, sizeof(long), &output_array, array_size, max_array_size);
+                write_data_into_array(remap_weights_group->get_remaped_dst_cells_indexes(), sizeof(long)*tmp_long_value, &output_array, array_size, max_array_size);
+            }
+        }
+
+    *array = output_array;
 }
 
 
 void Remap_weight_of_strategy_class::read_data_from_array(void *data, int data_size, const char *input_array, FILE *fp_binary, long &current_array_pos, long array_size, bool read_weight_values)
 {
-	EXECUTION_REPORT(REPORT_ERROR, -1, current_array_pos+data_size <= array_size, "the access of array is out-of-bound when reading for remapping weights %s", object_name);
+    EXECUTION_REPORT(REPORT_ERROR, -1, current_array_pos+data_size <= array_size, "the access of array is out-of-bound when reading for remapping weights %s", object_name);
 
-	if (read_weight_values) {
-		if (input_array != NULL) {
-			for (long i = 0; i < data_size; i ++)
-				((char*)data)[i] = input_array[current_array_pos+i];
-		}
-		else fread((char*)data, 1, data_size, fp_binary);
-	}
-	else if (fp_binary != NULL)
-		fseek(fp_binary, data_size, SEEK_CUR);
-	current_array_pos += data_size;
+    if (read_weight_values) {
+        if (input_array != NULL) {
+            for (long i = 0; i < data_size; i ++)
+                ((char*)data)[i] = input_array[current_array_pos+i];
+        }
+        else fread((char*)data, 1, data_size, fp_binary);
+    }
+    else if (fp_binary != NULL)
+        fseek(fp_binary, data_size, SEEK_CUR);
+    current_array_pos += data_size;
 }
 
 
@@ -791,9 +867,9 @@ void Remap_weight_of_strategy_class::read_grid_info_from_array(Remap_grid_class
     double *area_or_volumn;
     
 
-	read_data_from_array(&grid_size, sizeof(long), input_array, fp_binary, current_array_pos, array_size, true);
+    read_data_from_array(&grid_size, sizeof(long), input_array, fp_binary, current_array_pos, array_size, true);
     EXECUTION_REPORT(REPORT_ERROR, -1, grid_size == grid->get_grid_size(), "the grid size of %s does not match the binary file\n", grid->get_grid_name());
-	read_data_from_array(&grid_num_dimensions, sizeof(int), input_array, fp_binary, current_array_pos, array_size, true);
+    read_data_from_array(&grid_num_dimensions, sizeof(int), input_array, fp_binary, current_array_pos, array_size, true);
     EXECUTION_REPORT(REPORT_ERROR, -1, grid_num_dimensions == grid->get_num_dimensions(), "the number of dimensions of grid %s does not match the binary file\n", grid->get_grid_name());
     grid->get_leaf_grids(&num_leaf_grids, leaf_grids, grid);
     for (i = 0; i < num_leaf_grids; i ++) {
@@ -805,16 +881,16 @@ void Remap_weight_of_strategy_class::read_grid_info_from_array(Remap_grid_class
             gid = 3;
         else if (words_are_the_same(leaf_grids[i]->get_coord_label(), COORD_LABEL_TIME))
             gid = 4;
-		read_data_from_array(&rid, sizeof(int), input_array, fp_binary, current_array_pos, array_size, true);
+        read_data_from_array(&rid, sizeof(int), input_array, fp_binary, current_array_pos, array_size, true);
         EXECUTION_REPORT(REPORT_ERROR, -1, gid == rid, "the arrange of coordinate systems of grid %s does not match the binary file\n", grid->get_grid_name());
     }
 
     if (consider_area_or_volumn) {
-		read_data_from_array(&tmp_int_value, sizeof(int), input_array, fp_binary, current_array_pos, array_size, true);
+        read_data_from_array(&tmp_int_value, sizeof(int), input_array, fp_binary, current_array_pos, array_size, true);
         if (tmp_int_value == 1) {
             EXECUTION_REPORT(REPORT_ERROR, -1, grid->get_area_or_volumn() != NULL, "the area or volumn of grid %s does not match the binary file\n", grid->get_grid_name());
             area_or_volumn = new double [grid->get_grid_size()];
-			read_data_from_array(area_or_volumn, sizeof(double)*grid->get_grid_size(), input_array, fp_binary, current_array_pos, array_size, true);
+            read_data_from_array(area_or_volumn, sizeof(double)*grid->get_grid_size(), input_array, fp_binary, current_array_pos, array_size, true);
             for (long i = 0; i < grid->get_grid_size(); i ++)
                 EXECUTION_REPORT(REPORT_ERROR, -1, grid->get_area_or_volumn()[i] == area_or_volumn[i], "the area or volumn of grid %s does not match the binary file\n", grid->get_grid_name());
             delete [] area_or_volumn;            
@@ -825,7 +901,7 @@ void Remap_weight_of_strategy_class::read_grid_info_from_array(Remap_grid_class
 
 
 void Remap_weight_of_strategy_class::read_remap_operator_instance_from_array(Remap_grid_class *field_data_grid_src, Remap_grid_class *field_data_grid_dst,
-															  Remap_grid_class *operator_grid_src, Remap_grid_class *operator_grid_dst,
+                                                              Remap_grid_class *operator_grid_src, Remap_grid_class *operator_grid_dst,
                                                               Remap_operator_basis *remap_operator, long remap_begin_iter, long remap_end_iter,
                                                               const char *input_array, FILE *fp_binary, long &current_array_pos, long array_size,
                                                               bool read_weight_values)    
@@ -838,111 +914,109 @@ void Remap_weight_of_strategy_class::read_remap_operator_instance_from_array(Rem
     double *weight_values;
 
 
-	if (read_weight_values)
-	    duplicated_remap_operator = remap_operator->duplicate_remap_operator(false);
-	else duplicated_remap_operator = NULL;
-	read_data_from_array(&num_remap_weights_groups, sizeof(int), input_array, fp_binary, current_array_pos, array_size, true);
+    if (read_weight_values)
+        duplicated_remap_operator = remap_operator->duplicate_remap_operator(false);
+    else duplicated_remap_operator = NULL;
+    read_data_from_array(&num_remap_weights_groups, sizeof(int), input_array, fp_binary, current_array_pos, array_size, true);
     for (i = 0; i < num_remap_weights_groups; i ++) {
-		read_data_from_array(&num_weights, sizeof(long), input_array, fp_binary, current_array_pos, array_size, true);
-		if (read_weight_values) {
-	        indexes_src_grid = new long [num_weights];
-	        indexes_dst_grid = new long [num_weights];
-    	    weight_values = new double [num_weights];
-		}
-		read_data_from_array(indexes_src_grid, sizeof(long)*num_weights, input_array, fp_binary, current_array_pos, array_size, read_weight_values);
-		read_data_from_array(indexes_dst_grid, sizeof(long)*num_weights, input_array, fp_binary, current_array_pos, array_size, read_weight_values);
-		read_data_from_array(weight_values, sizeof(double)*num_weights, input_array, fp_binary, current_array_pos, array_size, read_weight_values);
-		read_data_from_array(&num_remaped_dst_cells_indexes, sizeof(long), input_array, fp_binary, current_array_pos, array_size, true);
-		if (read_weight_values)
-	        remaped_dst_cells_indexes = new long [num_remaped_dst_cells_indexes];
-		read_data_from_array(remaped_dst_cells_indexes, sizeof(long)*num_remaped_dst_cells_indexes, input_array, fp_binary, current_array_pos, array_size, read_weight_values);
-		if (read_weight_values) {
-	        weight_sparse_matrix = new Remap_weight_sparse_matrix(remap_operator, num_weights, indexes_src_grid, indexes_dst_grid, weight_values, num_remaped_dst_cells_indexes, remaped_dst_cells_indexes);
-    	    duplicated_remap_operator->add_weight_sparse_matrix(weight_sparse_matrix);
-		}
+        read_data_from_array(&num_weights, sizeof(long), input_array, fp_binary, current_array_pos, array_size, true);
+        if (read_weight_values) {
+            indexes_src_grid = new long [num_weights];
+            indexes_dst_grid = new long [num_weights];
+            weight_values = new double [num_weights];
+        }
+        read_data_from_array(indexes_src_grid, sizeof(long)*num_weights, input_array, fp_binary, current_array_pos, array_size, read_weight_values);
+        read_data_from_array(indexes_dst_grid, sizeof(long)*num_weights, input_array, fp_binary, current_array_pos, array_size, read_weight_values);
+        read_data_from_array(weight_values, sizeof(double)*num_weights, input_array, fp_binary, current_array_pos, array_size, read_weight_values);
+        read_data_from_array(&num_remaped_dst_cells_indexes, sizeof(long), input_array, fp_binary, current_array_pos, array_size, true);
+        if (read_weight_values)
+            remaped_dst_cells_indexes = new long [num_remaped_dst_cells_indexes];
+        read_data_from_array(remaped_dst_cells_indexes, sizeof(long)*num_remaped_dst_cells_indexes, input_array, fp_binary, current_array_pos, array_size, read_weight_values);
+        if (read_weight_values) {
+            weight_sparse_matrix = new Remap_weight_sparse_matrix(remap_operator, num_weights, indexes_src_grid, indexes_dst_grid, weight_values, num_remaped_dst_cells_indexes, remaped_dst_cells_indexes);
+            duplicated_remap_operator->add_weight_sparse_matrix(weight_sparse_matrix);
+        }
     }
     
     remap_operator_instance = new Remap_weight_of_operator_instance_class(field_data_grid_src, field_data_grid_dst, remap_begin_iter, remap_operator, duplicated_remap_operator);
-	remap_operator_instance->operator_grid_src = operator_grid_src;
-	remap_operator_instance->operator_grid_dst = operator_grid_dst;
-	remap_operator_instance->remap_end_iter = remap_end_iter;
-    add_remap_weight_of_operator_instance(remap_operator_instance);
+    remap_operator_instance->remap_end_iter = remap_end_iter;
+    add_remap_weight_of_operator_instance(remap_operator_instance, field_data_grid_src, field_data_grid_dst, remap_operator, operator_grid_src, operator_grid_dst);
 }
 
 
 void Remap_weight_of_strategy_class::read_remap_weights_from_array(const char *input_array, FILE *fp_binary, long array_size, bool read_grid, Remap_grid_class **remap_related_decomp_grids, bool read_weight_values)
 {
     Remap_grid_class *field_grid_src, *field_grid_dst, *current_field_grid_src, *current_field_grid_dst;
-	Remap_grid_class *operator_grid_src, *operator_grid_dst;
+    Remap_grid_class *operator_grid_src, *operator_grid_dst;
     int i, j, k, m, num_remap_operator_instances, num_remap_operator, num_leaf_grids_all, num_leaf_grids_remap_operator;
     Remap_operator_basis *remap_operator;
     int coord_system_ids[256], tmp_grid_num_dimensions, num_sized_sub_grids;
     long tmp_grid_size, current_remap_iter, remap_end_iter;
     char operator_name[256], last_operator_name[256], tmp_grid_name[256];
-	long current_array_pos = 0;
-	int field_data_grids_iter = 0;
+    long current_array_pos = 0;
+    int field_data_grids_iter = 0;
     
 
-	if (read_grid) {
-	    field_grid_src = get_data_grid_src();
-	    field_grid_dst = get_data_grid_dst();
-		m = 1;
-		EXECUTION_REPORT(REPORT_ERROR, -1, remap_related_decomp_grids == NULL, "software error in read_remap_weights_from_array");
-    	read_grid_info_from_array(field_grid_src, true, input_array, fp_binary, current_array_pos, array_size);
-    	read_grid_info_from_array(field_grid_dst, true, input_array, fp_binary, current_array_pos, array_size);
-	}
-	else {
-		EXECUTION_REPORT(REPORT_ERROR, -1, remap_related_decomp_grids != NULL, "software error in read_remap_weights_from_array");
-	    field_grid_src = remap_related_decomp_grids[field_data_grids_iter++];
-    	field_grid_dst = remap_related_decomp_grids[field_data_grids_iter++];
-	}
+    if (read_grid) {
+        field_grid_src = get_data_grid_src();
+        field_grid_dst = get_data_grid_dst();
+        m = 1;
+        EXECUTION_REPORT(REPORT_ERROR, -1, remap_related_decomp_grids == NULL, "software error in read_remap_weights_from_array");
+        read_grid_info_from_array(field_grid_src, true, input_array, fp_binary, current_array_pos, array_size);
+        read_grid_info_from_array(field_grid_dst, true, input_array, fp_binary, current_array_pos, array_size);
+    }
+    else {
+        EXECUTION_REPORT(REPORT_ERROR, -1, remap_related_decomp_grids != NULL, "software error in read_remap_weights_from_array");
+        field_grid_src = remap_related_decomp_grids[field_data_grids_iter++];
+        field_grid_dst = remap_related_decomp_grids[field_data_grids_iter++];
+    }
 
-	read_data_from_array(&num_remap_operator_instances, sizeof(int), input_array, fp_binary, current_array_pos, array_size, true);
+    read_data_from_array(&num_remap_operator_instances, sizeof(int), input_array, fp_binary, current_array_pos, array_size, true);
     num_remap_operator = 0;
     current_field_grid_src = field_grid_src;
     for (i = 0; i < num_remap_operator_instances; i ++) {
-		read_data_from_array(&current_remap_iter, sizeof(long), input_array, fp_binary, current_array_pos, array_size, true);
-		read_data_from_array(&remap_end_iter, sizeof(long), input_array, fp_binary, current_array_pos, array_size, true);
-		read_data_from_array(operator_name, sizeof(char)*256, input_array, fp_binary, current_array_pos, array_size, true);
-		if (read_grid) {
-			if (i == 0)
-				strcpy(last_operator_name, operator_name);
-			if (!words_are_the_same(last_operator_name, operator_name)) {
-				num_remap_operator ++;
-				strcpy(last_operator_name, operator_name);
-			}
-    	    remap_operator = remap_strategy->get_remap_operator(num_remap_operator);
-			EXECUTION_REPORT(REPORT_ERROR, -1, words_are_the_same(operator_name, remap_operator->get_operator_name()),
-							 "the remap operator %s does not match the binary file, which should be %s\n", 
-							 operator_name, remap_operator->get_operator_name());
-			read_data_from_array(&tmp_grid_size, sizeof(long), input_array, fp_binary, current_array_pos, array_size, true);
-			read_data_from_array(&tmp_grid_num_dimensions, sizeof(int), input_array, fp_binary, current_array_pos, array_size, true);
-	        EXECUTION_REPORT(REPORT_ERROR, -1, tmp_grid_num_dimensions == field_grid_src->get_num_dimensions(), "remap software error2 in read_remap_weights_from_array binary\n");
-	        for (j = 0; j < tmp_grid_num_dimensions; j ++)
-				read_data_from_array(&coord_system_ids[j], sizeof(int), input_array, fp_binary, current_array_pos, array_size, true);
-	        num_sized_sub_grids = 0;
-			current_field_grid_src = field_data_grids_in_remapping_process[1+num_remap_operator*2];
-			current_field_grid_dst = field_data_grids_in_remapping_process[2+num_remap_operator*2];
-	        read_grid_info_from_array(current_field_grid_dst, false, input_array, fp_binary, current_array_pos, array_size);
-    	    read_grid_info_from_array(remap_operator->get_src_grid(), false, input_array, fp_binary, current_array_pos, array_size);
-        	read_grid_info_from_array(remap_operator->get_dst_grid(), false, input_array, fp_binary, current_array_pos, array_size);
-			operator_grid_src = remap_operator->get_src_grid();
-			operator_grid_dst = remap_operator->get_dst_grid();
-
-    	}
-		else {
-			remap_operator = remap_operator_manager->search_remap_operator(operator_name);
-			EXECUTION_REPORT(REPORT_ERROR, -1, remap_operator != NULL, "software error when searching remap operator %s in read_remap_weights_from_array", operator_name);
-			current_field_grid_src = remap_related_decomp_grids[field_data_grids_iter+0];
-			current_field_grid_dst = remap_related_decomp_grids[field_data_grids_iter+1];
-			operator_grid_src = remap_related_decomp_grids[field_data_grids_iter+2];
-			operator_grid_dst = remap_related_decomp_grids[field_data_grids_iter+3];
-			field_data_grids_iter += 4;
-		}
-		read_remap_operator_instance_from_array(current_field_grid_src, current_field_grid_dst, operator_grid_src, operator_grid_dst, remap_operator, current_remap_iter, remap_end_iter, input_array, fp_binary, current_array_pos, array_size, read_weight_values);
+        read_data_from_array(&current_remap_iter, sizeof(long), input_array, fp_binary, current_array_pos, array_size, true);
+        read_data_from_array(&remap_end_iter, sizeof(long), input_array, fp_binary, current_array_pos, array_size, true);
+        read_data_from_array(operator_name, sizeof(char)*256, input_array, fp_binary, current_array_pos, array_size, true);
+        if (read_grid) {
+            if (i == 0)
+                strcpy(last_operator_name, operator_name);
+            if (!words_are_the_same(last_operator_name, operator_name)) {
+                num_remap_operator ++;
+                strcpy(last_operator_name, operator_name);
+            }
+            remap_operator = remap_strategy->get_remap_operator(num_remap_operator);
+            EXECUTION_REPORT(REPORT_ERROR, -1, words_are_the_same(operator_name, remap_operator->get_operator_name()),
+                             "the remap operator %s does not match the binary file, which should be %s\n", 
+                             operator_name, remap_operator->get_operator_name());
+            read_data_from_array(&tmp_grid_size, sizeof(long), input_array, fp_binary, current_array_pos, array_size, true);
+            read_data_from_array(&tmp_grid_num_dimensions, sizeof(int), input_array, fp_binary, current_array_pos, array_size, true);
+            EXECUTION_REPORT(REPORT_ERROR, -1, tmp_grid_num_dimensions == field_grid_src->get_num_dimensions(), "remap software error2 in read_remap_weights_from_array binary\n");
+            for (j = 0; j < tmp_grid_num_dimensions; j ++)
+                read_data_from_array(&coord_system_ids[j], sizeof(int), input_array, fp_binary, current_array_pos, array_size, true);
+            num_sized_sub_grids = 0;
+            current_field_grid_src = field_data_grids_in_remapping_process[1+num_remap_operator*2];
+            current_field_grid_dst = field_data_grids_in_remapping_process[2+num_remap_operator*2];
+            read_grid_info_from_array(current_field_grid_dst, false, input_array, fp_binary, current_array_pos, array_size);
+            read_grid_info_from_array(remap_operator->get_src_grid(), false, input_array, fp_binary, current_array_pos, array_size);
+            read_grid_info_from_array(remap_operator->get_dst_grid(), false, input_array, fp_binary, current_array_pos, array_size);
+            operator_grid_src = remap_operator->get_src_grid();
+            operator_grid_dst = remap_operator->get_dst_grid();
+
+        }
+        else {
+            remap_operator = remap_operator_manager->search_remap_operator(operator_name);
+            EXECUTION_REPORT(REPORT_ERROR, -1, remap_operator != NULL, "software error when searching remap operator %s in read_remap_weights_from_array", operator_name);
+            current_field_grid_src = remap_related_decomp_grids[field_data_grids_iter+0];
+            current_field_grid_dst = remap_related_decomp_grids[field_data_grids_iter+1];
+            operator_grid_src = remap_related_decomp_grids[field_data_grids_iter+2];
+            operator_grid_dst = remap_related_decomp_grids[field_data_grids_iter+3];
+            field_data_grids_iter += 4;
+        }
+        read_remap_operator_instance_from_array(current_field_grid_src, current_field_grid_dst, operator_grid_src, operator_grid_dst, remap_operator, current_remap_iter, remap_end_iter, input_array, fp_binary, current_array_pos, array_size, read_weight_values);
     }
     EXECUTION_REPORT(REPORT_ERROR, -1, current_field_grid_dst->is_similar_grid_with(field_grid_dst), "remap software error4 in read_remap_weights_from_array\n");
-	EXECUTION_REPORT(REPORT_ERROR, -1, current_array_pos == array_size, "the input array does not match the remapping weights %s when reading", object_name);
+    EXECUTION_REPORT(REPORT_ERROR, -1, current_array_pos == array_size, "the input array does not match the remapping weights %s when reading", object_name);
 }
 
 
@@ -953,79 +1027,87 @@ void Remap_weight_of_strategy_class::check_remap_weights_format()
     bool have_sphere_grid_remapping = false;
     
 
-	for (k = 0; k < remap_weights_of_operators.size(); k ++)
-	    for (i = 0; i < remap_weights_of_operators[k]->remap_weights_of_operator_instances.size(); i ++) {
-			if (remap_weights_of_operators[k]->remap_weights_of_operator_instances[i]->duplicated_remap_operator == NULL)
-				continue;
-	        grid_src = remap_weights_of_operators[k]->remap_weights_of_operator_instances[i]->duplicated_remap_operator->get_src_grid();
-	        j = 0;
-	        if (grid_src->has_grid_coord_label(COORD_LABEL_LON))
-	            j ++;
-	        if (grid_src->has_grid_coord_label(COORD_LABEL_LAT))
-	            j ++;
-	        EXECUTION_REPORT(REPORT_ERROR, -1, j == 0 || j == 2, "the remap operator %s for coupling must remap on both longitude and latitude\n", 
-							 remap_weights_of_operators[k]->remap_weights_of_operator_instances[i]->duplicated_remap_operator->get_operator_name());
-	        if (grid_src->has_grid_coord_label(COORD_LABEL_LON)) {
-	            EXECUTION_REPORT(REPORT_ERROR, -1, !have_sphere_grid_remapping, "the remap weights %s must have only one remap operator remapping on only one grid\n", 
-								 remap_weights_of_operators[k]->remap_weights_of_operator_instances[i]->duplicated_remap_operator->get_object_name());
-	            have_sphere_grid_remapping = true;
-	        }
-	    }
+    for (k = 0; k < remap_weights_of_operators.size(); k ++)
+        for (i = 0; i < remap_weights_of_operators[k]->remap_weights_of_operator_instances.size(); i ++) {
+            if (remap_weights_of_operators[k]->remap_weights_of_operator_instances[i]->duplicated_remap_operator == NULL)
+                continue;
+            grid_src = remap_weights_of_operators[k]->remap_weights_of_operator_instances[i]->duplicated_remap_operator->get_src_grid();
+            j = 0;
+            if (grid_src->has_grid_coord_label(COORD_LABEL_LON))
+                j ++;
+            if (grid_src->has_grid_coord_label(COORD_LABEL_LAT))
+                j ++;
+            EXECUTION_REPORT(REPORT_ERROR, -1, j == 0 || j == 2, "the remap operator %s for coupling must remap on both longitude and latitude\n", 
+                             remap_weights_of_operators[k]->remap_weights_of_operator_instances[i]->duplicated_remap_operator->get_operator_name());
+            if (grid_src->has_grid_coord_label(COORD_LABEL_LON)) {
+                EXECUTION_REPORT(REPORT_ERROR, -1, !have_sphere_grid_remapping, "the remap weights %s must have only one remap operator remapping on only one grid\n", 
+                                 remap_weights_of_operators[k]->remap_weights_of_operator_instances[i]->duplicated_remap_operator->get_object_name());
+                have_sphere_grid_remapping = true;
+            }
+        }
 }
 
 
 Remap_operator_basis *Remap_weight_of_strategy_class::get_unique_remap_operator_of_weights() 
 { 
-	EXECUTION_REPORT(REPORT_ERROR, -1, remap_weights_of_operators.size() > 0 && remap_weights_of_operators[0]->remap_weights_of_operator_instances.size() > 0 &&
-					 remap_weights_of_operators[0]->remap_weights_of_operator_instances[0]->duplicated_remap_operator != NULL, 
-					 "C-Coupler error in get_unique_remap_operator_of_weights");
+    EXECUTION_REPORT(REPORT_ERROR, -1, remap_weights_of_operators.size() > 0 && remap_weights_of_operators[0]->remap_weights_of_operator_instances.size() > 0 &&
+                     remap_weights_of_operators[0]->remap_weights_of_operator_instances[0]->duplicated_remap_operator != NULL, 
+                     "C-Coupler error in get_unique_remap_operator_of_weights");
 
-	if (remap_weights_of_operators.size() == 1 && remap_weights_of_operators[0]->remap_weights_of_operator_instances.size() == 1)
-		return remap_weights_of_operators[0]->remap_weights_of_operator_instances[0]->duplicated_remap_operator;
-	else return NULL;
+    if (remap_weights_of_operators.size() == 1 && remap_weights_of_operators[0]->remap_weights_of_operator_instances.size() == 1)
+        return remap_weights_of_operators[0]->remap_weights_of_operator_instances[0]->duplicated_remap_operator;
+    else return NULL;
 }
 
 
 void Remap_weight_of_strategy_class::add_remap_weight_of_operators_to_manager(bool are_parallel_remap_weights)
 {
-	public_remap_weights_of_operators = true;
-	for (int i = 0; i < remap_weights_of_operators.size(); i ++)
-		if (are_parallel_remap_weights)
-			parallel_remap_weight_of_operator_manager->add_remap_weights_of_operator(remap_weights_of_operators[i]);
-		else sequential_remap_weight_of_operator_manager->add_remap_weights_of_operator(remap_weights_of_operators[i]);
+    public_remap_weights_of_operators = true;
+    for (int i = 0; i < remap_weights_of_operators.size(); i ++)
+        if (are_parallel_remap_weights)
+            parallel_remap_weight_of_operator_manager->add_remap_weights_of_operator(remap_weights_of_operators[i]);
+        else sequential_remap_weight_of_operator_manager->add_remap_weights_of_operator(remap_weights_of_operators[i]);
 }
 
 
 Remap_grid_class *Remap_weight_of_strategy_class::get_field_data_grid_in_remapping_process(int i) 
 { 
-	EXECUTION_REPORT(REPORT_ERROR, -1, i < num_field_data_grids_in_remapping_process, "C-Coupler error in get_field_data_grid_in_remapping_process of Remap_weight_of_strategy_class");
-	return field_data_grids_in_remapping_process[i]; 
+    EXECUTION_REPORT(REPORT_ERROR, -1, i < num_field_data_grids_in_remapping_process, "C-Coupler error in get_field_data_grid_in_remapping_process of Remap_weight_of_strategy_class");
+    return field_data_grids_in_remapping_process[i]; 
 }
 
 
 Remap_grid_data_class *Remap_weight_of_strategy_class::get_runtime_mask_field_in_remapping_process(int i) 
 { 
-	EXECUTION_REPORT(REPORT_ERROR, -1, i < num_field_data_grids_in_remapping_process, "C-Coupler error in get_runtime_mask_field_in_remapping_process of Remap_weight_of_strategy_class");
-	return runtime_mask_fields_in_remapping_process[i]; 
+    EXECUTION_REPORT(REPORT_ERROR, -1, i < num_field_data_grids_in_remapping_process, "C-Coupler error in get_runtime_mask_field_in_remapping_process of Remap_weight_of_strategy_class");
+    return runtime_mask_fields_in_remapping_process[i]; 
 }
 
 
 void Remap_weight_of_strategy_class::renew_object_name(const char*new_object_name)
 {
-	if (words_are_the_same(object_name, new_object_name))
-		return;
-	
-	EXECUTION_REPORT(REPORT_ERROR, -1, strncmp(object_name, "TEMP_WEIGHT", strlen("TEMP_WEIGHT")) == 0, "Remap weights %s is the same as %s. Please do not calculate the same remap weights more than once", object_name, new_object_name);
+    if (words_are_the_same(object_name, new_object_name))
+        return;
+    
+    EXECUTION_REPORT(REPORT_ERROR, -1, strncmp(object_name, "TEMP_WEIGHT", strlen("TEMP_WEIGHT")) == 0, "Remap weights %s is the same as %s. Please do not calculate the same remap weights more than once", object_name, new_object_name);
 }
 
 
 Remap_weight_of_operator_class *Remap_weight_of_strategy_class::get_dynamic_V1D_remap_weight_of_operator()
 {
+    for (int i = 0; i < remap_weights_of_operators.size(); i ++)
+        if (remap_weights_of_operators[i]->operator_grid_src->has_grid_coord_label(COORD_LABEL_LEV) && (remap_weights_of_operators[i]->field_data_grid_src->is_sigma_grid() || remap_weights_of_operators[i]->field_data_grid_src->does_use_V3D_level_coord() || remap_weights_of_operators[i]->field_data_grid_dst->is_sigma_grid() || remap_weights_of_operators[i]->field_data_grid_dst->does_use_V3D_level_coord()))
+            return remap_weights_of_operators[i];
+    
+    return NULL;
+}
+
+
+void Remap_weight_of_strategy_class::write_overall_H2D_remapping_weights(int comp_id)
+{
 	for (int i = 0; i < remap_weights_of_operators.size(); i ++)
-		if (remap_weights_of_operators[i]->operator_grid_src->has_grid_coord_label(COORD_LABEL_LEV) && (remap_weights_of_operators[i]->field_data_grid_src->is_sigma_grid() || remap_weights_of_operators[i]->field_data_grid_dst->is_sigma_grid()))
-			return remap_weights_of_operators[i];
-	
-	return NULL;
+		if (remap_weights_of_operators[i]->operator_grid_src->get_is_sphere_grid())
+			remap_weights_of_operators[i]->write_overall_remapping_weights(comp_id);
 }
 
 
diff --git a/src/CoR/remap_weight_of_strategy_class.h b/src/CoR/remap_weight_of_strategy_class.h
old mode 100644
new mode 100755
index 667b723..f182139
--- a/src/CoR/remap_weight_of_strategy_class.h
+++ b/src/CoR/remap_weight_of_strategy_class.h
@@ -24,31 +24,34 @@ class Remap_weight_of_strategy_class;
 class Remap_weight_of_operator_class;
 
 
+class Remap_weight_of_operator_class;
+
+
 class Remap_weight_of_operator_instance_class
 {
     private:
         friend class Remap_weight_of_strategy_class;
-		friend class Remap_weight_of_operator_class;
-        Remap_grid_class *field_data_grid_src;
-        Remap_grid_class *field_data_grid_dst;
-        Remap_grid_class *operator_grid_src;
-        Remap_grid_class *operator_grid_dst;
-        Remap_operator_basis *original_remap_operator;
+        friend class Remap_weight_of_operator_class;
+		Remap_weight_of_operator_class *remap_weight_of_operator;
         Remap_operator_basis *duplicated_remap_operator;
-        long remap_beg_iter;
-        long remap_end_iter;
+        int remap_beg_iter;
+        int remap_end_iter;
         
     public: 
-        Remap_weight_of_operator_instance_class() {}
+        Remap_weight_of_operator_instance_class() { duplicated_remap_operator = NULL; }
         Remap_weight_of_operator_instance_class(Remap_grid_class*, Remap_grid_class*, long, Remap_operator_basis*);
         Remap_weight_of_operator_instance_class(Remap_grid_class*, Remap_grid_class*, long, Remap_operator_basis*, Remap_operator_basis*);
         ~Remap_weight_of_operator_instance_class();
         long get_remap_begin_iter() { return remap_beg_iter; }
-		long get_remap_end_iter() { return remap_end_iter; }
-        Remap_grid_class *get_field_data_grid_src() { return field_data_grid_src; }
-        Remap_grid_class *get_field_data_grid_dst() { return field_data_grid_dst; }
+        long get_remap_end_iter() { return remap_end_iter; }
+        Remap_grid_class *get_field_data_grid_src();
+        Remap_grid_class *get_field_data_grid_dst();
+		Remap_operator_basis *get_original_remap_operator();
+        Remap_grid_class *get_operator_grid_src();
+        Remap_grid_class *get_operator_grid_dst();
         Remap_weight_of_operator_instance_class *generate_parallel_remap_weights(Remap_grid_class**, int **);
-		void renew_remapping_time_end_iter(long);
+        void renew_remapping_time_end_iter(long);
+		void set_remap_weight_of_operator(Remap_weight_of_operator_class *remap_weight_of_operator) { this->remap_weight_of_operator = remap_weight_of_operator; } ;
 };
 
 
@@ -61,54 +64,57 @@ class Remap_weight_of_operator_class
         Remap_grid_class *operator_grid_src;
         Remap_grid_class *operator_grid_dst;
         Remap_operator_basis *original_remap_operator;
-		std::vector<Remap_weight_of_operator_instance_class*> remap_weights_of_operator_instances;
-		bool empty_remap_weight;
+        std::vector<Remap_weight_of_operator_instance_class*> remap_weights_of_operator_instances;
+        bool empty_remap_weight;
         
     public: 
         Remap_weight_of_operator_class(Remap_grid_class*, Remap_grid_class*, Remap_operator_basis*, Remap_grid_class*, Remap_grid_class*);
         ~Remap_weight_of_operator_class();
         Remap_grid_class *get_field_data_grid_src() { return field_data_grid_src; }
         Remap_grid_class *get_field_data_grid_dst() { return field_data_grid_dst; }
-		void calculate_src_decomp(long*, const long*);
+        Remap_grid_class *get_operator_grid_src() { return operator_grid_src; }
+        Remap_grid_class *get_operator_grid_dst() { return operator_grid_dst; } 
+        void calculate_src_decomp(long*, const long*);
         Remap_weight_of_operator_class *generate_parallel_remap_weights(Remap_grid_class**, Remap_grid_class**, int **, int &, Remap_weight_of_strategy_class*);
-        void do_remap(Remap_grid_data_class*, Remap_grid_data_class*);
-		void add_remap_weight_of_operator_instance(Remap_weight_of_operator_instance_class *);
-		Remap_operator_basis *get_original_remap_operator() { return original_remap_operator; }
-		void renew_vertical_remap_weights(Remap_grid_class *runtime_remap_grid_src, Remap_grid_class *runtime_remap_grid_dst);
-		void mark_empty_remap_weight() { empty_remap_weight = true; }
-		bool is_remap_weight_empty() { return empty_remap_weight; }		
+        void do_remap(int, Remap_grid_data_class*, Remap_grid_data_class*);
+        void add_remap_weight_of_operator_instance(Remap_weight_of_operator_instance_class *);
+        Remap_operator_basis *get_original_remap_operator() { return original_remap_operator; }
+        void renew_vertical_remap_weights(Remap_grid_class *runtime_remap_grid_src, Remap_grid_class *runtime_remap_grid_dst);
+        void mark_empty_remap_weight() { empty_remap_weight = true; }
+        bool is_remap_weight_empty() { return empty_remap_weight; }        
+		void write_overall_remapping_weights(int);
 };
 
 
 class Remap_weight_of_strategy_class
 {
     private:
-        char object_name[256];
-		std::vector<Remap_weight_of_operator_class*> remap_weights_of_operators;
+        char object_name[NAME_STR_SIZE];
+        std::vector<Remap_weight_of_operator_class*> remap_weights_of_operators;
         Remap_grid_class *data_grid_src;
         Remap_grid_class *data_grid_dst;
         Remap_strategy_class *remap_strategy;
-		bool dynamic_vertical_remapping_weights_src;
-		bool dynamic_vertical_remapping_weights_dst;
-		bool public_remap_weights_of_operators;
-		int num_field_data_grids_in_remapping_process;
-		Remap_grid_class *field_data_grids_in_remapping_process[512];
-		Remap_grid_data_class *runtime_mask_fields_in_remapping_process[512];
-
-		void read_grid_info_from_array(Remap_grid_class*, bool, const char *, FILE*, long&, long);
-		void read_data_from_array(void*, int, const char*, FILE*, long&, long, bool);
-		void read_remap_operator_instance_from_array(Remap_grid_class*, Remap_grid_class*, Remap_grid_class*, Remap_grid_class*, Remap_operator_basis*, long, long, const char*, FILE*, long&, long, bool);
-		void write_grid_info_into_array(Remap_grid_class*, bool, char **, long&, long &);
-		void write_data_into_array(void*, int, char**, long&, long &);
+        bool dynamic_vertical_remapping_weights_src;
+        bool dynamic_vertical_remapping_weights_dst;
+        bool public_remap_weights_of_operators;
+        int num_field_data_grids_in_remapping_process;
+        Remap_grid_class *field_data_grids_in_remapping_process[512];
+        Remap_grid_data_class *runtime_mask_fields_in_remapping_process[512];
+
+        void read_grid_info_from_array(Remap_grid_class*, bool, const char *, FILE*, long&, long);
+        void read_data_from_array(void*, int, const char*, FILE*, long&, long, bool);
+        void read_remap_operator_instance_from_array(Remap_grid_class*, Remap_grid_class*, Remap_grid_class*, Remap_grid_class*, Remap_operator_basis*, long, long, const char*, FILE*, long&, long, bool);
+        void write_grid_info_into_array(Remap_grid_class*, bool, char **, long&, long &);
+        void write_data_into_array(void*, int, char**, long&, long &);
 
     public:
         Remap_weight_of_strategy_class(const char*, const char*, const char*, const char*, const char*, const char*, bool);
-		Remap_weight_of_strategy_class(const char *, Remap_strategy_class *, Remap_grid_class *, Remap_grid_class *, const char *);
-		void set_basic_fields(const char*, Remap_strategy_class*, Remap_grid_class*, Remap_grid_class*);
-		void initialize_object();
+        Remap_weight_of_strategy_class(const char *, Remap_strategy_class *, Remap_grid_class *, Remap_grid_class *, const char *, bool, int);
+        void set_basic_fields(const char*, Remap_strategy_class*, Remap_grid_class*, Remap_grid_class*);
+        void initialize_object();
         Remap_weight_of_strategy_class() { initialize_object(); }
         bool match_object_name(const char*);
-		int generate_remapping_related_grids();
+        int generate_remapping_related_grids();
         ~Remap_weight_of_strategy_class();
 
         Remap_grid_class *get_data_grid_src() { return data_grid_src; }
@@ -116,24 +122,27 @@ class Remap_weight_of_strategy_class
         Remap_strategy_class *get_remap_strategy() { return remap_strategy; }
         Remap_operator_basis *get_unique_remap_operator_of_weights();
         Remap_weight_of_operator_instance_class *add_remap_weight_of_operator_instance(Remap_grid_class*, Remap_grid_class*, long, Remap_operator_basis*);
-        void do_remap(Remap_grid_data_class*, Remap_grid_data_class*);
-        void add_remap_weight_of_operator_instance(Remap_weight_of_operator_instance_class *);
+        void do_remap(int, Remap_grid_data_class*, Remap_grid_data_class*);
+        void add_remap_weight_of_operator_instance(Remap_weight_of_operator_instance_class *, Remap_grid_class *, Remap_grid_class *, Remap_operator_basis *, Remap_grid_class *, Remap_grid_class *);
         void calculate_src_decomp(Remap_grid_class*, Remap_grid_class*, long*, const long*);
-        Remap_grid_class **get_remap_related_grids(int&);
+		void get_remap_related_grids(std::vector<std::pair<Remap_grid_class *, bool> > &);		
+		void add_remap_related_grid(std::vector<std::pair<Remap_grid_class *, bool> > &, Remap_grid_class *, bool);
         Remap_weight_of_strategy_class *generate_parallel_remap_weights(Remap_grid_class**, Remap_grid_class**, int **);
         const char *get_object_name() { return object_name; }
-		void renew_object_name(const char*);
-		void write_remap_weights_into_array(char**, long&, bool);
-		void read_remap_weights_from_array(const char*, FILE*, long, bool, Remap_grid_class**, bool);
-		void check_remap_weights_format();
-		void add_remap_weight_of_operators_to_manager(bool);
-		int get_num_remap_weights_of_operators() { return remap_weights_of_operators.size(); }
-		Remap_weight_of_operator_class *get_remap_weights_of_operator(int i) { return remap_weights_of_operators[i]; }
-		int get_num_field_data_grids_in_remapping_process() { return num_field_data_grids_in_remapping_process; }
-		Remap_grid_class *get_field_data_grid_in_remapping_process(int);
-		Remap_grid_data_class *get_runtime_mask_field_in_remapping_process(int);
-		Remap_weight_of_operator_class *get_dynamic_V1D_remap_weight_of_operator();
-		void mark_empty_remap_weight() { remap_weights_of_operators[remap_weights_of_operators.size()-1]->mark_empty_remap_weight(); }
+        void renew_object_name(const char*);
+        void write_remap_weights_into_array(char**, long&, bool);
+        void read_remap_weights_from_array(const char*, FILE*, long, bool, Remap_grid_class**, bool);
+        void check_remap_weights_format();
+        void add_remap_weight_of_operators_to_manager(bool);
+        int get_num_remap_weights_of_operators() { return remap_weights_of_operators.size(); }
+        Remap_weight_of_operator_class *get_remap_weights_of_operator(int i) { return remap_weights_of_operators[i]; }
+		void add_remap_weights_of_operator(Remap_weight_of_operator_class *remap_weights_of_operator) { remap_weights_of_operators.push_back(remap_weights_of_operator); }
+        int get_num_field_data_grids_in_remapping_process() { return num_field_data_grids_in_remapping_process; }
+        Remap_grid_class *get_field_data_grid_in_remapping_process(int);
+        Remap_grid_data_class *get_runtime_mask_field_in_remapping_process(int);
+        Remap_weight_of_operator_class *get_dynamic_V1D_remap_weight_of_operator();
+        void mark_empty_remap_weight() { remap_weights_of_operators[remap_weights_of_operators.size()-1]->mark_empty_remap_weight(); }
+		void write_overall_H2D_remapping_weights(int);
 };
 
 
diff --git a/src/CoR/remap_weight_of_strategy_mgt.cxx b/src/CoR/remap_weight_of_strategy_mgt.cxx
old mode 100644
new mode 100755
index 7020168..38ed596
--- a/src/CoR/remap_weight_of_strategy_mgt.cxx
+++ b/src/CoR/remap_weight_of_strategy_mgt.cxx
@@ -16,31 +16,31 @@
 
 Remap_weight_of_operator_class *Remap_weight_of_operator_mgt::search_remap_weights_of_operator(Remap_grid_class *field_data_grid_src, Remap_grid_class *field_data_grid_dst, Remap_operator_basis *original_remap_operator)
 {
-	for (int i = 0; i < remap_weights_of_operators.size(); i ++) {
-		if (field_data_grid_src->is_similar_grid_with(remap_weights_of_operators[i]->get_field_data_grid_src())&&
-			field_data_grid_dst->is_similar_grid_with(remap_weights_of_operators[i]->get_field_data_grid_dst()) &&
-			original_remap_operator == remap_weights_of_operators[i]->get_original_remap_operator())
-			return remap_weights_of_operators[i];
-	}
-		
-	return NULL;
+    for (int i = 0; i < remap_weights_of_operators.size(); i ++) {
+        if (field_data_grid_src->is_similar_grid_with(remap_weights_of_operators[i]->get_field_data_grid_src())&&
+            field_data_grid_dst->is_similar_grid_with(remap_weights_of_operators[i]->get_field_data_grid_dst()) &&
+            original_remap_operator == remap_weights_of_operators[i]->get_original_remap_operator())
+            return remap_weights_of_operators[i];
+    }
+        
+    return NULL;
 }
 
 
 void Remap_weight_of_operator_mgt::add_remap_weights_of_operator(Remap_weight_of_operator_class *remap_weight_of_operator)
 {
 /*
-	EXECUTION_REPORT(REPORT_ERROR, -1, search_remap_weights_of_operator(remap_weight_of_operator->get_field_data_grid_src(), remap_weight_of_operator->get_field_data_grid_dst(), remap_weight_of_operator->get_original_remap_operator()) == NULL,
-					 "C-Coupler error1 in add_remap_weights_of_operator of Remap_weight_of_operator_mgt");
+    EXECUTION_REPORT(REPORT_ERROR, -1, search_remap_weights_of_operator(remap_weight_of_operator->get_field_data_grid_src(), remap_weight_of_operator->get_field_data_grid_dst(), remap_weight_of_operator->get_original_remap_operator()) == NULL,
+                     "C-Coupler error1 in add_remap_weights_of_operator of Remap_weight_of_operator_mgt");
 */
-	remap_weights_of_operators.push_back(remap_weight_of_operator);
+    remap_weights_of_operators.push_back(remap_weight_of_operator);
 }
 
 
 Remap_weight_of_operator_mgt::~Remap_weight_of_operator_mgt()
 {
-	for (int i = 0; i < remap_weights_of_operators.size(); i ++)
-		delete remap_weights_of_operators[i];
+    for (int i = 0; i < remap_weights_of_operators.size(); i ++)
+        delete remap_weights_of_operators[i];
 }
 
 
@@ -58,9 +58,9 @@ void Remap_weight_of_strategy_mgt::execute(const char*function, Remap_statement_
         check_is_parameter_object_type_grid(function, 2, statement_operands[2], "the src grid of remap weights (the grid of src field)\n");
         check_is_parameter_object_type_grid(function, 3, statement_operands[3], "the dst grid of remap weights (the grid of dst field)\n");
         generate_new_remap_weights(statement_operands[0]->object->object_name, statement_operands[1]->object->object_name,
-			                       statement_operands[2]->object->object_name, statement_operands[3]->object->object_name,
-			                       NULL, NULL, false);
-		remap_weights_of_strategies[remap_weights_of_strategies.size()-1]->add_remap_weight_of_operators_to_manager(false);
+                                   statement_operands[2]->object->object_name, statement_operands[3]->object->object_name,
+                                   NULL, NULL, false);
+        remap_weights_of_strategies[remap_weights_of_strategies.size()-1]->add_remap_weight_of_operators_to_manager(false);
     }
     else if (words_are_the_same(function, FUNCTION_WORD_REMAP)){
         EXECUTION_REPORT(REPORT_ERROR, -1, num_operands == 3, "function \"%s\" must have no result parameter and three input parameters\n", function);
@@ -70,7 +70,7 @@ void Remap_weight_of_strategy_mgt::execute(const char*function, Remap_statement_
         remap_weights = remap_weights_of_strategy_manager->search_remap_weight_of_strategy(statement_operands[0]->object->object_name);
         field_data_src = remap_field_data_manager->search_remap_field_data(statement_operands[1]->object->object_name);
         field_data_dst = remap_field_data_manager->search_remap_field_data(statement_operands[2]->object->object_name);
-        remap_weights->do_remap(field_data_src, field_data_dst);
+        remap_weights->do_remap(-1, field_data_src, field_data_dst);
     }
     else if (words_are_the_same(function, FUNCTION_WORD_READ_REMAP_WEIGHTS)) {
         EXECUTION_REPORT(REPORT_ERROR, -1, num_operands == 6, "function \"%s\" must have one result parameter and five input parameters\n", function);
@@ -85,28 +85,28 @@ void Remap_weight_of_strategy_mgt::execute(const char*function, Remap_statement_
         remap_weights = generate_new_remap_weights(statement_operands[0]->object->object_name, statement_operands[1]->object->object_name,
                                                    statement_operands[2]->object->object_name, statement_operands[3]->object->object_name,
                                                    statement_operands[4]->object->object_name, statement_operands[5]->extension_names[0], true);
-		remap_weights_of_strategies[remap_weights_of_strategies.size()-1]->add_remap_weight_of_operators_to_manager(false);
+        remap_weights_of_strategies[remap_weights_of_strategies.size()-1]->add_remap_weight_of_operators_to_manager(false);
     }
 }
 
 
 Remap_weight_of_strategy_class *Remap_weight_of_strategy_mgt::search_or_add_remap_weight_of_strategy(Remap_grid_class *field_grid_src, Remap_grid_class *field_grid_dst, Remap_strategy_class *remap_strategy, const char *weight_object_name,
-																											 const char *input_IO_file_name, const char *weight_IO_format, bool read_from_io)
+                                                                                                             const char *input_IO_file_name, const char *weight_IO_format, bool read_from_io)
 {
-	char temp_object_name[512];
+    char temp_object_name[512];
 
-	
+    
     for (int i = 0; i < remap_weights_of_strategies.size(); i ++) 
         if (field_grid_src == remap_weights_of_strategies[i]->get_data_grid_src() && field_grid_dst == remap_weights_of_strategies[i]->get_data_grid_dst() && remap_strategy == remap_weights_of_strategies[i]->get_remap_strategy()) {
-			if (weight_object_name != NULL)
-				remap_weights_of_strategies[i]->renew_object_name(weight_object_name);
+            if (weight_object_name != NULL)
+                remap_weights_of_strategies[i]->renew_object_name(weight_object_name);
             return remap_weights_of_strategies[i];
         }
 
-	if (weight_object_name != NULL)
-		strcpy(temp_object_name, weight_object_name);
-	else sprintf(temp_object_name, "TEMP_WEIGHT_%s_%s_%s", remap_strategy->get_strategy_name(), field_grid_src->get_grid_name(), field_grid_dst->get_grid_name());
-	remap_weights_of_strategies.push_back(new Remap_weight_of_strategy_class(temp_object_name,remap_strategy->get_strategy_name(), field_grid_src->get_grid_name(), field_grid_dst->get_grid_name(),
+    if (weight_object_name != NULL)
+        strcpy(temp_object_name, weight_object_name);
+    else sprintf(temp_object_name, "TEMP_WEIGHT_%s_%s_%s", remap_strategy->get_strategy_name(), field_grid_src->get_grid_name(), field_grid_dst->get_grid_name());
+    remap_weights_of_strategies.push_back(new Remap_weight_of_strategy_class(temp_object_name,remap_strategy->get_strategy_name(), field_grid_src->get_grid_name(), field_grid_dst->get_grid_name(),
                                                                              input_IO_file_name, weight_IO_format, read_from_io));
 
     return remap_weights_of_strategies[remap_weights_of_strategies.size()-1];
@@ -116,17 +116,17 @@ Remap_weight_of_strategy_class *Remap_weight_of_strategy_mgt::search_or_add_rema
 Remap_weight_of_strategy_class *Remap_weight_of_strategy_mgt::generate_new_remap_weights(const char *object_name, const char *remap_strategy_name, const char *data_grid_name_src, const char *data_grid_name_dst,
                                                                                          const char *input_IO_file_name, const char *weight_IO_format, bool read_from_io)
 {
-	Remap_strategy_class *remap_strategy;
-	Remap_grid_class *data_grid_src, *data_grid_dst;
-	
-		
+    Remap_strategy_class *remap_strategy;
+    Remap_grid_class *data_grid_src, *data_grid_dst;
+    
+        
     remap_strategy = remap_strategy_manager->search_remap_strategy(remap_strategy_name);
     data_grid_src = remap_grid_manager->search_remap_grid_with_grid_name(data_grid_name_src);
     data_grid_dst = remap_grid_manager->search_remap_grid_with_grid_name(data_grid_name_dst);
 
-	EXECUTION_REPORT(REPORT_ERROR, -1, remap_strategy != NULL && data_grid_src != NULL && data_grid_dst != NULL, "C-Coupler error in Remap_weight_of_strategy_class::Remap_weight_of_strategy_class");
+    EXECUTION_REPORT(REPORT_ERROR, -1, remap_strategy != NULL && data_grid_src != NULL && data_grid_dst != NULL, "C-Coupler error in Remap_weight_of_strategy_class::Remap_weight_of_strategy_class");
 
-	return search_or_add_remap_weight_of_strategy(data_grid_src, data_grid_dst, remap_strategy, object_name, input_IO_file_name, weight_IO_format, read_from_io);
+    return search_or_add_remap_weight_of_strategy(data_grid_src, data_grid_dst, remap_strategy, object_name, input_IO_file_name, weight_IO_format, read_from_io);
 }
 
 
@@ -149,6 +149,6 @@ Remap_weight_of_strategy_mgt::~Remap_weight_of_strategy_mgt()
 
 void Remap_weight_of_strategy_mgt::add_remap_weight_of_strategy(Remap_weight_of_strategy_class *remap_weight_of_strategy)
 {
-	remap_weights_of_strategies.push_back(remap_weight_of_strategy);
+    remap_weights_of_strategies.push_back(remap_weight_of_strategy);
 }
 
diff --git a/src/CoR/remap_weight_of_strategy_mgt.h b/src/CoR/remap_weight_of_strategy_mgt.h
old mode 100644
new mode 100755
index 2eb4b37..0d9c1f2
--- a/src/CoR/remap_weight_of_strategy_mgt.h
+++ b/src/CoR/remap_weight_of_strategy_mgt.h
@@ -18,14 +18,14 @@
 
 class Remap_weight_of_operator_mgt
 {
-	private: 
-		std::vector<Remap_weight_of_operator_class *> remap_weights_of_operators;
-
-	public:
-		Remap_weight_of_operator_mgt() {}
-		~Remap_weight_of_operator_mgt();
-		void add_remap_weights_of_operator(Remap_weight_of_operator_class*);
-		Remap_weight_of_operator_class *search_remap_weights_of_operator(Remap_grid_class*, Remap_grid_class*, Remap_operator_basis*);
+    private: 
+        std::vector<Remap_weight_of_operator_class *> remap_weights_of_operators;
+
+    public:
+        Remap_weight_of_operator_mgt() {}
+        ~Remap_weight_of_operator_mgt();
+        void add_remap_weights_of_operator(Remap_weight_of_operator_class*);
+        Remap_weight_of_operator_class *search_remap_weights_of_operator(Remap_grid_class*, Remap_grid_class*, Remap_operator_basis*);
 };
 
 
@@ -39,9 +39,9 @@ class Remap_weight_of_strategy_mgt
         ~Remap_weight_of_strategy_mgt();
         void execute(const char*, Remap_statement_operand **, int);
         Remap_weight_of_strategy_class *search_remap_weight_of_strategy(const char*);
-		Remap_weight_of_strategy_class *search_or_add_remap_weight_of_strategy(Remap_grid_class*, Remap_grid_class*, Remap_strategy_class*, const char*, const char*, const char*, bool);
-		void add_remap_weight_of_strategy(Remap_weight_of_strategy_class *);
-		Remap_weight_of_strategy_class *generate_new_remap_weights(const char*, const char*, const char*, const char*, const char*, const char*, bool);
+        Remap_weight_of_strategy_class *search_or_add_remap_weight_of_strategy(Remap_grid_class*, Remap_grid_class*, Remap_strategy_class*, const char*, const char*, const char*, bool);
+        void add_remap_weight_of_strategy(Remap_weight_of_strategy_class *);
+        Remap_weight_of_strategy_class *generate_new_remap_weights(const char*, const char*, const char*, const char*, const char*, const char*, bool);
 };
 
 #endif
diff --git a/src/CoR/remap_weight_sparse_matrix.cxx b/src/CoR/remap_weight_sparse_matrix.cxx
old mode 100644
new mode 100755
index 44d572c..abbcc7f
--- a/src/CoR/remap_weight_sparse_matrix.cxx
+++ b/src/CoR/remap_weight_sparse_matrix.cxx
@@ -8,6 +8,7 @@
 
 
 #include "cor_global_data.h"
+#include "global_data.h"
 #include "remap_weight_sparse_matrix.h"
 #include "remap_operator_basis.h"
 #include <stdio.h>
@@ -26,27 +27,27 @@ Remap_weight_sparse_matrix::Remap_weight_sparse_matrix(Remap_operator_basis *rem
     this->cells_indexes_dst = cells_indexes_dst;
     this->weight_values = weight_values;
     this->remaped_dst_cells_indexes = remaped_dst_cells_indexes;
-	this->num_remaped_dst_cells_indexes = num_remaped_dst_cells_indexes;
+    this->num_remaped_dst_cells_indexes = num_remaped_dst_cells_indexes;
     
     if (remaped_dst_cells_indexes == NULL) {
-		int *mask = new int [remap_operator->get_dst_grid()->get_grid_size()];
-		for (int i = 0; i < remap_operator->get_dst_grid()->get_grid_size(); i ++)
-			mask[i] = 0;
-		for (int i = 0; i < num_weights; i ++)
-			mask[cells_indexes_dst[i]] = 1;
-		this->num_remaped_dst_cells_indexes = 0;
-		for (int i = 0; i < remap_operator->get_dst_grid()->get_grid_size(); i ++)
-			if (mask[i] == 1)
-				this->num_remaped_dst_cells_indexes ++;
-		this->remaped_dst_cells_indexes = new long [this->num_remaped_dst_cells_indexes];
+        int *mask = new int [remap_operator->get_dst_grid()->get_grid_size()];
+        for (int i = 0; i < remap_operator->get_dst_grid()->get_grid_size(); i ++)
+            mask[i] = 0;
+        for (int i = 0; i < num_weights; i ++)
+            mask[cells_indexes_dst[i]] = 1;
         this->num_remaped_dst_cells_indexes = 0;
-		for (int i = 0; i < remap_operator->get_dst_grid()->get_grid_size(); i ++)
-			if (mask[i] == 1)
-				this->remaped_dst_cells_indexes[this->num_remaped_dst_cells_indexes ++] = i;
-		delete [] mask;
+        for (int i = 0; i < remap_operator->get_dst_grid()->get_grid_size(); i ++)
+            if (mask[i] == 1)
+                this->num_remaped_dst_cells_indexes ++;
+        this->remaped_dst_cells_indexes = new long [this->num_remaped_dst_cells_indexes];
+        this->num_remaped_dst_cells_indexes = 0;
+        for (int i = 0; i < remap_operator->get_dst_grid()->get_grid_size(); i ++)
+            if (mask[i] == 1)
+                this->remaped_dst_cells_indexes[this->num_remaped_dst_cells_indexes ++] = i;
+        delete [] mask;
     }
 
-	this->remaped_dst_cells_indexes_array_size = this->num_remaped_dst_cells_indexes;
+    this->remaped_dst_cells_indexes_array_size = this->num_remaped_dst_cells_indexes;
 }
 
 
@@ -88,11 +89,11 @@ void Remap_weight_sparse_matrix::add_weights(long *indexes_src, long index_dst,
     long i, new_array_size;
 
 
-	if (is_real_weight) {
-		for (i = 0; i < num_added_weights; i ++)
-			EXECUTION_REPORT(REPORT_ERROR, -1, indexes_src[i] >= 0 && indexes_src[i] < remap_operator->get_src_grid()->get_grid_size(), "C-Coupler error1 in add_weights of Remap_weight_sparse_matrix");
-		EXECUTION_REPORT(REPORT_ERROR, -1, remap_operator->get_dst_grid() != NULL && index_dst >= 0 && index_dst < remap_operator->get_dst_grid()->get_grid_size(), "C-Coupler error2 in add_weights of Remap_weight_sparse_matrix");
-	}
+    if (is_real_weight) {
+        for (i = 0; i < num_added_weights; i ++)
+            EXECUTION_REPORT(REPORT_ERROR, -1, indexes_src[i] >= 0 && indexes_src[i] < remap_operator->get_src_grid()->get_grid_size(), "C-Coupler error1 in add_weights of Remap_weight_sparse_matrix");
+        EXECUTION_REPORT(REPORT_ERROR, -1, remap_operator->get_dst_grid() != NULL && index_dst >= 0 && index_dst < remap_operator->get_dst_grid()->get_grid_size(), "C-Coupler error2 in add_weights of Remap_weight_sparse_matrix");
+    }
     
     if (num_weights + num_added_weights > weight_arrays_size) {
         new_array_size = 2 * (num_weights+num_added_weights);
@@ -135,14 +136,14 @@ void Remap_weight_sparse_matrix::add_weights(long *indexes_src, long index_dst,
 
 void Remap_weight_sparse_matrix::get_weight(long *index_src, long *index_dst, double *weight_value, int index_weight)
 {
-	EXECUTION_REPORT(REPORT_ERROR, -1, index_weight >= 0 && index_weight < num_weights, "software error when get remapping weight of sparse matrix\n");
-	*index_src = cells_indexes_src[index_weight];
-	*index_dst = cells_indexes_dst[index_weight];
-	*weight_value = weight_values[index_weight];
+    EXECUTION_REPORT_ERROR_OPTIONALLY(REPORT_ERROR, -1, index_weight >= 0 && index_weight < num_weights, "software error when get remapping weight of sparse matrix\n");
+    *index_src = cells_indexes_src[index_weight];
+    *index_dst = cells_indexes_dst[index_weight];
+    *weight_value = weight_values[index_weight];
 }
 
 
-void Remap_weight_sparse_matrix::remap_values(double *data_values_src, double *data_values_dst)
+void Remap_weight_sparse_matrix::remap_values(double *data_values_src, double *data_values_dst, int dst_array_size)
 {
     for (long i = 0; i < num_remaped_dst_cells_indexes; i ++)
         data_values_dst[remaped_dst_cells_indexes[i]] = 0.0;
@@ -248,22 +249,76 @@ Remap_weight_sparse_matrix *Remap_weight_sparse_matrix::generate_parallel_remap_
 
 void Remap_weight_sparse_matrix::compare_to_another_sparse_matrix(Remap_weight_sparse_matrix *another_sparse_matrix)
 {
-	EXECUTION_REPORT(REPORT_ERROR, -1, this->num_weights == another_sparse_matrix->num_weights, "C-Coupler error1 in compare_to_another_sparse_matrix");
-	EXECUTION_REPORT(REPORT_ERROR, -1, this->num_remaped_dst_cells_indexes == another_sparse_matrix->num_remaped_dst_cells_indexes, "C-Coupler error2 in compare_to_another_sparse_matrix");
-
-	for (long i = 0; i < num_weights; i ++) {
-		EXECUTION_REPORT(REPORT_ERROR, -1, this->cells_indexes_src[i] == another_sparse_matrix->cells_indexes_src[i], "C-Coupler error3 in compare_to_another_sparse_matrix");
-		EXECUTION_REPORT(REPORT_ERROR, -1, this->cells_indexes_dst[i] == another_sparse_matrix->cells_indexes_dst[i], "C-Coupler error4 in compare_to_another_sparse_matrix");
-		EXECUTION_REPORT(REPORT_ERROR, -1, this->weight_values[i] == another_sparse_matrix->weight_values[i], "C-Coupler error5 in compare_to_another_sparse_matrix");		
-	}
-	
-	for (long i = 0; i < num_remaped_dst_cells_indexes; i ++)
-		EXECUTION_REPORT(REPORT_ERROR, -1, this->remaped_dst_cells_indexes[i] == another_sparse_matrix->remaped_dst_cells_indexes[i], "C-Coupler error6 in compare_to_another_sparse_matrix");
+    EXECUTION_REPORT(REPORT_ERROR, -1, this->num_weights == another_sparse_matrix->num_weights, "C-Coupler error1 in compare_to_another_sparse_matrix");
+    EXECUTION_REPORT(REPORT_ERROR, -1, this->num_remaped_dst_cells_indexes == another_sparse_matrix->num_remaped_dst_cells_indexes, "C-Coupler error2 in compare_to_another_sparse_matrix");
+
+    for (long i = 0; i < num_weights; i ++) {
+        EXECUTION_REPORT(REPORT_ERROR, -1, this->cells_indexes_src[i] == another_sparse_matrix->cells_indexes_src[i], "C-Coupler error3 in compare_to_another_sparse_matrix");
+        EXECUTION_REPORT(REPORT_ERROR, -1, this->cells_indexes_dst[i] == another_sparse_matrix->cells_indexes_dst[i], "C-Coupler error4 in compare_to_another_sparse_matrix");
+        EXECUTION_REPORT(REPORT_ERROR, -1, this->weight_values[i] == another_sparse_matrix->weight_values[i], "C-Coupler error5 in compare_to_another_sparse_matrix");        
+    }
+    
+    for (long i = 0; i < num_remaped_dst_cells_indexes; i ++)
+        EXECUTION_REPORT(REPORT_ERROR, -1, this->remaped_dst_cells_indexes[i] == another_sparse_matrix->remaped_dst_cells_indexes[i], "C-Coupler error6 in compare_to_another_sparse_matrix");
 }
 
 
 void Remap_weight_sparse_matrix::print()
 {
-	for (int i = 0; i < num_weights; i ++)
-		printf("remapping weight (%d): src_index=%d, dst_index=%d, weight_value=%lf\n", i, cells_indexes_src[i], cells_indexes_dst[i], weight_values[i]);
+    for (int i = 0; i < num_weights; i ++)
+        printf("remapping weight (%d): src_index=%d, dst_index=%d, weight_value=%lf\n", i, cells_indexes_src[i], cells_indexes_dst[i], weight_values[i]);
 }
+
+
+Remap_weight_sparse_matrix *Remap_weight_sparse_matrix::gather(int comp_id)
+{
+	Comp_comm_group_mgt_node *comp_node = comp_comm_group_mgt_mgr->search_global_node(comp_id);
+	long *overall_cells_indexes_src = NULL;
+	long *overall_cells_indexes_dst = NULL;
+	double *overall_wgt_values = NULL;
+	long num_overall_wgts, true_num_overall_wgts, i, j, offset;
+	int *all_array_size = new int [comp_node->get_num_procs()];
+	Remap_weight_sparse_matrix *overall_sparse_matrix = NULL;
+	
+	gather_array_in_one_comp(comp_node->get_num_procs(), comp_node->get_current_proc_local_id(), (void*)cells_indexes_src, num_weights, sizeof(long), all_array_size, (void**)(&overall_cells_indexes_src), num_overall_wgts, comp_node->get_comm_group());
+	gather_array_in_one_comp(comp_node->get_num_procs(), comp_node->get_current_proc_local_id(), (void*)cells_indexes_dst, num_weights, sizeof(long), all_array_size, (void**)(&overall_cells_indexes_dst), num_overall_wgts, comp_node->get_comm_group());
+	gather_array_in_one_comp(comp_node->get_num_procs(), comp_node->get_current_proc_local_id(), (void*)weight_values, num_weights, sizeof(long), all_array_size, (void**)(&overall_wgt_values), num_overall_wgts, comp_node->get_comm_group());
+
+	if (comp_node->get_current_proc_local_id() == 0) {
+		bool *checking_mask = new bool [remap_operator->get_dst_grid()->get_grid_size()];
+		for (i = 0; i < remap_operator->get_dst_grid()->get_grid_size(); i ++)
+			checking_mask[i] = false;		
+		for (i = 0, offset = 0; i < comp_node->get_num_procs(); i ++) {
+			for (j = 0; j < all_array_size[i]; j ++) {
+				EXECUTION_REPORT_ERROR_OPTIONALLY(REPORT_ERROR, -1, overall_cells_indexes_dst[offset+j] >= 0 && overall_cells_indexes_dst[offset+j] < remap_operator->get_dst_grid()->get_grid_size(), "Software error in Remap_weight_sparse_matrix::gather: %ld vs %ld", overall_cells_indexes_dst[offset+j], remap_operator->get_dst_grid()->get_grid_size());
+				if (checking_mask[overall_cells_indexes_dst[offset+j]]) {
+					overall_cells_indexes_dst[offset+j] = -1;
+					overall_cells_indexes_src[offset+j] = -1;
+				}
+			}
+			for (j = 0; j < all_array_size[i]; j ++)
+				if (overall_cells_indexes_dst[offset+j] != -1)
+					checking_mask[overall_cells_indexes_dst[offset+j]] = true;
+			offset += all_array_size[i];
+		}
+		for (i = 0, offset = 0; i < num_overall_wgts; i ++)
+			if (overall_cells_indexes_dst[i] != -1) {
+				overall_cells_indexes_dst[offset] = overall_cells_indexes_dst[i];
+				overall_cells_indexes_src[offset] = overall_cells_indexes_src[i];
+				overall_wgt_values[offset] = overall_wgt_values[i];
+				offset ++;
+			}
+		if (num_overall_wgts != offset)
+			EXECUTION_REPORT_LOG(REPORT_LOG, comp_id, true, "When generating the overall remapping sparse matrix, repeated remapping weights are detected: %ld vs %ld", num_overall_wgts, offset);
+		num_overall_wgts = offset;
+		delete [] checking_mask;
+		
+		overall_sparse_matrix = new Remap_weight_sparse_matrix(remap_operator, num_overall_wgts, overall_cells_indexes_src, overall_cells_indexes_dst, overall_wgt_values, 0, NULL);
+		EXECUTION_REPORT_LOG(REPORT_LOG, comp_id, true, "The overall remapping sparse matrix have %ld weights", num_overall_wgts);
+	}	
+
+	delete [] all_array_size;
+	return overall_sparse_matrix;
+}
+
+
diff --git a/src/CoR/remap_weight_sparse_matrix.h b/src/CoR/remap_weight_sparse_matrix.h
old mode 100644
new mode 100755
index 88b4ca3..f9b39e6
--- a/src/CoR/remap_weight_sparse_matrix.h
+++ b/src/CoR/remap_weight_sparse_matrix.h
@@ -36,8 +36,8 @@ class Remap_weight_sparse_matrix
         ~Remap_weight_sparse_matrix();
         void clear_weights_info();
         void add_weights(long*, long, double*, int, bool);
-		void get_weight(long*, long*, double*, int);
-        void remap_values(double*, double*);
+        void get_weight(long*, long*, double*, int);
+        void remap_values(double*, double*, int);
         void calc_src_decomp(long*, const long*);
         Remap_weight_sparse_matrix *duplicate_remap_weight_of_sparse_matrix();
         Remap_weight_sparse_matrix *generate_parallel_remap_weight_of_sparse_matrix(Remap_grid_class **, int **);
@@ -48,8 +48,9 @@ class Remap_weight_sparse_matrix
         long get_num_remaped_dst_cells_indexes() { return num_remaped_dst_cells_indexes; }
         long *get_remaped_dst_cells_indexes() { return remaped_dst_cells_indexes; }
         double *get_weight_values() { return weight_values; }
-		void compare_to_another_sparse_matrix(Remap_weight_sparse_matrix*);
-		void print();
+        void compare_to_another_sparse_matrix(Remap_weight_sparse_matrix*);
+        void print();
+		Remap_weight_sparse_matrix *gather(int);
 };
 
 
diff --git a/src/CoR/runtime_remap_function.cxx b/src/CoR/runtime_remap_function.cxx
old mode 100644
new mode 100755
index 4a0a4c2..6c35722
--- a/src/CoR/runtime_remap_function.cxx
+++ b/src/CoR/runtime_remap_function.cxx
@@ -19,7 +19,8 @@ Runtime_remap_function::Runtime_remap_function(Remap_grid_class *interchanged_gr
                                           Remap_operator_basis *runtime_remap_operator,
                                           Remap_grid_data_class *remap_field_data_src,
                                           Remap_grid_data_class *remap_field_data_dst,
-                                          Remap_weight_of_strategy_class *remap_weight_of_strategy)
+                                          Remap_weight_of_strategy_class *remap_weight_of_strategy,
+                                          const char *H2D_remapping_wgt_file)
 {
     int num_sized_grids_of_remapping_src, num_sized_grids_of_remapping_dst, num_leaf_grids;
     Remap_grid_class *sized_grids_of_remapping_src[256], *sized_grids_of_remapping_dst[256], *leaf_grids[256];
@@ -40,7 +41,7 @@ Runtime_remap_function::Runtime_remap_function(Remap_grid_class *interchanged_gr
     this->num_remapping_times = interchanged_grid_src->get_grid_size()/remap_operator_runtime_grid_src->get_grid_size();
     this->remap_weight_of_strategy = remap_weight_of_strategy;
     this->last_remapping_time_iter = -1;
-	this->last_remap_weight_of_operator_instance = NULL;
+    this->last_remap_weight_of_operator_instance = NULL;
 
     /* Check the remap software and then set num_sized_grids_of_interchanged_grid,
          sized_grids_of_interchanged_grid, index_size_array, etc */
@@ -74,8 +75,8 @@ Runtime_remap_function::Runtime_remap_function(Remap_grid_class *interchanged_gr
         for (i = 0; i < num_leaf_grids_of_remap_operator_grid_src; i ++) {
             EXECUTION_REPORT(REPORT_ERROR, -1, leaf_grids_of_remap_operator_grid_src[i]->super_grid_of_setting_coord_values != NULL, "remap software error6 in new Runtime_remap_function\n");
             EXECUTION_REPORT(REPORT_ERROR, -1, leaf_grids_of_remap_operator_grid_src[i]->grid_vertex_fields.size() == 1, 
-							 "remap operator %s (%s) requires users to specify vertex coordinate values in source grid %s", 
-							 runtime_remap_operator->get_object_name(), runtime_remap_operator->get_operator_name(), remap_operator_runtime_grid_src->get_grid_name());
+                             "remap operator %s (%s) requires users to specify vertex coordinate values in source grid %s", 
+                             runtime_remap_operator->get_object_name(), runtime_remap_operator->get_operator_name(), remap_operator_runtime_grid_src->get_grid_name());
             if (leaf_grids_of_remap_operator_grid_src[i]->super_grid_of_setting_coord_values->num_dimensions > 1)
                 EXECUTION_REPORT(REPORT_ERROR, -1, !leaf_grids_of_remap_operator_grid_src[i]->super_grid_of_setting_coord_values->are_vertex_values_set_in_default, 
                              "remap operator \"%s\" requires vertex values. The vertex values of \"%s\" in source grid \"%s\" are not given by users\n",
@@ -84,8 +85,8 @@ Runtime_remap_function::Runtime_remap_function(Remap_grid_class *interchanged_gr
                              leaf_grids_of_remap_operator_grid_src[i]->super_grid_of_setting_coord_values->grid_name);
             EXECUTION_REPORT(REPORT_ERROR, -1, leaf_grids_of_remap_operator_grid_dst[i]->super_grid_of_setting_coord_values != NULL, "remap software error8 in new Runtime_remap_function\n");
             EXECUTION_REPORT(REPORT_ERROR, -1, leaf_grids_of_remap_operator_grid_dst[i]->grid_vertex_fields.size() == 1, 
-							 "remap operator %s (%s) requires users to specify vertex coordinate values in target grid %s", 
-							 runtime_remap_operator->get_object_name(), runtime_remap_operator->get_operator_name(), remap_operator_runtime_grid_dst->get_grid_name());
+                             "remap operator %s (%s) requires users to specify vertex coordinate values in target grid %s", 
+                             runtime_remap_operator->get_object_name(), runtime_remap_operator->get_operator_name(), remap_operator_runtime_grid_dst->get_grid_name());
             if (leaf_grids_of_remap_operator_grid_dst[i]->super_grid_of_setting_coord_values->num_dimensions > 1)
                 EXECUTION_REPORT(REPORT_ERROR, -1, !leaf_grids_of_remap_operator_grid_dst[i]->super_grid_of_setting_coord_values->are_vertex_values_set_in_default, 
                              "remap operator \"%s\" requires vertex values. The vertex values of \"%s\" in destination grid \"%s\" are not given by users\n",
@@ -95,8 +96,14 @@ Runtime_remap_function::Runtime_remap_function(Remap_grid_class *interchanged_gr
         }
     }
 
-    runtime_remap_operator_grid_src = new Remap_operator_grid(remap_operator_runtime_grid_src, runtime_remap_operator, true, false);
-    runtime_remap_operator_grid_dst = new Remap_operator_grid(remap_operator_runtime_grid_dst, runtime_remap_operator, false, false);
+	if (runtime_remap_operator->get_src_grid()->get_is_sphere_grid() && H2D_remapping_wgt_file != NULL) {
+		runtime_remap_operator_grid_src = NULL;
+		runtime_remap_operator_grid_dst = NULL;
+	}
+	else {
+	    runtime_remap_operator_grid_src = new Remap_operator_grid(remap_operator_runtime_grid_src, runtime_remap_operator, true, false);
+    	runtime_remap_operator_grid_dst = new Remap_operator_grid(remap_operator_runtime_grid_dst, runtime_remap_operator, false, false);
+	}
 
     if (remap_field_data_dst != NULL && !remap_field_data_dst->have_data_content()) 
         remap_field_data_dst->grid_data_field->initialize_to_fill_value();
@@ -131,8 +138,8 @@ Runtime_remap_function::Runtime_remap_function(Remap_grid_class *interchanged_gr
             super_grid = leaf_grids[i]->super_grid_of_setting_coord_values;
             if (super_grid == NULL)
                 continue;
-			if (super_grid->is_sigma_grid())
-				continue;
+            if (super_grid->is_sigma_grid())
+                continue;
             partial_redundant_mark_field = remap_field_data_redundant_mark_field_src->get_coord_value_grid()->expand_to_generate_full_coord_value(super_grid->redundant_cell_mark_field);
             for (j = 0; j < remap_field_data_redundant_mark_field_src->get_coord_value_grid()->get_grid_size(); j ++) 
                 ((bool*)remap_field_data_redundant_mark_field_src->grid_data_field->data_buf)[j] |= ((bool*)partial_redundant_mark_field->grid_data_field->data_buf)[j];
@@ -150,8 +157,11 @@ Runtime_remap_function::Runtime_remap_function(Remap_grid_class *interchanged_gr
 
 Runtime_remap_function::~Runtime_remap_function()
 {
-    delete runtime_remap_operator_grid_src;
-    delete runtime_remap_operator_grid_dst;
+	if (runtime_remap_operator_grid_src != NULL)
+	    delete runtime_remap_operator_grid_src;
+
+	if (runtime_remap_operator_grid_dst != NULL)
+	    delete runtime_remap_operator_grid_dst;
 
     if (last_mask_values_src)
         delete [] last_mask_values_src;
@@ -164,7 +174,7 @@ Runtime_remap_function::~Runtime_remap_function()
 }
 
 
-void Runtime_remap_function::calculate_static_remapping_weights(long current_remapping_time_iter, const char *H2D_remapping_wgt_file)
+void Runtime_remap_function::calculate_static_remapping_weights(long current_remapping_time_iter, const char *H2D_remapping_wgt_file, int wgt_cal_comp_id, bool outer_mask)
 /*  Calculate static remapping weights and allocate entries for dynamic remapping weights
  */
 {
@@ -172,62 +182,63 @@ void Runtime_remap_function::calculate_static_remapping_weights(long current_rem
     bool mask_values_have_been_changed, coord_values_have_been_changed_src, coord_values_have_been_changed_dst;
     int mask_values_status_src, mask_values_status_dst, redundant_mark_status_src;
     double *current_data_values_src, *current_data_values_dst;
-	bool src_grid_changed = false, dst_grid_changed = false;
+    bool src_grid_changed = false, dst_grid_changed = false;
 
 
-	EXECUTION_REPORT(REPORT_ERROR, -1, remap_weight_of_strategy != NULL, "Software error in Runtime_remap_function::calculate_static_remapping_weights: empty remap_weight_of_strategy");
+    EXECUTION_REPORT(REPORT_ERROR, -1, remap_weight_of_strategy != NULL, "Software error in Runtime_remap_function::calculate_static_remapping_weights: empty remap_weight_of_strategy");
     EXECUTION_REPORT(REPORT_ERROR, -1, current_remapping_time_iter < num_remapping_times, "Software error in Runtime_remap_function::calculate_static_remapping_weights: wrong current_remapping_time_iter. \n");
-	
-	if (runtime_remap_operator->get_src_grid()->has_grid_coord_label(COORD_LABEL_LEV)) {
-		EXECUTION_REPORT(REPORT_ERROR, -1, runtime_remap_operator->get_src_grid()->get_num_dimensions() == 1, "Software error in Runtime_remap_function::calculate_static_remapping_weights: wrong dimension number of a remapping operator with vertical interpolation");
-		if (runtime_remap_operator->get_src_grid()->get_a_leaf_grid_of_sigma_or_hybrid() || runtime_remap_operator->get_dst_grid()->get_a_leaf_grid_of_sigma_or_hybrid()) {
-	        last_remap_weight_of_operator_instance = remap_weight_of_strategy->add_remap_weight_of_operator_instance(interchanged_grid_src, interchanged_grid_dst, current_remapping_time_iter, runtime_remap_operator);
-			return;
-		}
-	}
-	
-	current_runtime_remap_operator_grid_src = runtime_remap_operator_grid_src;
-	current_runtime_remap_operator_grid_dst = runtime_remap_operator_grid_dst;
+    
+    if (runtime_remap_operator->get_src_grid()->has_grid_coord_label(COORD_LABEL_LEV)) {
+        EXECUTION_REPORT(REPORT_ERROR, -1, runtime_remap_operator->get_src_grid()->get_num_dimensions() == 1, "Software error in Runtime_remap_function::calculate_static_remapping_weights: wrong dimension number of a remapping operator with vertical interpolation");
+        if (runtime_remap_operator->get_src_grid()->get_a_leaf_grid_of_sigma_or_hybrid() || runtime_remap_operator->get_dst_grid()->get_a_leaf_grid_of_sigma_or_hybrid() || runtime_remap_operator->get_src_grid()->does_use_V3D_level_coord() || runtime_remap_operator->get_dst_grid()->does_use_V3D_level_coord()) {
+			//if (outer_mask)
+	            last_remap_weight_of_operator_instance = remap_weight_of_strategy->add_remap_weight_of_operator_instance(interchanged_grid_src, interchanged_grid_dst, current_remapping_time_iter, runtime_remap_operator);
+            return;
+        }
+    }
+    
+    current_runtime_remap_operator_grid_src = runtime_remap_operator_grid_src;
+    current_runtime_remap_operator_grid_dst = runtime_remap_operator_grid_dst;
     current_runtime_remap_operator = runtime_remap_operator;
 
-	if (current_remapping_time_iter == 0) {
-		src_grid_changed = true;
-		dst_grid_changed = true;
-	}
+    if (current_remapping_time_iter == 0) {
+        src_grid_changed = true;
+        dst_grid_changed = true;
+    }
 
     if (remap_field_data_redundant_mark_field_src != NULL) {
         extract_runtime_field(remap_operator_runtime_grid_src, remap_field_data_redundant_mark_field_src, remap_operator_runtime_grid_src->redundant_cell_mark_field, current_remapping_time_iter);
-		if (!check_mask_values_status(last_redundant_mark_src, current_redundant_mark_src, remap_operator_runtime_grid_src->grid_size))
-			src_grid_changed = true;
+        if (!check_mask_values_status(last_redundant_mark_src, current_redundant_mark_src, remap_operator_runtime_grid_src->grid_size))
+            src_grid_changed = true;
     }
     /* Extract the runtime grid field data for runtime remapping */
     extract_runtime_field(remap_operator_runtime_grid_src, remap_operator_runtime_grid_src->original_grid_mask_field, remap_operator_runtime_grid_src->grid_mask_field, current_remapping_time_iter);
     extract_runtime_field(remap_operator_runtime_grid_dst, remap_operator_runtime_grid_dst->original_grid_mask_field, remap_operator_runtime_grid_dst->grid_mask_field, current_remapping_time_iter);
-	if (!check_mask_values_status(last_mask_values_src, current_mask_values_src, remap_operator_runtime_grid_src->grid_size)) 
-		src_grid_changed = true;
-	if (!check_mask_values_status(last_mask_values_dst, current_mask_values_dst, remap_operator_runtime_grid_dst->grid_size))
-		dst_grid_changed = true;
+    if (!check_mask_values_status(last_mask_values_src, current_mask_values_src, remap_operator_runtime_grid_src->grid_size)) 
+        src_grid_changed = true;
+    if (!check_mask_values_status(last_mask_values_dst, current_mask_values_dst, remap_operator_runtime_grid_dst->grid_size))
+        dst_grid_changed = true;
     
     if (src_grid_changed || dst_grid_changed) {
-		if (runtime_remap_operator->get_src_grid()->get_is_sphere_grid() && H2D_remapping_wgt_file != NULL) {
-			EXECUTION_REPORT_LOG(REPORT_LOG, -1, true, "should use remap weight file \"%s\" for operator from grid %s to grid %s\n", H2D_remapping_wgt_file, runtime_remap_operator->get_src_grid()->get_grid_name(), runtime_remap_operator->get_dst_grid()->get_grid_name());
-			H2D_remapping_wgt_file_info *wgt_file_info = all_H2D_remapping_wgt_files_info->search_wgt_file_info(H2D_remapping_wgt_file);
-			EXECUTION_REPORT(REPORT_ERROR, -1, wgt_file_info != NULL, "Software error in Runtime_remap_function::calculate_static_remapping_weights: empty wgt_matrix");
-	        Remap_weight_sparse_matrix *wgt_matrix = new Remap_weight_sparse_matrix(runtime_remap_operator, wgt_file_info->get_num_wgts(), wgt_file_info->get_wgts_src_indexes(), wgt_file_info->get_wgts_dst_indexes(), wgt_file_info->get_wgts_values(), 0, NULL);
-			runtime_remap_operator->update_unique_weight_sparse_matrix(wgt_matrix);
-		}
-		else {
-			EXECUTION_REPORT_LOG(REPORT_LOG, -1, true, "should generate remap weight file for operator from grid \"%s\" to grid \"%s\" for interpolation from grid \"%s\" to grid \"%s\"\n", runtime_remap_operator->get_src_grid()->get_grid_name(), runtime_remap_operator->get_dst_grid()->get_grid_name(), interchanged_grid_src->get_grid_name(), interchanged_grid_dst->get_grid_name());
-			if (src_grid_changed)
-				runtime_remap_operator_grid_src->update_operator_grid_data();
-			if (dst_grid_changed)
-				runtime_remap_operator_grid_dst->update_operator_grid_data();
-			runtime_remap_operator->calculate_remap_weights();
-		}
+        if (runtime_remap_operator->get_src_grid()->get_is_sphere_grid() && H2D_remapping_wgt_file != NULL) {
+            H2D_remapping_wgt_file_info *wgt_file_info = all_H2D_remapping_wgt_files_info->search_wgt_file_info(H2D_remapping_wgt_file);
+			EXECUTION_REPORT_ERROR_OPTIONALLY(REPORT_ERROR, -1, wgt_cal_comp_id != -1, "Software error in Runtime_remap_function::calculate_static_remapping_weights");
+			wgt_file_info->read_remapping_weights(wgt_cal_comp_id);
+            EXECUTION_REPORT_ERROR_OPTIONALLY(REPORT_ERROR, -1, wgt_file_info != NULL && (wgt_file_info->get_num_wgts() == 0 || wgt_file_info->get_wgts_src_indexes() != NULL && wgt_file_info->get_wgts_dst_indexes() != NULL), "Software error in Runtime_remap_function::calculate_static_remapping_weights: empty wgt_matrix");
+            Remap_weight_sparse_matrix *wgt_matrix = new Remap_weight_sparse_matrix(runtime_remap_operator, wgt_file_info->get_num_wgts(), wgt_file_info->get_wgts_src_indexes(), wgt_file_info->get_wgts_dst_indexes(), wgt_file_info->get_wgts_values(), 0, NULL);
+            runtime_remap_operator->update_unique_weight_sparse_matrix(wgt_matrix);
+        }
+        else {
+            if (src_grid_changed)
+                runtime_remap_operator_grid_src->update_operator_grid_data();
+            if (dst_grid_changed)
+                runtime_remap_operator_grid_dst->update_operator_grid_data();
+            runtime_remap_operator->calculate_remap_weights();
+        }
         last_remapping_time_iter = current_remapping_time_iter;
         last_remap_weight_of_operator_instance = remap_weight_of_strategy->add_remap_weight_of_operator_instance(interchanged_grid_src, interchanged_grid_dst, current_remapping_time_iter, runtime_remap_operator);
     }
-	else last_remap_weight_of_operator_instance->renew_remapping_time_end_iter(current_remapping_time_iter);
+    else last_remap_weight_of_operator_instance->renew_remapping_time_end_iter(current_remapping_time_iter);
 }
 
 
@@ -236,12 +247,12 @@ void Runtime_remap_function::extract_runtime_field(Remap_grid_class *remap_opera
     if (global_field != NULL) {
         EXECUTION_REPORT(REPORT_ERROR, -1, operator_field != NULL, "remap software error8 in new extract_runtime_field\n");
         check_dimension_order_of_grid_field(global_field, remap_operator_runtime_grid);
-		long grid_field_size = operator_field->grid_data_field->required_data_size;
-		char *data_buf_global = (char*) global_field->grid_data_field->data_buf;
-		char *data_buf_runtime = (char*) operator_field->grid_data_field->data_buf;
-		memcpy(data_buf_runtime, 
-			   data_buf_global+current_remapping_time_iter*grid_field_size*get_data_type_size(operator_field->grid_data_field->data_type_in_application),
-			   grid_field_size*get_data_type_size(operator_field->grid_data_field->data_type_in_application));
+        long grid_field_size = operator_field->grid_data_field->required_data_size;
+        char *data_buf_global = (char*) global_field->grid_data_field->data_buf;
+        char *data_buf_runtime = (char*) operator_field->grid_data_field->data_buf;
+        memcpy(data_buf_runtime, 
+               data_buf_global+current_remapping_time_iter*grid_field_size*get_data_type_size(operator_field->grid_data_field->data_type_in_application),
+               grid_field_size*get_data_type_size(operator_field->grid_data_field->data_type_in_application));
     }
 }
 
@@ -259,7 +270,7 @@ bool Runtime_remap_function::check_mask_values_status(bool *last_mask_values, bo
         if (last_mask_values[i] != current_mask_values[i]) {
             result = false;
         }
-		last_mask_values[i] = current_mask_values[i];
+        last_mask_values[i] = current_mask_values[i];
     }
 
     return result;
diff --git a/src/CoR/runtime_remap_function.h b/src/CoR/runtime_remap_function.h
old mode 100644
new mode 100755
index 55a9434..9010992
--- a/src/CoR/runtime_remap_function.h
+++ b/src/CoR/runtime_remap_function.h
@@ -30,7 +30,7 @@ class Runtime_remap_function
         Remap_grid_data_class *remap_field_data_dst;
         Remap_grid_data_class *remap_field_data_redundant_mark_field_src;
         Remap_weight_of_strategy_class *remap_weight_of_strategy;
-		Remap_weight_of_operator_instance_class *last_remap_weight_of_operator_instance;
+        Remap_weight_of_operator_instance_class *last_remap_weight_of_operator_instance;
         int num_sized_grids_of_interchanged_grid;
         int num_leaf_grids_of_remap_operator_grid_src;
         int num_leaf_grids_of_remap_operator_grid_dst;
@@ -53,8 +53,8 @@ class Runtime_remap_function
         void check_dimension_order_of_grid_field(Remap_grid_data_class*, Remap_grid_class*);
         
     public:
-        Runtime_remap_function(Remap_grid_class*, Remap_grid_class*, Remap_grid_class*, Remap_grid_class*, Remap_operator_basis*, Remap_grid_data_class*, Remap_grid_data_class*, Remap_weight_of_strategy_class*);
-        void calculate_static_remapping_weights(long, const char*);
+        Runtime_remap_function(Remap_grid_class*, Remap_grid_class*, Remap_grid_class*, Remap_grid_class*, Remap_operator_basis*, Remap_grid_data_class*, Remap_grid_data_class*, Remap_weight_of_strategy_class*, const char*);
+        void calculate_static_remapping_weights(long, const char*, int, bool);
         ~Runtime_remap_function();
 };
 
diff --git a/src/CoR/syntax_check.cxx b/src/CoR/syntax_check.cxx
old mode 100644
new mode 100755
diff --git a/src/CoR/syntax_check.h b/src/CoR/syntax_check.h
old mode 100644
new mode 100755
diff --git a/src/Data_MGT/IO_field_mgt.cxx b/src/Data_MGT/IO_field_mgt.cxx
old mode 100644
new mode 100755
index deed0b3..bf6b35e
--- a/src/Data_MGT/IO_field_mgt.cxx
+++ b/src/Data_MGT/IO_field_mgt.cxx
@@ -13,333 +13,333 @@
 
 IO_field::IO_field(int IO_field_id, int field_instance_id, const char *field_IO_name, const char *annotation)
 {
-	this->IO_field_id = IO_field_id;
-
-	Field_mem_info *field_inst = memory_manager->get_field_instance(field_instance_id);
-	this->comp_id = field_inst->get_comp_id();
-	this->field_instance_id = field_instance_id;
-	if (strlen(field_IO_name) > 0) {
-		strcpy(this->field_IO_name, field_IO_name);
-		check_and_verify_name_format_of_string_for_API(this->comp_id, field_IO_name, API_ID_FIELD_MGT_REG_IO_FIELD_from_INST, "name of the I/O field in the data file", annotation);
-	}
-	else strcpy(this->field_IO_name, field_inst->get_field_name());
-	strcpy(this->field_long_name, fields_info->search_field_info(field_inst->get_field_name())->field_long_name);
-	strcpy(this->field_unit, field_inst->get_unit());
+    this->IO_field_id = IO_field_id;
+
+    Field_mem_info *field_inst = memory_manager->get_field_instance(field_instance_id);
+    this->comp_id = field_inst->get_comp_id();
+    this->field_instance_id = field_instance_id;
+    if (strlen(field_IO_name) > 0) {
+        strcpy(this->field_IO_name, field_IO_name);
+        check_and_verify_name_format_of_string_for_API(this->comp_id, field_IO_name, API_ID_FIELD_MGT_REG_IO_FIELD_from_INST, "name of the I/O field in the data file", annotation);
+    }
+    else strcpy(this->field_IO_name, field_inst->get_field_name());
+    strcpy(this->field_long_name, fields_info->search_field_info(field_inst->get_field_name())->field_long_name);
+    strcpy(this->field_unit, field_inst->get_unit());
 }
 
 
 IO_field::IO_field(int IO_field_id, int comp_or_grid_id, int decomp_id, int field_size, void *data_buffer, const char * field_IO_name, const char *long_name, const char *unit, const char *data_type, const char * annotation)
 {
-	Field_mem_info *field_mem;
+    Field_mem_info *field_mem;
 
 
-	this->IO_field_id = IO_field_id;
-	check_and_verify_name_format_of_string_for_API(this->comp_id, field_IO_name, API_ID_FIELD_MGT_REG_IO_FIELD_from_BUFFER, "name of the I/O field in the data file", annotation);
-	strcpy(this->field_IO_name, field_IO_name);
-	strcpy(this->field_unit, unit);
-	strcpy(this->field_long_name, long_name);
+    this->IO_field_id = IO_field_id;
+    check_and_verify_name_format_of_string_for_API(this->comp_id, field_IO_name, API_ID_FIELD_MGT_REG_IO_FIELD_from_BUFFER, "name of the I/O field in the data file", annotation);
+    strcpy(this->field_IO_name, field_IO_name);
+    strcpy(this->field_unit, unit);
+    strcpy(this->field_long_name, long_name);
 
-	if (decomp_id == -1) {
-		EXECUTION_REPORT(REPORT_ERROR, -1, comp_comm_group_mgt_mgr->is_legal_local_comp_id(comp_or_grid_id,true), "The parameter of component id when calling the CCPL interface \"CCPL_register_IO_field\" for registering IO field \"%s\" is wrong. Please verify the model code with the annotation \"%s\"", field_IO_name, annotation);
-		this->comp_id = comp_or_grid_id;
-	}
-	else {
-		EXECUTION_REPORT(REPORT_ERROR, -1, decomps_info_mgr->is_decomp_id_legal(decomp_id), "The parameter of decomposition id when calling the CCPL interface \"CCPL_register_IO_field\" for registering IO field \"%s\" is wrong. Please verify the model code with the annotation \"%s\"", field_IO_name, annotation);
-		this->comp_id = decomps_info_mgr->get_decomp_info(decomp_id)->get_comp_id();
-		EXECUTION_REPORT(REPORT_ERROR, comp_id, original_grid_mgr->is_grid_id_legal(comp_or_grid_id), "The parameter of grid id when calling the CCPL interface \"CCPL_register_IO_field\" for registering IO field \"%s\" is wrong. Please verify the model code with the annotation \"%s\"", field_IO_name, annotation);
-		EXECUTION_REPORT(REPORT_ERROR, comp_id, original_grid_mgr->get_comp_id_of_grid(comp_or_grid_id), "The parameters of grid id and decomposition id when calling the CCPL interface \"CCPL_register_IO_field\" for registering IO field \"%s\" do not belong to the same component. Please verify the model code with the annotation \"%s\"", field_IO_name, annotation);
-	}
+    if (decomp_id == -1) {
+        EXECUTION_REPORT(REPORT_ERROR, -1, comp_comm_group_mgt_mgr->is_legal_local_comp_id(comp_or_grid_id,true), "The parameter of component id when calling the CCPL interface \"CCPL_register_IO_field\" for registering IO field \"%s\" is wrong. Please verify the model code with the annotation \"%s\"", field_IO_name, annotation);
+        this->comp_id = comp_or_grid_id;
+    }
+    else {
+        EXECUTION_REPORT(REPORT_ERROR, -1, decomps_info_mgr->is_decomp_id_legal(decomp_id), "The parameter of decomposition id when calling the CCPL interface \"CCPL_register_IO_field\" for registering IO field \"%s\" is wrong. Please verify the model code with the annotation \"%s\"", field_IO_name, annotation);
+        this->comp_id = decomps_info_mgr->get_decomp_info(decomp_id)->get_comp_id();
+        EXECUTION_REPORT(REPORT_ERROR, comp_id, original_grid_mgr->is_grid_id_legal(comp_or_grid_id), "The parameter of grid id when calling the CCPL interface \"CCPL_register_IO_field\" for registering IO field \"%s\" is wrong. Please verify the model code with the annotation \"%s\"", field_IO_name, annotation);
+        EXECUTION_REPORT(REPORT_ERROR, comp_id, original_grid_mgr->get_comp_id_of_grid(comp_or_grid_id), "The parameters of grid id and decomposition id when calling the CCPL interface \"CCPL_register_IO_field\" for registering IO field \"%s\" do not belong to the same component. Please verify the model code with the annotation \"%s\"", field_IO_name, annotation);
+    }
 
-	EXECUTION_REPORT(REPORT_ERROR, comp_id, strlen(field_IO_name) > 0, "The parameter of field I/O name when calling the CCPL interface \"CCPL_register_IO_field\" is empty. Please verify the model code with the annotation \"%s\"", annotation);
+    EXECUTION_REPORT(REPORT_ERROR, comp_id, strlen(field_IO_name) > 0, "The parameter of field I/O name when calling the CCPL interface \"CCPL_register_IO_field\" is empty. Please verify the model code with the annotation \"%s\"", annotation);
 
-	field_instance_id = memory_manager->register_external_field_instance(field_IO_name, data_buffer, field_size, decomp_id, comp_or_grid_id, BUF_MARK_IO_FIELD_REG, REG_FIELD_TAG_REST, unit, data_type, annotation);
+    field_instance_id = memory_manager->register_external_field_instance(field_IO_name, data_buffer, field_size, decomp_id, comp_or_grid_id, BUF_MARK_IO_FIELD_REG, REG_FIELD_TAG_REST, unit, data_type, annotation);
 
-	EXECUTION_REPORT(REPORT_ERROR, comp_id, strlen(field_IO_name) > 0, "The parameter of field I/O name when calling the CCPL interface \"CCPL_register_IO_field\" cannot be an empty string. Please verify the model code with the annotation \"%s\"", annotation);
-	EXECUTION_REPORT(REPORT_ERROR, comp_id, strlen(long_name) > 0, "The parameter of long name of the I/O field \"%s\" when calling the CCPL interface \"CCPL_register_IO_field\" cannot be an empty string. Please verify the model code with the annotation \"%s\"", field_IO_name, annotation);
-	EXECUTION_REPORT(REPORT_ERROR, comp_id, strlen(unit) > 0, "The parameter of unit of the I/O field \"%s\" when calling the CCPL interface \"CCPL_register_IO_field\" cannot be an empty string. Please verify the model code with the annotation \"%s\"", field_IO_name, annotation);
+    EXECUTION_REPORT(REPORT_ERROR, comp_id, strlen(field_IO_name) > 0, "The parameter of field I/O name when calling the CCPL interface \"CCPL_register_IO_field\" cannot be an empty string. Please verify the model code with the annotation \"%s\"", annotation);
+    EXECUTION_REPORT(REPORT_ERROR, comp_id, strlen(long_name) > 0, "The parameter of long name of the I/O field \"%s\" when calling the CCPL interface \"CCPL_register_IO_field\" cannot be an empty string. Please verify the model code with the annotation \"%s\"", field_IO_name, annotation);
+    EXECUTION_REPORT(REPORT_ERROR, comp_id, strlen(unit) > 0, "The parameter of unit of the I/O field \"%s\" when calling the CCPL interface \"CCPL_register_IO_field\" cannot be an empty string. Please verify the model code with the annotation \"%s\"", field_IO_name, annotation);
 }
 
 
 IO_field *IO_field_mgt::search_IO_field(int comp_id, const char *field_IO_name)
 {
-	for (int i = 0; i < IO_fields.size(); i ++)
-		if (IO_fields[i]->get_comp_id() == comp_id && words_are_the_same(IO_fields[i]->get_field_IO_name(), field_IO_name))
-			return IO_fields[i];
+    for (int i = 0; i < IO_fields.size(); i ++)
+        if (IO_fields[i]->get_comp_id() == comp_id && words_are_the_same(IO_fields[i]->get_field_IO_name(), field_IO_name))
+            return IO_fields[i];
 
-	return NULL;
+    return NULL;
 }
 
 
 void IO_field_mgt::check_for_registering_IO_field(IO_field *new_IO_field, const char *annotation, int API_id)
 {
-	IO_field *existing_field = search_IO_field(new_IO_field->get_comp_id(), new_IO_field->get_field_IO_name());
-	if (existing_field != NULL)
-		EXECUTION_REPORT(REPORT_ERROR, new_IO_field->get_comp_id(), false, "IO field \"%s\" has been registered before (the corresponding model code annotation is \"%s\"). It cannot be registered again at the model code with the annotation \"%s\"",
-		                 new_IO_field->get_field_IO_name(), annotation_mgr->get_annotation(existing_field->get_IO_field_id(), "registering I/O field"), annotation);
-	annotation_mgr->add_annotation(new_IO_field->get_IO_field_id(), "registering I/O field", annotation);
-	synchronize_comp_processes_for_API(new_IO_field->get_comp_id(), API_id, comp_comm_group_mgt_mgr->get_comm_group_of_local_comp(new_IO_field->get_comp_id(),""), "registering an I/O field", annotation);
-	IO_fields.push_back(new_IO_field);
+    IO_field *existing_field = search_IO_field(new_IO_field->get_comp_id(), new_IO_field->get_field_IO_name());
+    if (existing_field != NULL)
+        EXECUTION_REPORT(REPORT_ERROR, new_IO_field->get_comp_id(), false, "IO field \"%s\" has been registered before (the corresponding model code annotation is \"%s\"). It cannot be registered again at the model code with the annotation \"%s\"",
+                         new_IO_field->get_field_IO_name(), annotation_mgr->get_annotation(existing_field->get_IO_field_id(), "registering I/O field"), annotation);
+    annotation_mgr->add_annotation(new_IO_field->get_IO_field_id(), "registering I/O field", annotation);
+    synchronize_comp_processes_for_API(new_IO_field->get_comp_id(), API_id, comp_comm_group_mgt_mgr->get_comm_group_of_local_comp(new_IO_field->get_comp_id(),""), "registering an I/O field", annotation);
+    IO_fields.push_back(new_IO_field);
 }
 
 
 IO_field_mgt::~IO_field_mgt()
 {
-	for (int i = 0; i < IO_fields.size(); i ++)
-		delete IO_fields[i];
+    for (int i = 0; i < IO_fields.size(); i ++)
+        delete IO_fields[i];
 }
 
 
 int IO_field_mgt::register_IO_field(int field_instance_id, const char *field_IO_name, const char *annotation)
 {
-	int IO_field_id = TYPE_IO_FIELD_PREFIX | IO_fields.size();
-	IO_field *new_IO_field = new IO_field(IO_field_id, field_instance_id, field_IO_name, annotation);
-	check_for_registering_IO_field(new_IO_field, annotation, API_ID_FIELD_MGT_REG_IO_FIELD_from_INST);
-	check_API_parameter_field_instance(new_IO_field->get_comp_id(), API_ID_FIELD_MGT_REG_IO_FIELD_from_INST, comp_comm_group_mgt_mgr->get_comm_group_of_local_comp(new_IO_field->get_comp_id(),""), "registering an I/O field", new_IO_field->get_field_instance_id(), "field_inst_id", annotation);
-	return IO_field_id;
+    int IO_field_id = TYPE_IO_FIELD_PREFIX | IO_fields.size();
+    IO_field *new_IO_field = new IO_field(IO_field_id, field_instance_id, field_IO_name, annotation);
+    check_for_registering_IO_field(new_IO_field, annotation, API_ID_FIELD_MGT_REG_IO_FIELD_from_INST);
+    check_API_parameter_field_instance(new_IO_field->get_comp_id(), API_ID_FIELD_MGT_REG_IO_FIELD_from_INST, comp_comm_group_mgt_mgr->get_comm_group_of_local_comp(new_IO_field->get_comp_id(),""), "registering an I/O field", new_IO_field->get_field_instance_id(), "field_inst_id", annotation);
+    return IO_field_id;
 }
 
 
 int IO_field_mgt::register_IO_fields(int num_field_inst, int size_field_inst_ids, int *field_inst_ids, const char *annotation)
 {
-	int comp_id = memory_manager->get_field_instance(field_inst_ids[0])->get_comp_id();
-	MPI_Comm comm = comp_comm_group_mgt_mgr->get_comm_group_of_local_comp(comp_id,"");
-
-
-	comp_comm_group_mgt_mgr->confirm_coupling_configuration_active(comp_id, API_ID_FIELD_MGT_REG_IO_FIELDs_from_INSTs, true, annotation);
-	EXECUTION_REPORT(REPORT_ERROR, comp_id, num_field_inst <= size_field_inst_ids, "Error happers when calling the API \"CCPL_register_IO_fields_from_field_instances\": the array size of the parameter \"field_inst_ids\" cannot be smaller than the parameter \"num_field_inst\". Please check the model code with the annotation \"%s\".", annotation);
-	for (int i = 1; i < num_field_inst; i ++)
-		EXECUTION_REPORT(REPORT_ERROR, comp_id, comp_id == memory_manager->get_field_instance(field_inst_ids[i])->get_comp_id(), "Error happers when calling the API \"CCPL_register_IO_fields_from_field_instances\": the field instances specified by the parameter \"field_inst_ids\" do not correspond to the same component model. Please check the model code with the annotation \"%s\".", annotation);
-	synchronize_comp_processes_for_API(comp_id, API_ID_FIELD_MGT_REG_IO_FIELDs_from_INSTs, comp_comm_group_mgt_mgr->get_comm_group_of_local_comp(comp_id,""), "registering I/O fields", annotation);
-	check_API_parameter_int(comp_id, API_ID_FIELD_MGT_REG_IO_FIELDs_from_INSTs, comm, NULL, num_field_inst, "\"num_field_inst\"", annotation);
-	for (int i = 0; i < num_field_inst; i ++)
-		check_API_parameter_field_instance(comp_id, API_ID_FIELD_MGT_REG_IO_FIELDs_from_INSTs, comm, "registering I/O fields", field_inst_ids[i], "field_inst_ids (detailed field instances)", annotation);	
-	for (int i = 0; i < num_field_inst; i ++)
-		IO_fields.push_back(new IO_field(TYPE_IO_FIELD_PREFIX|IO_fields.size(), field_inst_ids[i], memory_manager->get_field_instance(field_inst_ids[i])->get_field_name(), annotation));
-	
-	return 0;
+    int comp_id = memory_manager->get_field_instance(field_inst_ids[0])->get_comp_id();
+    MPI_Comm comm = comp_comm_group_mgt_mgr->get_comm_group_of_local_comp(comp_id,"");
+
+
+    comp_comm_group_mgt_mgr->confirm_coupling_configuration_active(comp_id, API_ID_FIELD_MGT_REG_IO_FIELDs_from_INSTs, true, annotation);
+    EXECUTION_REPORT(REPORT_ERROR, comp_id, num_field_inst <= size_field_inst_ids, "Error happers when calling the API \"CCPL_register_IO_fields_from_field_instances\": the array size of the parameter \"field_inst_ids\" cannot be smaller than the parameter \"num_field_inst\". Please check the model code with the annotation \"%s\".", annotation);
+    for (int i = 1; i < num_field_inst; i ++)
+        EXECUTION_REPORT(REPORT_ERROR, comp_id, comp_id == memory_manager->get_field_instance(field_inst_ids[i])->get_comp_id(), "Error happers when calling the API \"CCPL_register_IO_fields_from_field_instances\": the field instances specified by the parameter \"field_inst_ids\" do not correspond to the same component model. Please check the model code with the annotation \"%s\".", annotation);
+    synchronize_comp_processes_for_API(comp_id, API_ID_FIELD_MGT_REG_IO_FIELDs_from_INSTs, comp_comm_group_mgt_mgr->get_comm_group_of_local_comp(comp_id,""), "registering I/O fields", annotation);
+    check_API_parameter_int(comp_id, API_ID_FIELD_MGT_REG_IO_FIELDs_from_INSTs, comm, NULL, num_field_inst, "\"num_field_inst\"", annotation);
+    for (int i = 0; i < num_field_inst; i ++)
+        check_API_parameter_field_instance(comp_id, API_ID_FIELD_MGT_REG_IO_FIELDs_from_INSTs, comm, "registering I/O fields", field_inst_ids[i], "field_inst_ids (detailed field instances)", annotation);    
+    for (int i = 0; i < num_field_inst; i ++)
+        IO_fields.push_back(new IO_field(TYPE_IO_FIELD_PREFIX|IO_fields.size(), field_inst_ids[i], memory_manager->get_field_instance(field_inst_ids[i])->get_field_name(), annotation));
+    
+    return 0;
 }
 
 
 int IO_field_mgt::register_IO_field(int comp_or_grid_id, int decomp_id, int field_size, void *data_buffer, const char * field_IO_name, const char *long_name, const char *unit, const char *data_type, const char * annotation)
 {
-	int IO_field_id = TYPE_IO_FIELD_PREFIX | IO_fields.size();
-	IO_field *new_IO_field = new IO_field(IO_field_id, comp_or_grid_id, decomp_id, field_size, data_buffer, field_IO_name, long_name, unit, data_type, annotation);
-	check_for_registering_IO_field(new_IO_field, annotation, API_ID_FIELD_MGT_REG_IO_FIELD_from_BUFFER);
-	return IO_field_id;
+    int IO_field_id = TYPE_IO_FIELD_PREFIX | IO_fields.size();
+    IO_field *new_IO_field = new IO_field(IO_field_id, comp_or_grid_id, decomp_id, field_size, data_buffer, field_IO_name, long_name, unit, data_type, annotation);
+    check_for_registering_IO_field(new_IO_field, annotation, API_ID_FIELD_MGT_REG_IO_FIELD_from_BUFFER);
+    return IO_field_id;
 }
 
 
 IO_output_procedure::~IO_output_procedure()
 {
-	if (field_update_status != NULL)
-		delete [] field_update_status;
+    if (field_update_status != NULL)
+        delete [] field_update_status;
 }
 
 
 IO_output_procedure::IO_output_procedure(int comp_id, int procedure_id, Coupling_timer *default_field_timer, Coupling_timer *default_file_timer, bool synchronized_IO)
 {
-	this->comp_id = comp_id;
-	this->procedure_id = procedure_id;
-	inst_or_aver = USING_AVERAGE_VALUE;
-	import_interface = NULL;
-	export_interface = NULL;
-	time_mgr = components_time_mgrs->get_time_mgr(comp_id);
-	netcdf_file_object = NULL;
-	write_grid_name = false;
-
-	include_all_component_io_fields();
-
-	field_update_status = NULL;
-	
-	if (IO_fields.size() == 0)
-		return;
-
-	field_update_status = new int [IO_fields.size()];
-	
-	EXECUTION_REPORT(REPORT_ERROR, -1, comp_comm_group_mgt_mgr->is_legal_local_comp_id(comp_id,true), "Software error in IO_output_procedure::IO_output_procedure: wrong comp id");
-	
-	if (default_field_timer == NULL)
-		field_timer = timer_mgr->get_timer(timer_mgr->define_timer(comp_id, FREQUENCY_UNIT_DAYS, 1, 0, 0, "default timer for I/O fields"));
-	else {
-		field_timer = timer_mgr->get_timer(timer_mgr->define_timer(comp_id, default_field_timer));
-		field_timer->reset_remote_lag_count();
-	}
-	
-	if (default_file_timer == NULL)
-		file_timer = timer_mgr->get_timer(timer_mgr->define_timer(comp_id, FREQUENCY_UNIT_DAYS, 10, 0, 0, "default timer for I/O fields"));
-	else {
-		file_timer = timer_mgr->get_timer(timer_mgr->define_timer(comp_id, default_file_timer));
-		file_timer->reset_remote_lag_count();
-	}
-
-	int *fields_id = new int [IO_fields.size()];
-	int field_timer_id = field_timer->get_timer_id();
-	for (int i = 0; i < IO_fields.size(); i ++)
-		fields_id[i] = IO_fields[i]->get_field_instance_id();
-
-	export_interface = inout_interface_mgr->get_interface(inout_interface_mgr->register_inout_interface("Default_IO_output", 1, IO_fields.size(), fields_id, IO_fields.size(), field_timer_id, inst_or_aver, "register default IO field to output for a component", INTERFACE_SOURCE_IO_OUTPUT));
-
-	if (synchronized_IO) {
-		for (int i = 0; i < IO_fields.size(); i ++) {
-			Field_mem_info *IO_field_instance, *mirror_field_instance;
-			IO_field_instance = memory_manager->get_field_instance(IO_fields[i]->get_field_instance_id());
-			const char *data_type = IO_field_instance->get_data_type();
-			if (words_are_the_same(data_type, DATA_TYPE_DOUBLE) || words_are_the_same(data_type, DATA_TYPE_FLOAT))
-				mirror_field_instance = memory_manager->alloc_mem(IO_field_instance, BUF_MARK_IO_FIELD_MIRROR, inout_interface_mgr->get_next_interface_id(), DATA_TYPE_FLOAT, false);
-			else mirror_field_instance = memory_manager->alloc_mem(IO_field_instance, BUF_MARK_IO_FIELD_MIRROR, inout_interface_mgr->get_next_interface_id(), DATA_TYPE_INT, false);
-			fields_id[i] = mirror_field_instance->get_field_instance_id();
-			data_write_field_insts.push_back(mirror_field_instance);
-		}
-		import_interface = inout_interface_mgr->get_interface(inout_interface_mgr->register_inout_interface("Default_IO_write", 0, IO_fields.size(), fields_id, IO_fields.size(), field_timer_id, inst_or_aver, "register default IO field to write for a component", INTERFACE_SOURCE_IO_WRITE));
-	}
-	else {
-		EXECUTION_REPORT(REPORT_ERROR, -1, false, "asynchronized IO is not supported yet");
-	}
-
-	delete [] fields_id;
+    this->comp_id = comp_id;
+    this->procedure_id = procedure_id;
+    inst_or_aver = USING_AVERAGE_VALUE;
+    import_interface = NULL;
+    export_interface = NULL;
+    time_mgr = components_time_mgrs->get_time_mgr(comp_id);
+    netcdf_file_object = NULL;
+    write_grid_name = false;
+
+    include_all_component_io_fields();
+
+    field_update_status = NULL;
+    
+    if (IO_fields.size() == 0)
+        return;
+
+    field_update_status = new int [IO_fields.size()];
+    
+    EXECUTION_REPORT(REPORT_ERROR, -1, comp_comm_group_mgt_mgr->is_legal_local_comp_id(comp_id,true), "Software error in IO_output_procedure::IO_output_procedure: wrong comp id");
+    
+    if (default_field_timer == NULL)
+        field_timer = timer_mgr->get_timer(timer_mgr->define_timer(comp_id, FREQUENCY_UNIT_DAYS, 1, 0, 0, "default timer for I/O fields"));
+    else {
+        field_timer = timer_mgr->get_timer(timer_mgr->define_timer(comp_id, default_field_timer));
+        field_timer->reset_remote_lag_count();
+    }
+    
+    if (default_file_timer == NULL)
+        file_timer = timer_mgr->get_timer(timer_mgr->define_timer(comp_id, FREQUENCY_UNIT_DAYS, 10, 0, 0, "default timer for I/O fields"));
+    else {
+        file_timer = timer_mgr->get_timer(timer_mgr->define_timer(comp_id, default_file_timer));
+        file_timer->reset_remote_lag_count();
+    }
+
+    int *fields_id = new int [IO_fields.size()];
+    int field_timer_id = field_timer->get_timer_id();
+    for (int i = 0; i < IO_fields.size(); i ++)
+        fields_id[i] = IO_fields[i]->get_field_instance_id();
+
+    export_interface = inout_interface_mgr->get_interface(inout_interface_mgr->register_inout_interface("Default_IO_output", 1, IO_fields.size(), fields_id, IO_fields.size(), field_timer_id, inst_or_aver, "register default IO field to output for a component", INTERFACE_SOURCE_IO_OUTPUT));
+
+    if (synchronized_IO) {
+        for (int i = 0; i < IO_fields.size(); i ++) {
+            Field_mem_info *IO_field_instance, *mirror_field_instance;
+            IO_field_instance = memory_manager->get_field_instance(IO_fields[i]->get_field_instance_id());
+            const char *data_type = IO_field_instance->get_data_type();
+            if (words_are_the_same(data_type, DATA_TYPE_DOUBLE) || words_are_the_same(data_type, DATA_TYPE_FLOAT))
+                mirror_field_instance = memory_manager->alloc_mem(IO_field_instance, BUF_MARK_IO_FIELD_MIRROR, inout_interface_mgr->get_next_interface_id(), DATA_TYPE_FLOAT, false);
+            else mirror_field_instance = memory_manager->alloc_mem(IO_field_instance, BUF_MARK_IO_FIELD_MIRROR, inout_interface_mgr->get_next_interface_id(), DATA_TYPE_INT, false);
+            fields_id[i] = mirror_field_instance->get_field_instance_id();
+            data_write_field_insts.push_back(mirror_field_instance);
+        }
+        import_interface = inout_interface_mgr->get_interface(inout_interface_mgr->register_inout_interface("Default_IO_write", 0, IO_fields.size(), fields_id, IO_fields.size(), field_timer_id, inst_or_aver, "register default IO field to write for a component", INTERFACE_SOURCE_IO_WRITE));
+    }
+    else {
+        EXECUTION_REPORT(REPORT_ERROR, -1, false, "asynchronized IO is not supported yet");
+    }
+
+    delete [] fields_id;
 }
 
 
 void IO_output_procedure::execute()
 {
-	if (export_interface != NULL)
-		export_interface->execute(false, API_ID_INTERFACE_EXECUTE_WITH_ID, field_update_status, IO_fields.size(), "IO output procedure export interface execute");
-
-	if (import_interface != NULL) {
-		import_interface->execute(false, API_ID_INTERFACE_EXECUTE_WITH_ID, field_update_status, IO_fields.size(), "IO output procedure import interface execute");
-		if (field_timer->is_timer_on()) {
-			if (comp_comm_group_mgt_mgr->get_current_proc_id_in_comp(comp_id, "in IO_output_procedure::execute") == 0) {
-				if (netcdf_file_object == NULL || file_timer->is_timer_on()) {
-					char time_string[NAME_STR_SIZE];
-					char full_file_name[NAME_STR_SIZE];
-					char file_header[NAME_STR_SIZE];
-					if (IS_TIME_UNIT_SECOND(field_timer->get_frequency_unit()))
-						sprintf(time_string, "%04d%02d%02d-%05d", time_mgr->get_current_year(), time_mgr->get_current_month(), time_mgr->get_current_day(), time_mgr->get_current_second());
-					else if (IS_TIME_UNIT_DAY(field_timer->get_frequency_unit()))
-						sprintf(time_string, "%04d%02d%02d", time_mgr->get_current_year(), time_mgr->get_current_month(), time_mgr->get_current_day());	
-					else if (IS_TIME_UNIT_MONTH(field_timer->get_frequency_unit()))
-						sprintf(time_string, "%04d%02d", time_mgr->get_current_year(), time_mgr->get_current_month());	
-					else if (IS_TIME_UNIT_YEAR(field_timer->get_frequency_unit()))
-						sprintf(time_string, "%04d", time_mgr->get_current_year());
-					comp_comm_group_mgt_mgr->get_output_data_file_header(comp_id, file_header);
-					sprintf(full_file_name, "%s.%s.h%d.nc",file_header, time_string, procedure_id);
-					if (netcdf_file_object != NULL)
-						delete netcdf_file_object;
-	                netcdf_file_object = new IO_netcdf(full_file_name, full_file_name, "w", true);
-					// compset_communicators_info_mgr->write_case_info(netcdf_file_object);   // to be modify shortly
-				}
-			}
-			for (int i = 0; i < data_write_field_insts.size(); i ++) {
-				data_write_field_insts[i]->check_field_sum("before writing data into a file");
-            	fields_gather_scatter_mgr->gather_write_field(netcdf_file_object, data_write_field_insts[i], write_grid_name, time_mgr->get_current_date(), time_mgr->get_current_second(), false);
-			}
-		}
-	}
+    if (export_interface != NULL)
+        export_interface->execute(false, API_ID_INTERFACE_EXECUTE_WITH_ID, field_update_status, IO_fields.size(), "IO output procedure export interface execute");
+
+    if (import_interface != NULL) {
+        import_interface->execute(false, API_ID_INTERFACE_EXECUTE_WITH_ID, field_update_status, IO_fields.size(), "IO output procedure import interface execute");
+        if (field_timer->is_timer_on()) {
+            if (comp_comm_group_mgt_mgr->get_current_proc_id_in_comp(comp_id, "in IO_output_procedure::execute") == 0) {
+                if (netcdf_file_object == NULL || file_timer->is_timer_on()) {
+                    char time_string[NAME_STR_SIZE];
+                    char full_file_name[NAME_STR_SIZE];
+                    char file_header[NAME_STR_SIZE];
+                    if (IS_TIME_UNIT_SECOND(field_timer->get_frequency_unit()))
+                        sprintf(time_string, "%04d%02d%02d-%05d", time_mgr->get_current_year(), time_mgr->get_current_month(), time_mgr->get_current_day(), time_mgr->get_current_second());
+                    else if (IS_TIME_UNIT_DAY(field_timer->get_frequency_unit()))
+                        sprintf(time_string, "%04d%02d%02d", time_mgr->get_current_year(), time_mgr->get_current_month(), time_mgr->get_current_day());    
+                    else if (IS_TIME_UNIT_MONTH(field_timer->get_frequency_unit()))
+                        sprintf(time_string, "%04d%02d", time_mgr->get_current_year(), time_mgr->get_current_month());    
+                    else if (IS_TIME_UNIT_YEAR(field_timer->get_frequency_unit()))
+                        sprintf(time_string, "%04d", time_mgr->get_current_year());
+                    comp_comm_group_mgt_mgr->get_output_data_file_header(comp_id, file_header);
+                    sprintf(full_file_name, "%s.%s.h%d.nc",file_header, time_string, procedure_id);
+                    if (netcdf_file_object != NULL)
+                        delete netcdf_file_object;
+                    netcdf_file_object = new IO_netcdf(full_file_name, full_file_name, "w", true);
+                    // compset_communicators_info_mgr->write_case_info(netcdf_file_object);   // to be modify shortly
+                }
+            }
+            for (int i = 0; i < data_write_field_insts.size(); i ++) {
+                data_write_field_insts[i]->check_field_sum("before writing data into a file");
+                fields_gather_scatter_mgr->gather_write_field(netcdf_file_object, data_write_field_insts[i], write_grid_name, time_mgr->get_current_date(), time_mgr->get_current_second(), false);
+            }
+        }
+    }
 }
 
 
 Coupling_connection *IO_output_procedure::generate_coupling_connection(int connection_id)
 {
-	Coupling_connection *coupling_connection = NULL;
-	
-	if (import_interface != NULL && export_interface != NULL) {		
-		coupling_generator->synchronize_latest_connection_id(comp_comm_group_mgt_mgr->get_comm_group_of_local_comp(comp_id, ""));
-		coupling_connection = new Coupling_connection(coupling_generator->apply_connection_id());
-		strcpy(coupling_connection->dst_comp_full_name, comp_comm_group_mgt_mgr->get_global_node_of_local_comp(comp_id,true,"in IO_output_procedure::generate_coupling_connection")->get_full_name());
-		strcpy(coupling_connection->dst_interface_name, import_interface->get_interface_name());
-		std::pair<const char*,const char*> src_comp_interface;
-		src_comp_interface.first = strdup(coupling_connection->dst_comp_full_name);
-		src_comp_interface.second = strdup(export_interface->get_interface_name());
-		coupling_connection->src_comp_interfaces.push_back(src_comp_interface);
-		std::vector<const char*> import_fields_name;
-		import_interface->get_fields_name(&import_fields_name);
-		for (int k = 0; k < import_fields_name.size(); k ++)
-			coupling_connection->fields_name.push_back(strdup(import_fields_name[k]));
-	}
-
-	return coupling_connection;
+    Coupling_connection *coupling_connection = NULL;
+    
+    if (import_interface != NULL && export_interface != NULL) {        
+        coupling_generator->synchronize_latest_connection_id(comp_comm_group_mgt_mgr->get_comm_group_of_local_comp(comp_id, ""));
+        coupling_connection = new Coupling_connection(coupling_generator->apply_connection_id());
+        strcpy(coupling_connection->dst_comp_full_name, comp_comm_group_mgt_mgr->get_global_node_of_local_comp(comp_id,true,"in IO_output_procedure::generate_coupling_connection")->get_full_name());
+        strcpy(coupling_connection->dst_interface_name, import_interface->get_interface_name());
+        std::pair<const char*,const char*> src_comp_interface;
+        src_comp_interface.first = strdup(coupling_connection->dst_comp_full_name);
+        src_comp_interface.second = strdup(export_interface->get_interface_name());
+        coupling_connection->src_comp_interfaces.push_back(src_comp_interface);
+        std::vector<const char*> import_fields_name;
+        import_interface->get_fields_name(&import_fields_name);
+        for (int k = 0; k < import_fields_name.size(); k ++)
+            coupling_connection->fields_name.push_back(strdup(import_fields_name[k]));
+    }
+
+    return coupling_connection;
 }
 
 
 void IO_output_procedure::include_all_component_io_fields()
 {
-	for (int i = 0; i < IO_fields_mgr->IO_fields.size(); i ++)
-		if (IO_fields_mgr->IO_fields[i]->get_comp_id() == comp_id)
-			IO_fields.push_back(IO_fields_mgr->IO_fields[i]);
+    for (int i = 0; i < IO_fields_mgr->IO_fields.size(); i ++)
+        if (IO_fields_mgr->IO_fields[i]->get_comp_id() == comp_id)
+            IO_fields.push_back(IO_fields_mgr->IO_fields[i]);
 }
 
 
 Component_IO_output_procedures::Component_IO_output_procedures(int comp_id, const char *xml_file_name, bool synchronized_IO)
 {
-	this->comp_id = comp_id;
-	
-	if (xml_file_name == NULL)
-		IO_output_procedures.push_back(new IO_output_procedure(comp_id, IO_output_procedures.size(), NULL, NULL, synchronized_IO));
-	else {
-		EXECUTION_REPORT(REPORT_ERROR, -1, false, "asynchronized IO is not supported yet");
-	}
+    this->comp_id = comp_id;
+    
+    if (xml_file_name == NULL)
+        IO_output_procedures.push_back(new IO_output_procedure(comp_id, IO_output_procedures.size(), NULL, NULL, synchronized_IO));
+    else {
+        EXECUTION_REPORT(REPORT_ERROR, -1, false, "asynchronized IO is not supported yet");
+    }
 }
 
 
 Component_IO_output_procedures::~Component_IO_output_procedures()
 {
-	for (int i = 0; i < IO_output_procedures.size(); i ++)
-		delete IO_output_procedures[i];
+    for (int i = 0; i < IO_output_procedures.size(); i ++)
+        delete IO_output_procedures[i];
 }
 
 
 void Component_IO_output_procedures::generate_coupling_connection(std::vector<Coupling_connection*> &all_IO_connections, int basic_connection_id)
 {
-	for (int i = 0; i < IO_output_procedures.size(); i ++) {
-		Coupling_connection *coupling_connection = IO_output_procedures[i]->generate_coupling_connection(basic_connection_id+IO_output_procedures.size());
-		if (coupling_connection != NULL)
-			all_IO_connections.push_back(coupling_connection);
-	}
+    for (int i = 0; i < IO_output_procedures.size(); i ++) {
+        Coupling_connection *coupling_connection = IO_output_procedures[i]->generate_coupling_connection(basic_connection_id+IO_output_procedures.size());
+        if (coupling_connection != NULL)
+            all_IO_connections.push_back(coupling_connection);
+    }
 }
 
 
 void Component_IO_output_procedures::execute()
 {
-	for (int i = 0; i < IO_output_procedures.size(); i ++)
-		IO_output_procedures[i]->execute();
+    for (int i = 0; i < IO_output_procedures.size(); i ++)
+        IO_output_procedures[i]->execute();
 }
 
 
 Components_IO_output_procedures_mgt::~Components_IO_output_procedures_mgt()
 {
-	for (int i = 0; i < components_IO_output_procedures.size(); i ++)
-		delete components_IO_output_procedures[i];
+    for (int i = 0; i < components_IO_output_procedures.size(); i ++)
+        delete components_IO_output_procedures[i];
 }
 
 
 void Components_IO_output_procedures_mgt::add_component_IO_output_procedures(int comp_id, const char *xml_file_name, bool synchronized_IO)
 {
-	EXECUTION_REPORT(REPORT_ERROR, -1, comp_comm_group_mgt_mgr->is_legal_local_comp_id(comp_id,true), "Software error in Component_IO_output_procedures::Component_IO_output_procedures: wrong comp id");
-	// ...
-	int true_comp_id = (comp_id&TYPE_ID_SUFFIX_MASK);
-	for (int i = components_IO_output_procedures.size(); i <= true_comp_id; i ++)
-		components_IO_output_procedures.push_back(NULL);
-	EXECUTION_REPORT(REPORT_ERROR, -1, components_IO_output_procedures[true_comp_id] == NULL, "Software error in Component_IO_output_procedures::Component_IO_output_procedures: wrong");	
-	components_IO_output_procedures[true_comp_id] = new Component_IO_output_procedures(comp_id, xml_file_name, synchronized_IO);
+    EXECUTION_REPORT(REPORT_ERROR, -1, comp_comm_group_mgt_mgr->is_legal_local_comp_id(comp_id,true), "Software error in Component_IO_output_procedures::Component_IO_output_procedures: wrong comp id");
+    // ...
+    int true_comp_id = (comp_id&TYPE_ID_SUFFIX_MASK);
+    for (int i = components_IO_output_procedures.size(); i <= true_comp_id; i ++)
+        components_IO_output_procedures.push_back(NULL);
+    EXECUTION_REPORT(REPORT_ERROR, -1, components_IO_output_procedures[true_comp_id] == NULL, "Software error in Component_IO_output_procedures::Component_IO_output_procedures: wrong");    
+    components_IO_output_procedures[true_comp_id] = new Component_IO_output_procedures(comp_id, xml_file_name, synchronized_IO);
 }
 
 
 void Components_IO_output_procedures_mgt::add_all_components_IO_output_procedures()
 {
-	const int *all_components_ids = comp_comm_group_mgt_mgr->get_all_components_ids();
-	for (int i = 1; i < all_components_ids[0]; i ++) {
-		if (comp_comm_group_mgt_mgr->get_current_proc_id_in_comp(all_components_ids[i], "in add_all_components_IO_output_procedures") != -1)
-			add_component_IO_output_procedures(all_components_ids[i], NULL, true);
-	}
+    const int *all_components_ids = comp_comm_group_mgt_mgr->get_all_components_ids();
+    for (int i = 1; i < all_components_ids[0]; i ++) {
+        if (comp_comm_group_mgt_mgr->get_current_proc_id_in_comp(all_components_ids[i], "in add_all_components_IO_output_procedures") != -1)
+            add_component_IO_output_procedures(all_components_ids[i], NULL, true);
+    }
 }
 
 
 Component_IO_output_procedures *Components_IO_output_procedures_mgt::get_component_IO_output_procedures(int comp_id)
 {
-	EXECUTION_REPORT(REPORT_ERROR, -1, comp_comm_group_mgt_mgr->is_legal_local_comp_id(comp_id,true), "Software error in Components_IO_output_procedures_mgt::get_component_IO_output_procedures");
-	int true_comp_id = comp_id & TYPE_ID_SUFFIX_MASK;
-	EXECUTION_REPORT(REPORT_ERROR, -1, components_IO_output_procedures.size() > true_comp_id && components_IO_output_procedures[true_comp_id] != NULL, "Software error in Components_IO_output_procedures_mgt::get_component_IO_output_procedures");
-	return components_IO_output_procedures[true_comp_id];
+    EXECUTION_REPORT(REPORT_ERROR, -1, comp_comm_group_mgt_mgr->is_legal_local_comp_id(comp_id,true), "Software error in Components_IO_output_procedures_mgt::get_component_IO_output_procedures");
+    int true_comp_id = comp_id & TYPE_ID_SUFFIX_MASK;
+    EXECUTION_REPORT(REPORT_ERROR, -1, components_IO_output_procedures.size() > true_comp_id && components_IO_output_procedures[true_comp_id] != NULL, "Software error in Components_IO_output_procedures_mgt::get_component_IO_output_procedures");
+    return components_IO_output_procedures[true_comp_id];
 }
 
 
diff --git a/src/Data_MGT/IO_field_mgt.h b/src/Data_MGT/IO_field_mgt.h
old mode 100644
new mode 100755
index aa724ae..d3c2721
--- a/src/Data_MGT/IO_field_mgt.h
+++ b/src/Data_MGT/IO_field_mgt.h
@@ -22,93 +22,93 @@ class Coupling_connection;
 
 class IO_field
 {
-	private:
-		int IO_field_id;
-		int field_instance_id;
-		int comp_id;
-		char field_IO_name[NAME_STR_SIZE];
-		char field_long_name[NAME_STR_SIZE];
-		char field_unit[NAME_STR_SIZE];
-
-	public:
-		IO_field(int, int, const char *, const char *);
-		IO_field(int, int, int, int, void *, const char *, const char *, const char *, const char *, const char *);
-		~IO_field() {}
-		int get_comp_id() { return comp_id; }
-		int get_IO_field_id() { return IO_field_id; }
-		int get_field_instance_id() { return field_instance_id; }
-		const char *get_field_IO_name() { return field_IO_name; }
+    private:
+        int IO_field_id;
+        int field_instance_id;
+        int comp_id;
+        char field_IO_name[NAME_STR_SIZE];
+        char field_long_name[NAME_STR_SIZE];
+        char field_unit[NAME_STR_SIZE];
+
+    public:
+        IO_field(int, int, const char *, const char *);
+        IO_field(int, int, int, int, void *, const char *, const char *, const char *, const char *, const char *);
+        ~IO_field() {}
+        int get_comp_id() { return comp_id; }
+        int get_IO_field_id() { return IO_field_id; }
+        int get_field_instance_id() { return field_instance_id; }
+        const char *get_field_IO_name() { return field_IO_name; }
 };
 
 
 class IO_output_procedure
 {
-	private:
-		int comp_id;
-		int procedure_id;
-		Inout_interface *export_interface;
-		Inout_interface *import_interface;
-		Coupling_timer *field_timer;
-		Coupling_timer *file_timer;
-		Time_mgt *time_mgr;
-		std::vector<IO_field*> IO_fields;
-		std::vector<Field_mem_info*> data_write_field_insts;
-		IO_netcdf *netcdf_file_object;
-		bool write_grid_name;
-		int inst_or_aver;
-		int *field_update_status;
-
-	public:
-		IO_output_procedure(int, int, Coupling_timer *, Coupling_timer *, bool);
-		void include_all_component_io_fields();
-		Coupling_connection *generate_coupling_connection(int);
-		void execute();
-		~IO_output_procedure();
+    private:
+        int comp_id;
+        int procedure_id;
+        Inout_interface *export_interface;
+        Inout_interface *import_interface;
+        Coupling_timer *field_timer;
+        Coupling_timer *file_timer;
+        Time_mgt *time_mgr;
+        std::vector<IO_field*> IO_fields;
+        std::vector<Field_mem_info*> data_write_field_insts;
+        IO_netcdf *netcdf_file_object;
+        bool write_grid_name;
+        int inst_or_aver;
+        int *field_update_status;
+
+    public:
+        IO_output_procedure(int, int, Coupling_timer *, Coupling_timer *, bool);
+        void include_all_component_io_fields();
+        Coupling_connection *generate_coupling_connection(int);
+        void execute();
+        ~IO_output_procedure();
 };
 
 
 class IO_field_mgt
 {
-	private:
-		friend class IO_output_procedure;
-		std::vector<IO_field*> IO_fields;
-
-	public:
-		IO_field_mgt() {}
-		~IO_field_mgt();
-		int register_IO_field(int, const char *, const char *);
-		int register_IO_fields(int, int, int *, const char *);
-		int register_IO_field(int, int, int, void *, const char *, const char *, const char *, const char *, const char *);
-		IO_field *search_IO_field(int, const char*);
-		void check_for_registering_IO_field(IO_field *, const char *, int);
+    private:
+        friend class IO_output_procedure;
+        std::vector<IO_field*> IO_fields;
+
+    public:
+        IO_field_mgt() {}
+        ~IO_field_mgt();
+        int register_IO_field(int, const char *, const char *);
+        int register_IO_fields(int, int, int *, const char *);
+        int register_IO_field(int, int, int, void *, const char *, const char *, const char *, const char *, const char *);
+        IO_field *search_IO_field(int, const char*);
+        void check_for_registering_IO_field(IO_field *, const char *, int);
 };
 
 
 class Component_IO_output_procedures
 {
-	private:
-		std::vector<IO_output_procedure*> IO_output_procedures;
-		int comp_id;
-
-	public:
-		Component_IO_output_procedures(int, const char*, bool);
-		void generate_coupling_connection(std::vector<Coupling_connection*> &, int);
-		void execute();
-		~Component_IO_output_procedures();
+    private:
+        std::vector<IO_output_procedure*> IO_output_procedures;
+        int comp_id;
+
+    public:
+        Component_IO_output_procedures(int, const char*, bool);
+        void generate_coupling_connection(std::vector<Coupling_connection*> &, int);
+        void execute();
+        ~Component_IO_output_procedures();
 };
 
 
 class Components_IO_output_procedures_mgt
 {
-	private:
-		std::vector<Component_IO_output_procedures*> components_IO_output_procedures;
-
-	public:
-		Components_IO_output_procedures_mgt() {}
-		~Components_IO_output_procedures_mgt();
-		void add_component_IO_output_procedures(int, const char*, bool);
-		void add_all_components_IO_output_procedures();
-		Component_IO_output_procedures *get_component_IO_output_procedures(int);
+    private:
+        std::vector<Component_IO_output_procedures*> components_IO_output_procedures;
+
+    public:
+        Components_IO_output_procedures_mgt() {}
+        ~Components_IO_output_procedures_mgt();
+        void add_component_IO_output_procedures(int, const char*, bool);
+        void add_all_components_IO_output_procedures();
+        Component_IO_output_procedures *get_component_IO_output_procedures(int);
 };
 
 #endif
diff --git a/src/Data_MGT/field_info_mgt.cxx b/src/Data_MGT/field_info_mgt.cxx
old mode 100644
new mode 100755
index af0037d..6e7a806
--- a/src/Data_MGT/field_info_mgt.cxx
+++ b/src/Data_MGT/field_info_mgt.cxx
@@ -16,19 +16,19 @@
 
 int Field_info_mgt::get_field_num_dims(const char *field_dim, const char *cfg_name)
 {
-	if (words_are_the_same(field_dim, FIELD_0_DIM))
-		return 0;
-	if (words_are_the_same(field_dim, FIELD_2_DIM))
-		return 2;
-	if (words_are_the_same(field_dim, FIELD_V1_DIM))
-		return 1;
-	if (words_are_the_same(field_dim, FIELD_3_DIM))
-		return 3;
-	if (words_are_the_same(field_dim, FIELD_4_DIM))
-		return 4;
-
-	EXECUTION_REPORT(REPORT_ERROR,-1, false, "\"%s\" is an undefined description of the number of dimensions of field. Please verify the configuration file %s", field_dim, cfg_name);
-	return -1;
+    if (words_are_the_same(field_dim, FIELD_0_DIM))
+        return 0;
+    if (words_are_the_same(field_dim, FIELD_2_DIM))
+        return 2;
+    if (words_are_the_same(field_dim, FIELD_V1_DIM))
+        return 1;
+    if (words_are_the_same(field_dim, FIELD_3_DIM))
+        return 3;
+    if (words_are_the_same(field_dim, FIELD_4_DIM))
+        return 4;
+
+    EXECUTION_REPORT(REPORT_ERROR,-1, false, "\"%s\" is an undefined description of the number of dimensions of field. Please verify the configuration file %s", field_dim, cfg_name);
+    return -1;
 }
 
 
@@ -44,72 +44,72 @@ const field_attr *Field_info_mgt::search_field_info(const char *field_name)
 
 void Field_info_mgt::add_field_info(const char *field_name, const char *field_long_name, const char *field_unit, const char *field_dim, const char *field_type, int line_number)
 {
-	field_attr local_attr;
+    field_attr local_attr;
 
 
-	strcpy(local_attr.field_name, field_name);
-	strcpy(local_attr.field_long_name, field_long_name);
-	strcpy(local_attr.field_unit, field_unit);
-	strcpy(local_attr.field_dim, field_dim);
-	strcpy(local_attr.field_type, field_type);
-	local_attr.line_number = line_number;
-	fields_attr.push_back(local_attr);
-	EXECUTION_REPORT(REPORT_ERROR, -1, search_field_info(local_attr.field_name) == &(fields_attr[fields_attr.size()-1]), "Software error in Field_info_mgt::add_field_info");
+    strcpy(local_attr.field_name, field_name);
+    strcpy(local_attr.field_long_name, field_long_name);
+    strcpy(local_attr.field_unit, field_unit);
+    strcpy(local_attr.field_dim, field_dim);
+    strcpy(local_attr.field_type, field_type);
+    local_attr.line_number = line_number;
+    fields_attr.push_back(local_attr);
+    EXECUTION_REPORT(REPORT_ERROR, -1, search_field_info(local_attr.field_name) == &(fields_attr[fields_attr.size()-1]), "Software error in Field_info_mgt::add_field_info");
 }
 
 
 Field_info_mgt::Field_info_mgt()
 {
     char XML_file_name[NAME_STR_SIZE];
-	int line_number;
+    int line_number;
     field_attr local_attr;
-	
-
-	add_field_info("remap_frac", "fraction used for H2D remapping", "unitless", "H2D", "flux", -1);
-
-	sprintf(XML_file_name, "%s/all/public_field_attribute.xml", comp_comm_group_mgt_mgr->get_config_root_dir());
-	TiXmlDocument *XML_file = open_XML_file_to_read(-1, XML_file_name, MPI_COMM_WORLD, false);
-	if (XML_file == NULL) {
-		if (comp_comm_group_mgt_mgr->get_current_proc_global_id() == 0)
-			EXECUTION_REPORT(REPORT_WARNING, -1, true, "There is no configuration file public_field_attribute.xml under the directory \"%s/all\", which indicates that no fields will be coupled among component models.", comp_comm_group_mgt_mgr->get_config_root_dir());
-		return;
-	}
-	
-	for (TiXmlNode *field_XML_node = XML_file->FirstChildElement(); field_XML_node != NULL; field_XML_node = field_XML_node->NextSibling()) {
-		if (field_XML_node->Type() != TiXmlNode::TINYXML_ELEMENT)
-			continue;
-		TiXmlElement *field_XML_element = field_XML_node->ToElement();
-		EXECUTION_REPORT(REPORT_ERROR, -1, words_are_the_same(field_XML_element->Value(),"field"), "The XML element for specifying the attributes of a public field in the XML configuration file \"%s\" should be named \"field\". Please verify the XML file arround the line number %d.", XML_file_name, field_XML_element->Row());
-		const char *field_name = get_XML_attribute(-1, CCPL_NAME_STR_LEN, field_XML_element, "name", XML_file_name, line_number, "name of a field", "configuration of the attributes of shared fields for coupling", true);
-		const field_attr *existing_field = search_field_info(field_name);
-		if (existing_field != NULL)
-			EXECUTION_REPORT(REPORT_ERROR, -1, false, "Cannot spefify the attributes of field \"%s\" in the XML file \"%s\" around the line number %d again because it has already been specified around the line number %d", field_name, XML_file_name, line_number, existing_field->line_number);
-		const char *field_long_name = get_XML_attribute(-1, 1000, field_XML_element, "long_name", XML_file_name, line_number, "long name of a field", "configuration of the attributes of shared fields for coupling", true);
-		const char *field_dimensions = get_XML_attribute(-1, -1, field_XML_element, "dimensions", XML_file_name, line_number, "information of dimensions (0D, H2D, V1D or V3D) of a field", "configuration of the attributes of shared fields for coupling", true);
-		if (comp_comm_group_mgt_mgr->get_current_proc_global_id() == 0)
-			EXECUTION_REPORT(REPORT_ERROR, -1, words_are_the_same(field_dimensions, FIELD_0_DIM) || words_are_the_same(field_dimensions, FIELD_2_DIM) || words_are_the_same(field_dimensions, FIELD_3_DIM) || words_are_the_same(field_dimensions, FIELD_V1_DIM), "The dimensions of field \"%s\" is wrong (must be \"0D\", \"H2D\", \"V1D\" or \"V3D\"). Please verify the XML file \"%s\" arround the line number %d.", field_name, XML_file_name, field_XML_element->Row());
-		const char *default_unit = get_XML_attribute(-1, CCPL_NAME_STR_LEN, field_XML_element, "default_unit", XML_file_name, line_number, "default unit of a field", "configuration of the attributes of shared fields for coupling", true);
-		const char *field_type = get_XML_attribute(-1, -1, field_XML_element, "type", XML_file_name, line_number, "default unit of a field", "configuration of the attributes of shared fields for coupling", true);
-		add_field_info(field_name, field_long_name, default_unit, field_dimensions, field_type, line_number);
-	}
-
-	delete XML_file;
+    
+
+    add_field_info("remap_frac", "fraction used for H2D remapping", "unitless", "H2D", "flux", -1);
+
+    sprintf(XML_file_name, "%s/all/public_field_attribute.xml", comp_comm_group_mgt_mgr->get_config_root_dir());
+    TiXmlDocument *XML_file = open_XML_file_to_read(-1, XML_file_name, MPI_COMM_WORLD, false);
+    if (XML_file == NULL) {
+        if (comp_comm_group_mgt_mgr->get_current_proc_global_id() == 0)
+            EXECUTION_REPORT(REPORT_WARNING, -1, false, "There is no configuration file public_field_attribute.xml under the directory \"%s/all\", which indicates that no fields will be coupled among component models.", comp_comm_group_mgt_mgr->get_config_root_dir());
+        return;
+    }
+    
+    for (TiXmlNode *field_XML_node = XML_file->FirstChildElement(); field_XML_node != NULL; field_XML_node = field_XML_node->NextSibling()) {
+        if (field_XML_node->Type() != TiXmlNode::TINYXML_ELEMENT)
+            continue;
+        TiXmlElement *field_XML_element = field_XML_node->ToElement();
+        EXECUTION_REPORT(REPORT_ERROR, -1, words_are_the_same(field_XML_element->Value(),"field"), "The XML element for specifying the attributes of a public field in the XML configuration file \"%s\" should be named \"field\". Please verify the XML file arround the line number %d.", XML_file_name, field_XML_element->Row());
+        const char *field_name = get_XML_attribute(-1, CCPL_NAME_STR_LEN, field_XML_element, "name", XML_file_name, line_number, "name of a field", "configuration of the attributes of shared fields for coupling", true);
+        const field_attr *existing_field = search_field_info(field_name);
+        if (existing_field != NULL)
+            EXECUTION_REPORT(REPORT_ERROR, -1, false, "Cannot spefify the attributes of field \"%s\" in the XML file \"%s\" around the line number %d again because it has already been specified around the line number %d", field_name, XML_file_name, line_number, existing_field->line_number);
+        const char *field_long_name = get_XML_attribute(-1, 1000, field_XML_element, "long_name", XML_file_name, line_number, "long name of a field", "configuration of the attributes of shared fields for coupling", true);
+        const char *field_dimensions = get_XML_attribute(-1, -1, field_XML_element, "dimensions", XML_file_name, line_number, "information of dimensions (0D, H2D, V1D or V3D) of a field", "configuration of the attributes of shared fields for coupling", true);
+        if (comp_comm_group_mgt_mgr->get_current_proc_global_id() == 0)
+            EXECUTION_REPORT(REPORT_ERROR, -1, words_are_the_same(field_dimensions, FIELD_0_DIM) || words_are_the_same(field_dimensions, FIELD_2_DIM) || words_are_the_same(field_dimensions, FIELD_3_DIM) || words_are_the_same(field_dimensions, FIELD_V1_DIM), "The dimensions of field \"%s\" is wrong (must be \"0D\", \"H2D\", \"V1D\" or \"V3D\"). Please verify the XML file \"%s\" arround the line number %d.", field_name, XML_file_name, field_XML_element->Row());
+        const char *default_unit = get_XML_attribute(-1, CCPL_NAME_STR_LEN, field_XML_element, "default_unit", XML_file_name, line_number, "default unit of a field", "configuration of the attributes of shared fields for coupling", true);
+        const char *field_type = get_XML_attribute(-1, -1, field_XML_element, "type", XML_file_name, line_number, "default unit of a field", "configuration of the attributes of shared fields for coupling", true);
+        add_field_info(field_name, field_long_name, default_unit, field_dimensions, field_type, line_number);
+    }
+
+    delete XML_file;
 }
 
 
 const char *Field_info_mgt::get_field_long_name(const char *field_name)
 {
-	if (search_field_info(field_name) == NULL)
-		return NULL;
-	
+    if (search_field_info(field_name) == NULL)
+        return NULL;
+    
     return search_field_info(field_name)->field_long_name;
 }
 
 
 const char *Field_info_mgt::get_field_unit(const char *field_name)
 {
-	if (search_field_info(field_name) == NULL)
-		return NULL;
+    if (search_field_info(field_name) == NULL)
+        return NULL;
 
     return search_field_info(field_name)->field_unit;
 }
diff --git a/src/Data_MGT/field_info_mgt.h b/src/Data_MGT/field_info_mgt.h
old mode 100644
new mode 100755
index d52e830..95a8a19
--- a/src/Data_MGT/field_info_mgt.h
+++ b/src/Data_MGT/field_info_mgt.h
@@ -41,10 +41,10 @@ public:
     Field_info_mgt();
     ~Field_info_mgt() {}
     const field_attr* search_field_info(const char*);
-	int get_field_num_dims(const char*, const char*);
-	const char *get_field_long_name(const char*);
-	const char *get_field_unit(const char*);
-	void add_field_info(const char*, const char*, const char*, const char*, const char *, int);
+    int get_field_num_dims(const char*, const char*);
+    const char *get_field_long_name(const char*);
+    const char *get_field_unit(const char*);
+    void add_field_info(const char*, const char*, const char*, const char*, const char *, int);
 };
 
 #endif
diff --git a/src/Data_MGT/memory_mgt.cxx b/src/Data_MGT/memory_mgt.cxx
old mode 100644
new mode 100755
index 697fc48..9b6838a
--- a/src/Data_MGT/memory_mgt.cxx
+++ b/src/Data_MGT/memory_mgt.cxx
@@ -17,105 +17,105 @@
 
 
 Field_mem_info::Field_mem_info(const char *field_name, int decomp_id, int comp_or_grid_id, 
-	                           int buf_mark, const char *unit, const char *data_type, const char *annotation, bool check_field_name)
+                               int buf_mark, const char *unit, const char *data_type, const char *annotation, bool check_field_name)
 {
-	int mem_size;
-	Remap_grid_class *remap_grid_grid = NULL, *remap_grid_decomp = NULL;
+    int mem_size;
+    Remap_grid_class *remap_grid_grid = NULL, *remap_grid_decomp = NULL;
     Remap_data_field *remap_data_field;
 
 
-	if (decomp_id == -1) {
-		if (comp_comm_group_mgt_mgr->is_legal_local_comp_id(comp_or_grid_id,false)) {
-			comp_id = comp_or_grid_id;
-			grid_id = -1;
-			mem_size = get_data_type_size(data_type);
-		}
-		else {
-			comp_id = original_grid_mgr->get_comp_id_of_grid(comp_or_grid_id);
-			grid_id = comp_or_grid_id;
-			EXECUTION_REPORT(REPORT_ERROR, comp_id, original_grid_mgr->get_original_CoR_grid(grid_id)->get_num_dimensions() == 1 && original_grid_mgr->get_original_CoR_grid(grid_id)->has_grid_coord_label(COORD_LABEL_LEV), 
-				             "Error happens when calling the API \"CCPL_register_field_instance\" to register a field instance of \"%s\": when the given parallel decomposition ID (the parameter \"decomp_id\") is -1, the corresponding grid \"%s\" must be an one-dimension vertical grid. Please check the model code with the annotation \"%s\"", field_name, original_grid_mgr->get_original_grid(comp_or_grid_id)->get_grid_name(), annotation);
-			mem_size = original_grid_mgr->get_grid_size(grid_id, "in Field_mem_info::Field_mem_info") * get_data_type_size(data_type);
-		}
-		host_comp_id = comp_id;
-	}
-	else {
-		EXECUTION_REPORT(REPORT_ERROR, -1, original_grid_mgr->is_grid_id_legal(comp_or_grid_id), "Software error2 in new Field_mem_info");
-		EXECUTION_REPORT(REPORT_ERROR, -1, decomps_info_mgr->is_decomp_id_legal(decomp_id), "Software error3 in new Field_mem_info");
-		grid_id = comp_or_grid_id;
-		comp_id = original_grid_mgr->get_comp_id_of_grid(comp_or_grid_id);
-		host_comp_id = decomps_info_mgr->get_decomp_info(decomp_id)->get_host_comp_id();
-		EXECUTION_REPORT(REPORT_ERROR, -1, comp_id == decomps_info_mgr->get_comp_id_of_decomp(decomp_id), 
-			             "Software error4 in new Field_mem_info");
-		remap_grid_decomp = decomps_info_mgr->get_CoR_grid_of_decomp(decomp_id);
-		remap_grid_grid = original_grid_mgr->get_original_CoR_grid(comp_or_grid_id);
-		mem_size = decomps_info_mgr->get_decomp_info(decomp_id)->get_num_local_cells() * get_data_type_size(data_type) * remap_grid_grid->get_grid_size()/remap_grid_decomp->get_grid_size();
-		EXECUTION_REPORT(REPORT_ERROR, host_comp_id, remap_grid_decomp->is_subset_of_grid(remap_grid_grid), "Error happens when calling the API \"CCPL_register_field_instance\" to register a field instance of \"%s\": the parameters of grid ID and decomposition ID do not match each other: the grid corresponding to the decomposition (grid \"%s\") is not a subset of the grid corresponding to the grid ID (grid \"%s\"). Please check the model code with the annotation \"%s\"", field_name, decomps_info_mgr->get_decomp_info(decomp_id)->get_grid_name(), original_grid_mgr->get_original_grid(comp_or_grid_id)->get_grid_name(), annotation);
-	}
-	
-	host_comp_time_mgr = components_time_mgrs->get_time_mgr(host_comp_id);
-
-	const field_attr *field_attributes = fields_info->search_field_info(field_name);
-
-	if (check_field_name) {
-		EXECUTION_REPORT(REPORT_ERROR, host_comp_id, field_attributes != NULL, "Error happens when calling the API \"CCPL_register_field_instance\" to register a field instance of \"%s\": the field name \"%s\" is unknown (has not been registered through the configuration XML file public_field_attribute.xml). Please check the model code with the annotation \"%s\"", field_name, field_name, annotation);
-		bool dimensions_match_grid;
-		if (words_are_the_same(field_attributes->field_dim, FIELD_0_DIM))
-			dimensions_match_grid = decomp_id == -1 && remap_grid_grid == NULL;
-		if (words_are_the_same(field_attributes->field_dim, FIELD_V1_DIM))
-			dimensions_match_grid = decomp_id == -1 && remap_grid_grid != NULL && remap_grid_grid->get_num_dimensions() == 1 && remap_grid_grid->has_grid_coord_label(COORD_LABEL_LEV);
-		else if (words_are_the_same(field_attributes->field_dim, FIELD_2_DIM))
-			dimensions_match_grid = decomp_id != -1 && remap_grid_grid != NULL && remap_grid_grid->get_is_sphere_grid();
-		else if (words_are_the_same(field_attributes->field_dim, FIELD_3_DIM))
-			dimensions_match_grid = decomp_id != -1 && remap_grid_grid != NULL && remap_grid_grid->get_num_dimensions() == 3;
-		if (!dimensions_match_grid) {
-			if (grid_id != -1)
-				EXECUTION_REPORT(REPORT_ERROR, comp_id, false, "Error happens when calling the API \"CCPL_register_field_instance\" to register a field instance of \"%s\" at the model code with the annotation \"%s\": the dimension information (\"%s\") of the field does not match the dimensions of the corresponding grid \"%s\"", field_name, annotation, field_attributes->field_dim, original_grid_mgr->get_name_of_grid(grid_id));
-			else EXECUTION_REPORT(REPORT_ERROR, comp_id, false, "Error happens when calling the API \"CCPL_register_field_instance\" to register a field instance of \"%s\": the dimension information (\"%s\") of the field does not match the dimensions of the corresponding empty grid", field_name, annotation, field_attributes->field_dim);
-		}
-	}	
-
-	if (strlen(unit) > 0)
-		strcpy(field_unit, unit);
-	else if (field_attributes != NULL) 
-		strcpy(field_unit, fields_info->search_field_info(field_name)->field_unit);
-	// check the field unit
-
-	strcpy(this->field_name, field_name);
-	this->decomp_id = decomp_id;
-	this->comp_or_grid_id = comp_or_grid_id;
-	this->buf_mark = buf_mark;
-	this->usage_tag = -1;
+    if (decomp_id == -1) {
+        if (comp_comm_group_mgt_mgr->is_legal_local_comp_id(comp_or_grid_id,false)) {
+            comp_id = comp_or_grid_id;
+            grid_id = -1;
+            mem_size = get_data_type_size(data_type);
+        }
+        else {
+            comp_id = original_grid_mgr->get_comp_id_of_grid(comp_or_grid_id);
+            grid_id = comp_or_grid_id;
+            EXECUTION_REPORT(REPORT_ERROR, comp_id, original_grid_mgr->get_original_CoR_grid(grid_id)->get_num_dimensions() == 1 && original_grid_mgr->get_original_CoR_grid(grid_id)->has_grid_coord_label(COORD_LABEL_LEV), 
+                             "Error happens when calling the API \"CCPL_register_field_instance\" to register a field instance of \"%s\": when the given parallel decomposition ID (the parameter \"decomp_id\") is -1, the corresponding grid \"%s\" must be an one-dimension vertical grid. Please check the model code with the annotation \"%s\"", field_name, original_grid_mgr->get_original_grid(comp_or_grid_id)->get_grid_name(), annotation);
+            mem_size = original_grid_mgr->get_grid_size(grid_id, "in Field_mem_info::Field_mem_info") * get_data_type_size(data_type);
+        }
+        host_comp_id = comp_id;
+    }
+    else {
+        EXECUTION_REPORT(REPORT_ERROR, -1, original_grid_mgr->is_grid_id_legal(comp_or_grid_id), "Software error2 in new Field_mem_info");
+        EXECUTION_REPORT(REPORT_ERROR, -1, decomps_info_mgr->is_decomp_id_legal(decomp_id), "Software error3 in new Field_mem_info");
+        grid_id = comp_or_grid_id;
+        comp_id = original_grid_mgr->get_comp_id_of_grid(comp_or_grid_id);
+        host_comp_id = decomps_info_mgr->get_decomp_info(decomp_id)->get_host_comp_id();
+        EXECUTION_REPORT(REPORT_ERROR, -1, comp_id == decomps_info_mgr->get_comp_id_of_decomp(decomp_id), 
+                         "Software error4 in new Field_mem_info");
+        remap_grid_decomp = decomps_info_mgr->get_CoR_grid_of_decomp(decomp_id);
+        remap_grid_grid = original_grid_mgr->get_original_CoR_grid(comp_or_grid_id);
+        mem_size = decomps_info_mgr->get_decomp_info(decomp_id)->get_num_local_cells() * get_data_type_size(data_type) * remap_grid_grid->get_grid_size()/remap_grid_decomp->get_grid_size();
+        EXECUTION_REPORT(REPORT_ERROR, host_comp_id, remap_grid_decomp->is_subset_of_grid(remap_grid_grid), "Error happens when calling the API \"CCPL_register_field_instance\" to register a field instance of \"%s\": the parameters of grid ID and decomposition ID do not match each other: the grid corresponding to the decomposition (grid \"%s\") is not a subset of the grid corresponding to the grid ID (grid \"%s\"). Please check the model code with the annotation \"%s\"", field_name, decomps_info_mgr->get_decomp_info(decomp_id)->get_grid_name(), original_grid_mgr->get_original_grid(comp_or_grid_id)->get_grid_name(), annotation);
+    }
+    
+    host_comp_time_mgr = components_time_mgrs->get_time_mgr(host_comp_id);
+
+    const field_attr *field_attributes = fields_info->search_field_info(field_name);
+
+    if (check_field_name) {
+        EXECUTION_REPORT(REPORT_ERROR, host_comp_id, field_attributes != NULL, "Error happens when calling the API \"CCPL_register_field_instance\" to register a field instance of \"%s\": the field name \"%s\" is unknown (has not been registered through the configuration XML file public_field_attribute.xml). Please check the model code with the annotation \"%s\"", field_name, field_name, annotation);
+        bool dimensions_match_grid;
+        if (words_are_the_same(field_attributes->field_dim, FIELD_0_DIM))
+            dimensions_match_grid = decomp_id == -1 && remap_grid_grid == NULL;
+        if (words_are_the_same(field_attributes->field_dim, FIELD_V1_DIM))
+            dimensions_match_grid = decomp_id == -1 && remap_grid_grid != NULL && remap_grid_grid->get_num_dimensions() == 1 && remap_grid_grid->has_grid_coord_label(COORD_LABEL_LEV);
+        else if (words_are_the_same(field_attributes->field_dim, FIELD_2_DIM))
+            dimensions_match_grid = decomp_id != -1 && remap_grid_grid != NULL && remap_grid_grid->get_is_sphere_grid();
+        else if (words_are_the_same(field_attributes->field_dim, FIELD_3_DIM))
+            dimensions_match_grid = decomp_id != -1 && remap_grid_grid != NULL && remap_grid_grid->get_num_dimensions() == 3;
+        if (!dimensions_match_grid) {
+            if (grid_id != -1)
+                EXECUTION_REPORT(REPORT_ERROR, comp_id, false, "Error happens when calling the API \"CCPL_register_field_instance\" to register a field instance of \"%s\" at the model code with the annotation \"%s\": the dimension information (\"%s\") of the field that is specified in a configuration file does not match the dimensions of the corresponding grid \"%s\"", field_name, annotation, field_attributes->field_dim, original_grid_mgr->get_name_of_grid(grid_id));
+            else EXECUTION_REPORT(REPORT_ERROR, comp_id, false, "Error happens when calling the API \"CCPL_register_field_instance\" to register a field instance of \"%s\": the dimension information (\"%s\") of the field that is specified in a configuration file does not match the dimensions of the corresponding empty grid", field_name, annotation, field_attributes->field_dim);
+        }
+    }    
+
+    if (strlen(unit) > 0)
+        strcpy(field_unit, unit);
+    else if (field_attributes != NULL) 
+        strcpy(field_unit, fields_info->search_field_info(field_name)->field_unit);
+    // check the field unit
+
+    strcpy(this->field_name, field_name);
+    this->decomp_id = decomp_id;
+    this->comp_or_grid_id = comp_or_grid_id;
+    this->buf_mark = buf_mark;
+    this->usage_tag = -1;
     is_registered_model_buf = false;
-	is_field_active = false;
-	define_order_count = -1;
+    is_field_active = false;
+    define_order_count = -1;
     last_define_time = 0x7fffffffffffffff;
 
     remap_data_field = new Remap_data_field;
     strcpy(remap_data_field->field_name_in_application, field_name);
     strcpy(remap_data_field->field_name_in_IO_file, field_name);
     strcpy(remap_data_field->data_type_in_application, data_type);
-	strcpy(remap_data_field->data_type_in_IO_file, data_type);
+    strcpy(remap_data_field->data_type_in_IO_file, data_type);
     remap_data_field->required_data_size = mem_size / get_data_type_size(data_type);
     remap_data_field->read_data_size = remap_data_field->required_data_size;
-	if (remap_data_field->required_data_size > 0) {
-	    remap_data_field->data_buf = (char*) (new long [(mem_size+sizeof(long)-1)/sizeof(long)]);
-	    memset(remap_data_field->data_buf, 0, mem_size);
-	}
-	else remap_data_field->data_buf = NULL;
-	if (check_field_name)
-	    remap_data_field->set_field_long_name(fields_info->get_field_long_name(field_name));
+    if (remap_data_field->required_data_size > 0) {
+        remap_data_field->data_buf = (char*) (new long [(mem_size+sizeof(long)-1)/sizeof(long)]);
+        memset(remap_data_field->data_buf, 0, mem_size);
+    }
+    else remap_data_field->data_buf = NULL;
+    if (check_field_name)
+        remap_data_field->set_field_long_name(fields_info->get_field_long_name(field_name));
     remap_data_field->set_field_unit(unit);   // to complete: when strlen(unit) is 0, use default unit of the field
 
     if (decomp_id == -1)
-		grided_field_data = new Remap_grid_data_class(NULL, remap_data_field);
+        grided_field_data = new Remap_grid_data_class(NULL, remap_data_field);
     else {
         Remap_grid_class *decomp_grid = decomp_grids_mgr->search_decomp_grid_info(decomp_id, remap_grid_grid, false)->get_decomp_grid();
         grided_field_data = new Remap_grid_data_class(decomp_grid, remap_data_field);
         remap_data_field->set_fill_value(NULL);
     }
-	
-	last_checksum = -1;
+    
+    last_checksum = -1;
 }
 
 
@@ -129,17 +129,19 @@ Field_mem_info::~Field_mem_info()
 
 void Field_mem_info::reset_mem_buf(void * buf, bool is_external_field, int usage_tag)
 {
-	EXECUTION_REPORT(REPORT_ERROR, host_comp_id, buf != NULL, "The data buffer corresponding to the field instance of \"%s\" is not allocated. Please verify the model code corresponding to the annotation \"%s\"", field_name, annotation_mgr->get_annotation(field_instance_id, "allocate field instance"));
-	EXECUTION_REPORT(REPORT_ERROR, -1, !is_registered_model_buf, "Software error to release a registered buffer");
+	if (get_size_of_field() > 0)
+	    EXECUTION_REPORT(REPORT_ERROR, host_comp_id, buf != NULL, "The data buffer corresponding to the field instance of \"%s\" is not allocated. Please verify the model code corresponding to the annotation \"%s\"", field_name, annotation_mgr->get_annotation(field_instance_id, "allocate field instance"));
+    EXECUTION_REPORT(REPORT_ERROR, -1, !is_registered_model_buf, "Software error to release a registered buffer");
 
     if (grided_field_data->get_grid_data_field()->data_buf != NULL)
         delete [] grided_field_data->get_grid_data_field()->data_buf;
 
     grided_field_data->get_grid_data_field()->data_buf = buf;
-    is_registered_model_buf = true;
 
-	if (is_external_field)
-		this->usage_tag = usage_tag;
+    if (is_external_field) {
+        this->usage_tag = usage_tag;
+		is_registered_model_buf = true;
+    }
 }
 
 
@@ -151,25 +153,25 @@ void Field_mem_info::change_datatype_to_double()
 
 void Field_mem_info::define_field_values(bool is_restarting)
 {
-	if (!is_restarting)
-		is_field_active = true;
+    if (!is_restarting)
+        is_field_active = true;
     last_define_time = host_comp_time_mgr->get_current_full_time();
 }
 
 
 void Field_mem_info::use_field_values(const char *annotation)
-{	
+{    
     if (is_registered_model_buf) 
         return;
     
     if (last_define_time == host_comp_time_mgr->get_current_full_time())
         return;
 
-	if (last_define_time == 0x7fffffffffffffff) {
-		if (is_registered_model_buf)
-			EXECUTION_REPORT(REPORT_ERROR, host_comp_id, false, "field instance (field_name=\"%s\", decomp_name=\"%s\", grid_name=\"%s\", bufmark=%x) is used before defining it. Please modify the model code with the annotation \"%s\"", field_name, get_decomp_name(), get_grid_name(), buf_mark, annotation);
-		else EXECUTION_REPORT(REPORT_ERROR, -1, false, "Software error in Field_mem_info::use_field_values: field instance (field_name=\"%s\", decomp_name=\"%s\", grid_name=\"%s\", bufmark=%x) is used before defining it. Please modify the model code with the annotation \"%s\"", field_name, get_decomp_name(), get_grid_name(), buf_mark, annotation);		
-	}
+    if (last_define_time == 0x7fffffffffffffff) {
+        if (is_registered_model_buf)
+            EXECUTION_REPORT(REPORT_ERROR, host_comp_id, false, "field instance (field_name=\"%s\", decomp_name=\"%s\", grid_name=\"%s\", bufmark=%x) is used before defining it. Please modify the model code with the annotation \"%s\"", field_name, get_decomp_name(), get_grid_name(), buf_mark, annotation);
+        else EXECUTION_REPORT(REPORT_ERROR, -1, false, "Software error in Field_mem_info::use_field_values: field instance (field_name=\"%s\", decomp_name=\"%s\", grid_name=\"%s\", bufmark=%x) is used before defining it. Please modify the model code with the annotation \"%s\"", field_name, get_decomp_name(), get_grid_name(), buf_mark, annotation);        
+    }
     EXECUTION_REPORT_ERROR_OPTIONALLY(REPORT_ERROR, host_comp_id, last_define_time <= host_comp_time_mgr->get_current_full_time(), "C-Coupler error in Field_mem_info::use_field_values: wrong time order");
 }
 
@@ -194,17 +196,17 @@ void Field_mem_info::reset_field_name(const char *new_name)
 
 void Field_mem_info::calculate_field_conservative_sum(Field_mem_info *area_field)
 {
-	double partial_sum, total_sum;
+    double partial_sum, total_sum;
     long size;
 
-	if (report_internal_log_enabled) {
-		EXECUTION_REPORT(REPORT_ERROR,-1, words_are_the_same(get_field_data()->get_grid_data_field()->data_type_in_application, DATA_TYPE_DOUBLE), "C-Coupler error in calculate_field_sum");
-    	size = get_field_data()->get_grid_data_field()->required_data_size;
-	    partial_sum = 0;
-    	for (long j = 0; j < size; j ++)
-	        partial_sum += (((double*) get_data_buf())[j])*(((double*) area_field->get_data_buf())[j]);
-		MPI_Allreduce(&partial_sum, &total_sum, 1, MPI_DOUBLE, MPI_SUM, comp_comm_group_mgt_mgr->get_comm_group_of_local_comp(area_field->get_comp_id(),"in Field_mem_info::calculate_field_conservative_sum"));
-	}
+    if (report_internal_log_enabled) {
+        EXECUTION_REPORT(REPORT_ERROR,-1, words_are_the_same(get_field_data()->get_grid_data_field()->data_type_in_application, DATA_TYPE_DOUBLE), "C-Coupler error in calculate_field_sum");
+        size = get_field_data()->get_grid_data_field()->required_data_size;
+        partial_sum = 0;
+        for (long j = 0; j < size; j ++)
+            partial_sum += (((double*) get_data_buf())[j])*(((double*) area_field->get_data_buf())[j]);
+        MPI_Allreduce(&partial_sum, &total_sum, 1, MPI_DOUBLE, MPI_SUM, comp_comm_group_mgt_mgr->get_comm_group_of_local_comp(area_field->get_comp_id(),"in Field_mem_info::calculate_field_conservative_sum"));
+    }
 }
 
 
@@ -214,34 +216,34 @@ void Field_mem_info::check_field_sum(const char *hint)
     long size;
 
 
-	if (report_error_enabled && is_registered_model_buf) {
-		MPI_Barrier(comp_comm_group_mgt_mgr->get_comm_group_of_local_comp(host_comp_id, "Field_mem_info::check_field_sum"));
-		EXECUTION_REPORT_LOG(REPORT_LOG, host_comp_id, true, "Try to check the model data buffer of the field \"%s\" registered corresponding to the code annotation \"%s\". If it fails to pass the check (the model run is stopped), please make sure corresponding model data buffer is a global variable and has not been released", field_name, annotation_mgr->get_annotation(field_instance_id, "allocate field instance"));
-		char *temp_array = new char [get_size_of_field()*get_data_type_size(get_field_data()->get_grid_data_field()->data_type_in_application)];
-		memcpy(temp_array, get_data_buf(), get_size_of_field()*get_data_type_size(get_field_data()->get_grid_data_field()->data_type_in_application));
-		memcpy(get_data_buf(), temp_array, get_size_of_field()*get_data_type_size(get_field_data()->get_grid_data_field()->data_type_in_application));
-		MPI_Barrier(comp_comm_group_mgt_mgr->get_comm_group_of_local_comp(host_comp_id, "Field_mem_info::check_field_sum"));		
-		EXECUTION_REPORT_LOG(REPORT_LOG, host_comp_id, true, "Pass the check of the model data buffer of the field \"%s\" registered corresponding to the code annotation \"%s\". If it fails to pass the check (the model run is stopped), please make sure corresponding model data buffer is a global variable and has not been released", field_name, annotation_mgr->get_annotation(field_instance_id, "allocate field instance"));
-		delete [] temp_array;
-	}
-
-	if (report_internal_log_enabled) {
-		size = get_data_type_size(get_field_data()->get_grid_data_field()->data_type_in_application)*get_field_data()->get_grid_data_field()->required_data_size/4;
-		partial_sum = 0;
-		for (long j = 0; j < size; j ++)
-			partial_sum += (((int*) get_data_buf())[j]);
-
-		if (decomp_id != -1) {
-		    MPI_Allreduce(&partial_sum, &total_sum, 1, MPI_INT, MPI_SUM, comp_comm_group_mgt_mgr->get_comm_group_of_local_comp(host_comp_id, "Field_mem_info::check_field_sum"));
-		    EXECUTION_REPORT_LOG(REPORT_LOG, host_comp_id, true, "check sum of field \"%s\" %s is %x", get_field_name(), hint, total_sum);
-//		    EXECUTION_REPORT_LOG(REPORT_LOG, host_comp_id, true, "check sum of field \"%s\" %s is %x vs %x", get_field_name(), hint, total_sum, partial_sum);
-		}
-		else {
-			total_sum = partial_sum;
-			MPI_Bcast(&total_sum, 1, MPI_INT, 0, comp_comm_group_mgt_mgr->get_comm_group_of_local_comp(host_comp_id, "Field_mem_info::check_field_sum"));
-			EXECUTION_REPORT(REPORT_ERROR, host_comp_id, partial_sum == total_sum, "As an instance of the field \"%s\" is not on a horizontal grid, it should be the same but currently are not the same across all processes of the corresponding component model. Please check the model code related to the annotation \"%s\"", field_name, annotation_mgr->get_annotation(field_instance_id, "allocate field instance"));
-		}
-	}
+    if (report_error_enabled && is_registered_model_buf) {
+        MPI_Barrier(comp_comm_group_mgt_mgr->get_comm_group_of_local_comp(host_comp_id, "Field_mem_info::check_field_sum"));
+        EXECUTION_REPORT_LOG(REPORT_LOG, host_comp_id, true, "Try to check the model data buffer of the field \"%s\" registered corresponding to the code annotation \"%s\". If it fails to pass the check (the model run is stopped), please make sure corresponding model data buffer is a global variable and has not been released", field_name, annotation_mgr->get_annotation(field_instance_id, "allocate field instance"));
+        char *temp_array = new char [get_size_of_field()*get_data_type_size(get_field_data()->get_grid_data_field()->data_type_in_application)];
+        memcpy(temp_array, get_data_buf(), get_size_of_field()*get_data_type_size(get_field_data()->get_grid_data_field()->data_type_in_application));
+        memcpy(get_data_buf(), temp_array, get_size_of_field()*get_data_type_size(get_field_data()->get_grid_data_field()->data_type_in_application));
+        MPI_Barrier(comp_comm_group_mgt_mgr->get_comm_group_of_local_comp(host_comp_id, "Field_mem_info::check_field_sum"));        
+        EXECUTION_REPORT_LOG(REPORT_LOG, host_comp_id, true, "Pass the check of the model data buffer of the field \"%s\" registered corresponding to the code annotation \"%s\". If it fails to pass the check (the model run is stopped), please make sure corresponding model data buffer is a global variable and has not been released", field_name, annotation_mgr->get_annotation(field_instance_id, "allocate field instance"));
+        delete [] temp_array;
+    }
+
+    if (report_internal_log_enabled) {
+        size = get_data_type_size(get_field_data()->get_grid_data_field()->data_type_in_application)*get_field_data()->get_grid_data_field()->required_data_size/4;
+        partial_sum = 0;
+        for (long j = 0; j < size; j ++)
+            partial_sum += (((int*) get_data_buf())[j]);
+
+        if (decomp_id != -1) {
+            MPI_Allreduce(&partial_sum, &total_sum, 1, MPI_INT, MPI_SUM, comp_comm_group_mgt_mgr->get_comm_group_of_local_comp(host_comp_id, "Field_mem_info::check_field_sum"));
+            EXECUTION_REPORT_LOG(REPORT_LOG, host_comp_id, true, "check sum of field \"%s\" %s is %x", get_field_name(), hint, total_sum);
+//            EXECUTION_REPORT_LOG(REPORT_LOG, host_comp_id, true, "check sum of field \"%s\" %s is %x vs %x", get_field_name(), hint, total_sum, partial_sum);
+        }
+        else {
+            total_sum = partial_sum;
+            MPI_Bcast(&total_sum, 1, MPI_INT, 0, comp_comm_group_mgt_mgr->get_comm_group_of_local_comp(host_comp_id, "Field_mem_info::check_field_sum"));
+            EXECUTION_REPORT(REPORT_ERROR, host_comp_id, partial_sum == total_sum, "As an instance of the field \"%s\" is not on a horizontal grid, all its values should be the same but currently are not the same across all processes of the corresponding component model. Please check the model code related to the annotation \"%s\"", field_name, annotation_mgr->get_annotation(field_instance_id, "allocate field instance"));
+        }
+    }
 }
 
 
@@ -253,105 +255,105 @@ bool Field_mem_info::field_has_been_defined()
 
 long Field_mem_info::get_size_of_field()
 {
-	return grided_field_data->get_grid_data_field()->required_data_size;
+    return grided_field_data->get_grid_data_field()->required_data_size;
 }
 
 
 const char *Field_mem_info::get_grid_name() 
 {
-	if (grid_id == -1)
-		return NULL;
+    if (grid_id == -1)
+        return NULL;
 
-	return original_grid_mgr->search_grid_info(grid_id)->get_grid_name();
+    return original_grid_mgr->search_grid_info(grid_id)->get_grid_name();
 }
 
 
 const char *Field_mem_info::get_decomp_name()
 {
-	if (decomp_id == -1)
-		return NULL;
+    if (decomp_id == -1)
+        return NULL;
 
-	return decomps_info_mgr->get_decomp_info(decomp_id)->get_decomp_name();
+    return decomps_info_mgr->get_decomp_info(decomp_id)->get_decomp_name();
 }
 
 
 const char *Field_mem_info::get_data_type()
 {
-	return get_field_data()->get_grid_data_field()->data_type_in_application;
+    return get_field_data()->get_grid_data_field()->data_type_in_application;
 }
 
 
 void Field_mem_info::set_field_instance_id(int field_instance_id, const char *annotation)
 {
-	this->field_instance_id = field_instance_id;
-	annotation_mgr->add_annotation(field_instance_id, "allocate field instance", annotation);
+    this->field_instance_id = field_instance_id;
+    annotation_mgr->add_annotation(field_instance_id, "allocate field instance", annotation);
 }
 
 
 bool Field_mem_info::is_checksum_changed()
 {
-	if (last_checksum == -1)
-		return true;
+    if (last_checksum == -1)
+        return true;
 
-	long current_checksum = calculate_checksum_of_array((const char*)get_data_buf(), get_size_of_field(), get_data_type_size(get_data_type()), NULL, NULL);
-	
-	return current_checksum != last_checksum;
+    long current_checksum = calculate_checksum_of_array((const char*)get_data_buf(), get_size_of_field(), get_data_type_size(get_data_type()), NULL, NULL);
+    
+    return current_checksum != last_checksum;
 }
 
 
 void Field_mem_info::reset_checksum()
 {
-	last_checksum = calculate_checksum_of_array((const char*)get_data_buf(), get_size_of_field(), get_data_type_size(get_data_type()), NULL, NULL);
+    last_checksum = calculate_checksum_of_array((const char*)get_data_buf(), get_size_of_field(), get_data_type_size(get_data_type()), NULL, NULL);
 }
 
 
 Field_mem_info *Memory_mgt::alloc_mem(Field_mem_info *original_field_instance, int special_buf_mark, int object_id, const char *unit_or_datatype, bool check_field_name)
 {
-	EXECUTION_REPORT(REPORT_ERROR, -1, special_buf_mark == BUF_MARK_DATATYPE_TRANS || special_buf_mark == BUF_MARK_AVERAGED_INNER || special_buf_mark == BUF_MARK_AVERAGED_INTER || special_buf_mark == BUF_MARK_UNIT_TRANS || special_buf_mark == BUF_MARK_DATA_TRANSFER || 
-		             special_buf_mark == BUF_MARK_IO_FIELD_MIRROR || special_buf_mark == BUF_MARK_REMAP_NORMAL || special_buf_mark == BUF_MARK_REMAP_DATATYPE_TRANS_SRC || special_buf_mark == BUF_MARK_REMAP_DATATYPE_TRANS_DST || special_buf_mark == BUF_MARK_REMAP_FRAC, "Software error in Field_mem_info *alloc_mem: wrong special_buf_mark");
-	int new_buf_mark = (special_buf_mark ^ object_id);
-	Field_mem_info *existing_field_instance = search_field_instance(original_field_instance->get_field_name(), original_field_instance->get_decomp_id(), original_field_instance->get_comp_or_grid_id(), new_buf_mark);
-	if (existing_field_instance != NULL) {
-		if (special_buf_mark == BUF_MARK_UNIT_TRANS)
-			EXECUTION_REPORT(REPORT_ERROR, -1, words_are_the_same(existing_field_instance->get_data_type(), original_field_instance->get_data_type()) && words_are_the_same(existing_field_instance->get_unit(), unit_or_datatype), "Software error in Field_mem_info *alloc_mem: special field instance exists %lx with different data type or wrong unit", new_buf_mark);
-		else if (unit_or_datatype != NULL)
-			EXECUTION_REPORT(REPORT_ERROR, -1, words_are_the_same(existing_field_instance->get_data_type(), unit_or_datatype), "Software error in Field_mem_info *alloc_mem: special field instance exists %lx with wrong data type", new_buf_mark);
-		else EXECUTION_REPORT(REPORT_ERROR, -1, words_are_the_same(existing_field_instance->get_data_type(), original_field_instance->get_data_type()), "Software error in Field_mem_info *alloc_mem: special field instance exists %lx with wrong data type", new_buf_mark);
-		return existing_field_instance;
-	}
-	if (special_buf_mark == BUF_MARK_AVERAGED_INNER || special_buf_mark == BUF_MARK_AVERAGED_INTER)
-		fields_mem.push_back(new Field_mem_info(original_field_instance->get_field_name(), original_field_instance->get_decomp_id(), original_field_instance->get_comp_or_grid_id(), new_buf_mark, original_field_instance->get_unit(), original_field_instance->get_data_type(), "new field instance for averaging", check_field_name));	
-	else if (special_buf_mark == BUF_MARK_REMAP_FRAC)
-		fields_mem.push_back(new Field_mem_info(original_field_instance->get_field_name(), original_field_instance->get_decomp_id(), original_field_instance->get_comp_or_grid_id(), new_buf_mark, original_field_instance->get_unit(), original_field_instance->get_data_type(), "new field instance for the remapping with fraction", check_field_name));
-	else if (special_buf_mark == BUF_MARK_DATATYPE_TRANS || special_buf_mark == BUF_MARK_DATA_TRANSFER || special_buf_mark == BUF_MARK_REMAP_DATATYPE_TRANS_SRC || special_buf_mark == BUF_MARK_REMAP_DATATYPE_TRANS_DST) {
-		get_data_type_size(unit_or_datatype);
-		fields_mem.push_back(new Field_mem_info(original_field_instance->get_field_name(), original_field_instance->get_decomp_id(), original_field_instance->get_comp_or_grid_id(), new_buf_mark, original_field_instance->get_unit(), unit_or_datatype, "new field instance for data type transformation", check_field_name));
-	}
-	else if (special_buf_mark == BUF_MARK_IO_FIELD_MIRROR) {
-		get_data_type_size(unit_or_datatype);
-		fields_mem.push_back(new Field_mem_info(original_field_instance->get_field_name(), original_field_instance->get_decomp_id(), original_field_instance->get_comp_or_grid_id(), new_buf_mark, original_field_instance->get_unit(), unit_or_datatype, "new field instance for data type transformation", check_field_name));		
-	}
-	else if (special_buf_mark == BUF_MARK_UNIT_TRANS) {
-		// check unit
-		fields_mem.push_back(new Field_mem_info(original_field_instance->get_field_name(), original_field_instance->get_decomp_id(), original_field_instance->get_comp_or_grid_id(), new_buf_mark, unit_or_datatype, original_field_instance->get_data_type(), "new field instance for unit transformation", check_field_name));
-	}
-	else if (special_buf_mark == BUF_MARK_REMAP_NORMAL) {
-		// check unit
-		fields_mem.push_back(new Field_mem_info(original_field_instance->get_field_name(), original_field_instance->get_decomp_id(), original_field_instance->get_comp_or_grid_id(), new_buf_mark, original_field_instance->get_unit(), unit_or_datatype, "new field instance for remapping", check_field_name));
-	}
-	else if (special_buf_mark == BUF_MARK_REMAP_DATATYPE_TRANS_SRC) {
-		// check unit
-		fields_mem.push_back(new Field_mem_info(original_field_instance->get_field_name(), original_field_instance->get_decomp_id(), original_field_instance->get_comp_or_grid_id(), new_buf_mark, original_field_instance->get_unit(), unit_or_datatype, "new field instance for data type transformation in remapping", check_field_name));
-	}
-	else if (special_buf_mark == BUF_MARK_REMAP_DATATYPE_TRANS_DST) {
-		// check unit
-		fields_mem.push_back(new Field_mem_info(original_field_instance->get_field_name(), original_field_instance->get_decomp_id(), original_field_instance->get_comp_or_grid_id(), new_buf_mark, original_field_instance->get_unit(), unit_or_datatype, "new field instance for data type transformation in remapping", check_field_name));
-	}
-	else EXECUTION_REPORT(REPORT_ERROR, -1, false, "Software error in Field_mem_info *alloc_mem");
-
-	fields_mem[fields_mem.size()-1]->set_field_instance_id(TYPE_FIELD_INST_ID_PREFIX|(fields_mem.size()-1), "in Memory_mgt::alloc_mem");
-
-	return fields_mem[fields_mem.size()-1];
+    EXECUTION_REPORT(REPORT_ERROR, -1, special_buf_mark == BUF_MARK_DATATYPE_TRANS || special_buf_mark == BUF_MARK_AVERAGED_INNER || special_buf_mark == BUF_MARK_AVERAGED_INTER || special_buf_mark == BUF_MARK_UNIT_TRANS || special_buf_mark == BUF_MARK_DATA_TRANSFER || 
+                     special_buf_mark == BUF_MARK_IO_FIELD_MIRROR || special_buf_mark == BUF_MARK_REMAP_NORMAL || special_buf_mark == BUF_MARK_REMAP_DATATYPE_TRANS_SRC || special_buf_mark == BUF_MARK_REMAP_DATATYPE_TRANS_DST || special_buf_mark == BUF_MARK_REMAP_FRAC, "Software error in Field_mem_info *alloc_mem: wrong special_buf_mark");
+    int new_buf_mark = (special_buf_mark ^ object_id);
+    Field_mem_info *existing_field_instance = search_field_instance(original_field_instance->get_field_name(), original_field_instance->get_decomp_id(), original_field_instance->get_comp_or_grid_id(), new_buf_mark);
+    if (existing_field_instance != NULL) {
+        if (special_buf_mark == BUF_MARK_UNIT_TRANS)
+            EXECUTION_REPORT(REPORT_ERROR, -1, words_are_the_same(existing_field_instance->get_data_type(), original_field_instance->get_data_type()) && words_are_the_same(existing_field_instance->get_unit(), unit_or_datatype), "Software error in Field_mem_info *alloc_mem: special field instance exists %lx with different data type or wrong unit", new_buf_mark);
+        else if (unit_or_datatype != NULL)
+            EXECUTION_REPORT(REPORT_ERROR, -1, words_are_the_same(existing_field_instance->get_data_type(), unit_or_datatype), "Software error in Field_mem_info *alloc_mem: special field instance exists %lx with wrong data type", new_buf_mark);
+        else EXECUTION_REPORT(REPORT_ERROR, -1, words_are_the_same(existing_field_instance->get_data_type(), original_field_instance->get_data_type()), "Software error in Field_mem_info *alloc_mem: special field instance exists %lx with wrong data type", new_buf_mark);
+        return existing_field_instance;
+    }
+    if (special_buf_mark == BUF_MARK_AVERAGED_INNER || special_buf_mark == BUF_MARK_AVERAGED_INTER)
+        fields_mem.push_back(new Field_mem_info(original_field_instance->get_field_name(), original_field_instance->get_decomp_id(), original_field_instance->get_comp_or_grid_id(), new_buf_mark, original_field_instance->get_unit(), original_field_instance->get_data_type(), "new field instance for averaging", check_field_name));    
+    else if (special_buf_mark == BUF_MARK_REMAP_FRAC)
+        fields_mem.push_back(new Field_mem_info(original_field_instance->get_field_name(), original_field_instance->get_decomp_id(), original_field_instance->get_comp_or_grid_id(), new_buf_mark, original_field_instance->get_unit(), original_field_instance->get_data_type(), "new field instance for the remapping with fraction", check_field_name));
+    else if (special_buf_mark == BUF_MARK_DATATYPE_TRANS || special_buf_mark == BUF_MARK_DATA_TRANSFER || special_buf_mark == BUF_MARK_REMAP_DATATYPE_TRANS_SRC || special_buf_mark == BUF_MARK_REMAP_DATATYPE_TRANS_DST) {
+        get_data_type_size(unit_or_datatype);
+        fields_mem.push_back(new Field_mem_info(original_field_instance->get_field_name(), original_field_instance->get_decomp_id(), original_field_instance->get_comp_or_grid_id(), new_buf_mark, original_field_instance->get_unit(), unit_or_datatype, "new field instance for data type transformation", check_field_name));
+    }
+    else if (special_buf_mark == BUF_MARK_IO_FIELD_MIRROR) {
+        get_data_type_size(unit_or_datatype);
+        fields_mem.push_back(new Field_mem_info(original_field_instance->get_field_name(), original_field_instance->get_decomp_id(), original_field_instance->get_comp_or_grid_id(), new_buf_mark, original_field_instance->get_unit(), unit_or_datatype, "new field instance for data type transformation", check_field_name));        
+    }
+    else if (special_buf_mark == BUF_MARK_UNIT_TRANS) {
+        // check unit
+        fields_mem.push_back(new Field_mem_info(original_field_instance->get_field_name(), original_field_instance->get_decomp_id(), original_field_instance->get_comp_or_grid_id(), new_buf_mark, unit_or_datatype, original_field_instance->get_data_type(), "new field instance for unit transformation", check_field_name));
+    }
+    else if (special_buf_mark == BUF_MARK_REMAP_NORMAL) {
+        // check unit
+        fields_mem.push_back(new Field_mem_info(original_field_instance->get_field_name(), original_field_instance->get_decomp_id(), original_field_instance->get_comp_or_grid_id(), new_buf_mark, original_field_instance->get_unit(), unit_or_datatype, "new field instance for remapping", check_field_name));
+    }
+    else if (special_buf_mark == BUF_MARK_REMAP_DATATYPE_TRANS_SRC) {
+        // check unit
+        fields_mem.push_back(new Field_mem_info(original_field_instance->get_field_name(), original_field_instance->get_decomp_id(), original_field_instance->get_comp_or_grid_id(), new_buf_mark, original_field_instance->get_unit(), unit_or_datatype, "new field instance for data type transformation in remapping", check_field_name));
+    }
+    else if (special_buf_mark == BUF_MARK_REMAP_DATATYPE_TRANS_DST) {
+        // check unit
+        fields_mem.push_back(new Field_mem_info(original_field_instance->get_field_name(), original_field_instance->get_decomp_id(), original_field_instance->get_comp_or_grid_id(), new_buf_mark, original_field_instance->get_unit(), unit_or_datatype, "new field instance for data type transformation in remapping", check_field_name));
+    }
+    else EXECUTION_REPORT(REPORT_ERROR, -1, false, "Software error in Field_mem_info *alloc_mem");
+
+    fields_mem[fields_mem.size()-1]->set_field_instance_id(TYPE_FIELD_INST_ID_PREFIX|(fields_mem.size()-1), "in Memory_mgt::alloc_mem");
+
+    return fields_mem[fields_mem.size()-1];
 }
 
 
@@ -362,33 +364,35 @@ Field_mem_info *Memory_mgt::alloc_mem(const char *field_name, int decomp_id, int
     bool find_field_in_cfg;
 
 
-	EXECUTION_REPORT(REPORT_ERROR, -1, buf_mark < 0, "Software error in Memory_mgt::alloc_mem: wrong value of buffer mark");
-	EXECUTION_REPORT(REPORT_ERROR, -1, data_type != NULL, "Software error in Memory_mgt::alloc_mem: data type is NULL");
-	get_data_type_size(data_type);
-	if (decomp_id != -1) {
-		EXECUTION_REPORT(REPORT_ERROR, -1, decomps_info_mgr->is_decomp_id_legal(decomp_id), "Software error in Memory_mgt::alloc_mem: wrong decomposition id");
-		EXECUTION_REPORT(REPORT_ERROR, -1, original_grid_mgr->is_grid_id_legal(comp_or_grid_id), "Software error in Memory_mgt::alloc_mem: wrong grid id");
-		comp_id = original_grid_mgr->search_grid_info(comp_or_grid_id)->get_comp_id();
-	}
-	else {
-		EXECUTION_REPORT(REPORT_ERROR, -1, comp_comm_group_mgt_mgr->is_legal_local_comp_id(comp_or_grid_id,false), "Software error in Memory_mgt::alloc_mem: wrong component id");
-		comp_id = comp_or_grid_id;
-	}
-
-	
+    EXECUTION_REPORT(REPORT_ERROR, -1, buf_mark < 0, "Software error in Memory_mgt::alloc_mem: wrong value of buffer mark");
+    EXECUTION_REPORT(REPORT_ERROR, -1, data_type != NULL, "Software error in Memory_mgt::alloc_mem: data type is NULL");
+    get_data_type_size(data_type);
+    if (decomp_id != -1) {
+        EXECUTION_REPORT(REPORT_ERROR, -1, decomps_info_mgr->is_decomp_id_legal(decomp_id), "Software error in Memory_mgt::alloc_mem: wrong decomposition id");
+        EXECUTION_REPORT(REPORT_ERROR, -1, original_grid_mgr->is_grid_id_legal(comp_or_grid_id), "Software error in Memory_mgt::alloc_mem: wrong grid id");
+        comp_id = original_grid_mgr->search_grid_info(comp_or_grid_id)->get_comp_id();
+    }
+    else {
+        EXECUTION_REPORT(REPORT_ERROR, -1, comp_comm_group_mgt_mgr->is_legal_local_comp_id(comp_or_grid_id,false) || original_grid_mgr->is_grid_id_legal(comp_or_grid_id), "Software error in Memory_mgt::alloc_mem: wrong component id or grid_id");
+		if (original_grid_mgr->is_grid_id_legal(comp_or_grid_id))
+			comp_id = original_grid_mgr->search_grid_info(comp_or_grid_id)->get_comp_id();
+		else comp_id = comp_or_grid_id;
+    }
+
+    
     /* If memory buffer has been allocated, return it */
     for (i = 0; i < fields_mem.size(); i ++)
         if (fields_mem[i]->match_field_instance(field_name, decomp_id, comp_or_grid_id, buf_mark)) {
             // EXECUTION_REPORT(REPORT_ERROR, comp_id, field_unit, ...);
-			EXECUTION_REPORT(REPORT_ERROR, -1, words_are_the_same(data_type, fields_mem[i]->get_field_data()->get_grid_data_field()->data_type_in_application),
-			                 "Software error in Memory_mgt::alloc_mem: data types conflict");
+            EXECUTION_REPORT(REPORT_ERROR, -1, words_are_the_same(data_type, fields_mem[i]->get_field_data()->get_grid_data_field()->data_type_in_application),
+                             "Software error in Memory_mgt::alloc_mem: data types conflict");
             return fields_mem[i];
         }
 
     /* Compute the size of the memory buffer and then allocate and return it */
     field_mem = new Field_mem_info(field_name, decomp_id, comp_or_grid_id, buf_mark, field_unit, data_type, annotation, check_field_name);
-	field_mem->set_field_instance_id(TYPE_FIELD_INST_ID_PREFIX|fields_mem.size(), annotation);
-	fields_mem.push_back(field_mem);
+    field_mem->set_field_instance_id(TYPE_FIELD_INST_ID_PREFIX|fields_mem.size(), annotation);
+    fields_mem.push_back(field_mem);
 
     return field_mem;
 }
@@ -407,133 +411,134 @@ Field_mem_info *Memory_mgt::search_field_via_data_buf(const void *data_buf, bool
         if (fields_mem[i]->get_data_buf() == data_buf)
             return fields_mem[i];
 
-	if (diag)
-	    EXECUTION_REPORT(REPORT_ERROR,-1, false, "C-Coupler error in search_field_via_data_buf\n");
+    if (diag)
+        EXECUTION_REPORT(REPORT_ERROR,-1, false, "C-Coupler error in search_field_via_data_buf\n");
     return NULL;
 }
 
 
 void Memory_mgt::check_sum_of_all_fields()
 {
-	for (int i = 0; i < fields_mem.size(); i ++)
-		fields_mem[i]->check_field_sum("when checking all fields");
+    for (int i = 0; i < fields_mem.size(); i ++)
+        fields_mem[i]->check_field_sum("when checking all fields");
 }
 
 
 int Memory_mgt::get_field_size(void *data_buf, const char *annotation)
 {
-	Field_mem_info *field = search_field_via_data_buf(data_buf, false);
+    Field_mem_info *field = search_field_via_data_buf(data_buf, false);
 
-	EXECUTION_REPORT(REPORT_ERROR,-1, field != NULL, "Detect a memory buffer that is not managed by C-Coupler. Please verify the model code according to annotation \"%s\"", annotation);
+    EXECUTION_REPORT(REPORT_ERROR,-1, field != NULL, "Detect a memory buffer that is not managed by C-Coupler. Please verify the model code according to annotation \"%s\"", annotation);
 
-	return field->get_size_of_field();
+    return field->get_size_of_field();
 }
 
 
 Field_mem_info *Memory_mgt::search_field_instance(const char *field_name, int decomp_id, int comp_or_grid_id, int buf_mark)
 {
-	for (int i = 0; i < fields_mem.size(); i ++)
-		if (fields_mem[i]->match_field_instance(field_name, decomp_id, comp_or_grid_id, buf_mark))
-			return fields_mem[i];
+    for (int i = 0; i < fields_mem.size(); i ++)
+        if (fields_mem[i]->match_field_instance(field_name, decomp_id, comp_or_grid_id, buf_mark))
+            return fields_mem[i];
 
-	return NULL;
+    return NULL;
 }
 
 
 int Memory_mgt::register_external_field_instance(const char *field_name, void *data_buffer, int field_size, int decomp_id, int comp_or_grid_id, 
-	                                             int buf_mark, int usage_tag, const char *unit, const char *data_type, const char *annotation)
+                                                 int buf_mark, int usage_tag, const char *unit, const char *data_type, const char *annotation)
 {
-	int comp_id, API_id;
-	Field_mem_info *existing_field_instance_instance, *new_field_instance;
-
-
-	if (buf_mark == BUF_MARK_IO_FIELD_REG)
-		API_id = API_ID_FIELD_MGT_REG_IO_FIELD_from_BUFFER;
-	else API_id = API_ID_FIELD_MGT_REG_FIELD_INST;
-
-	EXECUTION_REPORT(REPORT_ERROR, -1, comp_comm_group_mgt_mgr->is_legal_local_comp_id(comp_or_grid_id,true) || original_grid_mgr->is_grid_id_legal(comp_or_grid_id), "Error happens when calling the API \"CCPL_register_field_instance\" to register a field instance of \"%s\": the parameter of \"comp_or_grid_id\" is not a grid id or a component id. Please check the model code with the annotation \"%s\"", field_name, annotation);
-	
-	if (comp_comm_group_mgt_mgr->is_legal_local_comp_id(comp_or_grid_id,true))
-		comp_id = comp_or_grid_id;
-	else comp_id = original_grid_mgr->get_comp_id_of_grid(comp_or_grid_id);
-
-	check_API_parameter_string_length(comp_id, API_id, CCPL_NAME_STR_LEN, field_name, "field_name", annotation);
-	check_and_verify_name_format_of_string_for_API(comp_id, field_name, API_id, "the field instance", annotation);
-
-	if (decomp_id != -1) {
-		EXECUTION_REPORT(REPORT_ERROR, -1, decomps_info_mgr->is_decomp_id_legal(decomp_id), "Error happens when calling the API \"CCPL_register_field_instance\" to register a field instance of \"%s\": the parameter of decomposition ID is wrong. Please check the model code with the annotation \"%s\"", field_name, annotation);
-		EXECUTION_REPORT(REPORT_ERROR, -1, original_grid_mgr->is_grid_id_legal(comp_or_grid_id), "Error happens when calling the API \"CCPL_register_field_instance\" to register a field instance of \"%s\": the parameter of grid ID is wrong. Please check the model code with the annotation \"%s\"", field_name, annotation);		
-		EXECUTION_REPORT(REPORT_ERROR, -1, comp_id == decomps_info_mgr->get_comp_id_of_decomp(decomp_id), 
-			             "Error happens when calling the API \"CCPL_register_field_instance\" to register a field instance of \"%s\": the parameters of grid ID and decomposition ID do not match each other: they belong to different component models. Please check the model code with the annotation \"%s\"",
-			             field_name, annotation);
-		EXECUTION_REPORT(REPORT_ERROR, -1, comp_comm_group_mgt_mgr->is_legal_local_comp_id(comp_id,true), "Software error in Memory_mgt::register_external_field_instance: illegal component id from grid id");
-	}
-	synchronize_comp_processes_for_API(comp_id, API_id, comp_comm_group_mgt_mgr->get_comm_group_of_local_comp(comp_id,"C-Coupler code in register_external_field_instance for getting component management node"), "registering a field instance or a I/O field", annotation);
-	comp_comm_group_mgt_mgr->confirm_coupling_configuration_active(comp_id, API_id, true, annotation);
-	check_API_parameter_string(comp_id, API_id, comp_comm_group_mgt_mgr->get_comm_group_of_local_comp(comp_id,"C-Coupler code in register_external_field_instance for getting component management node"), "registering a field instance or a I/O field", field_name, "field name", annotation);
-	check_API_parameter_string(comp_id, API_id, comp_comm_group_mgt_mgr->get_comm_group_of_local_comp(comp_id,"C-Coupler code in register_external_field_instance for getting component management node"), "registering a field instance or a I/O field", comp_comm_group_mgt_mgr->get_global_node_of_local_comp(comp_id,true,"C-Coupler code in register_external_field_instance for getting component management node")->get_comp_name(), "the component name specified by the corresponding ID", annotation);
-	check_API_parameter_int(comp_id, API_id, comp_comm_group_mgt_mgr->get_comm_group_of_local_comp(comp_id,"C-Coupler code in register_external_field_instance for getting component management node"), NULL, buf_mark, "buf_mark", annotation);
-	check_API_parameter_int(comp_id, API_id, comp_comm_group_mgt_mgr->get_comm_group_of_local_comp(comp_id,"C-Coupler code in register_external_field_instance for getting component management node"), NULL, usage_tag, "usage_tag", annotation);
-	check_API_parameter_string(comp_id, API_id, comp_comm_group_mgt_mgr->get_comm_group_of_local_comp(comp_id,"C-Coupler code in register_external_field_instance for getting component management node"), "registering a field instance or a I/O field", data_type, "the data type (such as integer, float, and double) of the field instance", annotation);
-	check_API_parameter_string(comp_id, API_id, comp_comm_group_mgt_mgr->get_comm_group_of_local_comp(comp_id,"C-Coupler code in register_external_field_instance for getting component management node"), "registering a field instance or a I/O field", unit, "unit", annotation);
-	if (decomp_id == -1) {
-		check_API_parameter_int(comp_id, API_id, comp_comm_group_mgt_mgr->get_comm_group_of_local_comp(comp_id,"C-Coupler code in register_external_field_instance for getting component management node"), NULL, decomp_id, "decomp_id (the ID of the parallel decomposition)", annotation);
-		int temp_int = (comp_id == comp_or_grid_id)? 1 : 0;
-		check_API_parameter_int(comp_id, API_id, comp_comm_group_mgt_mgr->get_comm_group_of_local_comp(comp_id,"C-Coupler code in register_external_field_instance for getting component management node"), NULL, decomp_id, "comp_or_grid_id (a grid id or a component id)", annotation);
-		if (comp_id != comp_or_grid_id)	{
-			check_API_parameter_string(comp_id, API_id, comp_comm_group_mgt_mgr->get_comm_group_of_local_comp(comp_id,"C-Coupler code in register_external_field_instance for getting component management node"), "registering a field instance or a I/O field", original_grid_mgr->get_name_of_grid(comp_or_grid_id), "the grid name specified by the corresponding ID", annotation);
-			EXECUTION_REPORT(REPORT_ERROR, comp_id, original_grid_mgr->get_original_grid(comp_or_grid_id)->get_H2D_sub_CoR_grid() == NULL && original_grid_mgr->get_original_grid(comp_or_grid_id)->get_V1D_sub_CoR_grid() != NULL, "Error happens when calling the API \"CCPL_register_field_instance\" to register a field instance of \"%s\": the grid corresponding to the parameter of \"comp_or_grid_id\" (the grid is \"%s\") should be but not a vertical grid when the given \"decomp_id\" is -1. Please check the model code with the annotation \"%s\"", field_name, original_grid_mgr->get_original_grid(comp_or_grid_id)->get_grid_name(), annotation);
-		}
-		EXECUTION_REPORT(REPORT_ERROR, -1, comp_id == comp_or_grid_id, "Error happens when calling the API \"CCPL_register_field_instance\" to register a field instance of \"%s\" at the model code with the annotation \"%s\". We are sorry that C-Coupler now only supports the coupling of a scalar field or a field on a grid related to a horizontal grid that is decomposed in parallelization of a model. If you want to couple more kinds of fields, please contact us (liuli-cess@tsinghua.edu.cn)", field_name, annotation);
-	}
-	else {
-		check_API_parameter_string(comp_id, API_id, comp_comm_group_mgt_mgr->get_comm_group_of_local_comp(comp_id,"C-Coupler code in register_external_field_instance for getting component management node"), "registering a field instance or a I/O field", decomps_info_mgr->get_decomp_info(decomp_id)->get_decomp_name(), "the parallel decomposition name specified by the corresponding ID", annotation);
-		check_API_parameter_string(comp_id, API_id, comp_comm_group_mgt_mgr->get_comm_group_of_local_comp(comp_id,"C-Coupler code in register_external_field_instance for getting component management node"), "registering a field instance or a I/O field", original_grid_mgr->get_name_of_grid(comp_or_grid_id), "the grid name specified by the corresponding ID", annotation);
-	}
-
-	if (buf_mark != BUF_MARK_IO_FIELD_REG)
-		EXECUTION_REPORT(REPORT_ERROR, comp_id, buf_mark >= 0, "Error happens when calling the API \"CCPL_register_field_instance\" to register a field instance of \"%s\": the parameter of the mark (\"buf_mark\") of the field instance cannot be a negative integer (currently is %d). Please check the model code with the annotation \"%s\"",
-				         field_name, buf_mark, annotation);
-
-	existing_field_instance_instance = search_field_instance(field_name, decomp_id, comp_or_grid_id, buf_mark);
-	if (existing_field_instance_instance != NULL)
-		EXECUTION_REPORT(REPORT_ERROR, comp_id, false, "Error happens when calling the API \"CCPL_register_field_instance\" to register a field instance of \"%s\": cannot register an instance of the field of \"%s\" again (the corresponding annotation is \"%s\") because this field instance has been registered before (the corresponding annotation is \"%s\")", 
-						 field_name, annotation, annotation_mgr->get_annotation(existing_field_instance_instance->get_field_instance_id(), "allocate field instance"));
-
-	new_field_instance = new Field_mem_info(field_name, decomp_id, comp_or_grid_id, buf_mark, unit, data_type, annotation, (buf_mark!=BUF_MARK_IO_FIELD_REG) && (usage_tag&REG_FIELD_TAG_CPL) == REG_FIELD_TAG_CPL);
-	EXECUTION_REPORT(REPORT_ERROR, comp_id, field_size == new_field_instance->get_size_of_field(), "Error happens when calling the API \"CCPL_register_field_instance\" to register a field instance of \"%s\": the size of the model data buffer (currently is %d) is different from the size determined by the parallel decomposition and grid (currently is %ld). Please check the model code with the annotation \"%s\"",
-					 field_name, field_size, new_field_instance->get_size_of_field(), annotation);
-	new_field_instance->set_field_instance_id(TYPE_FIELD_INST_ID_PREFIX|fields_mem.size(), annotation);
-	new_field_instance->reset_mem_buf(data_buffer, true, usage_tag);
-	EXECUTION_REPORT(REPORT_ERROR, comp_id, usage_tag >= 0 && usage_tag <= 3, "Error happens when calling the API \"CCPL_register_field_instance\" to register a field instance of \"%s\": the value of the parameter \"usage_tag\" (%d) is wrong. The right value should be between 1 and 3. Please check the model code with the annotation \"%s\"", field_name, usage_tag, annotation);
-	fields_mem.push_back(new_field_instance);
-
-	return new_field_instance->get_field_instance_id();
+    int comp_id, API_id;
+    Field_mem_info *existing_field_instance_instance, *new_field_instance;
+
+
+    if (buf_mark == BUF_MARK_IO_FIELD_REG)
+        API_id = API_ID_FIELD_MGT_REG_IO_FIELD_from_BUFFER;
+    else API_id = API_ID_FIELD_MGT_REG_FIELD_INST;
+
+    EXECUTION_REPORT(REPORT_ERROR, -1, comp_comm_group_mgt_mgr->is_legal_local_comp_id(comp_or_grid_id,true) || original_grid_mgr->is_grid_id_legal(comp_or_grid_id), "Error happens when calling the API \"CCPL_register_field_instance\" to register a field instance of \"%s\": the parameter of \"comp_or_grid_id\" is not a grid id or a component id. Please check the model code with the annotation \"%s\"", field_name, annotation);
+    
+    if (comp_comm_group_mgt_mgr->is_legal_local_comp_id(comp_or_grid_id,true))
+        comp_id = comp_or_grid_id;
+    else comp_id = original_grid_mgr->get_comp_id_of_grid(comp_or_grid_id);
+
+    check_API_parameter_string_length(comp_id, API_id, CCPL_NAME_STR_LEN, field_name, "field_name", annotation);
+    check_and_verify_name_format_of_string_for_API(comp_id, field_name, API_id, "the field instance", annotation);
+
+    if (decomp_id != -1) {
+        EXECUTION_REPORT(REPORT_ERROR, -1, decomps_info_mgr->is_decomp_id_legal(decomp_id), "Error happens when calling the API \"CCPL_register_field_instance\" to register a field instance of \"%s\": the parameter of decomposition ID is wrong. Please check the model code with the annotation \"%s\"", field_name, annotation);
+        EXECUTION_REPORT(REPORT_ERROR, -1, original_grid_mgr->is_grid_id_legal(comp_or_grid_id), "Error happens when calling the API \"CCPL_register_field_instance\" to register a field instance of \"%s\": the parameter of grid ID is wrong. Please check the model code with the annotation \"%s\"", field_name, annotation);        
+        EXECUTION_REPORT(REPORT_ERROR, -1, comp_id == decomps_info_mgr->get_comp_id_of_decomp(decomp_id), 
+                         "Error happens when calling the API \"CCPL_register_field_instance\" to register a field instance of \"%s\": the parameters of grid ID and decomposition ID do not match each other: they belong to different component models. Please check the model code with the annotation \"%s\"",
+                         field_name, annotation);
+        EXECUTION_REPORT(REPORT_ERROR, -1, comp_comm_group_mgt_mgr->is_legal_local_comp_id(comp_id,true), "Software error in Memory_mgt::register_external_field_instance: illegal component id from grid id");
+    }
+    synchronize_comp_processes_for_API(comp_id, API_id, comp_comm_group_mgt_mgr->get_comm_group_of_local_comp(comp_id,"C-Coupler code in register_external_field_instance for getting component management node"), "registering a field instance or a I/O field", annotation);
+    comp_comm_group_mgt_mgr->confirm_coupling_configuration_active(comp_id, API_id, true, annotation);
+    check_API_parameter_string(comp_id, API_id, comp_comm_group_mgt_mgr->get_comm_group_of_local_comp(comp_id,"C-Coupler code in register_external_field_instance for getting component management node"), "registering a field instance or a I/O field", field_name, "field name", annotation);
+    check_API_parameter_string(comp_id, API_id, comp_comm_group_mgt_mgr->get_comm_group_of_local_comp(comp_id,"C-Coupler code in register_external_field_instance for getting component management node"), "registering a field instance or a I/O field", comp_comm_group_mgt_mgr->get_global_node_of_local_comp(comp_id,true,"C-Coupler code in register_external_field_instance for getting component management node")->get_comp_name(), "the component name specified by the corresponding ID", annotation);
+    check_API_parameter_int(comp_id, API_id, comp_comm_group_mgt_mgr->get_comm_group_of_local_comp(comp_id,"C-Coupler code in register_external_field_instance for getting component management node"), NULL, buf_mark, "buf_mark", annotation);
+    check_API_parameter_int(comp_id, API_id, comp_comm_group_mgt_mgr->get_comm_group_of_local_comp(comp_id,"C-Coupler code in register_external_field_instance for getting component management node"), NULL, usage_tag, "usage_tag", annotation);
+    check_API_parameter_string(comp_id, API_id, comp_comm_group_mgt_mgr->get_comm_group_of_local_comp(comp_id,"C-Coupler code in register_external_field_instance for getting component management node"), "registering a field instance or a I/O field", data_type, "the data type (such as integer, float, and double) of the field instance", annotation);
+    check_API_parameter_string(comp_id, API_id, comp_comm_group_mgt_mgr->get_comm_group_of_local_comp(comp_id,"C-Coupler code in register_external_field_instance for getting component management node"), "registering a field instance or a I/O field", unit, "unit", annotation);
+    if (decomp_id == -1) {
+        check_API_parameter_int(comp_id, API_id, comp_comm_group_mgt_mgr->get_comm_group_of_local_comp(comp_id,"C-Coupler code in register_external_field_instance for getting component management node"), NULL, decomp_id, "decomp_id (the ID of the parallel decomposition)", annotation);
+        int temp_int = (comp_id == comp_or_grid_id)? 1 : 0;
+        check_API_parameter_int(comp_id, API_id, comp_comm_group_mgt_mgr->get_comm_group_of_local_comp(comp_id,"C-Coupler code in register_external_field_instance for getting component management node"), NULL, decomp_id, "comp_or_grid_id (a grid id or a component id)", annotation);
+        if (comp_id != comp_or_grid_id)    {
+            check_API_parameter_string(comp_id, API_id, comp_comm_group_mgt_mgr->get_comm_group_of_local_comp(comp_id,"C-Coupler code in register_external_field_instance for getting component management node"), "registering a field instance or a I/O field", original_grid_mgr->get_name_of_grid(comp_or_grid_id), "the grid name specified by the corresponding ID", annotation);
+            EXECUTION_REPORT(REPORT_ERROR, comp_id, original_grid_mgr->get_original_grid(comp_or_grid_id)->get_H2D_sub_CoR_grid() == NULL && original_grid_mgr->get_original_grid(comp_or_grid_id)->get_V1D_sub_CoR_grid() != NULL, "Error happens when calling the API \"CCPL_register_field_instance\" to register a field instance of \"%s\": the grid corresponding to the parameter of \"comp_or_grid_id\" (the grid is \"%s\") should be but not a vertical grid when the given \"decomp_id\" is -1. Please check the model code with the annotation \"%s\"", field_name, original_grid_mgr->get_original_grid(comp_or_grid_id)->get_grid_name(), annotation);
+        }
+        EXECUTION_REPORT(REPORT_ERROR, -1, comp_id == comp_or_grid_id, "Error happens when calling the API \"CCPL_register_field_instance\" to register a field instance of \"%s\" at the model code with the annotation \"%s\". We are sorry that C-Coupler now only supports the coupling of a scalar field or a field on a grid related to a horizontal grid that is decomposed in parallelization of a model. If you want to couple more kinds of fields, please contact us (liuli-cess@tsinghua.edu.cn)", field_name, annotation);
+    }
+    else {
+        check_API_parameter_string(comp_id, API_id, comp_comm_group_mgt_mgr->get_comm_group_of_local_comp(comp_id,"C-Coupler code in register_external_field_instance for getting component management node"), "registering a field instance or a I/O field", decomps_info_mgr->get_decomp_info(decomp_id)->get_decomp_name(), "the parallel decomposition name specified by the corresponding ID", annotation);
+        check_API_parameter_string(comp_id, API_id, comp_comm_group_mgt_mgr->get_comm_group_of_local_comp(comp_id,"C-Coupler code in register_external_field_instance for getting component management node"), "registering a field instance or a I/O field", original_grid_mgr->get_name_of_grid(comp_or_grid_id), "the grid name specified by the corresponding ID", annotation);
+    }
+
+    if (buf_mark != BUF_MARK_IO_FIELD_REG)
+        EXECUTION_REPORT(REPORT_ERROR, comp_id, buf_mark >= 0, "Error happens when calling the API \"CCPL_register_field_instance\" to register a field instance of \"%s\": the parameter of the mark (\"buf_mark\") of the field instance cannot be a negative integer (currently is %d). Please check the model code with the annotation \"%s\"",
+                         field_name, buf_mark, annotation);
+
+    existing_field_instance_instance = search_field_instance(field_name, decomp_id, comp_or_grid_id, buf_mark);
+    if (existing_field_instance_instance != NULL)
+        EXECUTION_REPORT(REPORT_ERROR, comp_id, false, "Error happens when calling the API \"CCPL_register_field_instance\" to register a field instance: cannot register an instance of the field of \"%s\" again (the corresponding annotation is \"%s\") because this field instance has been registered before (the corresponding annotation is \"%s\")", 
+                         field_name, annotation, annotation_mgr->get_annotation(existing_field_instance_instance->get_field_instance_id(), "allocate field instance"));
+
+    new_field_instance = new Field_mem_info(field_name, decomp_id, comp_or_grid_id, buf_mark, unit, data_type, annotation, (buf_mark!=BUF_MARK_IO_FIELD_REG) && (usage_tag&REG_FIELD_TAG_CPL) == REG_FIELD_TAG_CPL);
+    if (new_field_instance->get_size_of_field() > 0)
+        EXECUTION_REPORT(REPORT_ERROR, comp_id, field_size == new_field_instance->get_size_of_field(), "Error happens when calling the API \"CCPL_register_field_instance\" to register a field instance of \"%s\": the size of the model data buffer (currently is %d) is different from the size determined by the parallel decomposition and grid (currently is %ld). Please check the model code with the annotation \"%s\"",
+    	                 field_name, field_size, new_field_instance->get_size_of_field(), annotation);
+    new_field_instance->set_field_instance_id(TYPE_FIELD_INST_ID_PREFIX|fields_mem.size(), annotation);
+    new_field_instance->reset_mem_buf(data_buffer, true, usage_tag);
+    EXECUTION_REPORT(REPORT_ERROR, comp_id, usage_tag >= 0 && usage_tag <= 3, "Error happens when calling the API \"CCPL_register_field_instance\" to register a field instance of \"%s\": the value of the parameter \"usage_tag\" (%d) is wrong. The right value should be between 1 and 3. Please check the model code with the annotation \"%s\"", field_name, usage_tag, annotation);
+    fields_mem.push_back(new_field_instance);
+
+    return new_field_instance->get_field_instance_id();
 }
 
 
 bool Memory_mgt::check_is_legal_field_instance_id(int field_instance_id)
 {
-	if ((field_instance_id&TYPE_ID_PREFIX_MASK) != TYPE_FIELD_INST_ID_PREFIX)
-		return false;
+    if ((field_instance_id&TYPE_ID_PREFIX_MASK) != TYPE_FIELD_INST_ID_PREFIX)
+        return false;
 
-	return (field_instance_id&TYPE_ID_SUFFIX_MASK) < fields_mem.size();
+    return (field_instance_id&TYPE_ID_SUFFIX_MASK) < fields_mem.size();
 }
 
 
 Field_mem_info *Memory_mgt::get_field_instance(int field_instance_id)
 {
-	if (!check_is_legal_field_instance_id(field_instance_id))
-		return NULL;
+    if (!check_is_legal_field_instance_id(field_instance_id))
+        return NULL;
 
-	return fields_mem[field_instance_id&TYPE_ID_SUFFIX_MASK];
+    return fields_mem[field_instance_id&TYPE_ID_SUFFIX_MASK];
 }
 
 
 void Memory_mgt::copy_field_data_values(Field_mem_info *dst_field_inst, Field_mem_info *src_field_inst)
 {
-	EXECUTION_REPORT(REPORT_ERROR, -1, dst_field_inst->get_decomp_id() == src_field_inst->get_decomp_id() && dst_field_inst->get_comp_id() == src_field_inst->get_comp_id() && dst_field_inst->get_grid_id() == src_field_inst->get_grid_id() && words_are_the_same(src_field_inst->get_data_type(), dst_field_inst->get_data_type()),
-		             "Software erorr in Memory_mgt::copy_field_data_values");
-	memcpy(dst_field_inst->get_data_buf(), src_field_inst->get_data_buf(), dst_field_inst->get_size_of_field()*get_data_type_size(dst_field_inst->get_data_type()));
+    EXECUTION_REPORT(REPORT_ERROR, -1, dst_field_inst->get_decomp_id() == src_field_inst->get_decomp_id() && dst_field_inst->get_comp_id() == src_field_inst->get_comp_id() && dst_field_inst->get_grid_id() == src_field_inst->get_grid_id() && words_are_the_same(src_field_inst->get_data_type(), dst_field_inst->get_data_type()),
+                     "Software erorr in Memory_mgt::copy_field_data_values");
+    memcpy(dst_field_inst->get_data_buf(), src_field_inst->get_data_buf(), dst_field_inst->get_size_of_field()*get_data_type_size(dst_field_inst->get_data_type()));
 }
 
diff --git a/src/Data_MGT/memory_mgt.h b/src/Data_MGT/memory_mgt.h
old mode 100644
new mode 100755
index f082821..952798a
--- a/src/Data_MGT/memory_mgt.h
+++ b/src/Data_MGT/memory_mgt.h
@@ -41,61 +41,61 @@ class Field_mem_info
 {
     private:
         char field_name[NAME_STR_SIZE];
-		char field_unit[NAME_STR_SIZE];
-		int field_instance_id;
-		int decomp_id;
-		int grid_id;
-		int comp_or_grid_id;
-		int comp_id;
-		int host_comp_id;
-		int buf_mark;
-		int usage_tag;
+        char field_unit[NAME_STR_SIZE];
+        int field_instance_id;
+        int decomp_id;
+        int grid_id;
+        int comp_or_grid_id;
+        int comp_id;
+        int host_comp_id;
+        int buf_mark;
+        int usage_tag;
         bool is_registered_model_buf;
-		long last_define_time;
-		long define_order_count;
-		bool is_field_active;
+        long last_define_time;
+        long define_order_count;
+        bool is_field_active;
         Remap_grid_data_class *grided_field_data;
-		Time_mgt *host_comp_time_mgr;
-		long last_checksum;
+        Time_mgt *host_comp_time_mgr;
+        long last_checksum;
 
     public:
-		Field_mem_info(const char *, int, int, int, const char *, const char *, const char *, bool);
-		bool match_field_instance(const char *, int, int, int);
-		bool match_field_mem(void*);
-		bool get_is_registered_model_buf() { return is_registered_model_buf; }
-		bool check_is_field_active() { return is_field_active; }
+        Field_mem_info(const char *, int, int, int, const char *, const char *, const char *, bool);
+        bool match_field_instance(const char *, int, int, int);
+        bool match_field_mem(void*);
+        bool get_is_registered_model_buf() { return is_registered_model_buf; }
+        bool check_is_field_active() { return is_field_active; }
         void *get_data_buf() { return grided_field_data->get_grid_data_field()->data_buf; }
         Remap_grid_data_class *get_field_data() { return grided_field_data; }
         void reset_mem_buf(void *buf, bool, int);
         const char *get_decomp_name();
         const char *get_field_name() const { return field_name; }
-		long get_size_of_field();
+        long get_size_of_field();
         void reset_field_name(const char*);
-		void change_datatype_to_double();
-		void calculate_field_conservative_sum(Field_mem_info*);
+        void change_datatype_to_double();
+        void calculate_field_conservative_sum(Field_mem_info*);
         void check_field_sum(const char *);
-		void define_field_values(bool);
-		void use_field_values(const char*);
-		bool field_has_been_defined();
-		long get_last_define_time() const { return last_define_time; }
-		void set_define_order_count(long count) { define_order_count = count; }
-		long get_define_order_count() const { return define_order_count; }
-		int get_field_instance_id() const { return field_instance_id; }
-		int get_comp_id() { return comp_id; }
-		int get_host_comp_id() { return host_comp_id; }
-		int get_grid_id() { return grid_id; }
+        void define_field_values(bool);
+        void use_field_values(const char*);
+        bool field_has_been_defined();
+        long get_last_define_time() const { return last_define_time; }
+        void set_define_order_count(long count) { define_order_count = count; }
+        long get_define_order_count() const { return define_order_count; }
+        int get_field_instance_id() const { return field_instance_id; }
+        int get_comp_id() { return comp_id; }
+        int get_host_comp_id() { return host_comp_id; }
+        int get_grid_id() { return grid_id; }
         const char *get_grid_name();
-		const char *get_unit() const { return field_unit; }
-		int get_buf_mark() const { return buf_mark; }
-		int get_comp_or_grid_id() const { return comp_or_grid_id; }
-		int get_decomp_id() const { return decomp_id; }
-		void set_field_instance_id(int, const char*);
-		const char *get_data_type();
-		bool is_checksum_changed();
-		void reset_checksum();
-		bool is_CPL_field_inst() { return (usage_tag & REG_FIELD_TAG_CPL) == REG_FIELD_TAG_CPL; }
-		bool is_REST_field_inst() { return (usage_tag & REG_FIELD_TAG_REST) == REG_FIELD_TAG_REST; }
-		bool is_IO_field_inst() { return (usage_tag & REG_FIELD_TAG_IO) == REG_FIELD_TAG_IO; }
+        const char *get_unit() const { return field_unit; }
+        int get_buf_mark() const { return buf_mark; }
+        int get_comp_or_grid_id() const { return comp_or_grid_id; }
+        int get_decomp_id() const { return decomp_id; }
+        void set_field_instance_id(int, const char*);
+        const char *get_data_type();
+        bool is_checksum_changed();
+        void reset_checksum();
+        bool is_CPL_field_inst() { return (usage_tag & REG_FIELD_TAG_CPL) == REG_FIELD_TAG_CPL; }
+        bool is_REST_field_inst() { return (usage_tag & REG_FIELD_TAG_REST) == REG_FIELD_TAG_REST; }
+        bool is_IO_field_inst() { return (usage_tag & REG_FIELD_TAG_IO) == REG_FIELD_TAG_IO; }
         ~Field_mem_info();
 };
 
@@ -107,18 +107,18 @@ class Memory_mgt
         
     public: 
         Memory_mgt() {}
-		Field_mem_info *alloc_mem(Field_mem_info*, int, int, const char*, bool);
-		Field_mem_info *alloc_mem(const char*, int, int, int, const char*, const char*, const char*, bool);
- 		int register_external_field_instance(const char *, void *, int, int, int, int, int, const char *, const char *, const char *);
+        Field_mem_info *alloc_mem(Field_mem_info*, int, int, const char*, bool);
+        Field_mem_info *alloc_mem(const char*, int, int, int, const char*, const char*, const char*, bool);
+         int register_external_field_instance(const char *, void *, int, int, int, int, int, const char *, const char *, const char *);
         Field_mem_info *search_field_via_data_buf(const void*, bool);
-		void check_sum_of_all_fields();
-		int get_num_fields() { return fields_mem.size(); }
+        void check_sum_of_all_fields();
+        int get_num_fields() { return fields_mem.size(); }
         ~Memory_mgt();
-		int get_field_size(void*, const char*);
-		Field_mem_info *search_field_instance(const char *, int, int, int);
-		bool check_is_legal_field_instance_id(int);
-		Field_mem_info *get_field_instance(int);
-		void copy_field_data_values(Field_mem_info *, Field_mem_info*);
+        int get_field_size(void*, const char*);
+        Field_mem_info *search_field_instance(const char *, int, int, int);
+        bool check_is_legal_field_instance_id(int);
+        Field_mem_info *get_field_instance(int);
+        void copy_field_data_values(Field_mem_info *, Field_mem_info*);
 };
 
 #endif
diff --git a/src/Data_MGT/original_grid_mgt.cxx b/src/Data_MGT/original_grid_mgt.cxx
old mode 100644
new mode 100755
index df2a548..759f3f1
--- a/src/Data_MGT/original_grid_mgt.cxx
+++ b/src/Data_MGT/original_grid_mgt.cxx
@@ -16,1099 +16,1192 @@
 
 Original_grid_info::Original_grid_info(int comp_id, int grid_id, const char *grid_name, const char *annotation, Remap_grid_class *original_CoR_grid, bool model_registration)
 {
-	this->comp_id = comp_id;
-	this->grid_id = grid_id;
-	this->original_CoR_grid = original_CoR_grid;
-	this->bottom_field_variation_type = BOTTOM_FIELD_VARIATION_UNSET;
-	this->bottom_field_name = NULL;
-	this->bottom_field_id = -1;
-	this->checksum_H2D_mask = -1;
-	this->mid_point_grid = NULL;
-	this->interface_level_grid = NULL;
-	this->center_lon_values = NULL;
-	this->center_lat_values = NULL;
-	this->grid_name = strdup(grid_name);
-	comp_full_name = strdup(comp_comm_group_mgt_mgr->get_global_node_of_local_comp(comp_id, false, "Original_grid_info")->get_full_name());
-	annotation_mgr->add_annotation(this->grid_id, "grid_registration", annotation);
-	generate_remapping_grids();
-
-	if (H2D_sub_CoR_grid != NULL) {
-		center_lon_values = new double [H2D_sub_CoR_grid->get_grid_size()];
-		center_lat_values = new double [H2D_sub_CoR_grid->get_grid_size()];
-		char *grid_data = (char *) (new double [H2D_sub_CoR_grid->get_grid_size()]);
-		get_grid_data(-1, "lon", DATA_TYPE_DOUBLE, H2D_sub_CoR_grid->get_grid_size(), (char*) center_lon_values, "internal", "internal");
-		get_grid_data(-1, "lat", DATA_TYPE_DOUBLE, H2D_sub_CoR_grid->get_grid_size(), (char*) center_lat_values, "internal", "internal");
-		get_grid_data(-1, "mask", DATA_TYPE_INT, H2D_sub_CoR_grid->get_grid_size(), grid_data, "internal", "internal");
-		checksum_H2D_mask = calculate_checksum_of_array(grid_data, H2D_sub_CoR_grid->get_grid_size(), sizeof(int), NULL, NULL);
-		delete [] grid_data;
-	}
-
-	if (model_registration && H2D_sub_CoR_grid != NULL && V1D_sub_CoR_grid == NULL && T1D_sub_CoR_grid == NULL) {
-		char nc_file_name[NAME_STR_SIZE];
-		sprintf(nc_file_name, "%s/%s@%s.nc", comp_comm_group_mgt_mgr->get_internal_H2D_grids_dir(), grid_name, comp_comm_group_mgt_mgr->get_global_node_of_local_comp(comp_id, false, "Original_grid_info")->get_full_name());
-		if (comp_comm_group_mgt_mgr->get_current_proc_id_in_comp(comp_id, "in register_h2d_grid_with_data") == 0) {
-			IO_netcdf *netcdf_file_object = new IO_netcdf("H2D_grid_data", nc_file_name, "w", false);
-			netcdf_file_object->write_grid(H2D_sub_CoR_grid, false, true);
-			netcdf_file_object->put_global_attr("edge_type", "LON_LAT", DATA_TYPE_STRING, DATA_TYPE_STRING, -1);   // to be modified
-			Remap_grid_class *leaf_grids[256];
-			int num_leaf_grids;
-			H2D_sub_CoR_grid->get_leaf_grids(&num_leaf_grids, leaf_grids, H2D_sub_CoR_grid);
-			EXECUTION_REPORT(REPORT_ERROR, -1, words_are_the_same(leaf_grids[0]->get_coord_label(), COORD_LABEL_LON), "software error in Original_grid_info::Original_grid_info");
-			double temp_double = H2D_sub_CoR_grid->get_boundary_min_lon();
-			netcdf_file_object->put_global_attr("min_lon", &temp_double, DATA_TYPE_DOUBLE, DATA_TYPE_DOUBLE, 1);
-			temp_double = H2D_sub_CoR_grid->get_boundary_max_lon();
-			netcdf_file_object->put_global_attr("max_lon", &temp_double, DATA_TYPE_DOUBLE, DATA_TYPE_DOUBLE, 1);
-			temp_double = H2D_sub_CoR_grid->get_boundary_min_lat();
-			netcdf_file_object->put_global_attr("min_lat", &temp_double, DATA_TYPE_DOUBLE, DATA_TYPE_DOUBLE, 1);
-			temp_double = H2D_sub_CoR_grid->get_boundary_max_lat();
-			netcdf_file_object->put_global_attr("max_lat", &temp_double, DATA_TYPE_DOUBLE, DATA_TYPE_DOUBLE, 1);
-			if (leaf_grids[0]->get_grid_cyclic())					
-				netcdf_file_object->put_global_attr("cyclic_or_acyclic", "cyclic", DATA_TYPE_STRING, DATA_TYPE_STRING, -1);
-			else netcdf_file_object->put_global_attr("cyclic_or_acyclic", "acyclic", DATA_TYPE_STRING, DATA_TYPE_STRING, -1);			
-			netcdf_file_object->put_global_attr("title", grid_name, DATA_TYPE_STRING, DATA_TYPE_STRING, -1);
-			delete netcdf_file_object;
-			char status_file_name[NAME_STR_SIZE];
-			sprintf(status_file_name, "%s/%s@%s.nc.end", comp_comm_group_mgt_mgr->get_comps_ending_config_status_dir(), grid_name, comp_comm_group_mgt_mgr->get_global_node_of_local_comp(comp_id, false, "Original_grid_info")->get_full_name());
-			FILE *status_file = fopen(status_file_name, "w+");
-			EXECUTION_REPORT(REPORT_ERROR, -1, status_file != NULL, "Software error in Comp_comm_group_mgt_node::merge_comp_comm_info: configuration ending status file cannot be created: %s", status_file_name);
-			fclose(status_file);
-		}
-		MPI_Barrier(comp_comm_group_mgt_mgr->get_comm_group_of_local_comp(comp_id, "Original_grid_info::Original_grid_info"));
-	}
+    this->comp_id = comp_id;
+    this->grid_id = grid_id;
+    this->original_CoR_grid = original_CoR_grid;
+    this->bottom_field_variation_type = BOTTOM_FIELD_VARIATION_UNSET;
+	this->V3D_lev_field_variation_type = BOTTOM_FIELD_VARIATION_UNSET;
+    this->bottom_field_name = NULL;
+	this->V3D_lev_field_id = -1;
+    this->bottom_field_id = -1;
+    this->checksum_H2D_mask = -1;
+    this->mid_point_grid = NULL;
+    this->interface_level_grid = NULL;
+    this->grid_name = strdup(grid_name);
+    comp_full_name = strdup(comp_comm_group_mgt_mgr->get_global_node_of_local_comp(comp_id, false, "Original_grid_info")->get_full_name());
+    annotation_mgr->add_annotation(this->grid_id, "grid_registration", annotation);
+    generate_remapping_grids();
+
+    if (H2D_sub_CoR_grid != NULL && model_registration) {
+        char *grid_data = (char *) (new double [H2D_sub_CoR_grid->get_grid_size()]);
+        get_grid_data(-1, "mask", DATA_TYPE_INT, H2D_sub_CoR_grid->get_grid_size(), grid_data, "internal", "internal");
+        checksum_H2D_mask = calculate_checksum_of_array(grid_data, H2D_sub_CoR_grid->get_grid_size(), sizeof(int), NULL, NULL);
+        delete [] grid_data;
+    }
+
+    if (model_registration && H2D_sub_CoR_grid != NULL && V1D_sub_CoR_grid == NULL && T1D_sub_CoR_grid == NULL) {
+        char nc_file_name[NAME_STR_SIZE];
+        sprintf(nc_file_name, "%s/%s@%s.nc", comp_comm_group_mgt_mgr->get_internal_H2D_grids_dir(), grid_name, comp_comm_group_mgt_mgr->get_global_node_of_local_comp(comp_id, false, "Original_grid_info")->get_full_name());
+        if (comp_comm_group_mgt_mgr->get_current_proc_id_in_comp(comp_id, "in register_h2d_grid_with_data") == 0) {
+            IO_netcdf *netcdf_file_object = new IO_netcdf("H2D_grid_data", nc_file_name, "w", false);
+            netcdf_file_object->write_grid(H2D_sub_CoR_grid, false, true);
+            netcdf_file_object->put_global_attr("edge_type", "LON_LAT", DATA_TYPE_STRING, DATA_TYPE_STRING, -1);   // to be modified
+            Remap_grid_class *leaf_grids[256];
+            int num_leaf_grids;
+            H2D_sub_CoR_grid->get_leaf_grids(&num_leaf_grids, leaf_grids, H2D_sub_CoR_grid);
+            EXECUTION_REPORT(REPORT_ERROR, -1, words_are_the_same(leaf_grids[0]->get_coord_label(), COORD_LABEL_LON), "software error in Original_grid_info::Original_grid_info");
+            double temp_double = H2D_sub_CoR_grid->get_boundary_min_lon();
+            netcdf_file_object->put_global_attr("min_lon", &temp_double, DATA_TYPE_DOUBLE, DATA_TYPE_DOUBLE, 1);
+            temp_double = H2D_sub_CoR_grid->get_boundary_max_lon();
+            netcdf_file_object->put_global_attr("max_lon", &temp_double, DATA_TYPE_DOUBLE, DATA_TYPE_DOUBLE, 1);
+            temp_double = H2D_sub_CoR_grid->get_boundary_min_lat();
+            netcdf_file_object->put_global_attr("min_lat", &temp_double, DATA_TYPE_DOUBLE, DATA_TYPE_DOUBLE, 1);
+            temp_double = H2D_sub_CoR_grid->get_boundary_max_lat();
+            netcdf_file_object->put_global_attr("max_lat", &temp_double, DATA_TYPE_DOUBLE, DATA_TYPE_DOUBLE, 1);
+            if (leaf_grids[0]->get_grid_cyclic())                    
+                netcdf_file_object->put_global_attr("cyclic_or_acyclic", "cyclic", DATA_TYPE_STRING, DATA_TYPE_STRING, -1);
+            else netcdf_file_object->put_global_attr("cyclic_or_acyclic", "acyclic", DATA_TYPE_STRING, DATA_TYPE_STRING, -1);            
+            netcdf_file_object->put_global_attr("title", grid_name, DATA_TYPE_STRING, DATA_TYPE_STRING, -1);
+            delete netcdf_file_object;
+            char status_file_name[NAME_STR_SIZE];
+            sprintf(status_file_name, "%s/%s@%s.nc.end", comp_comm_group_mgt_mgr->get_comps_ending_config_status_dir(), grid_name, comp_comm_group_mgt_mgr->get_global_node_of_local_comp(comp_id, false, "Original_grid_info")->get_full_name());
+            FILE *status_file = fopen(status_file_name, "w+");
+            EXECUTION_REPORT(REPORT_ERROR, -1, status_file != NULL, "Software error in Comp_comm_group_mgt_node::merge_comp_comm_info: configuration ending status file cannot be created: %s", status_file_name);
+            fclose(status_file);
+        }
+        MPI_Barrier(comp_comm_group_mgt_mgr->get_comm_group_of_local_comp(comp_id, "Original_grid_info::Original_grid_info"));
+    }
 }
 
 
 Original_grid_info::~Original_grid_info()
 {
-	if (center_lon_values != NULL) {
-		delete [] center_lon_values;
-		delete [] center_lat_values;
-	}
-	delete [] grid_name;
-	delete [] comp_full_name;
-	if (bottom_field_name != NULL)
-		delete [] bottom_field_name;
+    delete [] grid_name;
+    delete [] comp_full_name;
+    if (bottom_field_name != NULL)
+        delete [] bottom_field_name;
 }
 
 
 void Original_grid_info::reset_grid_data()
 {
-	if (original_CoR_grid != NULL) {
-		delete original_CoR_grid;
-		original_CoR_grid = NULL;
-	}
-
-	if (center_lon_values != NULL) {
-		delete [] center_lon_values;
-		delete [] center_lat_values;
-		center_lon_values = NULL;
-		center_lat_values = NULL;
-	}	
+    if (original_CoR_grid != NULL) {
+        delete original_CoR_grid;
+        original_CoR_grid = NULL;
+    }  
 }
 
 
 
 const char *Original_grid_info::get_annotation()
 {
-	return annotation_mgr->get_annotation(this->grid_id, "grid_registration");
+    return annotation_mgr->get_annotation(this->grid_id, "grid_registration");
 }
 
 
 void Original_grid_info::generate_remapping_grids()
 {
-	Remap_grid_class *lon_sub_grid = NULL, *lat_sub_grid = NULL, *leaf_grids[256];
-	int num_leaf_grids;
-
-	
-	H2D_sub_CoR_grid = NULL;
-	V1D_sub_CoR_grid = NULL;
-	T1D_sub_CoR_grid = NULL;
-	H2D_sub_grid_order = -1;
-	V1D_sub_grid_order = -1;
-	T1D_sub_grid_order = -1;
-	
-	if (original_CoR_grid->get_num_dimensions() == 2)
-		EXECUTION_REPORT(REPORT_ERROR, -1, original_CoR_grid->get_is_sphere_grid(), "Software error in Original_grid_info::generate_remapping_grids: not a sphere grid");
-	if (original_CoR_grid->get_num_dimensions() == 1)
-		EXECUTION_REPORT(REPORT_ERROR, -1, words_are_the_same(original_CoR_grid->get_coord_label(),COORD_LABEL_LEV) || words_are_the_same(original_CoR_grid->get_coord_label(),COORD_LABEL_TIME), "Software error in Original_grid_info::generate_remapping_grids: not a vertical grid or not a time grid");
-	H2D_sub_CoR_grid = original_CoR_grid->get_sphere_sub_grid();
-	
-	original_CoR_grid->get_leaf_grids(&num_leaf_grids, leaf_grids, original_CoR_grid);
-	for (int i = 0; i < num_leaf_grids; i ++) {
-		if (words_are_the_same(leaf_grids[i]->get_coord_label(), COORD_LABEL_LON)) {
-			lon_sub_grid = leaf_grids[i];
-			H2D_sub_grid_order = i;
-		}
-		else if (words_are_the_same(leaf_grids[i]->get_coord_label(), COORD_LABEL_LAT))
-			lat_sub_grid = leaf_grids[i];
-		else if (words_are_the_same(leaf_grids[i]->get_coord_label(), COORD_LABEL_LEV)) {
-			V1D_sub_CoR_grid = leaf_grids[i];
-			V1D_sub_grid_order = i;
-		}
-		else if (words_are_the_same(leaf_grids[i]->get_coord_label(), COORD_LABEL_TIME)) {
-			T1D_sub_CoR_grid = leaf_grids[i];
-			T1D_sub_grid_order = i;
-		}
-	}
-
-	if (H2D_sub_CoR_grid == NULL && (lon_sub_grid != NULL || lat_sub_grid != NULL)) {
-		EXECUTION_REPORT(REPORT_ERROR, -1, lon_sub_grid != NULL && lat_sub_grid != NULL, "Software error in Original_grid_info::generate_remapping_grids: wrong sub grids for a sphere grid");
-		leaf_grids[0] = lon_sub_grid;
-		leaf_grids[1] = lat_sub_grid;
-		char H2D_grid_name[NAME_STR_SIZE];
-		sprintf(H2D_grid_name, "H2D_grid_for_%s", grid_name);
-		H2D_sub_CoR_grid = new Remap_grid_class(H2D_grid_name, 2, leaf_grids, 0);
-	}	
-
-	EXECUTION_REPORT(REPORT_ERROR, -1, H2D_sub_CoR_grid != NULL || V1D_sub_CoR_grid != NULL || T1D_sub_CoR_grid != NULL, "Software error in Original_grid_info::generate_remapping_grids: empty grid");
+    Remap_grid_class *lon_sub_grid = NULL, *lat_sub_grid = NULL, *leaf_grids[256];
+    int num_leaf_grids;
+
+    
+    H2D_sub_CoR_grid = NULL;
+    V1D_sub_CoR_grid = NULL;
+    T1D_sub_CoR_grid = NULL;
+    H2D_sub_grid_order = -1;
+    V1D_sub_grid_order = -1;
+    T1D_sub_grid_order = -1;
+    
+    if (original_CoR_grid->get_num_dimensions() == 2)
+        EXECUTION_REPORT(REPORT_ERROR, -1, original_CoR_grid->get_is_sphere_grid(), "Software error in Original_grid_info::generate_remapping_grids: not a sphere grid");
+    if (original_CoR_grid->get_num_dimensions() == 1)
+        EXECUTION_REPORT(REPORT_ERROR, -1, words_are_the_same(original_CoR_grid->get_coord_label(),COORD_LABEL_LEV) || words_are_the_same(original_CoR_grid->get_coord_label(),COORD_LABEL_TIME), "Software error in Original_grid_info::generate_remapping_grids: not a vertical grid or not a time grid");
+    H2D_sub_CoR_grid = original_CoR_grid->get_sphere_sub_grid();
+    
+    original_CoR_grid->get_leaf_grids(&num_leaf_grids, leaf_grids, original_CoR_grid);
+    for (int i = 0; i < num_leaf_grids; i ++) {
+        if (words_are_the_same(leaf_grids[i]->get_coord_label(), COORD_LABEL_LON)) {
+            lon_sub_grid = leaf_grids[i];
+            H2D_sub_grid_order = i;
+        }
+        else if (words_are_the_same(leaf_grids[i]->get_coord_label(), COORD_LABEL_LAT))
+            lat_sub_grid = leaf_grids[i];
+        else if (words_are_the_same(leaf_grids[i]->get_coord_label(), COORD_LABEL_LEV)) {
+            V1D_sub_CoR_grid = leaf_grids[i];
+            V1D_sub_grid_order = i;
+        }
+        else if (words_are_the_same(leaf_grids[i]->get_coord_label(), COORD_LABEL_TIME)) {
+            T1D_sub_CoR_grid = leaf_grids[i];
+            T1D_sub_grid_order = i;
+        }
+    }
+
+    if (H2D_sub_CoR_grid == NULL && (lon_sub_grid != NULL || lat_sub_grid != NULL)) {
+        EXECUTION_REPORT(REPORT_ERROR, -1, lon_sub_grid != NULL && lat_sub_grid != NULL, "Software error in Original_grid_info::generate_remapping_grids: wrong sub grids for a sphere grid");
+        leaf_grids[0] = lon_sub_grid;
+        leaf_grids[1] = lat_sub_grid;
+        char H2D_grid_name[NAME_STR_SIZE];
+        sprintf(H2D_grid_name, "H2D_grid_for_%s", grid_name);
+        H2D_sub_CoR_grid = new Remap_grid_class(H2D_grid_name, 2, leaf_grids, 0);
+    }    
+
+    EXECUTION_REPORT(REPORT_ERROR, -1, H2D_sub_CoR_grid != NULL || V1D_sub_CoR_grid != NULL || T1D_sub_CoR_grid != NULL, "Software error in Original_grid_info::generate_remapping_grids: empty grid");
 }
 
 
 bool Original_grid_info::is_V1D_sub_grid_after_H2D_sub_grid()
 {
-	if (H2D_sub_CoR_grid == NULL || V1D_sub_CoR_grid == NULL)
-		return true;
+    if (H2D_sub_CoR_grid == NULL || V1D_sub_CoR_grid == NULL)
+        return true;
 
-	return H2D_sub_grid_order < V1D_sub_grid_order;
+    return H2D_sub_grid_order < V1D_sub_grid_order;
 }
 
 
+void Original_grid_info::set_unique_3D_lev_field(int field_id, const char *type, const char *annotation) 
+{ 
+    EXECUTION_REPORT(REPORT_ERROR, -1, bottom_field_variation_type == BOTTOM_FIELD_VARIATION_UNSET && V3D_lev_field_variation_type == BOTTOM_FIELD_VARIATION_UNSET, "Software error in Original_grid_info::set_unique_3D_lev_field");
+    annotation_mgr->add_annotation(grid_id, "set 3-D level field", annotation);
+    V3D_lev_field_variation_type = words_are_the_same(type, "constant")? 0 : 1;
+	V3D_lev_field_id = field_id;
+} 
+
+
 void Original_grid_info::set_unique_bottom_field(int field_id, int type, const char *annotation) 
 { 
-	EXECUTION_REPORT(REPORT_ERROR, -1, bottom_field_variation_type == BOTTOM_FIELD_VARIATION_UNSET, "Software error in Original_grid_info::set_unique_bottom_field");
-	annotation_mgr->add_annotation(grid_id, "set surface field", annotation);	
-	bottom_field_variation_type = type;
-	if (type != BOTTOM_FIELD_VARIATION_EXTERNAL) {
-		Field_mem_info *field_inst = memory_manager->get_field_instance(field_id);
-		bottom_field_name = strdup(field_inst->get_field_name());
-		bottom_field_id = field_id;
-		decomp_grids_mgr->search_decomp_grid_info(field_inst->get_decomp_id(), get_original_CoR_grid(), false)->get_decomp_grid()->set_sigma_grid_dynamic_surface_value_field(field_inst->get_field_data());
-	}
+    EXECUTION_REPORT(REPORT_ERROR, -1, bottom_field_variation_type == BOTTOM_FIELD_VARIATION_UNSET, "Software error in Original_grid_info::set_unique_bottom_field");
+    annotation_mgr->add_annotation(grid_id, "set surface field", annotation);    
+    bottom_field_variation_type = type;
+    if (type != BOTTOM_FIELD_VARIATION_EXTERNAL) {
+        Field_mem_info *field_inst = memory_manager->get_field_instance(field_id);
+        bottom_field_name = strdup(field_inst->get_field_name());
+        bottom_field_id = field_id;
+        decomp_grids_mgr->search_decomp_grid_info(field_inst->get_decomp_id(), get_original_CoR_grid(), false)->get_decomp_grid()->set_level_V3D_coord_dynamic_trigger_field(field_inst->get_field_data());
+    }
 } 
 
 
 void Original_grid_info::write_grid_into_array(char **temp_array_buffer, long &buffer_max_size, long &buffer_content_size)
 {
-	get_original_CoR_grid()->write_grid_into_array(temp_array_buffer, buffer_max_size, buffer_content_size);
-	write_data_into_array_buffer(&bottom_field_variation_type, sizeof(int), temp_array_buffer, buffer_max_size, buffer_content_size);
-	write_data_into_array_buffer(&checksum_H2D_mask, sizeof(long), temp_array_buffer, buffer_max_size, buffer_content_size);
+    get_original_CoR_grid()->write_grid_into_array(temp_array_buffer, buffer_max_size, buffer_content_size);
+	write_data_into_array_buffer(&V3D_lev_field_variation_type, sizeof(int), temp_array_buffer, buffer_max_size, buffer_content_size);
+    write_data_into_array_buffer(&bottom_field_variation_type, sizeof(int), temp_array_buffer, buffer_max_size, buffer_content_size);
+    write_data_into_array_buffer(&checksum_H2D_mask, sizeof(long), temp_array_buffer, buffer_max_size, buffer_content_size);
 }
 
 
 void Original_grid_info::get_grid_data(int decomp_id, const char *label, const char *data_type, int array_size, char *grid_data, const char *annotation, const char *API_label)
 {
-	Remap_grid_data_class *grid_field;
-	Remap_grid_class *field_CoR_grid;
-	
-		
-	EXECUTION_REPORT(REPORT_ERROR, comp_id, words_are_the_same(label, COORD_LABEL_LON) || words_are_the_same(label, COORD_LABEL_LAT) || words_are_the_same(label, GRID_MASK_LABEL), "Error happens when calling the API \"%s\" to get the grid data of an H2D grid \"%s\": the label (currently is \"%s\") is wrong (must be \"lon\", \"lat\" or \"mask\"). Please verify the model code with the annotation \"%s\".", API_label, grid_name, label, annotation);	
-	if (words_are_the_same(label, GRID_MASK_LABEL))
-		EXECUTION_REPORT(REPORT_ERROR, comp_id, words_are_the_same(data_type, DATA_TYPE_INT), "Error happens when calling the API \"%s\" to get the grid data of an H2D grid \"%s\": the data type (currently is %s) corresponding to the parameter of \"grid_data\" is wrong when the label is \"mask\" (the right data type must be integer). Please verify the model code with the annotation \"%s.", API_label, grid_name, data_type, annotation);
-	else EXECUTION_REPORT(REPORT_ERROR, comp_id, words_are_the_same(data_type, DATA_TYPE_FLOAT) || words_are_the_same(data_type, DATA_TYPE_DOUBLE), "Error happens when calling the API \"%s\" to get the grid data of an H2D grid \"%s\": the data type (currently is %s) corresponding to the parameter of \"grid_data\" is wrong when the label (currently is \"%s\") is not \"mask\" (the right data type must be floating-point). Please verify the model code with the annotation \"%s.", API_label, grid_name, data_type, label, annotation);
-
-	EXECUTION_REPORT(REPORT_ERROR, comp_id, array_size > 0, "Error happens when calling the API \"%s\" to get the grid data of an H2D grid \"%s\": the array of \"grid_data\" has not been allocated. Please verify the model code with the annotation \"%s.", API_label, grid_name, annotation);
-	if (decomp_id != -1) {
-		field_CoR_grid = decomp_grids_mgr->search_decomp_grid_info(decomp_id, original_CoR_grid, false)->get_decomp_grid();
-		EXECUTION_REPORT(REPORT_ERROR, comp_id, array_size == decomps_info_mgr->get_decomp_info(decomp_id)->get_num_local_cells(), "Error happens when calling the API \"%s\" to get the grid data of an H2D grid \"%s\": the array size (currently is %d) of the parameter of \"grid_data\" is different from the size corresponding to the parallel decomposition (currently is %d). Please verify the model code with the annotation \"%s.", API_label, grid_name, array_size, decomps_info_mgr->get_decomp_info(decomp_id)->get_num_local_cells(), annotation);
-		EXECUTION_REPORT(REPORT_ERROR, comp_id, original_grid_mgr->get_original_CoR_grid(decomps_info_mgr->get_decomp_info(decomp_id)->get_grid_id()) == original_CoR_grid, "Error happens when calling the API \"%s\" to get the grid data of an H2D grid \"%s\": the grid_id and decomp_id do not correspond to the same H2D grid. Please verify the model code with the annotation \"%s.", API_label, grid_name, annotation);
-	}
-	else {
-		field_CoR_grid = H2D_sub_CoR_grid;
-		EXECUTION_REPORT(REPORT_ERROR, comp_id, array_size == field_CoR_grid->get_grid_size(), "Error happens when calling the API \"%s\" to get the grid data of an H2D grid \"%s\": the array size (currently is %d) of the parameter of \"grid_data\" is different from the size corresponding to the parallel decomposition (currently is %d). Please verify the model code with the annotation \"%s.", API_label, grid_name, array_size, field_CoR_grid->get_grid_size(), annotation);
-	}
-
-	if (!words_are_the_same(label, GRID_MASK_LABEL)) {
-		grid_field = field_CoR_grid->get_grid_center_field(label);
-		EXECUTION_REPORT(REPORT_ERROR, -1, grid_field != NULL, "Software error in Original_grid_info::get_grid_data: NULL grid center field");
-		EXECUTION_REPORT(REPORT_ERROR, -1, words_are_the_same(grid_field->get_grid_data_field()->data_type_in_application, DATA_TYPE_DOUBLE), "Software error in Original_grid_info::get_grid_data: wrong center field data type");
-		if (array_size != grid_field->get_grid_data_field()->required_data_size)
-			grid_field = field_CoR_grid->expand_to_generate_full_coord_value(grid_field);
-		if (words_are_the_same(data_type, DATA_TYPE_FLOAT))
-			transform_datatype_of_arrays((double*)grid_field->get_grid_data_field()->data_buf, (float*)grid_data, array_size);
-		else transform_datatype_of_arrays((double*)grid_field->get_grid_data_field()->data_buf, (double*)grid_data, array_size);
-		if (grid_field != field_CoR_grid->get_grid_center_field(label))
-			delete grid_field;
-	}
-	else {
-		grid_field = field_CoR_grid->get_grid_mask_field();
-		EXECUTION_REPORT(REPORT_ERROR, -1, grid_field != NULL, "Software error in Original_grid_info::get_grid_data: NULL grid mask field");			
-		EXECUTION_REPORT(REPORT_ERROR, -1, words_are_the_same(grid_field->get_grid_data_field()->data_type_in_application, DATA_TYPE_BOOL), "Software error in Original_grid_info::get_grid_data: wrong mask field data type");
-		EXECUTION_REPORT(REPORT_ERROR, -1, array_size == grid_field->get_grid_data_field()->required_data_size, "Software error in Original_grid_info::get_grid_data: inconsistent field size");
-		transform_datatype_of_arrays((bool*)grid_field->get_grid_data_field()->data_buf, (int*)grid_data, array_size);
-	}
+    Remap_grid_data_class *grid_field;
+    Remap_grid_class *field_CoR_grid;
+    
+        
+    EXECUTION_REPORT(REPORT_ERROR, comp_id, words_are_the_same(label, COORD_LABEL_LON) || words_are_the_same(label, COORD_LABEL_LAT) || words_are_the_same(label, GRID_MASK_LABEL), "Error happens when calling the API \"%s\" to get the grid data of an H2D grid \"%s\": the label (currently is \"%s\") is wrong (must be \"lon\", \"lat\" or \"mask\"). Please verify the model code with the annotation \"%s\".", API_label, grid_name, label, annotation);    
+    if (words_are_the_same(label, GRID_MASK_LABEL))
+        EXECUTION_REPORT(REPORT_ERROR, comp_id, words_are_the_same(data_type, DATA_TYPE_INT), "Error happens when calling the API \"%s\" to get the grid data of an H2D grid \"%s\": the data type (currently is %s) corresponding to the parameter of \"grid_data\" is wrong when the label is \"mask\" (the right data type must be integer). Please verify the model code with the annotation \"%s\".", API_label, grid_name, data_type, annotation);
+    else EXECUTION_REPORT(REPORT_ERROR, comp_id, words_are_the_same(data_type, DATA_TYPE_FLOAT) || words_are_the_same(data_type, DATA_TYPE_DOUBLE), "Error happens when calling the API \"%s\" to get the grid data of an H2D grid \"%s\": the data type (currently is %s) corresponding to the parameter of \"grid_data\" is wrong when the label (currently is \"%s\") is not \"mask\" (the right data type must be floating-point). Please verify the model code with the annotation \"%s\".", API_label, grid_name, data_type, label, annotation);
+
+    EXECUTION_REPORT(REPORT_ERROR, comp_id, array_size > 0, "Error happens when calling the API \"%s\" to get the grid data of an H2D grid \"%s\": the array of \"grid_data\" has not been allocated. Please verify the model code with the annotation \"%s\".", API_label, grid_name, annotation);
+    if (decomp_id != -1) {
+        field_CoR_grid = decomp_grids_mgr->search_decomp_grid_info(decomp_id, original_CoR_grid, false)->get_decomp_grid();
+        EXECUTION_REPORT(REPORT_ERROR, comp_id, array_size == decomps_info_mgr->get_decomp_info(decomp_id)->get_num_local_cells(), "Error happens when calling the API \"%s\" to get the grid data of an H2D grid \"%s\": the array size (currently is %d) of the parameter of \"grid_data\" is different from the size corresponding to the parallel decomposition (currently is %d). Please verify the model code with the annotation \"%s\".", API_label, grid_name, array_size, decomps_info_mgr->get_decomp_info(decomp_id)->get_num_local_cells(), annotation);
+        EXECUTION_REPORT(REPORT_ERROR, comp_id, original_grid_mgr->get_original_CoR_grid(decomps_info_mgr->get_decomp_info(decomp_id)->get_grid_id()) == original_CoR_grid, "Error happens when calling the API \"%s\" to get the grid data of an H2D grid \"%s\": the grid_id and decomp_id do not correspond to the same H2D grid. Please verify the model code with the annotation \"%s\".", API_label, grid_name, annotation);
+    }
+    else {
+        field_CoR_grid = H2D_sub_CoR_grid;
+        EXECUTION_REPORT(REPORT_ERROR, comp_id, array_size == field_CoR_grid->get_grid_size(), "Error happens when calling the API \"%s\" to get the grid data of an H2D grid \"%s\": the array size (currently is %d) of the parameter of \"grid_data\" is different from the size corresponding to the parallel decomposition (currently is %d). Please verify the model code with the annotation \"%s\".", API_label, grid_name, array_size, field_CoR_grid->get_grid_size(), annotation);
+    }
+
+    if (!words_are_the_same(label, GRID_MASK_LABEL)) {
+        grid_field = field_CoR_grid->get_grid_center_field(label);
+        EXECUTION_REPORT(REPORT_ERROR, -1, grid_field != NULL, "Software error in Original_grid_info::get_grid_data: NULL grid center field");
+        EXECUTION_REPORT(REPORT_ERROR, -1, words_are_the_same(grid_field->get_grid_data_field()->data_type_in_application, DATA_TYPE_DOUBLE), "Software error in Original_grid_info::get_grid_data: wrong center field data type");
+        if (array_size != grid_field->get_grid_data_field()->required_data_size)
+            grid_field = field_CoR_grid->expand_to_generate_full_coord_value(grid_field);
+        if (words_are_the_same(data_type, DATA_TYPE_FLOAT))
+            transform_datatype_of_arrays((double*)grid_field->get_grid_data_field()->data_buf, (float*)grid_data, array_size);
+        else transform_datatype_of_arrays((double*)grid_field->get_grid_data_field()->data_buf, (double*)grid_data, array_size);
+        if (grid_field != field_CoR_grid->get_grid_center_field(label))
+            delete grid_field;
+    }
+    else {
+        grid_field = field_CoR_grid->get_grid_mask_field();
+        EXECUTION_REPORT(REPORT_ERROR, -1, grid_field != NULL, "Software error in Original_grid_info::get_grid_data: NULL grid mask field");            
+        EXECUTION_REPORT(REPORT_ERROR, -1, words_are_the_same(grid_field->get_grid_data_field()->data_type_in_application, DATA_TYPE_BOOL), "Software error in Original_grid_info::get_grid_data: wrong mask field data type");
+        EXECUTION_REPORT(REPORT_ERROR, -1, array_size == grid_field->get_grid_data_field()->required_data_size, "Software error in Original_grid_info::get_grid_data: inconsistent field size");
+        transform_datatype_of_arrays((bool*)grid_field->get_grid_data_field()->data_buf, (int*)grid_data, array_size);
+    }
 }
 
 
 void Original_grid_info::set_mid_point_grid(Original_grid_info *new_grid)
 {
-	this->mid_point_grid = new_grid;
-	new_grid->interface_level_grid = this;
-	if (this->bottom_field_variation_type != BOTTOM_FIELD_VARIATION_UNSET)
-		new_grid->set_unique_bottom_field(this->bottom_field_id, this->bottom_field_variation_type, annotation_mgr->get_annotation(this->grid_id,"set surface field"));
+    this->mid_point_grid = new_grid;
+    new_grid->interface_level_grid = this;
+    if (this->bottom_field_variation_type != BOTTOM_FIELD_VARIATION_UNSET)
+        new_grid->set_unique_bottom_field(this->bottom_field_id, this->bottom_field_variation_type, annotation_mgr->get_annotation(this->grid_id,"set surface field"));
 }
 
 
 void Original_grid_info::set_grid_checksum(long checksum_mask)
 {
-	this->checksum_H2D_mask = checksum_mask;
+    this->checksum_H2D_mask = checksum_mask;
 }
 
 
-bool Original_grid_info::is_H2D_grid_and_the_same_as_another_grid(Original_grid_info *another_grid)
+double *Original_grid_info::get_center_lon_values()
 {
-	if (!this->is_H2D_grid() || !another_grid->is_H2D_grid())
-		return false;
+	EXECUTION_REPORT_ERROR_OPTIONALLY(REPORT_ERROR, -1, H2D_sub_CoR_grid != NULL, "Software error in Original_grid_info::get_center_lon_values");
+	double *center_lon_values = new double [H2D_sub_CoR_grid->get_grid_size()];
+	get_grid_data(-1, "lon", DATA_TYPE_DOUBLE, H2D_sub_CoR_grid->get_grid_size(), (char*) center_lon_values, "internal", "internal");
+	return center_lon_values;
+}
 
-	if (!are_two_coord_arrays_same(this->center_lon_values, another_grid->center_lon_values, this->get_H2D_sub_CoR_grid()->get_grid_size(), another_grid->get_H2D_sub_CoR_grid()->get_grid_size()))
-		return false;
 
-	return are_two_coord_arrays_same(this->center_lat_values, another_grid->center_lat_values, this->get_H2D_sub_CoR_grid()->get_grid_size(), another_grid->get_H2D_sub_CoR_grid()->get_grid_size());
+double *Original_grid_info::get_center_lat_values()
+{
+	EXECUTION_REPORT_ERROR_OPTIONALLY(REPORT_ERROR, -1, H2D_sub_CoR_grid != NULL, "Software error in Original_grid_info::get_center_lat_values");
+	double *center_lat_values = new double [H2D_sub_CoR_grid->get_grid_size()];
+	get_grid_data(-1, "lat", DATA_TYPE_DOUBLE, H2D_sub_CoR_grid->get_grid_size(), (char*) center_lat_values, "internal", "internal");
+	return center_lat_values;
+}
+
+
+bool Original_grid_info::is_H2D_grid_and_the_same_as_another_grid(Original_grid_info *another_grid)
+{
+	bool check_result;
+	double *this_center_lon, *this_center_lat, *another_center_lon, *another_center_lat;
+
+	
+    if (!this->is_H2D_grid() || !another_grid->is_H2D_grid())
+        return false;
+	
+	this_center_lon = this->get_center_lon_values();
+	another_center_lon = another_grid->get_center_lon_values();
+	check_result = are_two_coord_arrays_same(this_center_lon, another_center_lon, this->get_H2D_sub_CoR_grid()->get_grid_size(), another_grid->get_H2D_sub_CoR_grid()->get_grid_size());
+	delete [] this_center_lon;
+	delete [] another_center_lon;	
+	if (!check_result)
+        return false;
+
+	this_center_lat = this->get_center_lat_values();
+	another_center_lat = another_grid->get_center_lat_values();
+	check_result = are_two_coord_arrays_same(this_center_lat, another_center_lat, this->get_H2D_sub_CoR_grid()->get_grid_size(), another_grid->get_H2D_sub_CoR_grid()->get_grid_size());
+	delete [] this_center_lat;
+	delete [] another_center_lat;
+	return check_result;
 }
 
 
 Original_grid_mgt::Original_grid_mgt()
-{	
-	original_grids.clear();
-	CoR_script_name[0] = '\0';
-	CoR_grids = NULL;
+{    
+    original_grids.clear();
+    CoR_script_name[0] = '\0';
+    CoR_grids = NULL;
 }
 
 
 void Original_grid_mgt::initialize_CoR_grids()
 {
-	if (CoR_grids != NULL)
-		return;
-	
-	sprintf(CoR_script_name, "%s/CCPL_grid.cor", comp_comm_group_mgt_mgr->get_root_comp_config_dir());
-	FILE *fp = fopen(CoR_script_name, "r");
-	if (fp == NULL)
-		CoR_script_name[0] = '\0';
-	else fclose(fp);
-	if (strlen(CoR_script_name) != 0) {
-		char current_dir[NAME_STR_SIZE], grids_dir[NAME_STR_SIZE];
-		EXECUTION_REPORT(REPORT_ERROR, -1, getcwd(current_dir,NAME_STR_SIZE) != NULL, "Cannot get the current working directory for running the model");
-		sprintf(grids_dir, "%s/grids_weights", comp_comm_group_mgt_mgr->get_root_comp_config_dir());
-		EXECUTION_REPORT(REPORT_ERROR, -1, chdir(grids_dir) == 0, "Fail to access the directory of the CoR grid data files: \"%s\". Please verify.", grids_dir);
-		CoR_grids = new Remap_mgt(CoR_script_name);
-		chdir(current_dir);
-	}
-	else CoR_grids = new Remap_mgt(NULL);
+    if (CoR_grids != NULL)
+        return;
+    
+    sprintf(CoR_script_name, "%s/CCPL_grid.cor", comp_comm_group_mgt_mgr->get_root_comp_config_dir());
+    FILE *fp = fopen(CoR_script_name, "r");
+    if (fp == NULL)
+        CoR_script_name[0] = '\0';
+    else fclose(fp);
+    if (strlen(CoR_script_name) != 0) {
+        char current_dir[NAME_STR_SIZE], grids_dir[NAME_STR_SIZE];
+        EXECUTION_REPORT(REPORT_ERROR, -1, getcwd(current_dir,NAME_STR_SIZE) != NULL, "Cannot get the current working directory for running the model");
+        sprintf(grids_dir, "%s/grids_weights", comp_comm_group_mgt_mgr->get_root_comp_config_dir());
+        EXECUTION_REPORT(REPORT_ERROR, -1, chdir(grids_dir) == 0, "Fail to access the directory of the CoR grid data files: \"%s\". Please verify.", grids_dir);
+        CoR_grids = new Remap_mgt(CoR_script_name);
+        chdir(current_dir);
+    }
+    else CoR_grids = new Remap_mgt(NULL);
 }
 
 
 Original_grid_mgt::~Original_grid_mgt()
 {
-	for (int i = 0; i < original_grids.size(); i ++)
-		if (original_grids[i] != NULL)
-			delete original_grids[i];
-	
-	delete CoR_grids;
+    for (int i = 0; i < original_grids.size(); i ++)
+        if (original_grids[i] != NULL)
+            delete original_grids[i];
+    
+    delete CoR_grids;
 }
 
 
 void Original_grid_mgt::delete_external_original_grids()
 {
-	for (int i = 0; i < original_grids.size(); i ++) {
-		if (original_grids[i] == NULL)
-			continue;
-		Comp_comm_group_mgt_node *comp_node = comp_comm_group_mgt_mgr->search_global_node(original_grids[i]->get_comp_full_name());
-		if (comp_node == NULL || comp_node->get_current_proc_local_id() == -1) {
-			original_grids[i]->reset_grid_data();
-			delete original_grids[i];
-			original_grids[i] = NULL;
-		}
-	}
+    for (int i = 0; i < original_grids.size(); i ++) {
+        if (original_grids[i] == NULL)
+            continue;
+        Comp_comm_group_mgt_node *comp_node = comp_comm_group_mgt_mgr->search_global_node(original_grids[i]->get_comp_full_name());
+        if (comp_node == NULL || comp_node->get_current_proc_local_id() == -1) {
+            original_grids[i]->reset_grid_data();
+            delete original_grids[i];
+            original_grids[i] = NULL;
+        }
+    }
 }
 
 
 Original_grid_info *Original_grid_mgt::search_grid_info(const char *grid_name, int comp_id)
 {
-	for (int i = 0; i < original_grids.size(); i ++)
-		if (original_grids[i] != NULL)
-			if (words_are_the_same(original_grids[i]->get_grid_name(), grid_name) && original_grids[i]->get_comp_id() == comp_id)
-				return original_grids[i];
+    for (int i = 0; i < original_grids.size(); i ++)
+        if (original_grids[i] != NULL)
+            if (words_are_the_same(original_grids[i]->get_grid_name(), grid_name) && original_grids[i]->get_comp_id() == comp_id)
+                return original_grids[i];
 
-	return NULL;
+    return NULL;
 }
 
 
 Original_grid_info *Original_grid_mgt::search_grid_info(int grid_id)
 {
-	EXECUTION_REPORT(REPORT_ERROR, -1, is_grid_id_legal(grid_id), "software error in Original_grid_mgt::search_grid_info based on grid_id");	
-	return original_grids[grid_id&TYPE_ID_SUFFIX_MASK];
+    EXECUTION_REPORT(REPORT_ERROR, -1, is_grid_id_legal(grid_id), "software error in Original_grid_mgt::search_grid_info based on grid_id");    
+    return original_grids[grid_id&TYPE_ID_SUFFIX_MASK];
 }
 
 
 int Original_grid_mgt::register_H2D_grid_via_comp(int comp_id, const char *grid_name, const char *annotation)
 {
-	char XML_file_name[NAME_STR_SIZE], nc_file_name[NAME_STR_SIZE], status_file_name[NAME_STR_SIZE];
-	const char *another_comp_full_name = NULL, *another_comp_grid_name = NULL;
-	int line_number;
-	
-
-	sprintf(XML_file_name, "%s/all/coupling_connections/%s.coupling_connections.xml", comp_comm_group_mgt_mgr->get_config_root_dir(), comp_comm_group_mgt_mgr->get_global_node_of_local_comp(comp_id, false, "in register_H2D_grid_via_comp")->get_full_name());
-	TiXmlDocument *XML_file = open_XML_file_to_read(comp_id, XML_file_name, comp_comm_group_mgt_mgr->get_comm_group_of_local_comp(comp_id,"in register_H2D_grid_via_comp"), false);
-	EXECUTION_REPORT(REPORT_ERROR, comp_id, XML_file != NULL, "Error happens when calling the API \"CCPL_register_H2D_grid_from_another_component\" to register an H2D grid \"%s\": the coupling connection configuration file (\"%s\") does not exist. The API call is at the model code with the annotation \"%s\". ", grid_name, XML_file_name, annotation);
-
-	TiXmlElement *root_XML_element;
-	TiXmlNode *root_XML_element_node = get_XML_first_child_of_unique_root(comp_id, XML_file_name, XML_file);
-	for (; root_XML_element_node != NULL; root_XML_element_node = root_XML_element_node->NextSibling()) {
-		if (root_XML_element_node->Type() != TiXmlNode::TINYXML_ELEMENT)
-			continue;
-		root_XML_element = root_XML_element_node->ToElement();
-		if (words_are_the_same(root_XML_element->Value(),"local_grids"))
-			break;
-	}
-	if (root_XML_element_node != NULL) {
-		for (TiXmlNode *grid_XML_element_node = root_XML_element->FirstChild(); grid_XML_element_node != NULL; grid_XML_element_node = grid_XML_element_node->NextSibling()) {
-			if (grid_XML_element_node->Type() != TiXmlNode::TINYXML_ELEMENT)
-				continue;
-			TiXmlElement *grid_XML_element = grid_XML_element_node->ToElement();
-			const char *xml_grid_name = get_XML_attribute(comp_id, CCPL_NAME_STR_LEN, grid_XML_element, "local_grid_name", XML_file_name, line_number, "grid name of the current component", "the coupling connection configuration file", true);
-			if (words_are_the_same(xml_grid_name, grid_name)) {
-				another_comp_full_name = get_XML_attribute(comp_id, 512, grid_XML_element, "another_comp_full_name", XML_file_name, line_number, "the full name of the another component", "the coupling connection configuration file", true);
-				another_comp_grid_name = get_XML_attribute(comp_id, CCPL_NAME_STR_LEN, grid_XML_element, "another_comp_grid_name", XML_file_name, line_number, "the grid name of the another component", "the coupling connection configuration file", true);
-				EXECUTION_REPORT(REPORT_ERROR, comp_id, strlen(another_comp_grid_name) > 0, "Error happens when calling the API \"CCPL_register_H2D_grid_from_another_component\" to register an H2D grid \"%s\": the coupling connection configuration file (\"%s\") specifies an empty name of the remote grid. Please check the XML file around line number %d", grid_name, XML_file_name, line_number);
-				break;
-			}
-		}	
-	}
-
-	EXECUTION_REPORT(REPORT_ERROR, comp_id, another_comp_full_name != NULL && another_comp_grid_name != NULL, "Error happens when calling the API \"CCPL_register_H2D_grid_from_another_component\" to register an H2D grid \"%s\": the coupling connection configuration file (\"%s\") does not contain the information for this grid. The API call is at the model code with the annotation \"%s\". ", grid_name, XML_file_name, annotation);
-	sprintf(nc_file_name, "%s/%s@%s.nc", comp_comm_group_mgt_mgr->get_internal_H2D_grids_dir(), another_comp_grid_name, another_comp_full_name);
-	sprintf(status_file_name, "%s/%s@%s.nc.end", comp_comm_group_mgt_mgr->get_comps_ending_config_status_dir(), another_comp_grid_name, another_comp_full_name);
-	EXECUTION_REPORT_LOG(REPORT_LOG, comp_id, true, "Wait to read NetCDF file \"%s\" to register H2D grid \"%s\" based on the grid \"%s\" of remote component \"%s\". Dead wait will be encounted if the full name of the remote component is wrong. So please make sure the full name of the remote component is correct in the the coupling connection configuration file (\"%s\")", nc_file_name, grid_name, another_comp_grid_name, another_comp_full_name, XML_file_name);
-	if (comp_comm_group_mgt_mgr->get_current_proc_id_in_comp(comp_id, "in register_H2D_grid_via_comp") == 0) {
-		while (true) {
-			FILE *status_file = fopen(status_file_name, "r");
-			if (status_file == NULL) {
-				if (comp_comm_group_mgt_mgr->has_comp_ended_configuration(another_comp_full_name))
-					EXECUTION_REPORT(REPORT_ERROR, comp_id, false, "Fail to read NetCDF file \"%s\" to register H2D grid \"%s\": the remote component model \"%s\" has ended its coupling configuration stage without registering the required grid (\"%s\") before. Please check the configuration file (\"%s\") or the corresponding model code.", nc_file_name, grid_name, another_comp_full_name, another_comp_grid_name, XML_file_name);
-				continue;
-			}
-			fclose(status_file);
-			break;
-		}
-	}
-	
-	delete XML_file;
-	synchronize_comp_processes_for_API(comp_id, API_ID_GRID_MGT_REG_H2D_GRID_VIA_COMP, comp_comm_group_mgt_mgr->get_comm_group_of_local_comp(comp_id, "in register_H2D_grid_via_comp"), "register_H2D_grid_via_comp", annotation);
-	if (!report_error_enabled)
-		MPI_Barrier(comp_comm_group_mgt_mgr->get_comm_group_of_local_comp(comp_id,"in register_H2D_grid_via_comp"));
-
-	return register_H2D_grid_via_file(comp_id, grid_name, nc_file_name, annotation);
+    char XML_file_name[NAME_STR_SIZE], nc_file_name[NAME_STR_SIZE], status_file_name[NAME_STR_SIZE];
+    const char *another_comp_full_name = NULL, *another_comp_grid_name = NULL;
+    int line_number;
+    
+
+    sprintf(XML_file_name, "%s/all/coupling_connections/%s.coupling_connections.xml", comp_comm_group_mgt_mgr->get_config_root_dir(), comp_comm_group_mgt_mgr->get_global_node_of_local_comp(comp_id, false, "in register_H2D_grid_via_comp")->get_full_name());
+    TiXmlDocument *XML_file = open_XML_file_to_read(comp_id, XML_file_name, comp_comm_group_mgt_mgr->get_comm_group_of_local_comp(comp_id,"in register_H2D_grid_via_comp"), false);
+    EXECUTION_REPORT(REPORT_ERROR, comp_id, XML_file != NULL, "Error happens when calling the API \"CCPL_register_H2D_grid_from_another_component\" to register an H2D grid \"%s\": the coupling connection configuration file (\"%s\") does not exist. The API call is at the model code with the annotation \"%s\". ", grid_name, XML_file_name, annotation);
+
+    TiXmlElement *root_XML_element;
+    TiXmlNode *root_XML_element_node = get_XML_first_child_of_unique_root(comp_id, XML_file_name, XML_file);
+    for (; root_XML_element_node != NULL; root_XML_element_node = root_XML_element_node->NextSibling()) {
+        if (root_XML_element_node->Type() != TiXmlNode::TINYXML_ELEMENT)
+            continue;
+        root_XML_element = root_XML_element_node->ToElement();
+        if (words_are_the_same(root_XML_element->Value(),"local_grids"))
+            break;
+    }
+    if (root_XML_element_node != NULL) {
+        for (TiXmlNode *grid_XML_element_node = root_XML_element->FirstChild(); grid_XML_element_node != NULL; grid_XML_element_node = grid_XML_element_node->NextSibling()) {
+            if (grid_XML_element_node->Type() != TiXmlNode::TINYXML_ELEMENT)
+                continue;
+            TiXmlElement *grid_XML_element = grid_XML_element_node->ToElement();
+            const char *xml_grid_name = get_XML_attribute(comp_id, CCPL_NAME_STR_LEN, grid_XML_element, "local_grid_name", XML_file_name, line_number, "grid name of the current component", "the coupling connection configuration file", true);
+            if (words_are_the_same(xml_grid_name, grid_name)) {
+                another_comp_full_name = get_XML_attribute(comp_id, 512, grid_XML_element, "another_comp_full_name", XML_file_name, line_number, "the full name of the another component", "the coupling connection configuration file", true);
+                another_comp_grid_name = get_XML_attribute(comp_id, CCPL_NAME_STR_LEN, grid_XML_element, "another_comp_grid_name", XML_file_name, line_number, "the grid name of the another component", "the coupling connection configuration file", true);
+                EXECUTION_REPORT(REPORT_ERROR, comp_id, strlen(another_comp_grid_name) > 0, "Error happens when calling the API \"CCPL_register_H2D_grid_from_another_component\" to register an H2D grid \"%s\": the coupling connection configuration file (\"%s\") specifies an empty name of the remote grid. Please check the XML file around line number %d", grid_name, XML_file_name, line_number);
+                break;
+            }
+        }    
+    }
+
+    EXECUTION_REPORT(REPORT_ERROR, comp_id, another_comp_full_name != NULL && another_comp_grid_name != NULL, "Error happens when calling the API \"CCPL_register_H2D_grid_from_another_component\" to register an H2D grid \"%s\": the coupling connection configuration file (\"%s\") does not contain the information for this grid. The API call is at the model code with the annotation \"%s\". ", grid_name, XML_file_name, annotation);
+    sprintf(nc_file_name, "%s/%s@%s.nc", comp_comm_group_mgt_mgr->get_internal_H2D_grids_dir(), another_comp_grid_name, another_comp_full_name);
+    sprintf(status_file_name, "%s/%s@%s.nc.end", comp_comm_group_mgt_mgr->get_comps_ending_config_status_dir(), another_comp_grid_name, another_comp_full_name);
+    EXECUTION_REPORT_LOG(REPORT_LOG, comp_id, true, "Wait to read NetCDF file \"%s\" to register H2D grid \"%s\" based on the grid \"%s\" of remote component \"%s\". Dead wait will be encounted if the full name of the remote component is wrong. So please make sure the full name of the remote component is correct in the the coupling connection configuration file (\"%s\")", nc_file_name, grid_name, another_comp_grid_name, another_comp_full_name, XML_file_name);
+    if (comp_comm_group_mgt_mgr->get_current_proc_id_in_comp(comp_id, "in register_H2D_grid_via_comp") == 0) {
+        while (true) {
+            FILE *status_file = fopen(status_file_name, "r");
+            if (status_file == NULL) {
+                if (comp_comm_group_mgt_mgr->has_comp_ended_configuration(another_comp_full_name))
+                    EXECUTION_REPORT(REPORT_ERROR, comp_id, false, "Fail to read NetCDF file \"%s\" to register H2D grid \"%s\": the remote component model \"%s\" has ended its coupling configuration stage without registering the required grid (\"%s\") before. Please check the configuration file (\"%s\") or the corresponding model code.", nc_file_name, grid_name, another_comp_full_name, another_comp_grid_name, XML_file_name);
+                continue;
+            }
+            fclose(status_file);
+            break;
+        }
+    }
+    
+    delete XML_file;
+    synchronize_comp_processes_for_API(comp_id, API_ID_GRID_MGT_REG_H2D_GRID_VIA_COMP, comp_comm_group_mgt_mgr->get_comm_group_of_local_comp(comp_id, "in register_H2D_grid_via_comp"), "register_H2D_grid_via_comp", annotation);
+    if (!report_error_enabled)
+        MPI_Barrier(comp_comm_group_mgt_mgr->get_comm_group_of_local_comp(comp_id,"in register_H2D_grid_via_comp"));
+
+    return register_H2D_grid_via_file(comp_id, grid_name, nc_file_name, annotation);
 }
 
 
 void Original_grid_mgt::calculate_min_max_H2D_coord_value(int comp_id, char *center_coord, char *vertex_coord, int size_center_coord, int size_vertex_coord, const char *data_type, double &min_coord_value, double &max_coord_value)
 {
-	if (words_are_the_same(data_type, DATA_TYPE_FLOAT)) {
-		float float_min_value = (float)NULL_COORD_VALUE, float_max_value = (float)NULL_COORD_VALUE;
-		get_min_value_in_array((float*)center_coord, size_center_coord, true, (float)NULL_COORD_VALUE, float_min_value);
-		get_min_value_in_array((float*)vertex_coord, size_vertex_coord, true, (float)NULL_COORD_VALUE, float_min_value);
-		get_max_value_in_array((float*)center_coord, size_center_coord, true, (float)NULL_COORD_VALUE, float_max_value);
-		get_max_value_in_array((float*)vertex_coord, size_vertex_coord, true, (float)NULL_COORD_VALUE, float_max_value);
-		min_coord_value = float_min_value;
-		max_coord_value = float_max_value;
-	}
-	else {
-		min_coord_value = NULL_COORD_VALUE, max_coord_value = NULL_COORD_VALUE;
-		get_min_value_in_array((double*)center_coord, size_center_coord, true, NULL_COORD_VALUE, min_coord_value);
-		get_min_value_in_array((double*)vertex_coord, size_vertex_coord, true, NULL_COORD_VALUE, min_coord_value);
-		get_max_value_in_array((double*)center_coord, size_center_coord, true, NULL_COORD_VALUE, max_coord_value);
-		get_max_value_in_array((double*)vertex_coord, size_vertex_coord, true, NULL_COORD_VALUE, max_coord_value);
-	}
-	double *all_min_coord_values = new double [comp_comm_group_mgt_mgr->get_global_node_of_local_comp(comp_id,false,"")->get_num_procs()];
-	double *all_max_coord_values = new double [comp_comm_group_mgt_mgr->get_global_node_of_local_comp(comp_id,false,"")->get_num_procs()];
-	EXECUTION_REPORT_LOG(REPORT_LOG, comp_id, true, "The min and max values calculated by C-Coupler is %lf and %lf", min_coord_value, max_coord_value);
-	MPI_Gather(&min_coord_value, 1, MPI_DOUBLE, all_min_coord_values, 1, MPI_DOUBLE, 0, comp_comm_group_mgt_mgr->get_comm_group_of_local_comp(comp_id,""));
-	MPI_Gather(&max_coord_value, 1, MPI_DOUBLE, all_max_coord_values, 1, MPI_DOUBLE, 0, comp_comm_group_mgt_mgr->get_comm_group_of_local_comp(comp_id,""));
-	if (comp_comm_group_mgt_mgr->get_current_proc_id_in_comp(comp_id,"") == 0)
-		for (int i = 0; i < comp_comm_group_mgt_mgr->get_global_node_of_local_comp(comp_id,false,"")->get_num_procs(); i ++) {
-			if (are_floating_values_equal(NULL_COORD_VALUE, min_coord_value) || !are_floating_values_equal(NULL_COORD_VALUE, all_min_coord_values[i]) && min_coord_value > all_min_coord_values[i])
-				min_coord_value = all_min_coord_values[i];
-			if (are_floating_values_equal(NULL_COORD_VALUE, max_coord_value) || !are_floating_values_equal(NULL_COORD_VALUE, all_max_coord_values[i]) && max_coord_value < all_max_coord_values[i])
-				max_coord_value = all_max_coord_values[i];
-		}
-	MPI_Bcast(&min_coord_value, 1, MPI_DOUBLE, 0, comp_comm_group_mgt_mgr->get_comm_group_of_local_comp(comp_id,""));
-	MPI_Bcast(&max_coord_value, 1, MPI_DOUBLE, 0, comp_comm_group_mgt_mgr->get_comm_group_of_local_comp(comp_id,""));
-	delete [] all_min_coord_values;
-	delete [] all_max_coord_values;
+    if (words_are_the_same(data_type, DATA_TYPE_FLOAT)) {
+        float float_min_value = (float)NULL_COORD_VALUE, float_max_value = (float)NULL_COORD_VALUE;
+        get_min_value_in_array((float*)center_coord, size_center_coord, true, (float)NULL_COORD_VALUE, float_min_value);
+        get_min_value_in_array((float*)vertex_coord, size_vertex_coord, true, (float)NULL_COORD_VALUE, float_min_value);
+        get_max_value_in_array((float*)center_coord, size_center_coord, true, (float)NULL_COORD_VALUE, float_max_value);
+        get_max_value_in_array((float*)vertex_coord, size_vertex_coord, true, (float)NULL_COORD_VALUE, float_max_value);
+        min_coord_value = float_min_value;
+        max_coord_value = float_max_value;
+    }
+    else {
+        min_coord_value = NULL_COORD_VALUE, max_coord_value = NULL_COORD_VALUE;
+        get_min_value_in_array((double*)center_coord, size_center_coord, true, NULL_COORD_VALUE, min_coord_value);
+        get_min_value_in_array((double*)vertex_coord, size_vertex_coord, true, NULL_COORD_VALUE, min_coord_value);
+        get_max_value_in_array((double*)center_coord, size_center_coord, true, NULL_COORD_VALUE, max_coord_value);
+        get_max_value_in_array((double*)vertex_coord, size_vertex_coord, true, NULL_COORD_VALUE, max_coord_value);
+    }
+    double *all_min_coord_values = new double [comp_comm_group_mgt_mgr->get_global_node_of_local_comp(comp_id,false,"")->get_num_procs()];
+    double *all_max_coord_values = new double [comp_comm_group_mgt_mgr->get_global_node_of_local_comp(comp_id,false,"")->get_num_procs()];
+    EXECUTION_REPORT_LOG(REPORT_LOG, comp_id, true, "The min and max values calculated by C-Coupler is %lf and %lf", min_coord_value, max_coord_value);
+    MPI_Gather(&min_coord_value, 1, MPI_DOUBLE, all_min_coord_values, 1, MPI_DOUBLE, 0, comp_comm_group_mgt_mgr->get_comm_group_of_local_comp(comp_id,""));
+    MPI_Gather(&max_coord_value, 1, MPI_DOUBLE, all_max_coord_values, 1, MPI_DOUBLE, 0, comp_comm_group_mgt_mgr->get_comm_group_of_local_comp(comp_id,""));
+    if (comp_comm_group_mgt_mgr->get_current_proc_id_in_comp(comp_id,"") == 0)
+        for (int i = 0; i < comp_comm_group_mgt_mgr->get_global_node_of_local_comp(comp_id,false,"")->get_num_procs(); i ++) {
+            if (are_floating_values_equal(NULL_COORD_VALUE, min_coord_value) || !are_floating_values_equal(NULL_COORD_VALUE, all_min_coord_values[i]) && min_coord_value > all_min_coord_values[i])
+                min_coord_value = all_min_coord_values[i];
+            if (are_floating_values_equal(NULL_COORD_VALUE, max_coord_value) || !are_floating_values_equal(NULL_COORD_VALUE, all_max_coord_values[i]) && max_coord_value < all_max_coord_values[i])
+                max_coord_value = all_max_coord_values[i];
+        }
+    MPI_Bcast(&min_coord_value, 1, MPI_DOUBLE, 0, comp_comm_group_mgt_mgr->get_comm_group_of_local_comp(comp_id,""));
+    MPI_Bcast(&max_coord_value, 1, MPI_DOUBLE, 0, comp_comm_group_mgt_mgr->get_comm_group_of_local_comp(comp_id,""));
+    delete [] all_min_coord_values;
+    delete [] all_max_coord_values;
 }
 
 
 void Original_grid_mgt::common_checking_for_H2D_registration_via_data(int comp_id, const char *grid_name, const char *edge_type, const char *coord_unit, char *cyclic_or_acyclic, const char *data_type, int size_mask, int size_center_lon, 
-	                                                                  int size_center_lat, int size_vertex_lon, int size_vertex_lat, int *mask, char *min_lon, char *max_lon, char *min_lat, char *max_lat, char *center_lon, char *center_lat, char *vertex_lon, char *vertex_lat, const char *annotation, int API_id)
+                                                                      int size_center_lat, int size_vertex_lon, int size_vertex_lat, int *mask, char *min_lon, char *max_lon, char *min_lat, char *max_lat, char *center_lon, char *center_lat, char *vertex_lon, char *vertex_lat, const char *annotation, int API_id)
 {
-	char API_label[NAME_STR_SIZE], hint[NAME_STR_SIZE];
-	double eps = 1.0000001;
-	double min_lon_value, max_lon_value, min_lat_value, max_lat_value;
-
-	
-	get_API_hint(comp_id, API_id, API_label);
-	sprintf(hint, "registering an H2D grid \"%s\"", grid_name);
-	
-	transform_datatype_of_arrays(min_lon, (char*)(&min_lon_value), data_type, DATA_TYPE_DOUBLE, 1);
-	transform_datatype_of_arrays(max_lon, (char*)(&max_lon_value), data_type, DATA_TYPE_DOUBLE, 1);
-	transform_datatype_of_arrays(min_lat, (char*)(&min_lat_value), data_type, DATA_TYPE_DOUBLE, 1);
-	transform_datatype_of_arrays(max_lat, (char*)(&max_lat_value), data_type, DATA_TYPE_DOUBLE, 1);
-	check_API_parameter_string(comp_id, API_id, comp_comm_group_mgt_mgr->get_comm_group_of_local_comp(comp_id, "in register_h2d_grid_with_data"), hint, edge_type, "edge_type", annotation);
-	check_API_parameter_string(comp_id, API_id, comp_comm_group_mgt_mgr->get_comm_group_of_local_comp(comp_id, "in register_h2d_grid_with_data"), hint, cyclic_or_acyclic, "cyclic_or_acyclic", annotation);
-	check_API_parameter_string(comp_id, API_id, comp_comm_group_mgt_mgr->get_comm_group_of_local_comp(comp_id, "in register_h2d_grid_with_data"), hint, data_type, "implicit data type", annotation);
-	check_API_parameter_double(comp_id, API_id, comp_comm_group_mgt_mgr->get_comm_group_of_local_comp(comp_id, "in register_h2d_grid_with_data"), NULL, min_lon_value, "\"min_lon\"", annotation);
-	check_API_parameter_double(comp_id, API_id, comp_comm_group_mgt_mgr->get_comm_group_of_local_comp(comp_id, "in register_h2d_grid_with_data"), NULL, max_lon_value, "\"max_lon\"", annotation);
-	check_API_parameter_double(comp_id, API_id, comp_comm_group_mgt_mgr->get_comm_group_of_local_comp(comp_id, "in register_h2d_grid_with_data"), NULL, min_lat_value, "\"min_lat\"", annotation);
-	check_API_parameter_double(comp_id, API_id, comp_comm_group_mgt_mgr->get_comm_group_of_local_comp(comp_id, "in register_h2d_grid_with_data"), NULL, max_lat_value, "\"max_lat\"", annotation);
-
-	EXECUTION_REPORT(REPORT_ERROR, comp_id, words_are_the_same(edge_type, "LON_LAT") || words_are_the_same(edge_type, "GREAT_ARC") || words_are_the_same(edge_type, "XY") || words_are_the_same(edge_type, "TriPolar"), "Error happens when registering an H2D grid \"%s\" through the API \"%s\": the value (currently is \"%s\") of parameter \"edge_type\" is not \"LON_LAT\", \"GREAT_ARC\", \"TriPolar\" or \"XY\". Please check the model code related to the annotation \"%s\".", grid_name, API_label, edge_type, annotation);
-	if (words_are_the_same(edge_type, "LON_LAT") || words_are_the_same(edge_type, "GREAT_ARC") || words_are_the_same(edge_type, "TriPolar"))
-		EXECUTION_REPORT(REPORT_ERROR, comp_id, words_are_the_same(coord_unit, COORD_UNIT_DEGREES) || words_are_the_same(coord_unit, COORD_UNIT_RADIANS), "Error happens when registering an H2D grid \"%s\" through the API \"%s\": the parameter \"coord_unit\" (currently is \"%s\") is not \"degrees\" or \"radians\". Please check the model code related to the annotation \"%s\".", grid_name, API_label, coord_unit, annotation);
-	EXECUTION_REPORT(REPORT_ERROR, comp_id, words_are_the_same(cyclic_or_acyclic, "cyclic") || words_are_the_same(cyclic_or_acyclic, "acyclic"), "Error happens when registering an H2D grid \"%s\" through the API \"%s\": the value (currently is \"%s\") of parameter \"cyclic_or_acyclic\" is not \"cyclic\" or \"acyclic\". Please check the model code related to the annotation \"%s\".", grid_name, API_label, cyclic_or_acyclic, annotation);
-	if (words_are_the_same(edge_type, "XY"))
-		EXECUTION_REPORT(REPORT_ERROR, comp_id, words_are_the_same(cyclic_or_acyclic, "acyclic"), "Error happens when registering an H2D grid \"%s\" through the API \"%s\": the value (currently is \"%s\") of parameter \"cyclic_or_acyclic\" is not \"acyclic\" when the parameter \"edge_type\" has been set to \"XY\". Please check the model code related to the annotation \"%s\".", grid_name, API_label, cyclic_or_acyclic, annotation);
-	EXECUTION_REPORT(REPORT_ERROR, comp_id, words_are_the_same(data_type, DATA_TYPE_FLOAT) || words_are_the_same(data_type, DATA_TYPE_DOUBLE), "software error in register_h2d_grid_with_data: wrong implicit data type");
-
-	EXECUTION_REPORT(REPORT_ERROR, comp_id, are_array_values_between_boundaries("integer", mask, size_mask, 0, 1, 0, false), "Error happens when registering an H2D grid \"%s\" through the API \"%s\": some values of the parameter \"mask\" are wrong (not 0 and 1). Please check the model code related to the annotation \"%s\".", grid_name, API_label, annotation);
-	EXECUTION_REPORT(REPORT_ERROR, comp_id, are_floating_values_equal(NULL_COORD_VALUE, min_lon_value) && are_floating_values_equal(NULL_COORD_VALUE, max_lon_value) || !are_floating_values_equal(NULL_COORD_VALUE, min_lon_value) && !are_floating_values_equal(NULL_COORD_VALUE, max_lon_value), "Error happens when registering an H2D grid \"%s\" through the API \"%s\": \"min_lon\" (currently is %lf) and \"max_lon\" (currently is %lf) must be CCPL_NULL_COORD_VALUE (%lf) or not at the same time. Please check the model code related to the annotation \"%s\"", grid_name, API_label, min_lon, max_lon, NULL_COORD_VALUE, annotation);
-	EXECUTION_REPORT(REPORT_ERROR, comp_id, are_floating_values_equal(NULL_COORD_VALUE, min_lat_value) && are_floating_values_equal(NULL_COORD_VALUE, max_lat_value) || !are_floating_values_equal(NULL_COORD_VALUE, min_lat_value) && !are_floating_values_equal(NULL_COORD_VALUE, max_lat_value), "Error happens when registering an H2D grid \"%s\" through the API \"%s\": \"min_lat\" (currently is %lf) and \"max_lat\" (currently is %lf) must be CCPL_NULL_COORD_VALUE (%lf) or not at the same time. Please check the model code related to the annotation \"%s\"", grid_name, API_label, min_lat, max_lat, NULL_COORD_VALUE, annotation);
-
-	if (!are_floating_values_equal(NULL_COORD_VALUE, min_lat_value))
-		EXECUTION_REPORT(REPORT_ERROR, comp_id, max_lat_value > min_lat_value, "Error happens when registering an H2D grid \"%s\" through the API \"%s\": \"min_lat\" (currently is %lf) is not smaller than \"max_lat\" (currently is %lf). Please check the model code related to the annotation \"%s\".", grid_name, API_label, min_lat_value, max_lat_value, annotation);
-	else {
-		calculate_min_max_H2D_coord_value(comp_id, center_lat, vertex_lat, size_center_lat, size_vertex_lat, data_type, min_lat_value, max_lat_value);
-		EXECUTION_REPORT_LOG(REPORT_LOG, comp_id, true, "The min and max latitude values of the grid \"%s\" calculated by C-Coupler is %lf and %lf", grid_name, min_lat_value, max_lat_value);
-		transform_datatype_of_arrays((char*)(&min_lat_value), min_lat, DATA_TYPE_DOUBLE, data_type, 1);
-		transform_datatype_of_arrays((char*)(&max_lat_value), max_lat, DATA_TYPE_DOUBLE, data_type, 1);
-	}	
-	if (words_are_the_same(coord_unit, COORD_UNIT_DEGREES)) {
-		if (!are_floating_values_equal(NULL_COORD_VALUE, min_lat_value)) {
-			EXECUTION_REPORT(REPORT_ERROR, comp_id, are_array_values_between_boundaries(data_type, &min_lat_value, 1, (double) -90.0*eps, (double) 90.0*eps, (double) NULL_COORD_VALUE, false), "Error happens when registering an H2D grid \"%s\" through the API \"%s\": the specified value (%lf) of the parameter \"min_lat\" is wrong (not between -90 and 90). Please check the model code related to the annotation \"%s\".", grid_name, API_label, min_lat_value, annotation);
-			EXECUTION_REPORT(REPORT_ERROR, comp_id, are_array_values_between_boundaries(data_type, &max_lat_value, 1, (double) -90.0*eps, (double) 90.0*eps, (double) NULL_COORD_VALUE, false), "Error happens when registering an H2D grid \"%s\" through the API \"%s\": the specified value (%lf) of the parameter \"max_lat\" is wrong (not between -90 and 90). Please check the model code related to the annotation \"%s\".", grid_name, API_label, max_lat_value, annotation);
-		}
-		if (are_floating_values_equal((double)-90.0, min_lat_value) || are_floating_values_equal((double)90.0, max_lat_value))
-			strcpy(cyclic_or_acyclic, "cyclic");	
-		if (words_are_the_same(cyclic_or_acyclic, "cyclic")) {
-			min_lon_value = -360;
-			max_lon_value = 360;
-		}
-		if (!are_floating_values_equal(NULL_COORD_VALUE, min_lon_value)) {
-			EXECUTION_REPORT(REPORT_ERROR, comp_id, are_array_values_between_boundaries(data_type, &min_lon_value, 1, (double) -360.0*eps, (double) 360.0*eps, (double) NULL_COORD_VALUE, false), "Error happens when registering an H2D grid \"%s\" through the API \"%s\": the specified value (%lf) of the parameter \"min_lon\" is wrong (not between -360 and 360). Please check the model code related to the annotation \"%s\".", grid_name, API_label, min_lon_value, annotation);
-			EXECUTION_REPORT(REPORT_ERROR, comp_id, are_array_values_between_boundaries(data_type, &max_lon_value, 1, (double) -360.0*eps, (double) 360.0*eps, (double) NULL_COORD_VALUE, false), "Error happens when registering an H2D grid \"%s\" through the API \"%s\": the specified value (%lf) of the parameter \"max_lon\" is wrong (not between -360 and 360). Please check the model code related to the annotation \"%s\".", grid_name, API_label, max_lon_value, annotation);
-			if (words_are_the_same(cyclic_or_acyclic, "acyclic"))
-				EXECUTION_REPORT(REPORT_ERROR, comp_id, fabs(max_lon_value-min_lon_value) <= ((double)360.0)*eps, "Error happens when registering an H2D grid \"%s\" through the API \"%s\": the difference between \"min_lon\" and \"max_lon\" (%lf) is wrong (not between -360 and 360). Please check the model code related to the annotation \"%s\".", grid_name, API_label, fabs(max_lon_value-min_lon_value), annotation);			
-		}
-	}
-	else if (words_are_the_same(coord_unit, COORD_UNIT_RADIANS)) {
-		if (are_floating_values_equal(NULL_COORD_VALUE, min_lat_value)) {
-			EXECUTION_REPORT(REPORT_ERROR, comp_id, are_array_values_between_boundaries(data_type, &min_lat_value, 1, -((double)3.1415927)/2*eps, ((double)3.1415927)/2*eps, (double) NULL_COORD_VALUE, false), "Error happens when registering an H2D grid \"%s\" through the API \"%s\": the specified value (%lf) of the parameter \"min_lat\" are wrong (not between -PI/2 and PI/2). Please check the model code related to the annotation \"%s\".", grid_name, API_label, min_lat_value, annotation);
-			EXECUTION_REPORT(REPORT_ERROR, comp_id, are_array_values_between_boundaries(data_type, &max_lat_value, 1, -((double)3.1415927)/2*eps, ((double)3.1415927)/2*eps, (double) NULL_COORD_VALUE, false), "Error happens when registering an H2D grid \"%s\" through the API \"%s\": the specified value (%lf) of the parameter \"max_lat\" are wrong (not between -PI/2 and PI/2). Please check the model code related to the annotation \"%s\".", grid_name, API_label, max_lat_value, annotation);
-		}
-		if (are_floating_values_equal((double)-PI/2, min_lat_value) || are_floating_values_equal((double)PI/2, max_lat_value))
-			strcpy(cyclic_or_acyclic, "cyclic");
-		if (words_are_the_same(cyclic_or_acyclic, "cyclic")) {
-			min_lon_value = -((double)3.1415927)*2;
-			max_lon_value = ((double)3.1415927)*2;
-		}
-		if (are_floating_values_equal(NULL_COORD_VALUE, min_lon_value)) {
-			EXECUTION_REPORT(REPORT_ERROR, comp_id, are_array_values_between_boundaries(data_type, &min_lon_value, 1, -((double)3.1415927)*2*eps, ((double)3.1415927)*2*eps, (double) NULL_COORD_VALUE, false), "Error happens when registering an H2D grid \"%s\" through the API \"%s\": the specified value (%lf) of the parameter \"min_lon\" are wrong (not between -2PI and 2PI). Please check the model code related to the annotation \"%s\".", grid_name, API_label, min_lon_value, annotation);
-			EXECUTION_REPORT(REPORT_ERROR, comp_id, are_array_values_between_boundaries(data_type, &max_lon_value, 1, -((double)3.1415927)*2*eps, ((double)3.1415927)*2*eps, (double) NULL_COORD_VALUE, false), "Error happens when registering an H2D grid \"%s\" through the API \"%s\": the specified value (%lf) of the parameter \"max_lon\" are wrong (not between -2PI and 2PI). Please check the model code related to the annotation \"%s\".", grid_name, API_label, max_lon_value, annotation);
-			if (words_are_the_same(cyclic_or_acyclic, "acyclic"))
-				EXECUTION_REPORT(REPORT_ERROR, comp_id, fabs(max_lon_value-min_lon_value) <= ((double)3.1415927)*2*eps, "Error happens when registering an H2D grid \"%s\" through the API \"%s\": the difference between \"min_lon\" and \"max_lon\" is wrong (not between -2PI and 2PI). Please check the model code related to the annotation \"%s\".", grid_name, API_label, annotation);	
-		}
-	}
-	if (are_floating_values_equal(NULL_COORD_VALUE, min_lon_value)) {
-		calculate_min_max_H2D_coord_value(comp_id, center_lon, vertex_lon, size_center_lon, size_vertex_lon, data_type, min_lon_value, max_lon_value);
-		EXECUTION_REPORT_LOG(REPORT_LOG, comp_id, true, "The min and max longitude values of the grid \"%s\" calculated by C-Coupler is %lf and %lf", grid_name, min_lon_value, max_lon_value);
-		transform_datatype_of_arrays((char*)(&min_lon_value), min_lon, DATA_TYPE_DOUBLE, data_type, 1);
-		transform_datatype_of_arrays((char*)(&max_lon_value), max_lon, DATA_TYPE_DOUBLE, data_type, 1);
-	}
-	if (!are_floating_values_equal(NULL_COORD_VALUE, min_lon_value)) {
-		EXECUTION_REPORT(REPORT_ERROR, comp_id, are_array_values_between_boundaries(data_type, (double*) center_lon, size_center_lon, min_lon_value, max_lon_value, (double) NULL_COORD_VALUE, false), "Error happens when registering an H2D grid \"%s\" through the API \"%s\": some values of the parameter \"center_lon\" are not between \"min_lon\" (%lf) and \"max_lon\" (%lf). Please check the model code related to the annotation \"%s\".", grid_name, API_label, min_lon_value, max_lon_value, annotation);
-		EXECUTION_REPORT(REPORT_ERROR, comp_id, are_array_values_between_boundaries(data_type, (double*) vertex_lon, size_vertex_lon, min_lon_value, max_lon_value, (double) NULL_COORD_VALUE, true), "Error happens when registering an H2D grid \"%s\" through the API \"%s\": some values of the parameter \"vertex_lon\" are not between \"min_lon\" (%lf) and \"max_lon\" (%lf). Please check the model code related to the annotation \"%s\".", grid_name, API_label, min_lon_value, max_lon_value, annotation);
-	}
-	if (!are_floating_values_equal(NULL_COORD_VALUE, min_lat_value)) {
-		EXECUTION_REPORT(REPORT_ERROR, comp_id, are_array_values_between_boundaries(data_type, (double*) center_lat, size_center_lat, min_lat_value, max_lat_value, (double) NULL_COORD_VALUE, false), "Error happens when registering an H2D grid \"%s\" through the API \"%s\": some values of the parameter \"center_lat\" are not between \"min_lat\" (%lf) and \"max_lat\" (%lf). Please check the model code related to the annotation \"%s\".", grid_name, API_label, min_lat_value, max_lat_value, annotation);
-		EXECUTION_REPORT(REPORT_ERROR, comp_id, are_array_values_between_boundaries(data_type, (double*) vertex_lat, size_vertex_lat, min_lat_value, max_lat_value, (double) NULL_COORD_VALUE, true), "Error happens when registering an H2D grid \"%s\" through the API \"%s\": some values of the parameter \"vertex_lat\" are not between \"min_lat\" (%lf) and \"max_lat\" (%lf). Please check the model code related to the annotation \"%s\".", grid_name, API_label, min_lat_value, max_lat_value, annotation);
-	}
+    char API_label[NAME_STR_SIZE], hint[NAME_STR_SIZE];
+    double eps = 1.0000001;
+    double min_lon_value, max_lon_value, min_lat_value, max_lat_value;
+
+    
+    get_API_hint(comp_id, API_id, API_label);
+    sprintf(hint, "registering an H2D grid \"%s\"", grid_name);
+    
+    transform_datatype_of_arrays(min_lon, (char*)(&min_lon_value), data_type, DATA_TYPE_DOUBLE, 1);
+    transform_datatype_of_arrays(max_lon, (char*)(&max_lon_value), data_type, DATA_TYPE_DOUBLE, 1);
+    transform_datatype_of_arrays(min_lat, (char*)(&min_lat_value), data_type, DATA_TYPE_DOUBLE, 1);
+    transform_datatype_of_arrays(max_lat, (char*)(&max_lat_value), data_type, DATA_TYPE_DOUBLE, 1);
+    check_API_parameter_string(comp_id, API_id, comp_comm_group_mgt_mgr->get_comm_group_of_local_comp(comp_id, "in register_h2d_grid_with_data"), hint, edge_type, "edge_type", annotation);
+    check_API_parameter_string(comp_id, API_id, comp_comm_group_mgt_mgr->get_comm_group_of_local_comp(comp_id, "in register_h2d_grid_with_data"), hint, cyclic_or_acyclic, "cyclic_or_acyclic", annotation);
+    check_API_parameter_string(comp_id, API_id, comp_comm_group_mgt_mgr->get_comm_group_of_local_comp(comp_id, "in register_h2d_grid_with_data"), hint, data_type, "implicit data type", annotation);
+    check_API_parameter_double(comp_id, API_id, comp_comm_group_mgt_mgr->get_comm_group_of_local_comp(comp_id, "in register_h2d_grid_with_data"), NULL, min_lon_value, "\"min_lon\"", annotation);
+    check_API_parameter_double(comp_id, API_id, comp_comm_group_mgt_mgr->get_comm_group_of_local_comp(comp_id, "in register_h2d_grid_with_data"), NULL, max_lon_value, "\"max_lon\"", annotation);
+    check_API_parameter_double(comp_id, API_id, comp_comm_group_mgt_mgr->get_comm_group_of_local_comp(comp_id, "in register_h2d_grid_with_data"), NULL, min_lat_value, "\"min_lat\"", annotation);
+    check_API_parameter_double(comp_id, API_id, comp_comm_group_mgt_mgr->get_comm_group_of_local_comp(comp_id, "in register_h2d_grid_with_data"), NULL, max_lat_value, "\"max_lat\"", annotation);
+
+    EXECUTION_REPORT(REPORT_ERROR, comp_id, words_are_the_same(edge_type, "LON_LAT") || words_are_the_same(edge_type, "GREAT_ARC") || words_are_the_same(edge_type, "XY") || words_are_the_same(edge_type, "TriPolar"), "Error happens when registering an H2D grid \"%s\" through the API \"%s\": the value (currently is \"%s\") of parameter \"edge_type\" is not \"LON_LAT\", \"GREAT_ARC\", \"TriPolar\" or \"XY\". Please check the model code related to the annotation \"%s\".", grid_name, API_label, edge_type, annotation);
+    if (words_are_the_same(edge_type, "LON_LAT") || words_are_the_same(edge_type, "GREAT_ARC") || words_are_the_same(edge_type, "TriPolar"))
+        EXECUTION_REPORT(REPORT_ERROR, comp_id, words_are_the_same(coord_unit, COORD_UNIT_DEGREES) || words_are_the_same(coord_unit, COORD_UNIT_RADIANS), "Error happens when registering an H2D grid \"%s\" through the API \"%s\": the parameter \"coord_unit\" (currently is \"%s\") is not \"degrees\" or \"radians\". Please check the model code related to the annotation \"%s\".", grid_name, API_label, coord_unit, annotation);
+    EXECUTION_REPORT(REPORT_ERROR, comp_id, words_are_the_same(cyclic_or_acyclic, "cyclic") || words_are_the_same(cyclic_or_acyclic, "acyclic"), "Error happens when registering an H2D grid \"%s\" through the API \"%s\": the value (currently is \"%s\") of parameter \"cyclic_or_acyclic\" is not \"cyclic\" or \"acyclic\". Please check the model code related to the annotation \"%s\".", grid_name, API_label, cyclic_or_acyclic, annotation);
+    if (words_are_the_same(edge_type, "XY"))
+        EXECUTION_REPORT(REPORT_ERROR, comp_id, words_are_the_same(cyclic_or_acyclic, "acyclic"), "Error happens when registering an H2D grid \"%s\" through the API \"%s\": the value (currently is \"%s\") of parameter \"cyclic_or_acyclic\" is not \"acyclic\" when the parameter \"edge_type\" has been set to \"XY\". Please check the model code related to the annotation \"%s\".", grid_name, API_label, cyclic_or_acyclic, annotation);
+    EXECUTION_REPORT(REPORT_ERROR, comp_id, words_are_the_same(data_type, DATA_TYPE_FLOAT) || words_are_the_same(data_type, DATA_TYPE_DOUBLE), "software error in register_h2d_grid_with_data: wrong implicit data type");
+
+    EXECUTION_REPORT(REPORT_ERROR, comp_id, are_array_values_between_boundaries("integer", mask, size_mask, 0, 1, 0, false), "Error happens when registering an H2D grid \"%s\" through the API \"%s\": some values of the parameter \"mask\" are wrong (not 0 and 1). Please check the model code related to the annotation \"%s\".", grid_name, API_label, annotation);
+    EXECUTION_REPORT(REPORT_ERROR, comp_id, are_floating_values_equal(NULL_COORD_VALUE, min_lon_value) && are_floating_values_equal(NULL_COORD_VALUE, max_lon_value) || !are_floating_values_equal(NULL_COORD_VALUE, min_lon_value) && !are_floating_values_equal(NULL_COORD_VALUE, max_lon_value), "Error happens when registering an H2D grid \"%s\" through the API \"%s\": \"min_lon\" (currently is %lf) and \"max_lon\" (currently is %lf) must be CCPL_NULL_COORD_VALUE (%lf) or not at the same time. Please check the model code related to the annotation \"%s\"", grid_name, API_label, min_lon_value, max_lon_value, NULL_COORD_VALUE, annotation);
+    EXECUTION_REPORT(REPORT_ERROR, comp_id, are_floating_values_equal(NULL_COORD_VALUE, min_lat_value) && are_floating_values_equal(NULL_COORD_VALUE, max_lat_value) || !are_floating_values_equal(NULL_COORD_VALUE, min_lat_value) && !are_floating_values_equal(NULL_COORD_VALUE, max_lat_value), "Error happens when registering an H2D grid \"%s\" through the API \"%s\": \"min_lat\" (currently is %lf) and \"max_lat\" (currently is %lf) must be CCPL_NULL_COORD_VALUE (%lf) or not at the same time. Please check the model code related to the annotation \"%s\"", grid_name, API_label, min_lat_value, max_lat_value, NULL_COORD_VALUE, annotation);
+
+    if (!are_floating_values_equal(NULL_COORD_VALUE, min_lat_value))
+        EXECUTION_REPORT(REPORT_ERROR, comp_id, max_lat_value > min_lat_value, "Error happens when registering an H2D grid \"%s\" through the API \"%s\": \"min_lat\" (currently is %lf) is not smaller than \"max_lat\" (currently is %lf). Please check the model code related to the annotation \"%s\".", grid_name, API_label, min_lat_value, max_lat_value, annotation);
+    else {
+        calculate_min_max_H2D_coord_value(comp_id, center_lat, vertex_lat, size_center_lat, size_vertex_lat, data_type, min_lat_value, max_lat_value);
+        EXECUTION_REPORT_LOG(REPORT_LOG, comp_id, true, "The min and max latitude values of the grid \"%s\" calculated by C-Coupler is %lf and %lf", grid_name, min_lat_value, max_lat_value);
+        transform_datatype_of_arrays((char*)(&min_lat_value), min_lat, DATA_TYPE_DOUBLE, data_type, 1);
+        transform_datatype_of_arrays((char*)(&max_lat_value), max_lat, DATA_TYPE_DOUBLE, data_type, 1);
+    }    
+    if (words_are_the_same(coord_unit, COORD_UNIT_DEGREES)) {
+        if (!are_floating_values_equal(NULL_COORD_VALUE, min_lat_value)) {
+            EXECUTION_REPORT(REPORT_ERROR, comp_id, are_array_values_between_boundaries(DATA_TYPE_DOUBLE, &min_lat_value, 1, (double) -90.0*eps, (double) 90.0*eps, (double) NULL_COORD_VALUE, false), "Error happens when registering an H2D grid \"%s\" through the API \"%s\": the specified value (%lf) of the parameter \"min_lat\" is wrong (not between -90 and 90). Please check the model code related to the annotation \"%s\".", grid_name, API_label, min_lat_value, annotation);
+            EXECUTION_REPORT(REPORT_ERROR, comp_id, are_array_values_between_boundaries(DATA_TYPE_DOUBLE, &max_lat_value, 1, (double) -90.0*eps, (double) 90.0*eps, (double) NULL_COORD_VALUE, false), "Error happens when registering an H2D grid \"%s\" through the API \"%s\": the specified value (%lf) of the parameter \"max_lat\" is wrong (not between -90 and 90). Please check the model code related to the annotation \"%s\".", grid_name, API_label, max_lat_value, annotation);
+        }
+        if (are_floating_values_equal((double)-90.0, min_lat_value) || are_floating_values_equal((double)90.0, max_lat_value))
+            strcpy(cyclic_or_acyclic, "cyclic");    
+        if (words_are_the_same(cyclic_or_acyclic, "cyclic")) {
+            min_lon_value = -360;
+            max_lon_value = 360;
+        }
+        if (!are_floating_values_equal(NULL_COORD_VALUE, min_lon_value)) {
+            EXECUTION_REPORT(REPORT_ERROR, comp_id, are_array_values_between_boundaries(DATA_TYPE_DOUBLE, &min_lon_value, 1, (double) -360.0*eps, (double) 360.0*eps, (double) NULL_COORD_VALUE, false), "Error happens when registering an H2D grid \"%s\" through the API \"%s\": the specified value (%lf) of the parameter \"min_lon\" is wrong (not between -360 and 360). Please check the model code related to the annotation \"%s\".", grid_name, API_label, min_lon_value, annotation);
+            EXECUTION_REPORT(REPORT_ERROR, comp_id, are_array_values_between_boundaries(DATA_TYPE_DOUBLE, &max_lon_value, 1, (double) -360.0*eps, (double) 360.0*eps, (double) NULL_COORD_VALUE, false), "Error happens when registering an H2D grid \"%s\" through the API \"%s\": the specified value (%lf) of the parameter \"max_lon\" is wrong (not between -360 and 360). Please check the model code related to the annotation \"%s\".", grid_name, API_label, max_lon_value, annotation);
+            if (words_are_the_same(cyclic_or_acyclic, "acyclic"))
+                EXECUTION_REPORT(REPORT_ERROR, comp_id, fabs(max_lon_value-min_lon_value) <= ((double)360.0)*eps, "Error happens when registering an H2D grid \"%s\" through the API \"%s\": the difference between \"min_lon\" and \"max_lon\" (%lf) is wrong (not between -360 and 360). Please check the model code related to the annotation \"%s\".", grid_name, API_label, fabs(max_lon_value-min_lon_value), annotation);            
+        }
+    }
+    else if (words_are_the_same(coord_unit, COORD_UNIT_RADIANS)) {
+        if (!are_floating_values_equal(NULL_COORD_VALUE, min_lat_value)) {
+            EXECUTION_REPORT(REPORT_ERROR, comp_id, are_array_values_between_boundaries(DATA_TYPE_DOUBLE, &min_lat_value, 1, -((double)3.1415927)/2*eps, ((double)3.1415927)/2*eps, (double) NULL_COORD_VALUE, false), "Error happens when registering an H2D grid \"%s\" through the API \"%s\": the specified value (%lf) of the parameter \"min_lat\" are wrong (not between -PI/2 and PI/2). Please check the model code related to the annotation \"%s\".", grid_name, API_label, min_lat_value, annotation);
+            EXECUTION_REPORT(REPORT_ERROR, comp_id, are_array_values_between_boundaries(DATA_TYPE_DOUBLE, &max_lat_value, 1, -((double)3.1415927)/2*eps, ((double)3.1415927)/2*eps, (double) NULL_COORD_VALUE, false), "Error happens when registering an H2D grid \"%s\" through the API \"%s\": the specified value (%lf) of the parameter \"max_lat\" are wrong (not between -PI/2 and PI/2). Please check the model code related to the annotation \"%s\".", grid_name, API_label, max_lat_value, annotation);
+        }
+        if (are_floating_values_equal((double)-PI/2, min_lat_value) || are_floating_values_equal((double)PI/2, max_lat_value))
+            strcpy(cyclic_or_acyclic, "cyclic");
+        if (words_are_the_same(cyclic_or_acyclic, "cyclic")) {
+            min_lon_value = -((double)3.1415927)*2;
+            max_lon_value = ((double)3.1415927)*2;
+        }
+        if (!are_floating_values_equal(NULL_COORD_VALUE, min_lon_value)) {
+            EXECUTION_REPORT(REPORT_ERROR, comp_id, are_array_values_between_boundaries(DATA_TYPE_DOUBLE, &min_lon_value, 1, -((double)3.1415927)*2*eps, ((double)3.1415927)*2*eps, (double) NULL_COORD_VALUE, false), "Error happens when registering an H2D grid \"%s\" through the API \"%s\": the specified value (%lf) of the parameter \"min_lon\" are wrong (not between -2PI and 2PI). Please check the model code related to the annotation \"%s\".", grid_name, API_label, min_lon_value, annotation);
+            EXECUTION_REPORT(REPORT_ERROR, comp_id, are_array_values_between_boundaries(DATA_TYPE_DOUBLE, &max_lon_value, 1, -((double)3.1415927)*2*eps, ((double)3.1415927)*2*eps, (double) NULL_COORD_VALUE, false), "Error happens when registering an H2D grid \"%s\" through the API \"%s\": the specified value (%lf) of the parameter \"max_lon\" are wrong (not between -2PI and 2PI). Please check the model code related to the annotation \"%s\".", grid_name, API_label, max_lon_value, annotation);
+            if (words_are_the_same(cyclic_or_acyclic, "acyclic"))
+                EXECUTION_REPORT(REPORT_ERROR, comp_id, fabs(max_lon_value-min_lon_value) <= ((double)3.1415927)*2*eps, "Error happens when registering an H2D grid \"%s\" through the API \"%s\": the difference between \"min_lon\" and \"max_lon\" is wrong (not between -2PI and 2PI). Please check the model code related to the annotation \"%s\".", grid_name, API_label, annotation);    
+        }
+    }
+    if (are_floating_values_equal(NULL_COORD_VALUE, min_lon_value)) {
+        calculate_min_max_H2D_coord_value(comp_id, center_lon, vertex_lon, size_center_lon, size_vertex_lon, data_type, min_lon_value, max_lon_value);
+        EXECUTION_REPORT_LOG(REPORT_LOG, comp_id, true, "The min and max longitude values of the grid \"%s\" calculated by C-Coupler is %lf and %lf", grid_name, min_lon_value, max_lon_value);
+        transform_datatype_of_arrays((char*)(&min_lon_value), min_lon, DATA_TYPE_DOUBLE, data_type, 1);
+        transform_datatype_of_arrays((char*)(&max_lon_value), max_lon, DATA_TYPE_DOUBLE, data_type, 1);
+    }
+    if (!are_floating_values_equal(NULL_COORD_VALUE, min_lon_value)) {
+        EXECUTION_REPORT(REPORT_ERROR, comp_id, are_array_values_between_boundaries(data_type, (double*) center_lon, size_center_lon, min_lon_value, max_lon_value, (double) NULL_COORD_VALUE, false), "Error happens when registering an H2D grid \"%s\" through the API \"%s\": some values of the parameter \"center_lon\" are not between \"min_lon\" (%lf) and \"max_lon\" (%lf). Please check the model code related to the annotation \"%s\".", grid_name, API_label, min_lon_value, max_lon_value, annotation);
+        EXECUTION_REPORT(REPORT_ERROR, comp_id, are_array_values_between_boundaries(data_type, (double*) vertex_lon, size_vertex_lon, min_lon_value, max_lon_value, (double) NULL_COORD_VALUE, true), "Error happens when registering an H2D grid \"%s\" through the API \"%s\": some values of the parameter \"vertex_lon\" are not between \"min_lon\" (%lf) and \"max_lon\" (%lf). Please check the model code related to the annotation \"%s\".", grid_name, API_label, min_lon_value, max_lon_value, annotation);
+    }
+    if (!are_floating_values_equal(NULL_COORD_VALUE, min_lat_value)) {
+        EXECUTION_REPORT(REPORT_ERROR, comp_id, are_array_values_between_boundaries(data_type, (double*) center_lat, size_center_lat, min_lat_value, max_lat_value, (double) NULL_COORD_VALUE, false), "Error happens when registering an H2D grid \"%s\" through the API \"%s\": some values of the parameter \"center_lat\" are not between \"min_lat\" (%lf) and \"max_lat\" (%lf). Please check the model code related to the annotation \"%s\".", grid_name, API_label, min_lat_value, max_lat_value, annotation);
+        EXECUTION_REPORT(REPORT_ERROR, comp_id, are_array_values_between_boundaries(data_type, (double*) vertex_lat, size_vertex_lat, min_lat_value, max_lat_value, (double) NULL_COORD_VALUE, true), "Error happens when registering an H2D grid \"%s\" through the API \"%s\": some values of the parameter \"vertex_lat\" are not between \"min_lat\" (%lf) and \"max_lat\" (%lf). Please check the model code related to the annotation \"%s\".", grid_name, API_label, min_lat_value, max_lat_value, annotation);
+    }
 }
 
 
 int Original_grid_mgt::register_H2D_grid_via_local_data(int comp_id, const char *grid_name, const char *edge_type, const char *coord_unit, char *cyclic_or_acyclic, const char *data_type, int grid_size, int num_local_cells, int size_local_cells_global_index, int size_center_lon, int size_center_lat, 
-	                                               int size_mask, int size_area, int size_vertex_lon, int size_vertex_lat, int *local_cells_global_index, char *min_lon, char *max_lon, char *min_lat, char *max_lat, char *center_lon, char *center_lat, int *mask, char *area, char *vertex_lon, char *vertex_lat, const char *decomp_name, int *decomp_id, const char *annotation, int API_id)
+                                                   int size_mask, int size_area, int size_vertex_lon, int size_vertex_lat, int *local_cells_global_index, char *min_lon, char *max_lon, char *min_lat, char *max_lat, char *center_lon, char *center_lat, int *mask, char *area, char *vertex_lon, char *vertex_lat, const char *decomp_name, int *decomp_id, const char *annotation, int API_id)
 {
-	int data_type_size;
-	MPI_Comm comm = comp_comm_group_mgt_mgr->get_comm_group_of_local_comp(comp_id,"in register_h2d_grid_with_data");
-	char API_label[NAME_STR_SIZE], hint[NAME_STR_SIZE];
-	int global_center_lon_size, global_center_lat_size, global_area_size, global_mask_size, global_vertex_lon_size, global_vertex_lat_size;
-	
-
-
-	get_API_hint(comp_id, API_id, API_label);
-	sprintf(hint, "registering an H2D grid \"%s\"", grid_name);
-
-	EXECUTION_REPORT(REPORT_ERROR, comp_id, num_local_cells >= 0, "Error happens when calling the API \"%s\" to register an H2D grid \"%s\": the specified number (%d) of local grid cells is wrong (smaller than 0). Please check the model code related to \"%s\"", API_label, grid_name, num_local_cells, annotation);
-	EXECUTION_REPORT(REPORT_ERROR, comp_id, num_local_cells <= size_local_cells_global_index, "Error happens when calling the API \"%s\" to register an H2D grid \"%s\": the array size (currently is %d) of \"local_cells_global_index\" is smaller than \"num_local_cells\" (currently is %d). Please check the model code related to \"%s\"", API_label, grid_name, num_local_cells, size_local_cells_global_index, annotation);
-	EXECUTION_REPORT(REPORT_ERROR, comp_id, *decomp_id == 0 && strlen(decomp_name) > 0 || *decomp_id == -1 && strlen(decomp_name) == 0, "Error happens when calling the API \"%s\" to register an H2D grid \"%s\": parameters \"decomp_name\" and \"decomp_id\" are not speicified/unspecified at the same time. Please check the model code related to the annotation \"%s\"", API_label, grid_name, annotation);
-	
-	common_checking_for_H2D_registration_via_data(comp_id, grid_name, edge_type, coord_unit, cyclic_or_acyclic, data_type, size_mask, size_center_lon, size_center_lat, 
-		                                          size_vertex_lon, size_vertex_lat, mask, min_lon, max_lon, min_lat, max_lat, center_lon, center_lat, vertex_lon, vertex_lat, annotation, API_id);
-
-	EXECUTION_REPORT(REPORT_ERROR, comp_id, grid_size > 0, "Error happens when calling the API \"%s\" to register an H2D grid \"%s\": the \"grid_size\" (currently is %d) is too small (smaller than 1). Please check the model code related to \"%s\"", API_label, grid_name, grid_size, annotation);
-	check_API_parameter_int(comp_id, API_id, comm, NULL, grid_size, "\"grid_size\"", annotation);
-	for (int i = 0; i < num_local_cells; i ++)
-		EXECUTION_REPORT(REPORT_ERROR, comp_id, local_cells_global_index[i] >= 1 && local_cells_global_index[i] <= grid_size, "Error happens when calling the API \"%s\" to register an H2D grid \"%s\": some values in \"local_cells_global_index\" (for example, %d) are out of bound (smaller than 1 or larger than \"grid_size\" (%d)). Please check the model code related to the annotation \"%s\".", API_label, grid_name, local_cells_global_index[i], grid_size, annotation);
-
-	data_type_size = get_data_type_size(data_type);
-	char *global_center_lon = check_and_aggregate_local_grid_data(comp_id, API_id, comm, hint, grid_size, size_center_lon, data_type_size, (char*) center_lon, "center_lon", num_local_cells, local_cells_global_index, global_center_lon_size, annotation);
-	char *global_center_lat = check_and_aggregate_local_grid_data(comp_id, API_id, comm, hint, grid_size, size_center_lat, data_type_size, (char*) center_lat, "center_lat", num_local_cells, local_cells_global_index, global_center_lat_size, annotation);
-	char *global_area = check_and_aggregate_local_grid_data(comp_id, API_id, comm, hint, grid_size, size_area, data_type_size, (char*) area, "area", num_local_cells, local_cells_global_index, global_area_size, annotation);
-	char *global_vertex_lon = check_and_aggregate_local_grid_data(comp_id, API_id, comm, hint, grid_size, size_vertex_lon, data_type_size, (char*) vertex_lon, "vertex_lon", num_local_cells, local_cells_global_index, global_vertex_lon_size, annotation);
-	char *global_vertex_lat = check_and_aggregate_local_grid_data(comp_id, API_id, comm, hint, grid_size, size_vertex_lat, data_type_size, (char*) vertex_lat, "vertex_lat", num_local_cells, local_cells_global_index, global_vertex_lat_size, annotation);
-	EXECUTION_REPORT(REPORT_ERROR, comp_id, global_vertex_lon_size == global_vertex_lat_size, "Error happens when calling the API \"%s\" to register an H2D grid \"%s\": \"vertex_lon\" or \"vertex_lat\" are not consistent with each other (not specified/unspecified at the same time or have different array sizes (%d and %d respectively)). Please check the model code related to the annotation \"%s\".", API_label, grid_name, global_vertex_lon_size, global_vertex_lat_size, annotation);
-
-	int *global_mask = (int*) check_and_aggregate_local_grid_data(comp_id, API_id, comm, hint, grid_size, size_mask, sizeof(int), (char*) mask, "mask", num_local_cells, local_cells_global_index, global_mask_size, annotation);
-	if (global_mask == NULL) {
-		int *active_mask = NULL;
-		if (num_local_cells > 0) {
-			active_mask = new int [num_local_cells];
-			for (int i = 0; i < num_local_cells; i ++)
-				active_mask[i] = 1;
-		}
-		global_mask = (int*) check_and_aggregate_local_grid_data(comp_id, API_id, comm, hint, grid_size, num_local_cells, sizeof(int), (char*) active_mask, "mask", num_local_cells, local_cells_global_index, global_mask_size, annotation);
-		if (active_mask != NULL)
-			delete [] active_mask;
-	}
-	
-	int grid_id = create_H2D_grid_from_global_data(comp_id, grid_name, coord_unit, cyclic_or_acyclic, data_type, grid_size, 0, global_vertex_lon_size/grid_size, global_center_lon_size, global_center_lat_size, 
-	                                               global_mask_size, global_area_size, global_vertex_lon_size, global_vertex_lat_size, min_lon, max_lon, min_lat, max_lat, global_center_lon, global_center_lat, global_mask, global_area, global_vertex_lon, global_vertex_lat, annotation);
-	
-	if (strlen(decomp_name) != 0)
-		*decomp_id = decomps_info_mgr->register_H2D_parallel_decomposition(decomp_name, grid_id, num_local_cells, local_cells_global_index, annotation);
-
-	return grid_id;
+    int data_type_size;
+    MPI_Comm comm = comp_comm_group_mgt_mgr->get_comm_group_of_local_comp(comp_id,"in register_h2d_grid_with_data");
+    char API_label[NAME_STR_SIZE], hint[NAME_STR_SIZE];
+    int global_center_lon_size, global_center_lat_size, global_area_size, global_mask_size, global_vertex_lon_size, global_vertex_lat_size;
+    
+
+
+    get_API_hint(comp_id, API_id, API_label);
+    sprintf(hint, "registering an H2D grid \"%s\"", grid_name);
+
+    EXECUTION_REPORT(REPORT_ERROR, comp_id, num_local_cells >= 0, "Error happens when calling the API \"%s\" to register an H2D grid \"%s\": the specified number (%d) of local grid cells is wrong (smaller than 0). Please check the model code related to \"%s\"", API_label, grid_name, num_local_cells, annotation);
+    EXECUTION_REPORT(REPORT_ERROR, comp_id, num_local_cells <= size_local_cells_global_index, "Error happens when calling the API \"%s\" to register an H2D grid \"%s\": the array size (currently is %d) of \"local_cells_global_index\" is smaller than \"num_local_cells\" (currently is %d). Please check the model code related to \"%s\"", API_label, grid_name, num_local_cells, size_local_cells_global_index, annotation);
+    EXECUTION_REPORT(REPORT_ERROR, comp_id, *decomp_id == 0 && strlen(decomp_name) > 0 || *decomp_id == -1 && strlen(decomp_name) == 0, "Error happens when calling the API \"%s\" to register an H2D grid \"%s\": parameters \"decomp_name\" and \"decomp_id\" are not speicified/unspecified at the same time. Please check the model code related to the annotation \"%s\"", API_label, grid_name, annotation);
+    
+    common_checking_for_H2D_registration_via_data(comp_id, grid_name, edge_type, coord_unit, cyclic_or_acyclic, data_type, size_mask, size_center_lon, size_center_lat, 
+                                                  size_vertex_lon, size_vertex_lat, mask, min_lon, max_lon, min_lat, max_lat, center_lon, center_lat, vertex_lon, vertex_lat, annotation, API_id);
+
+    EXECUTION_REPORT(REPORT_ERROR, comp_id, grid_size > 0, "Error happens when calling the API \"%s\" to register an H2D grid \"%s\": the \"grid_size\" (currently is %d) is too small (smaller than 1). Please check the model code related to \"%s\"", API_label, grid_name, grid_size, annotation);
+    check_API_parameter_int(comp_id, API_id, comm, NULL, grid_size, "\"grid_size\"", annotation);
+    for (int i = 0; i < num_local_cells; i ++)
+        EXECUTION_REPORT(REPORT_ERROR, comp_id, local_cells_global_index[i] >= 1 && local_cells_global_index[i] <= grid_size, "Error happens when calling the API \"%s\" to register an H2D grid \"%s\": some values in \"local_cells_global_index\" (for example, %d) are out of bound (smaller than 1 or larger than \"grid_size\" (%d)). Please check the model code related to the annotation \"%s\".", API_label, grid_name, local_cells_global_index[i], grid_size, annotation);
+
+    data_type_size = get_data_type_size(data_type);
+    char *global_center_lon = check_and_aggregate_local_grid_data(comp_id, API_id, comm, hint, grid_size, size_center_lon, data_type_size, (char*) center_lon, "center_lon", num_local_cells, local_cells_global_index, global_center_lon_size, annotation);
+    char *global_center_lat = check_and_aggregate_local_grid_data(comp_id, API_id, comm, hint, grid_size, size_center_lat, data_type_size, (char*) center_lat, "center_lat", num_local_cells, local_cells_global_index, global_center_lat_size, annotation);
+    char *global_area = check_and_aggregate_local_grid_data(comp_id, API_id, comm, hint, grid_size, size_area, data_type_size, (char*) area, "area", num_local_cells, local_cells_global_index, global_area_size, annotation);
+    char *global_vertex_lon = check_and_aggregate_local_grid_data(comp_id, API_id, comm, hint, grid_size, size_vertex_lon, data_type_size, (char*) vertex_lon, "vertex_lon", num_local_cells, local_cells_global_index, global_vertex_lon_size, annotation);
+    char *global_vertex_lat = check_and_aggregate_local_grid_data(comp_id, API_id, comm, hint, grid_size, size_vertex_lat, data_type_size, (char*) vertex_lat, "vertex_lat", num_local_cells, local_cells_global_index, global_vertex_lat_size, annotation);
+    EXECUTION_REPORT(REPORT_ERROR, comp_id, global_vertex_lon_size == global_vertex_lat_size, "Error happens when calling the API \"%s\" to register an H2D grid \"%s\": \"vertex_lon\" or \"vertex_lat\" are not consistent with each other (not specified/unspecified at the same time or have different array sizes (%d and %d respectively)). Please check the model code related to the annotation \"%s\".", API_label, grid_name, global_vertex_lon_size, global_vertex_lat_size, annotation);
+
+    int *global_mask = (int*) check_and_aggregate_local_grid_data(comp_id, API_id, comm, hint, grid_size, size_mask, sizeof(int), (char*) mask, "mask", num_local_cells, local_cells_global_index, global_mask_size, annotation);
+    if (global_mask == NULL) {
+        int *active_mask = NULL;
+        if (num_local_cells > 0) {
+            active_mask = new int [num_local_cells];
+            for (int i = 0; i < num_local_cells; i ++)
+                active_mask[i] = 1;
+        }
+        global_mask = (int*) check_and_aggregate_local_grid_data(comp_id, API_id, comm, hint, grid_size, num_local_cells, sizeof(int), (char*) active_mask, "mask", num_local_cells, local_cells_global_index, global_mask_size, annotation);
+        if (active_mask != NULL)
+            delete [] active_mask;
+    }
+    
+    int grid_id = create_H2D_grid_from_global_data(comp_id, grid_name, coord_unit, cyclic_or_acyclic, data_type, grid_size, 0, global_vertex_lon_size/grid_size, global_center_lon_size, global_center_lat_size, 
+                                                   global_mask_size, global_area_size, global_vertex_lon_size, global_vertex_lat_size, min_lon, max_lon, min_lat, max_lat, global_center_lon, global_center_lat, global_mask, global_area, global_vertex_lon, global_vertex_lat, annotation);
+    
+    if (strlen(decomp_name) != 0)
+        *decomp_id = decomps_info_mgr->register_H2D_parallel_decomposition(decomp_name, grid_id, num_local_cells, local_cells_global_index, annotation);
+
+    return grid_id;
 }
 
 
 int Original_grid_mgt::create_H2D_grid_from_global_data(int comp_id, const char *grid_name, const char *coord_unit, const char *cyclic_or_acyclic, const char *data_type, int dim_size1, int dim_size2, int num_vertex, int size_center_lon,
-	                                               int size_center_lat, int size_mask, int size_area, int size_vertex_lon, int size_vertex_lat, char *min_lon, char *max_lon, char *min_lat, char *max_lat, char *center_lon, char *center_lat, int *mask, char *area, char *vertex_lon, char *vertex_lat, const char *annotation)
+                                                   int size_center_lat, int size_mask, int size_area, int size_vertex_lon, int size_vertex_lat, char *min_lon, char *max_lon, char *min_lat, char *max_lat, char *center_lon, char *center_lat, int *mask, char *area, char *vertex_lon, char *vertex_lat, const char *annotation)
 {
-	char true_H2D_grid_name[NAME_STR_SIZE], true_lon_grid_name[NAME_STR_SIZE], true_lat_grid_name[NAME_STR_SIZE];
-	Remap_grid_class *CoR_H2D_grid, *CoR_lon_grid, *CoR_lat_grid, *sub_grids[256];
-	int grid_size = dim_size2 == 0? dim_size1 : dim_size1*dim_size2;
-	double min_lon_value, max_lon_value, min_lat_value, max_lat_value;
-
-
-	sprintf(true_H2D_grid_name, "%s@%s", grid_name, comp_comm_group_mgt_mgr->get_global_node_of_local_comp(comp_id, false, annotation)->get_full_name());
-	sprintf(true_lon_grid_name, "lon_%s", true_H2D_grid_name);
-	sprintf(true_lat_grid_name, "lat_%s", true_H2D_grid_name);
-	if (dim_size2 == 0) {
-		CoR_lon_grid = new Remap_grid_class(true_lon_grid_name, "lon", coord_unit, cyclic_or_acyclic, 0);
-		CoR_lat_grid = new Remap_grid_class(true_lat_grid_name, "lat", coord_unit, cyclic_or_acyclic, 0);
-	}
-	else {
-		CoR_lon_grid = new Remap_grid_class(true_lon_grid_name, "lon", coord_unit, cyclic_or_acyclic, dim_size1);
-		CoR_lat_grid = new Remap_grid_class(true_lat_grid_name, "lat", coord_unit, cyclic_or_acyclic, dim_size2);		
-	}
-	sub_grids[0] = CoR_lon_grid;
-	sub_grids[1] = CoR_lat_grid;
-	CoR_H2D_grid = new Remap_grid_class(true_H2D_grid_name, 2, sub_grids, grid_size);
-	if (size_mask > 0)
-		CoR_H2D_grid->read_grid_data_from_array("mask", "mask", DATA_TYPE_INT, (const char*)mask, 0);
-	else {
-		int *tmp_mask = new int [CoR_H2D_grid->get_grid_size()];
-		for (int i = 0; i < CoR_H2D_grid->get_grid_size(); i ++)
-			tmp_mask[i] = 1;
-		CoR_H2D_grid->read_grid_data_from_array("mask", "mask", DATA_TYPE_INT, (const char*)tmp_mask, 0);
-		delete [] tmp_mask;
-	}
-	if (size_area > 0)
-		CoR_H2D_grid->read_grid_data_from_array("area", "area", data_type, (const char*)area, 0);	
-	if (size_center_lon == grid_size) {
-		CoR_H2D_grid->read_grid_data_from_array("center", COORD_LABEL_LON, data_type, (const char*)center_lon, 0);
-		CoR_H2D_grid->read_grid_data_from_array("center", COORD_LABEL_LAT, data_type, (const char*)center_lat, 0);
-		if (size_vertex_lon >0) {
-			CoR_H2D_grid->read_grid_data_from_array("vertex", COORD_LABEL_LON, data_type, (const char*)vertex_lon, num_vertex);
-			CoR_H2D_grid->read_grid_data_from_array("vertex", COORD_LABEL_LAT, data_type, (const char*)vertex_lat, num_vertex);		
-		}
-	}
-	else {
-		CoR_lon_grid->read_grid_data_from_array("center", COORD_LABEL_LON, data_type, (const char*)center_lon, 0);
-		CoR_lat_grid->read_grid_data_from_array("center", COORD_LABEL_LAT, data_type, (const char*)center_lat, 0);		
-		if (size_vertex_lon > 0) {
-			CoR_lon_grid->read_grid_data_from_array("vertex", COORD_LABEL_LON, data_type, (const char*)vertex_lon, num_vertex);
-			CoR_lat_grid->read_grid_data_from_array("vertex", COORD_LABEL_LAT, data_type, (const char*)vertex_lat, num_vertex);		
-		}
-	}
-
-	transform_datatype_of_arrays(min_lon, (char*)(&min_lon_value), data_type, DATA_TYPE_DOUBLE, 1);
-	transform_datatype_of_arrays(max_lon, (char*)(&max_lon_value), data_type, DATA_TYPE_DOUBLE, 1);
-	transform_datatype_of_arrays(min_lat, (char*)(&min_lat_value), data_type, DATA_TYPE_DOUBLE, 1);
-	transform_datatype_of_arrays(max_lat, (char*)(&max_lat_value), data_type, DATA_TYPE_DOUBLE, 1);
-	if (words_are_the_same(coord_unit,COORD_UNIT_RADIANS)) {
-		min_lon_value = min_lon_value*180/PI;
-		max_lon_value = max_lon_value*180/PI;
-		min_lat_value = min_lat_value*180/PI;
-		max_lat_value = max_lat_value*180/PI;
-	}
-	if (words_are_the_same(cyclic_or_acyclic, "cyclic")) {
-		min_lon_value = 0.0;
-		max_lon_value = 360.0;
-	}
-	CoR_H2D_grid->set_grid_boundary(min_lon_value, max_lon_value, min_lat_value, max_lat_value);
-	
-	remap_grid_manager->add_remap_grid(CoR_lon_grid);
-	remap_grid_manager->add_remap_grid(CoR_lat_grid);
-	remap_grid_manager->add_remap_grid(CoR_H2D_grid);
-	CoR_H2D_grid->end_grid_definition_stage(NULL);
-	original_grids.push_back(new Original_grid_info(comp_id, original_grids.size()|TYPE_GRID_LOCAL_ID_PREFIX, grid_name, annotation, CoR_H2D_grid, true));
+    char true_H2D_grid_name[NAME_STR_SIZE], true_lon_grid_name[NAME_STR_SIZE], true_lat_grid_name[NAME_STR_SIZE];
+    Remap_grid_class *CoR_H2D_grid, *CoR_lon_grid, *CoR_lat_grid, *sub_grids[256];
+    int grid_size = dim_size2 == 0? dim_size1 : dim_size1*dim_size2;
+    double min_lon_value, max_lon_value, min_lat_value, max_lat_value;
+
+
+    sprintf(true_H2D_grid_name, "%s@%s", grid_name, comp_comm_group_mgt_mgr->get_global_node_of_local_comp(comp_id, false, annotation)->get_full_name());
+    sprintf(true_lon_grid_name, "lon_%s", true_H2D_grid_name);
+    sprintf(true_lat_grid_name, "lat_%s", true_H2D_grid_name);
+    if (dim_size2 == 0) {
+        CoR_lon_grid = new Remap_grid_class(true_lon_grid_name, "lon", coord_unit, cyclic_or_acyclic, 0);
+        CoR_lat_grid = new Remap_grid_class(true_lat_grid_name, "lat", coord_unit, cyclic_or_acyclic, 0);
+    }
+    else {
+        CoR_lon_grid = new Remap_grid_class(true_lon_grid_name, "lon", coord_unit, cyclic_or_acyclic, dim_size1);
+        CoR_lat_grid = new Remap_grid_class(true_lat_grid_name, "lat", coord_unit, cyclic_or_acyclic, dim_size2);        
+    }
+    sub_grids[0] = CoR_lon_grid;
+    sub_grids[1] = CoR_lat_grid;
+    CoR_H2D_grid = new Remap_grid_class(true_H2D_grid_name, 2, sub_grids, grid_size);
+    if (size_mask > 0)
+        CoR_H2D_grid->read_grid_data_from_array("mask", "mask", DATA_TYPE_INT, (const char*)mask, 0);
+    else {
+        int *tmp_mask = new int [CoR_H2D_grid->get_grid_size()];
+        for (int i = 0; i < CoR_H2D_grid->get_grid_size(); i ++)
+            tmp_mask[i] = 1;
+        CoR_H2D_grid->read_grid_data_from_array("mask", "mask", DATA_TYPE_INT, (const char*)tmp_mask, 0);
+        delete [] tmp_mask;
+    }
+    if (size_area > 0)
+        CoR_H2D_grid->read_grid_data_from_array("area", "area", data_type, (const char*)area, 0);    
+    if (size_center_lon == grid_size) {
+        CoR_H2D_grid->read_grid_data_from_array("center", COORD_LABEL_LON, data_type, (const char*)center_lon, 0);
+        CoR_H2D_grid->read_grid_data_from_array("center", COORD_LABEL_LAT, data_type, (const char*)center_lat, 0);
+        if (size_vertex_lon >0) {
+            CoR_H2D_grid->read_grid_data_from_array("vertex", COORD_LABEL_LON, data_type, (const char*)vertex_lon, num_vertex);
+            CoR_H2D_grid->read_grid_data_from_array("vertex", COORD_LABEL_LAT, data_type, (const char*)vertex_lat, num_vertex);        
+        }
+    }
+    else {
+        CoR_lon_grid->read_grid_data_from_array("center", COORD_LABEL_LON, data_type, (const char*)center_lon, 0);
+        CoR_lat_grid->read_grid_data_from_array("center", COORD_LABEL_LAT, data_type, (const char*)center_lat, 0);        
+        if (size_vertex_lon > 0) {
+            CoR_lon_grid->read_grid_data_from_array("vertex", COORD_LABEL_LON, data_type, (const char*)vertex_lon, num_vertex);
+            CoR_lat_grid->read_grid_data_from_array("vertex", COORD_LABEL_LAT, data_type, (const char*)vertex_lat, num_vertex);        
+        }
+    }
+
+    transform_datatype_of_arrays(min_lon, (char*)(&min_lon_value), data_type, DATA_TYPE_DOUBLE, 1);
+    transform_datatype_of_arrays(max_lon, (char*)(&max_lon_value), data_type, DATA_TYPE_DOUBLE, 1);
+    transform_datatype_of_arrays(min_lat, (char*)(&min_lat_value), data_type, DATA_TYPE_DOUBLE, 1);
+    transform_datatype_of_arrays(max_lat, (char*)(&max_lat_value), data_type, DATA_TYPE_DOUBLE, 1);
+    if (words_are_the_same(coord_unit,COORD_UNIT_RADIANS)) {
+        min_lon_value = min_lon_value*180/PI;
+        max_lon_value = max_lon_value*180/PI;
+        min_lat_value = min_lat_value*180/PI;
+        max_lat_value = max_lat_value*180/PI;
+    }
+    if (words_are_the_same(cyclic_or_acyclic, "cyclic")) {
+        min_lon_value = 0.0;
+        max_lon_value = 360.0;
+    }
+    
+    remap_grid_manager->add_remap_grid(CoR_lon_grid);
+    remap_grid_manager->add_remap_grid(CoR_lat_grid);
+    remap_grid_manager->add_remap_grid(CoR_H2D_grid);
+    CoR_H2D_grid->set_grid_boundary(min_lon_value, max_lon_value, min_lat_value, max_lat_value);
+    original_grids.push_back(new Original_grid_info(comp_id, original_grids.size()|TYPE_GRID_LOCAL_ID_PREFIX, grid_name, annotation, CoR_H2D_grid, true));
+    CoR_H2D_grid->end_grid_definition_stage(NULL);
 	
-	return original_grids[original_grids.size()-1]->get_grid_id();
+    return original_grids[original_grids.size()-1]->get_grid_id();
 }
 
 
 int Original_grid_mgt::register_H2D_grid_via_global_data(int comp_id, const char *grid_name, const char *edge_type, const char *coord_unit, char *cyclic_or_acyclic, const char *data_type, int dim_size1, int dim_size2, int size_center_lon, int size_center_lat, 
-	                                               int size_mask, int size_area, int size_vertex_lon, int size_vertex_lat, char *min_lon, char *max_lon, char *min_lat, char *max_lat, char *center_lon, char *center_lat, int *mask, char *area, char *vertex_lon, char *vertex_lat, const char *annotation, int API_id)
+                                                   int size_mask, int size_area, int size_vertex_lon, int size_vertex_lat, char *min_lon, char *max_lon, char *min_lat, char *max_lat, char *center_lon, char *center_lat, int *mask, char *area, char *vertex_lon, char *vertex_lat, const char *annotation, int API_id)
 {
-	int data_type_size, grid_size, num_vertex;
-	char true_H2D_grid_name[NAME_STR_SIZE], true_lon_grid_name[NAME_STR_SIZE], true_lat_grid_name[NAME_STR_SIZE];
-	char coord_label[NAME_STR_SIZE], coord_name[NAME_STR_SIZE], API_label[NAME_STR_SIZE], hint[NAME_STR_SIZE];
-	Remap_grid_class *CoR_H2D_grid, *CoR_lon_grid, *CoR_lat_grid, *sub_grids[256];
-	
-
-	get_API_hint(comp_id, API_id, API_label);
-	sprintf(hint, "registering an H2D grid \"%s\"", grid_name);
-	
-	common_checking_for_H2D_registration_via_data(comp_id, grid_name, edge_type, coord_unit, cyclic_or_acyclic, data_type, size_mask, size_center_lon, size_center_lat, 
-		                                          size_vertex_lon, size_vertex_lat, mask, min_lon, max_lon, min_lat, max_lat, center_lon, center_lat, vertex_lon, vertex_lat, annotation, API_id);
-	
-	data_type_size = get_data_type_size(data_type);
-	check_API_parameter_data_array(comp_id, API_id, comp_comm_group_mgt_mgr->get_comm_group_of_local_comp(comp_id,"in register_h2d_grid_with_data"), hint, size_center_lon, data_type_size, (const char*)center_lon, "center_lon", annotation);
-	check_API_parameter_data_array(comp_id, API_id, comp_comm_group_mgt_mgr->get_comm_group_of_local_comp(comp_id,"in register_h2d_grid_with_data"), hint, size_center_lat, data_type_size, (const char*)center_lat, "center_lat", annotation);
-	check_API_parameter_data_array(comp_id, API_id, comp_comm_group_mgt_mgr->get_comm_group_of_local_comp(comp_id,"in register_h2d_grid_with_data"), hint, size_mask, sizeof(int), (const char*)mask, "mask", annotation);
-	check_API_parameter_data_array(comp_id, API_id, comp_comm_group_mgt_mgr->get_comm_group_of_local_comp(comp_id,"in register_h2d_grid_with_data"), hint, size_area, data_type_size, (const char*)area, "area", annotation);
-	check_API_parameter_data_array(comp_id, API_id, comp_comm_group_mgt_mgr->get_comm_group_of_local_comp(comp_id,"in register_h2d_grid_with_data"), hint, size_vertex_lon, data_type_size, (const char*)vertex_lon, "vertex_lon", annotation);
-	check_API_parameter_data_array(comp_id, API_id, comp_comm_group_mgt_mgr->get_comm_group_of_local_comp(comp_id,"in register_h2d_grid_with_data"), hint, size_vertex_lat, data_type_size, (const char*)vertex_lat, "vertex_lat", annotation);
-	check_API_parameter_int(comp_id, API_id, comp_comm_group_mgt_mgr->get_comm_group_of_local_comp(comp_id,"in register_h2d_grid_with_data"), NULL, dim_size1, "dim_size1", annotation);
-	check_API_parameter_int(comp_id, API_id, comp_comm_group_mgt_mgr->get_comm_group_of_local_comp(comp_id,"in register_h2d_grid_with_data"), NULL, dim_size2, "dim_size2", annotation);
-	EXECUTION_REPORT(REPORT_ERROR, comp_id, dim_size1 > 3, "Error happens when registering an H2D grid \"%s\" through the API \"%s\": the value (currently is %d) of the parameter \"dim_size1\" is wrong. It must be larger than 3. Please check the model code related to the annotation \"%s\".", grid_name, API_label, dim_size1, annotation);
-	EXECUTION_REPORT(REPORT_ERROR, comp_id, dim_size2 == 0 || dim_size2 > 3, "Error happens when registering an H2D grid \"%s\" through the API \"%s\": the value (currently is %d) of the parameter \"dim_size2\" is wrong. It must be 0 or a positive value larger than 3. Please check the model code related to the annotation \"%s\".", grid_name, API_label, dim_size2, annotation);
-	if (dim_size2 == 0) {
-		grid_size = dim_size1;
-		EXECUTION_REPORT(REPORT_ERROR, comp_id, size_center_lon == grid_size, "Error happens when registering an H2D grid \"%s\" through the API \"%s\": the array size (currently is %d) of \"center_lon\" is different from the grid size that is determined by \"dim_size1\" (currently is %d). Please check the model code related to the annotation \"%s\".", grid_name, API_label, size_center_lon, grid_size, annotation);
-		EXECUTION_REPORT(REPORT_ERROR, comp_id, size_center_lat == grid_size, "Error happens when registering an H2D grid \"%s\" through the API \"%s\": the array size (currently is %d) of \"center_lat\" is different from the grid size that is determined by \"dim_size1\" (currently is %d). Please check the model code related to the annotation \"%s\".", grid_name, API_label, size_center_lat, grid_size, annotation);
-	}
-	else {
-		grid_size = (dim_size1)*(dim_size2);
-		if (size_center_lon == dim_size1)
-			EXECUTION_REPORT(REPORT_ERROR, comp_id, size_center_lat == dim_size2, "Error happens when registering an H2D grid \"%s\" through the API \"%s\": the array size (currently is %d) of \"center_lat\" is different from \"dim_size2\" (currently is %d). Please check the model code related to the annotation \"%s\".", grid_name, API_label, size_center_lat, dim_size2, annotation);
-		else {			
-			EXECUTION_REPORT(REPORT_ERROR, comp_id, size_center_lon == grid_size, "Error happens when registering an H2D grid \"%s\" through the API \"%s\": the array size (currently is %d) of \"center_lon\" is different from \"dim_size1\" (currently is %d) and the grid size (currently is %d) that is determined by the product of \"dim_size1\" and \"dim_size2\". Please check the model code related to the annotation \"%s\".", grid_name, API_label, size_center_lon, dim_size1, grid_size, annotation);
-			EXECUTION_REPORT(REPORT_ERROR, comp_id, size_center_lat == grid_size, "Error happens when registering an H2D grid \"%s\" through the API \"%s\": the array size (currently is %d) of \"center_lat\" is different from the grid size (currently is %d) that is determined by the product of \"dim_size1\" and \"dim_size2\" (the array size of \"center_lon\" is the same as the grid size). Please check the model code related to the annotation \"%s\".", grid_name, API_label, size_center_lat, grid_size, annotation);
-		}	
-	}
-	if (size_mask > 0)		
-		EXECUTION_REPORT(REPORT_ERROR, comp_id, size_mask == grid_size, "Error happens when registering an H2D grid \"%s\" through the API \"%s\": the array size (currently is %d) of \"mask\" is different from the grid size (currently is %d). Please check the model code related to the annotation \"%s\".", grid_name, API_label, size_mask, grid_size, annotation);
-	if (size_area > 0)		
-		EXECUTION_REPORT(REPORT_ERROR, comp_id, size_area == grid_size, "Error happens when registering an H2D grid \"%s\" through the API \"%s\": the array size (currently is %d) of \"area\" is different from the grid size (currently is %d). Please check the model code related to the annotation \"%s\".", grid_name, API_label, size_area, grid_size, annotation);
-	EXECUTION_REPORT(REPORT_ERROR, comp_id, (size_vertex_lon == -1 && size_vertex_lat == -1) || (size_vertex_lon > 0 && size_vertex_lat > 0), "Error happens when registering an H2D grid \"%s\" through the API \"%s\": the optional parameters \"vertex_lon\" and \"vertex_lat\" are not set/unset at the same time. Please check the model code related to the annotation \"%s\".", grid_name, API_label, annotation);
-	if (size_vertex_lon > 0) {
-		EXECUTION_REPORT(REPORT_ERROR, comp_id, (size_vertex_lon) % (size_center_lon) == 0, "Error happens when registering an H2D grid \"%s\" through the API \"%s\": the array size of \"vertex_lon\" (currently is %d) is not an integral multiple of the array size (currently is %d) of \"center_lon\". Please check the model code related to the annotation \"%s\".", grid_name, API_label, size_vertex_lon, size_center_lon, annotation);
-		EXECUTION_REPORT(REPORT_ERROR, comp_id, (size_vertex_lat) % (size_center_lat) == 0, "Error happens when registering an H2D grid \"%s\" through the API \"%s\": the array size of \"vertex_lat\" (currently is %d) is not an integral multiple of the array size (currently is %d) of \"center_lat\". Please check the model code related to the annotation \"%s\".", grid_name, API_label, size_vertex_lat, size_center_lat, annotation);
-		int num_vertex_lon = (size_vertex_lon) / (size_center_lon);
-		int num_vertex_lat = (size_vertex_lat) / (size_center_lat);
-		EXECUTION_REPORT(REPORT_ERROR, comp_id, num_vertex_lon == num_vertex_lat, "Error happens when registering an H2D grid \"%s\" through the API \"%s\": the numbers of vertexes determined by \"vertex_lon\" (currently is %d) and \"vertex_lat\" (currently is %d) respectively are not the same. Please check the model code related to the annotation \"%s\".", grid_name, API_label, num_vertex_lon, num_vertex_lat, annotation);
-		EXECUTION_REPORT(REPORT_ERROR, comp_id, size_vertex_lon > grid_size && size_vertex_lat > grid_size || size_vertex_lon < grid_size && size_vertex_lat < grid_size, "Error happens when registering an H2D grid \"%s\" through the API \"%s\": the array sizes of \"vertex_lon\" and \"vertex_lat\" (currently are %d and %d respectively) are not bigger/smaller than the grid size at the same time. Please check the model code related to the annotation \"%s\".", grid_name, API_label, size_vertex_lon, size_vertex_lat, annotation);
-		if (size_center_lon == grid_size) 
-			EXECUTION_REPORT(REPORT_ERROR, comp_id, num_vertex_lon >= 3, "Error happens when registering an H2D grid \"%s\" through the API \"%s\": the number of vertexes (currently is %d) is wrong as it is smaller than 3. Please check the model code related to the annotation \"%s\".", grid_name, API_label, num_vertex_lon, annotation);
-		else EXECUTION_REPORT(REPORT_ERROR, comp_id ,num_vertex_lon == 2, "Error happens when registering an H2D grid \"%s\" through the API \"%s\": the number of vertexes (currently is %d) is wrong as it is not 2. Please check the model code related to the annotation \"%s\".", grid_name, API_label, num_vertex_lon, annotation);
-		num_vertex = num_vertex_lon;
-	}
-
-	return create_H2D_grid_from_global_data(comp_id, grid_name, coord_unit, cyclic_or_acyclic, data_type, dim_size1, dim_size2, num_vertex, size_center_lon, size_center_lat, 
-	                                        size_mask, size_area, size_vertex_lon, size_vertex_lat, min_lon, max_lon, min_lat, max_lat, center_lon, center_lat, mask, area, vertex_lon, vertex_lat, annotation);
+    int data_type_size, grid_size, num_vertex;
+    char true_H2D_grid_name[NAME_STR_SIZE], true_lon_grid_name[NAME_STR_SIZE], true_lat_grid_name[NAME_STR_SIZE];
+    char coord_label[NAME_STR_SIZE], coord_name[NAME_STR_SIZE], API_label[NAME_STR_SIZE], hint[NAME_STR_SIZE];
+    Remap_grid_class *CoR_H2D_grid, *CoR_lon_grid, *CoR_lat_grid, *sub_grids[256];
+    
+
+    get_API_hint(comp_id, API_id, API_label);
+    sprintf(hint, "registering an H2D grid \"%s\"", grid_name);
+    
+    common_checking_for_H2D_registration_via_data(comp_id, grid_name, edge_type, coord_unit, cyclic_or_acyclic, data_type, size_mask, size_center_lon, size_center_lat, 
+                                                  size_vertex_lon, size_vertex_lat, mask, min_lon, max_lon, min_lat, max_lat, center_lon, center_lat, vertex_lon, vertex_lat, annotation, API_id);
+    
+    data_type_size = get_data_type_size(data_type);
+    check_API_parameter_data_array(comp_id, API_id, comp_comm_group_mgt_mgr->get_comm_group_of_local_comp(comp_id,"in register_h2d_grid_with_data"), hint, size_center_lon, data_type_size, (const char*)center_lon, "center_lon", annotation);
+    check_API_parameter_data_array(comp_id, API_id, comp_comm_group_mgt_mgr->get_comm_group_of_local_comp(comp_id,"in register_h2d_grid_with_data"), hint, size_center_lat, data_type_size, (const char*)center_lat, "center_lat", annotation);
+    check_API_parameter_data_array(comp_id, API_id, comp_comm_group_mgt_mgr->get_comm_group_of_local_comp(comp_id,"in register_h2d_grid_with_data"), hint, size_mask, sizeof(int), (const char*)mask, "mask", annotation);
+    check_API_parameter_data_array(comp_id, API_id, comp_comm_group_mgt_mgr->get_comm_group_of_local_comp(comp_id,"in register_h2d_grid_with_data"), hint, size_area, data_type_size, (const char*)area, "area", annotation);
+    check_API_parameter_data_array(comp_id, API_id, comp_comm_group_mgt_mgr->get_comm_group_of_local_comp(comp_id,"in register_h2d_grid_with_data"), hint, size_vertex_lon, data_type_size, (const char*)vertex_lon, "vertex_lon", annotation);
+    check_API_parameter_data_array(comp_id, API_id, comp_comm_group_mgt_mgr->get_comm_group_of_local_comp(comp_id,"in register_h2d_grid_with_data"), hint, size_vertex_lat, data_type_size, (const char*)vertex_lat, "vertex_lat", annotation);
+    check_API_parameter_int(comp_id, API_id, comp_comm_group_mgt_mgr->get_comm_group_of_local_comp(comp_id,"in register_h2d_grid_with_data"), NULL, dim_size1, "dim_size1", annotation);
+    check_API_parameter_int(comp_id, API_id, comp_comm_group_mgt_mgr->get_comm_group_of_local_comp(comp_id,"in register_h2d_grid_with_data"), NULL, dim_size2, "dim_size2", annotation);
+    EXECUTION_REPORT(REPORT_ERROR, comp_id, dim_size1 > 3, "Error happens when registering an H2D grid \"%s\" through the API \"%s\": the value (currently is %d) of the parameter \"dim_size1\" is wrong. It must be larger than 3. Please check the model code related to the annotation \"%s\".", grid_name, API_label, dim_size1, annotation);
+    EXECUTION_REPORT(REPORT_ERROR, comp_id, dim_size2 == 0 || dim_size2 > 3, "Error happens when registering an H2D grid \"%s\" through the API \"%s\": the value (currently is %d) of the parameter \"dim_size2\" is wrong. It must be 0 or a positive value larger than 3. Please check the model code related to the annotation \"%s\".", grid_name, API_label, dim_size2, annotation);
+    if (dim_size2 == 0) {
+        grid_size = dim_size1;
+        EXECUTION_REPORT(REPORT_ERROR, comp_id, size_center_lon == grid_size, "Error happens when registering an H2D grid \"%s\" through the API \"%s\": the array size (currently is %d) of \"center_lon\" is different from the grid size that is determined by \"dim_size1\" (currently is %d). Please check the model code related to the annotation \"%s\".", grid_name, API_label, size_center_lon, grid_size, annotation);
+        EXECUTION_REPORT(REPORT_ERROR, comp_id, size_center_lat == grid_size, "Error happens when registering an H2D grid \"%s\" through the API \"%s\": the array size (currently is %d) of \"center_lat\" is different from the grid size that is determined by \"dim_size1\" (currently is %d). Please check the model code related to the annotation \"%s\".", grid_name, API_label, size_center_lat, grid_size, annotation);
+    }
+    else {
+        grid_size = (dim_size1)*(dim_size2);
+        if (size_center_lon == dim_size1)
+            EXECUTION_REPORT(REPORT_ERROR, comp_id, size_center_lat == dim_size2, "Error happens when registering an H2D grid \"%s\" through the API \"%s\": the array size (currently is %d) of \"center_lat\" is different from \"dim_size2\" (currently is %d). Please check the model code related to the annotation \"%s\".", grid_name, API_label, size_center_lat, dim_size2, annotation);
+        else {            
+            EXECUTION_REPORT(REPORT_ERROR, comp_id, size_center_lon == grid_size, "Error happens when registering an H2D grid \"%s\" through the API \"%s\": the array size (currently is %d) of \"center_lon\" is different from \"dim_size1\" (currently is %d) and the grid size (currently is %d) that is determined by the product of \"dim_size1\" and \"dim_size2\". Please check the model code related to the annotation \"%s\".", grid_name, API_label, size_center_lon, dim_size1, grid_size, annotation);
+            EXECUTION_REPORT(REPORT_ERROR, comp_id, size_center_lat == grid_size, "Error happens when registering an H2D grid \"%s\" through the API \"%s\": the array size (currently is %d) of \"center_lat\" is different from the grid size (currently is %d) that is determined by the product of \"dim_size1\" and \"dim_size2\" (the array size of \"center_lon\" is the same as the grid size). Please check the model code related to the annotation \"%s\".", grid_name, API_label, size_center_lat, grid_size, annotation);
+        }    
+    }
+    if (size_mask > 0)        
+        EXECUTION_REPORT(REPORT_ERROR, comp_id, size_mask == grid_size, "Error happens when registering an H2D grid \"%s\" through the API \"%s\": the array size (currently is %d) of \"mask\" is different from the grid size (currently is %d). Please check the model code related to the annotation \"%s\".", grid_name, API_label, size_mask, grid_size, annotation);
+    if (size_area > 0)        
+        EXECUTION_REPORT(REPORT_ERROR, comp_id, size_area == grid_size, "Error happens when registering an H2D grid \"%s\" through the API \"%s\": the array size (currently is %d) of \"area\" is different from the grid size (currently is %d). Please check the model code related to the annotation \"%s\".", grid_name, API_label, size_area, grid_size, annotation);
+    EXECUTION_REPORT(REPORT_ERROR, comp_id, (size_vertex_lon == -1 && size_vertex_lat == -1) || (size_vertex_lon > 0 && size_vertex_lat > 0), "Error happens when registering an H2D grid \"%s\" through the API \"%s\": the optional parameters \"vertex_lon\" and \"vertex_lat\" are not set/unset at the same time. Please check the model code related to the annotation \"%s\".", grid_name, API_label, annotation);
+    if (size_vertex_lon > 0) {
+        EXECUTION_REPORT(REPORT_ERROR, comp_id, (size_vertex_lon) % (size_center_lon) == 0, "Error happens when registering an H2D grid \"%s\" through the API \"%s\": the array size of \"vertex_lon\" (currently is %d) is not an integral multiple of the array size (currently is %d) of \"center_lon\". Please check the model code related to the annotation \"%s\".", grid_name, API_label, size_vertex_lon, size_center_lon, annotation);
+        EXECUTION_REPORT(REPORT_ERROR, comp_id, (size_vertex_lat) % (size_center_lat) == 0, "Error happens when registering an H2D grid \"%s\" through the API \"%s\": the array size of \"vertex_lat\" (currently is %d) is not an integral multiple of the array size (currently is %d) of \"center_lat\". Please check the model code related to the annotation \"%s\".", grid_name, API_label, size_vertex_lat, size_center_lat, annotation);
+        int num_vertex_lon = (size_vertex_lon) / (size_center_lon);
+        int num_vertex_lat = (size_vertex_lat) / (size_center_lat);
+        EXECUTION_REPORT(REPORT_ERROR, comp_id, num_vertex_lon == num_vertex_lat, "Error happens when registering an H2D grid \"%s\" through the API \"%s\": the numbers of vertexes determined by \"vertex_lon\" (currently is %d) and \"vertex_lat\" (currently is %d) respectively are not the same. Please check the model code related to the annotation \"%s\".", grid_name, API_label, num_vertex_lon, num_vertex_lat, annotation);
+        EXECUTION_REPORT(REPORT_ERROR, comp_id, size_vertex_lon > grid_size && size_vertex_lat > grid_size || size_vertex_lon < grid_size && size_vertex_lat < grid_size, "Error happens when registering an H2D grid \"%s\" through the API \"%s\": the array sizes of \"vertex_lon\" and \"vertex_lat\" (currently are %d and %d respectively) are not bigger/smaller than the grid size at the same time. Please check the model code related to the annotation \"%s\".", grid_name, API_label, size_vertex_lon, size_vertex_lat, annotation);
+        if (size_center_lon == grid_size) 
+            EXECUTION_REPORT(REPORT_ERROR, comp_id, num_vertex_lon >= 3, "Error happens when registering an H2D grid \"%s\" through the API \"%s\": the number of vertexes (currently is %d) is wrong as it is smaller than 3. Please check the model code related to the annotation \"%s\".", grid_name, API_label, num_vertex_lon, annotation);
+        else EXECUTION_REPORT(REPORT_ERROR, comp_id ,num_vertex_lon == 2, "Error happens when registering an H2D grid \"%s\" through the API \"%s\": the number of vertexes (currently is %d) is wrong as it is not 2. Please check the model code related to the annotation \"%s\".", grid_name, API_label, num_vertex_lon, annotation);
+        num_vertex = num_vertex_lon;
+    }
+
+    return create_H2D_grid_from_global_data(comp_id, grid_name, coord_unit, cyclic_or_acyclic, data_type, dim_size1, dim_size2, num_vertex, size_center_lon, size_center_lat, 
+                                            size_mask, size_area, size_vertex_lon, size_vertex_lat, min_lon, max_lon, min_lat, max_lat, center_lon, center_lat, mask, area, vertex_lon, vertex_lat, annotation);
 }
 
 
 int Original_grid_mgt::register_H2D_grid_via_file(int comp_id, const char *grid_name, const char *data_file_name, const char *annotation)
 {
-	int rcode, ncfile_id, grid_id;
-	int size_center_lon, size_center_lat, size_mask, size_area, size_vertex_lon, size_vertex_lat;
-	long dim_lon_size, dim_lat_size, dim_H2D_size, dim_size1, dim_size2;
-	char *center_lon, *center_lat, *vertex_lon, *vertex_lat, *area;
-	char min_lon[NAME_STR_SIZE], max_lon[NAME_STR_SIZE], min_lat[NAME_STR_SIZE], max_lat[NAME_STR_SIZE];
-	int *mask;
-	char data_type_for_center_lat[NAME_STR_SIZE], data_type_for_center_lon[NAME_STR_SIZE], data_type_for_vertex_lon[NAME_STR_SIZE], data_type_for_vertex_lat[NAME_STR_SIZE], data_type_for_mask[NAME_STR_SIZE], data_type_for_area[NAME_STR_SIZE];
-	char data_type_temp[NAME_STR_SIZE];
-	char edge_type[NAME_STR_SIZE], cyclic_or_acyclic[NAME_STR_SIZE], unit_center_lon[NAME_STR_SIZE], unit_center_lat[NAME_STR_SIZE], unit_vertex_lon[NAME_STR_SIZE], unit_vertex_lat[NAME_STR_SIZE];
-	MPI_Comm comm = comp_comm_group_mgt_mgr->get_comm_group_of_local_comp(comp_id, "in register_H2D_grid_via_file");
-	bool is_root_proc = comp_comm_group_mgt_mgr->get_current_proc_id_in_comp(comp_id, "in register_H2D_grid_via_file") == 0;
-	
+    int rcode, ncfile_id, grid_id;
+    int size_center_lon, size_center_lat, size_mask, size_area, size_vertex_lon, size_vertex_lat;
+    long dim_lon_size, dim_lat_size, dim_H2D_size, dim_size1, dim_size2;
+    char *center_lon, *center_lat, *vertex_lon, *vertex_lat, *area;
+    char min_lon[NAME_STR_SIZE], max_lon[NAME_STR_SIZE], min_lat[NAME_STR_SIZE], max_lat[NAME_STR_SIZE];
+    int *mask;
+    char data_type_for_center_lat[NAME_STR_SIZE], data_type_for_center_lon[NAME_STR_SIZE], data_type_for_vertex_lon[NAME_STR_SIZE], data_type_for_vertex_lat[NAME_STR_SIZE], data_type_for_mask[NAME_STR_SIZE], data_type_for_area[NAME_STR_SIZE];
+    char data_type_temp[NAME_STR_SIZE];
+    char edge_type[NAME_STR_SIZE], cyclic_or_acyclic[NAME_STR_SIZE], unit_center_lon[NAME_STR_SIZE], unit_center_lat[NAME_STR_SIZE], unit_vertex_lon[NAME_STR_SIZE], unit_vertex_lat[NAME_STR_SIZE];
+    MPI_Comm comm = comp_comm_group_mgt_mgr->get_comm_group_of_local_comp(comp_id, "in register_H2D_grid_via_file");
+    bool is_root_proc = comp_comm_group_mgt_mgr->get_current_proc_id_in_comp(comp_id, "in register_H2D_grid_via_file") == 0;
+    
+
+    check_API_parameter_string(comp_id, API_ID_GRID_MGT_REG_H2D_GRID_VIA_FILE, comm, "registering an H2D grid", data_file_name, "data_file_name", annotation);
+
+    IO_netcdf *netcdf_file_object = new IO_netcdf("H2D_grid_data", data_file_name, "r", false);
+    dim_lon_size = netcdf_file_object->get_dimension_size(COORD_LABEL_LON, comm, is_root_proc);
+    dim_lat_size = netcdf_file_object->get_dimension_size(COORD_LABEL_LAT, comm, is_root_proc);
+    dim_H2D_size = netcdf_file_object->get_dimension_size("grid_size", comm, is_root_proc);
+    netcdf_file_object->read_file_field(SCRIP_CENTER_LON_LABEL, (void**)(&center_lon), &size_center_lon, data_type_for_center_lon, comm, is_root_proc);
+    netcdf_file_object->read_file_field(SCRIP_CENTER_LAT_LABEL, (void**)(&center_lat), &size_center_lat, data_type_for_center_lat, comm, is_root_proc);
+    netcdf_file_object->read_file_field(SCRIP_VERTEX_LON_LABEL, (void**)(&vertex_lon), &size_vertex_lon, data_type_for_vertex_lon, comm, is_root_proc);
+    netcdf_file_object->read_file_field(SCRIP_VERTEX_LAT_LABEL, (void**)(&vertex_lat), &size_vertex_lat, data_type_for_vertex_lat, comm, is_root_proc);
+    netcdf_file_object->read_file_field("area", (void**)(&area), &size_area, data_type_for_area, comm, is_root_proc);
+    netcdf_file_object->read_file_field(SCRIP_MASK_LABEL, (void**)(&mask), &size_mask, data_type_for_mask, comm, is_root_proc);
+    if (dim_lon_size > 0 && dim_lat_size > 0 && dim_H2D_size > 0)
+        EXECUTION_REPORT(REPORT_ERROR, comp_id, dim_H2D_size == dim_lon_size*dim_lat_size, "Error happens when registering an H2D grid \"%s\" (the corresponding model code annotation is \"%s\") through the API CCPL_register_H2D_grid_via_data_file: in the data file \"%s\", the size (currently is %d) of dimension \"grid_size\" is different from the multiple (currently is %d) of sizes of dimensions \"lon\" and \"lat\"", grid_name, annotation, dim_H2D_size, dim_lon_size*dim_lat_size, data_file_name);
+    EXECUTION_REPORT(REPORT_ERROR, comp_id, dim_H2D_size > 0 || (dim_lon_size > 0 && dim_lat_size > 0), "Error happens when registering an H2D grid \"%s\" (the corresponding model code annotation is \"%s\") through the API CCPL_register_H2D_grid_via_data_file: the dimension size (dimensions \"lon\" and \"lat\" in the file) or the grid size (dimension \"grid_size\" in the file) is not correctly specified in the file \"%s\". Please verify.", grid_name, annotation, data_file_name);
+    if (dim_lon_size > 0 && dim_lat_size > 0) {
+        dim_size1 = dim_lon_size;
+        dim_size2 = dim_lat_size;
+    }
+    else {
+        dim_size1 = dim_H2D_size;
+        dim_size2 = 0;
+    }
+
+    EXECUTION_REPORT(REPORT_ERROR, comp_id, center_lon != NULL, "Error happens when registering an H2D grid \"%s\" (the corresponding model code annotation is \"%s\") through the API CCPL_register_H2D_grid_via_data_file: the longitude value for the center of each grid point (variable \"lon\" in the file) is not specified in the data file \"%s\". ", 
+                     grid_name, annotation, data_file_name);
+    EXECUTION_REPORT(REPORT_ERROR, comp_id, center_lat != NULL, "Error happens when registering an H2D grid \"%s\" (the corresponding model code annotation is \"%s\") through the API CCPL_register_H2D_grid_via_data_file: the latitude value for the center of each grid point (variable \"lat\" in the file) is not specified in the data file \"%s\". ", 
+                     grid_name, annotation, data_file_name);
+    EXECUTION_REPORT(REPORT_ERROR, comp_id, vertex_lon != NULL && vertex_lat != NULL || vertex_lon == NULL && vertex_lat == NULL, "Error happens when registering an H2D grid \"%s\" (the corresponding model code annotation is \"%s\") through the API CCPL_register_H2D_grid_via_data_file: in the data file \"%s\", the longitude and latitude values for each vertex (variables \"vertex_lon\" and \"vertex_lat\" in the file) of each grid point must be specified/unspecified at the same time", 
+                     grid_name, annotation, data_file_name);
+    EXECUTION_REPORT(REPORT_ERROR, comp_id, words_are_the_same(data_type_for_center_lon,data_type_for_center_lat), "Error happens when registering an H2D grid \"%s\" (the corresponding model code annotation is \"%s\") through the API CCPL_register_H2D_grid_via_data_file: in the data file \"%s\", the data type of variables \"lon\" and \"lat\" are not the same", grid_name, annotation, data_file_name);
+    EXECUTION_REPORT(REPORT_ERROR, comp_id, words_are_the_same(data_type_for_center_lon,DATA_TYPE_FLOAT) || words_are_the_same(data_type_for_center_lon,DATA_TYPE_DOUBLE), "Error happens when registering an H2D grid \"%s\" (the corresponding model code annotation is \"%s\") through the API CCPL_register_H2D_grid_via_data_file: in the data file \"%s\", the data type of variables \"lon\" is not floating-point", grid_name, annotation, data_file_name);
+    if (vertex_lon != NULL) {
+        EXECUTION_REPORT(REPORT_ERROR, comp_id, words_are_the_same(data_type_for_center_lon,data_type_for_vertex_lon), "Error happens when registering an H2D grid \"%s\" (the corresponding model code annotation is \"%s\") through the API CCPL_register_H2D_grid_via_data_file: in the data file \"%s\", the data type of variable \"vertex_lon\" is different from the data type of variable \"lon\".", grid_name, annotation, data_file_name);
+        EXECUTION_REPORT(REPORT_ERROR, comp_id, words_are_the_same(data_type_for_center_lon,data_type_for_vertex_lat), "Error happens when registering an H2D grid \"%s\" (the corresponding model code annotation is \"%s\") through the API CCPL_register_H2D_grid_via_data_file: in the data file \"%s\", the data type of variable \"vertex_lat\" is different from the data type of variable \"lat\".", grid_name, annotation, data_file_name);
+    }
+    if (area != NULL)        
+        EXECUTION_REPORT(REPORT_ERROR, comp_id, words_are_the_same(data_type_for_center_lon,data_type_for_area), "Error happens when registering an H2D grid \"%s\" (the corresponding model code annotation is \"%s\") through the API CCPL_register_H2D_grid_via_data_file: in the data file \"%s\", the data type of variable \"area\" is different from the data type of variable \"lon\".", grid_name, annotation, data_file_name);
+    if (mask != NULL)
+        EXECUTION_REPORT(REPORT_ERROR, comp_id, words_are_the_same(data_type_for_mask, DATA_TYPE_INT), "Error happens when registering an H2D grid \"%s\" (the corresponding model code annotation is \"%s\") through the API CCPL_register_H2D_grid_via_data_file: in the data file \"%s\", the data type of variable \"mask\" is not \"integer\".", grid_name, annotation, data_file_name);
+
+    EXECUTION_REPORT(REPORT_ERROR, comp_id, netcdf_file_object->get_file_field_string_attribute(NULL, "edge_type", edge_type, data_type_temp, comm, is_root_proc) && words_are_the_same(data_type_temp, DATA_TYPE_STRING), "Error happens when registering an H2D grid \"%s\" (the corresponding model code annotation is \"%s\") through the API CCPL_register_H2D_grid_via_data_file: fail to get the global attribute \"edge_type\" from the data file \"%s\": it does not exist or its type is not string", grid_name, annotation, data_file_name);
+    EXECUTION_REPORT(REPORT_ERROR, comp_id, netcdf_file_object->get_file_field_string_attribute(NULL, "cyclic_or_acyclic", cyclic_or_acyclic, data_type_temp, comm, is_root_proc) && words_are_the_same(data_type_temp, DATA_TYPE_STRING), "Error happens when registering an H2D grid \"%s\" (the corresponding model code annotation is \"%s\") through the API CCPL_register_H2D_grid_via_data_file: fail to get the global attribute \"cyclic_or_acyclic\" from the data file \"%s\": it does not exist or its type is not string", grid_name, annotation, data_file_name);
+    EXECUTION_REPORT(REPORT_ERROR, comp_id, strlen(edge_type) > 0, "Error happens when registering an H2D grid \"%s\" (the corresponding model code annotation is \"%s\") through the API CCPL_register_H2D_grid_via_data_file: in the data file \"%s\", \"edge_type\" is not specified as a global attribute", grid_name, annotation, data_file_name);
+    EXECUTION_REPORT(REPORT_ERROR, comp_id, strlen(cyclic_or_acyclic) > 0, "Error happens when registering an H2D grid \"%s\" (the corresponding model code annotation is \"%s\") through the API CCPL_register_H2D_grid_via_data_file: in the data file \"%s\", \"cyclic_or_acyclic\" is not specified as a global attribute", grid_name, annotation, data_file_name);
+    EXECUTION_REPORT(REPORT_ERROR, comp_id, (netcdf_file_object->get_file_field_string_attribute(SCRIP_CENTER_LON_LABEL, "unit", unit_center_lon, data_type_temp, comm, is_root_proc) || netcdf_file_object->get_file_field_string_attribute(SCRIP_CENTER_LON_LABEL, "units", unit_center_lon, data_type_temp, comm, is_root_proc)) && words_are_the_same(data_type_temp, DATA_TYPE_STRING), "Error happens when registering an H2D grid \"%s\" (the corresponding model code annotation is \"%s\") through the API CCPL_register_H2D_grid_via_data_file: fail to get the unit of variable \"%s\" from the data file \"%s\": it does not exist or its type is not string", grid_name, annotation, SCRIP_CENTER_LON_LABEL, data_file_name);
+    EXECUTION_REPORT(REPORT_ERROR, comp_id, (netcdf_file_object->get_file_field_string_attribute(SCRIP_CENTER_LAT_LABEL, "unit", unit_center_lat, data_type_temp, comm, is_root_proc) || netcdf_file_object->get_file_field_string_attribute(SCRIP_CENTER_LAT_LABEL, "units", unit_center_lat, data_type_temp, comm, is_root_proc)) && words_are_the_same(data_type_temp, DATA_TYPE_STRING), "Error happens when registering an H2D grid \"%s\" (the corresponding model code annotation is \"%s\") through the API CCPL_register_H2D_grid_via_data_file: fail to get the unit of variable \"%s\" from the data file \"%s\": it does not exist or its type is not string", grid_name, annotation, SCRIP_CENTER_LAT_LABEL, data_file_name);
+    EXECUTION_REPORT(REPORT_ERROR, comp_id, netcdf_file_object->get_file_field_string_attribute(NULL, "min_lon", min_lon, data_type_temp, comm, is_root_proc) && (words_are_the_same(data_type_temp, DATA_TYPE_FLOAT) || words_are_the_same(data_type_temp, DATA_TYPE_DOUBLE)), "Error happens when registering an H2D grid \"%s\" (the corresponding model code annotation is \"%s\") through the API CCPL_register_H2D_grid_via_data_file: fail to get the value of the global attribute \"min_lon\" from the data file \"%s\": it does not exist or its type is not float or double", grid_name, annotation, data_file_name);
+    transform_datatype_of_arrays(min_lon, min_lon, data_type_temp, data_type_for_center_lon, 1);
+    EXECUTION_REPORT(REPORT_ERROR, comp_id, netcdf_file_object->get_file_field_string_attribute(NULL, "max_lon", max_lon, data_type_temp, comm, is_root_proc) && (words_are_the_same(data_type_temp, DATA_TYPE_FLOAT) || words_are_the_same(data_type_temp, DATA_TYPE_DOUBLE)), "Error happens when registering an H2D grid \"%s\" (the corresponding model code annotation is \"%s\") through the API CCPL_register_H2D_grid_via_data_file: fail to get the value of the global attribute \"max_lon\" from the data file \"%s\": it does not exist or its type is not float or double", grid_name, annotation, data_file_name);
+    transform_datatype_of_arrays(max_lon, max_lon, data_type_temp, data_type_for_center_lon, 1);
+    EXECUTION_REPORT(REPORT_ERROR, comp_id, netcdf_file_object->get_file_field_string_attribute(NULL, "min_lat", min_lat, data_type_temp, comm, is_root_proc) && (words_are_the_same(data_type_temp, DATA_TYPE_FLOAT) || words_are_the_same(data_type_temp, DATA_TYPE_DOUBLE)), "Error happens when registering an H2D grid \"%s\" (the corresponding model code annotation is \"%s\") through the API CCPL_register_H2D_grid_via_data_file: fail to get the value of the global attribute \"min_lat\" from the data file \"%s\": it does not exist or its type is not float or double", grid_name, annotation, data_file_name);    
+    transform_datatype_of_arrays(min_lat, min_lat, data_type_temp, data_type_for_center_lon, 1);
+    EXECUTION_REPORT(REPORT_ERROR, comp_id, netcdf_file_object->get_file_field_string_attribute(NULL, "max_lat", max_lat, data_type_temp, comm, is_root_proc) && (words_are_the_same(data_type_temp, DATA_TYPE_FLOAT) || words_are_the_same(data_type_temp, DATA_TYPE_DOUBLE)), "Error happens when registering an H2D grid \"%s\" (the corresponding model code annotation is \"%s\") through the API CCPL_register_H2D_grid_via_data_file: fail to get the value of the global attribute \"max_lat\" from the data file \"%s\": it does not exist or its type is not float or double", grid_name, annotation, data_file_name);
+    transform_datatype_of_arrays(max_lat, max_lat, data_type_temp, data_type_for_center_lon, 1);
+    EXECUTION_REPORT(REPORT_ERROR, comp_id, words_are_the_same(unit_center_lon,unit_center_lat), "Error happens when registering an H2D grid \"%s\" (the corresponding model code annotation is \"%s\") through the API CCPL_register_H2D_grid_via_data_file: in the data file \"%s\", the units of variables \"lon\" and \"lat\" are different", grid_name, annotation, data_file_name);
+    if (vertex_lon != NULL) {
+        EXECUTION_REPORT(REPORT_ERROR, comp_id, netcdf_file_object->get_file_field_string_attribute(SCRIP_VERTEX_LON_LABEL, "unit", unit_vertex_lon, data_type_temp, comm, is_root_proc) || netcdf_file_object->get_file_field_string_attribute(SCRIP_VERTEX_LON_LABEL, "units", unit_vertex_lon, data_type_temp, comm, is_root_proc), "Error happens when registering an H2D grid \"%s\" (the corresponding model code annotation is \"%s\") through the API CCPL_register_H2D_grid_via_data_file: fail to get the unit of variable \"vertex_lon\" from the data file \"%s\": it does not exist or its type is not string", grid_name, annotation, data_file_name);
+        EXECUTION_REPORT(REPORT_ERROR, comp_id, netcdf_file_object->get_file_field_string_attribute(SCRIP_VERTEX_LAT_LABEL, "unit", unit_vertex_lat, data_type_temp, comm, is_root_proc) || netcdf_file_object->get_file_field_string_attribute(SCRIP_VERTEX_LAT_LABEL, "units", unit_vertex_lat, data_type_temp, comm, is_root_proc), "Error happens when registering an H2D grid \"%s\" (the corresponding model code annotation is \"%s\") through the API CCPL_register_H2D_grid_via_data_file: fail to get the unit of variable \"vertex_lat\" from the data file \"%s\": it does not exist or its type is not string", grid_name, annotation, data_file_name);
+        EXECUTION_REPORT(REPORT_ERROR, comp_id, words_are_the_same(unit_center_lon,unit_vertex_lon), "Error happens when registering an H2D grid \"%s\" (the corresponding model code annotation is \"%s\") through the API CCPL_register_H2D_grid_via_data_file: in the data file \"%s\", the units of variables \"lon\" and \"vertex_lon\" are different", grid_name, annotation, data_file_name);
+        EXECUTION_REPORT(REPORT_ERROR, comp_id, words_are_the_same(unit_center_lat,unit_vertex_lat), "Error happens when registering an H2D grid \"%s\" (the corresponding model code annotation is \"%s\") through the API CCPL_register_H2D_grid_via_data_file: in the data file \"%s\", the units of variables \"lat\" and \"vertex_lat\" are different", grid_name, annotation, data_file_name);
+    }
+
+    grid_id = register_H2D_grid_via_global_data(comp_id, grid_name, edge_type, unit_center_lon, cyclic_or_acyclic, data_type_for_center_lon, dim_size1, dim_size2,size_center_lon, size_center_lat,
+                                         size_mask, size_area, size_vertex_lon, size_vertex_lat, min_lon, max_lon, min_lat, max_lat, center_lon, center_lat, mask, area, vertex_lon, vertex_lat, annotation, API_ID_GRID_MGT_REG_H2D_GRID_VIA_FILE);
+
+    delete [] center_lon;
+    delete [] center_lat;
+    if (vertex_lon != NULL) {
+        delete [] vertex_lon;
+        delete [] vertex_lat;
+    }
+    if (mask != NULL)
+        delete [] mask;
+    if (area != NULL)
+        delete [] area;
+
+    return grid_id;
+}
 
-	check_API_parameter_string(comp_id, API_ID_GRID_MGT_REG_H2D_GRID_VIA_FILE, comm, "registering an H2D grid", data_file_name, "data_file_name", annotation);
-
-	IO_netcdf *netcdf_file_object = new IO_netcdf("H2D_grid_data", data_file_name, "r", false);
-	dim_lon_size = netcdf_file_object->get_dimension_size(COORD_LABEL_LON, comm, is_root_proc);
-	dim_lat_size = netcdf_file_object->get_dimension_size(COORD_LABEL_LAT, comm, is_root_proc);
-	dim_H2D_size = netcdf_file_object->get_dimension_size("grid_size", comm, is_root_proc);
-	netcdf_file_object->read_file_field(SCRIP_CENTER_LON_LABEL, (void**)(&center_lon), &size_center_lon, data_type_for_center_lon, comm, is_root_proc);
-	netcdf_file_object->read_file_field(SCRIP_CENTER_LAT_LABEL, (void**)(&center_lat), &size_center_lat, data_type_for_center_lat, comm, is_root_proc);
-	netcdf_file_object->read_file_field(SCRIP_VERTEX_LON_LABEL, (void**)(&vertex_lon), &size_vertex_lon, data_type_for_vertex_lon, comm, is_root_proc);
-	netcdf_file_object->read_file_field(SCRIP_VERTEX_LAT_LABEL, (void**)(&vertex_lat), &size_vertex_lat, data_type_for_vertex_lat, comm, is_root_proc);
-	netcdf_file_object->read_file_field("area", (void**)(&area), &size_area, data_type_for_area, comm, is_root_proc);
-	netcdf_file_object->read_file_field(SCRIP_MASK_LABEL, (void**)(&mask), &size_mask, data_type_for_mask, comm, is_root_proc);
-	if (dim_lon_size > 0 && dim_lat_size > 0 && dim_H2D_size > 0)
-		EXECUTION_REPORT(REPORT_ERROR, comp_id, dim_H2D_size == dim_lon_size*dim_lat_size, "Error happens when registering an H2D grid \"%s\" (the corresponding model code annotation is \"%s\") through the API CCPL_register_H2D_grid_via_data_file: in the data file \"%s\", the size (currently is %d) of dimension \"grid_size\" is different from the multiple (currently is %d) of sizes of dimensions \"lon\" and \"lat\"", grid_name, annotation, dim_H2D_size, dim_lon_size*dim_lat_size, data_file_name);
-	EXECUTION_REPORT(REPORT_ERROR, comp_id, dim_H2D_size > 0 || (dim_lon_size > 0 && dim_lat_size > 0), "Error happens when registering an H2D grid \"%s\" (the corresponding model code annotation is \"%s\") through the API CCPL_register_H2D_grid_via_data_file: the dimension size (dimensions \"lon\" and \"lat\" in the file) or the grid size (dimension \"grid_size\" in the file) is not correctly specified in the file \"%s\". Please verify.", grid_name, annotation, data_file_name);
-	if (dim_lon_size > 0 && dim_lat_size > 0) {
-		dim_size1 = dim_lon_size;
-		dim_size2 = dim_lat_size;
-	}
-	else {
-		dim_size1 = dim_H2D_size;
-		dim_size2 = 0;
-	}
 
-	EXECUTION_REPORT(REPORT_ERROR, comp_id, center_lon != NULL, "Error happens when registering an H2D grid \"%s\" (the corresponding model code annotation is \"%s\") through the API CCPL_register_H2D_grid_via_data_file: the longitude value for the center of each grid point (variable \"lon\" in the file) is not specified in the data file \"%s\". ", 
-		             grid_name, annotation, data_file_name);
-	EXECUTION_REPORT(REPORT_ERROR, comp_id, center_lat != NULL, "Error happens when registering an H2D grid \"%s\" (the corresponding model code annotation is \"%s\") through the API CCPL_register_H2D_grid_via_data_file: the latitude value for the center of each grid point (variable \"lat\" in the file) is not specified in the data file \"%s\". ", 
-		             grid_name, annotation, data_file_name);
-	EXECUTION_REPORT(REPORT_ERROR, comp_id, vertex_lon != NULL && vertex_lat != NULL || vertex_lon == NULL && vertex_lat == NULL, "Error happens when registering an H2D grid \"%s\" (the corresponding model code annotation is \"%s\") through the API CCPL_register_H2D_grid_via_data_file: in the data file \"%s\", the longitude and latitude values for each vertex (variables \"vertex_lon\" and \"vertex_lat\" in the file) of each grid point must be specified/unspecified at the same time", 
-					 grid_name, annotation, data_file_name);
-	EXECUTION_REPORT(REPORT_ERROR, comp_id, words_are_the_same(data_type_for_center_lon,data_type_for_center_lat), "Error happens when registering an H2D grid \"%s\" (the corresponding model code annotation is \"%s\") through the API CCPL_register_H2D_grid_via_data_file: in the data file \"%s\", the data type of variables \"lon\" and \"lat\" are not the same", grid_name, annotation, data_file_name);
-	EXECUTION_REPORT(REPORT_ERROR, comp_id, words_are_the_same(data_type_for_center_lon,DATA_TYPE_FLOAT) || words_are_the_same(data_type_for_center_lon,DATA_TYPE_DOUBLE), "Error happens when registering an H2D grid \"%s\" (the corresponding model code annotation is \"%s\") through the API CCPL_register_H2D_grid_via_data_file: in the data file \"%s\", the data type of variables \"lon\" is not floating-point", grid_name, annotation, data_file_name);
-	if (vertex_lon != NULL) {
-		EXECUTION_REPORT(REPORT_ERROR, comp_id, words_are_the_same(data_type_for_center_lon,data_type_for_vertex_lon), "Error happens when registering an H2D grid \"%s\" (the corresponding model code annotation is \"%s\") through the API CCPL_register_H2D_grid_via_data_file: in the data file \"%s\", the data type of variable \"vertex_lon\" is different from the data type of variable \"lon\".", grid_name, annotation, data_file_name);
-		EXECUTION_REPORT(REPORT_ERROR, comp_id, words_are_the_same(data_type_for_center_lon,data_type_for_vertex_lat), "Error happens when registering an H2D grid \"%s\" (the corresponding model code annotation is \"%s\") through the API CCPL_register_H2D_grid_via_data_file: in the data file \"%s\", the data type of variable \"vertex_lat\" is different from the data type of variable \"lat\".", grid_name, annotation, data_file_name);
-	}
-	if (area != NULL)		
-		EXECUTION_REPORT(REPORT_ERROR, comp_id, words_are_the_same(data_type_for_center_lon,data_type_for_area), "Error happens when registering an H2D grid \"%s\" (the corresponding model code annotation is \"%s\") through the API CCPL_register_H2D_grid_via_data_file: in the data file \"%s\", the data type of variable \"area\" is different from the data type of variable \"lon\".", grid_name, annotation, data_file_name);
-	if (mask != NULL)
-		EXECUTION_REPORT(REPORT_ERROR, comp_id, words_are_the_same(data_type_for_mask, DATA_TYPE_INT), "Error happens when registering an H2D grid \"%s\" (the corresponding model code annotation is \"%s\") through the API CCPL_register_H2D_grid_via_data_file: in the data file \"%s\", the data type of variable \"mask\" is not \"integer\".", grid_name, annotation, data_file_name);
-
-	EXECUTION_REPORT(REPORT_ERROR, comp_id, netcdf_file_object->get_file_field_string_attribute(NULL, "edge_type", edge_type, data_type_temp, comm, is_root_proc) && words_are_the_same(data_type_temp, DATA_TYPE_STRING), "Error happens when registering an H2D grid \"%s\" (the corresponding model code annotation is \"%s\") through the API CCPL_register_H2D_grid_via_data_file: fail to get the global attribute \"edge_type\" from the data file \"%s\": it does not exist or its type is not string", grid_name, annotation, data_file_name);
-	EXECUTION_REPORT(REPORT_ERROR, comp_id, netcdf_file_object->get_file_field_string_attribute(NULL, "cyclic_or_acyclic", cyclic_or_acyclic, data_type_temp, comm, is_root_proc) && words_are_the_same(data_type_temp, DATA_TYPE_STRING), "Error happens when registering an H2D grid \"%s\" (the corresponding model code annotation is \"%s\") through the API CCPL_register_H2D_grid_via_data_file: fail to get the global attribute \"cyclic_or_acyclic\" from the data file \"%s\": it does not exist or its type is not string", grid_name, annotation, data_file_name);
-	EXECUTION_REPORT(REPORT_ERROR, comp_id, strlen(edge_type) > 0, "Error happens when registering an H2D grid \"%s\" (the corresponding model code annotation is \"%s\") through the API CCPL_register_H2D_grid_via_data_file: in the data file \"%s\", \"edge_type\" is not specified as a global attribute", grid_name, annotation, data_file_name);
-	EXECUTION_REPORT(REPORT_ERROR, comp_id, strlen(cyclic_or_acyclic) > 0, "Error happens when registering an H2D grid \"%s\" (the corresponding model code annotation is \"%s\") through the API CCPL_register_H2D_grid_via_data_file: in the data file \"%s\", \"cyclic_or_acyclic\" is not specified as a global attribute", grid_name, annotation, data_file_name);
-	EXECUTION_REPORT(REPORT_ERROR, comp_id, (netcdf_file_object->get_file_field_string_attribute(SCRIP_CENTER_LON_LABEL, "unit", unit_center_lon, data_type_temp, comm, is_root_proc) || netcdf_file_object->get_file_field_string_attribute(SCRIP_CENTER_LON_LABEL, "units", unit_center_lon, data_type_temp, comm, is_root_proc)) && words_are_the_same(data_type_temp, DATA_TYPE_STRING), "Error happens when registering an H2D grid \"%s\" (the corresponding model code annotation is \"%s\") through the API CCPL_register_H2D_grid_via_data_file: fail to get the unit of variable \"%s\" from the data file \"%s\": it does not exist or its type is not string", grid_name, annotation, SCRIP_CENTER_LON_LABEL, data_file_name);
-	EXECUTION_REPORT(REPORT_ERROR, comp_id, (netcdf_file_object->get_file_field_string_attribute(SCRIP_CENTER_LAT_LABEL, "unit", unit_center_lat, data_type_temp, comm, is_root_proc) || netcdf_file_object->get_file_field_string_attribute(SCRIP_CENTER_LAT_LABEL, "units", unit_center_lat, data_type_temp, comm, is_root_proc)) && words_are_the_same(data_type_temp, DATA_TYPE_STRING), "Error happens when registering an H2D grid \"%s\" (the corresponding model code annotation is \"%s\") through the API CCPL_register_H2D_grid_via_data_file: fail to get the unit of variable \"%s\" from the data file \"%s\": it does not exist or its type is not string", grid_name, annotation, SCRIP_CENTER_LAT_LABEL, data_file_name);
-	EXECUTION_REPORT(REPORT_ERROR, comp_id, netcdf_file_object->get_file_field_string_attribute(NULL, "min_lon", min_lon, data_type_temp, comm, is_root_proc) && (words_are_the_same(data_type_temp, DATA_TYPE_FLOAT) || words_are_the_same(data_type_temp, DATA_TYPE_DOUBLE)), "Error happens when registering an H2D grid \"%s\" (the corresponding model code annotation is \"%s\") through the API CCPL_register_H2D_grid_via_data_file: fail to get the value of the global attribute \"min_lon\" from the data file \"%s\": it does not exist or its type is not float or double", grid_name, annotation, data_file_name);
-	transform_datatype_of_arrays(min_lon, min_lon, data_type_temp, data_type_for_center_lon, 1);
-	EXECUTION_REPORT(REPORT_ERROR, comp_id, netcdf_file_object->get_file_field_string_attribute(NULL, "max_lon", max_lon, data_type_temp, comm, is_root_proc) && (words_are_the_same(data_type_temp, DATA_TYPE_FLOAT) || words_are_the_same(data_type_temp, DATA_TYPE_DOUBLE)), "Error happens when registering an H2D grid \"%s\" (the corresponding model code annotation is \"%s\") through the API CCPL_register_H2D_grid_via_data_file: fail to get the value of the global attribute \"max_lon\" from the data file \"%s\": it does not exist or its type is not float or double", grid_name, annotation, data_file_name);
-	transform_datatype_of_arrays(max_lon, max_lon, data_type_temp, data_type_for_center_lon, 1);
-	EXECUTION_REPORT(REPORT_ERROR, comp_id, netcdf_file_object->get_file_field_string_attribute(NULL, "min_lat", min_lat, data_type_temp, comm, is_root_proc) && (words_are_the_same(data_type_temp, DATA_TYPE_FLOAT) || words_are_the_same(data_type_temp, DATA_TYPE_DOUBLE)), "Error happens when registering an H2D grid \"%s\" (the corresponding model code annotation is \"%s\") through the API CCPL_register_H2D_grid_via_data_file: fail to get the value of the global attribute \"min_lat\" from the data file \"%s\": it does not exist or its type is not float or double", grid_name, annotation, data_file_name);	
-	transform_datatype_of_arrays(min_lat, min_lat, data_type_temp, data_type_for_center_lon, 1);
-	EXECUTION_REPORT(REPORT_ERROR, comp_id, netcdf_file_object->get_file_field_string_attribute(NULL, "max_lat", max_lat, data_type_temp, comm, is_root_proc) && (words_are_the_same(data_type_temp, DATA_TYPE_FLOAT) || words_are_the_same(data_type_temp, DATA_TYPE_DOUBLE)), "Error happens when registering an H2D grid \"%s\" (the corresponding model code annotation is \"%s\") through the API CCPL_register_H2D_grid_via_data_file: fail to get the value of the global attribute \"max_lat\" from the data file \"%s\": it does not exist or its type is not float or double", grid_name, annotation, data_file_name);
-	transform_datatype_of_arrays(max_lat, max_lat, data_type_temp, data_type_for_center_lon, 1);
-	EXECUTION_REPORT(REPORT_ERROR, comp_id, words_are_the_same(unit_center_lon,unit_center_lat), "Error happens when registering an H2D grid \"%s\" (the corresponding model code annotation is \"%s\") through the API CCPL_register_H2D_grid_via_data_file: in the data file \"%s\", the units of variables \"lon\" and \"lat\" are different", grid_name, annotation, data_file_name);
-	if (vertex_lon != NULL) {
-		EXECUTION_REPORT(REPORT_ERROR, comp_id, netcdf_file_object->get_file_field_string_attribute(SCRIP_VERTEX_LON_LABEL, "unit", unit_vertex_lon, data_type_temp, comm, is_root_proc) || netcdf_file_object->get_file_field_string_attribute(SCRIP_VERTEX_LON_LABEL, "units", unit_vertex_lon, data_type_temp, comm, is_root_proc), "Error happens when registering an H2D grid \"%s\" (the corresponding model code annotation is \"%s\") through the API CCPL_register_H2D_grid_via_data_file: fail to get the unit of variable \"vertex_lon\" from the data file \"%s\": it does not exist or its type is not string", grid_name, annotation, data_file_name);
-		EXECUTION_REPORT(REPORT_ERROR, comp_id, netcdf_file_object->get_file_field_string_attribute(SCRIP_VERTEX_LAT_LABEL, "unit", unit_vertex_lat, data_type_temp, comm, is_root_proc) || netcdf_file_object->get_file_field_string_attribute(SCRIP_VERTEX_LAT_LABEL, "units", unit_vertex_lat, data_type_temp, comm, is_root_proc), "Error happens when registering an H2D grid \"%s\" (the corresponding model code annotation is \"%s\") through the API CCPL_register_H2D_grid_via_data_file: fail to get the unit of variable \"vertex_lat\" from the data file \"%s\": it does not exist or its type is not string", grid_name, annotation, data_file_name);
-		EXECUTION_REPORT(REPORT_ERROR, comp_id, words_are_the_same(unit_center_lon,unit_vertex_lon), "Error happens when registering an H2D grid \"%s\" (the corresponding model code annotation is \"%s\") through the API CCPL_register_H2D_grid_via_data_file: in the data file \"%s\", the units of variables \"lon\" and \"vertex_lon\" are different", grid_name, annotation, data_file_name);
-		EXECUTION_REPORT(REPORT_ERROR, comp_id, words_are_the_same(unit_center_lat,unit_vertex_lat), "Error happens when registering an H2D grid \"%s\" (the corresponding model code annotation is \"%s\") through the API CCPL_register_H2D_grid_via_data_file: in the data file \"%s\", the units of variables \"lat\" and \"vertex_lat\" are different", grid_name, annotation, data_file_name);
+int Original_grid_mgt::register_V1D_grid_via_data(int API_id, int comp_id, const char *grid_name, int grid_type, const char *coord_unit, int grid_size, 
+                                                  double value1, const double *value2, const double *value3, const char *annotation)
+{
+    char full_grid_name[NAME_STR_SIZE];
+    Remap_grid_class *CoR_V1D_grid;
+    
+    
+    check_API_parameter_int(comp_id, API_id, comp_comm_group_mgt_mgr->get_comm_group_of_local_comp(comp_id,"in register_V1D_grid_via_data"), NULL, grid_size, "implicit grid size", annotation);
+    check_API_parameter_data_array(comp_id, API_id, comp_comm_group_mgt_mgr->get_comm_group_of_local_comp(comp_id,"in register_V1D_grid_via_data"), "registering a V1D grid", 1, sizeof(double), (const char*)(&value1), "floating-point parameters", annotation);
+	if (value2 != NULL)
+	    check_API_parameter_data_array(comp_id, API_id, comp_comm_group_mgt_mgr->get_comm_group_of_local_comp(comp_id,"in register_V1D_grid_via_data"), "registering a V1D grid", grid_size, sizeof(double), (const char*)(value2), "floating-point parameters", annotation);
+	if (value3 != NULL)
+	    check_API_parameter_data_array(comp_id, API_id, comp_comm_group_mgt_mgr->get_comm_group_of_local_comp(comp_id,"in register_V1D_grid_via_data"), "registering a V1D grid", grid_size, sizeof(double), (const char*)(value3), "floating-point parameters", annotation);
+
+    sprintf(full_grid_name, "%s@%s", grid_name, comp_comm_group_mgt_mgr->get_global_node_of_local_comp(comp_id,false,"in register_V1D_grid_via_data")->get_full_name());
+	if (grid_type == 0)
+		CoR_V1D_grid = new Remap_grid_class(full_grid_name, COORD_LABEL_TRACER, "", NULL, grid_size);
+	else if (grid_type <= 4)
+		CoR_V1D_grid = new Remap_grid_class(full_grid_name, COORD_LABEL_LEV, coord_unit, NULL, grid_size);
+	switch(grid_type) {
+		case 1:
+			CoR_V1D_grid->read_grid_data_from_array("center", COORD_LABEL_LEV, DATA_TYPE_DOUBLE, (const char*)value2, 0);
+			break;
+		case 2:
+			CoR_V1D_grid->set_lev_grid_sigma_info(value1, value2, NULL, 1.0);
+			break;
+		case 3:
+			CoR_V1D_grid->set_lev_grid_sigma_info(value1, value2, value3, 1.0);
+			break;
+		default:
+			break;
 	}
 
-	grid_id = register_H2D_grid_via_global_data(comp_id, grid_name, edge_type, unit_center_lon, cyclic_or_acyclic, data_type_for_center_lon, dim_size1, dim_size2,size_center_lon, size_center_lat,
-										 size_mask, size_area, size_vertex_lon, size_vertex_lat, min_lon, max_lon, min_lat, max_lat, center_lon, center_lat, mask, area, vertex_lon, vertex_lat, annotation, API_ID_GRID_MGT_REG_H2D_GRID_VIA_FILE);
-
-	delete [] center_lon;
-	delete [] center_lat;
-	if (vertex_lon != NULL) {
-		delete [] vertex_lon;
-		delete [] vertex_lat;
-	}
-	if (mask != NULL)
-		delete [] mask;
-	if (area != NULL)
-		delete [] area;
+    original_grids.push_back(new Original_grid_info(comp_id, original_grids.size()|TYPE_GRID_LOCAL_ID_PREFIX, grid_name, annotation, CoR_V1D_grid, true));
 
-	return grid_id;
+    remap_grid_manager->add_remap_grid(CoR_V1D_grid);
+    
+    return original_grids[original_grids.size()-1]->get_grid_id();    
 }
 
 
-int Original_grid_mgt::register_V1D_grid_via_data(int API_id, int comp_id, const char *grid_name, int grid_type, const char *coord_unit, int grid_size, 
-	                                              double value1, const double *value2, const double *value3, const char *annotation)
+int Original_grid_mgt::register_md_grid_via_multi_grids(int comp_id, const char *grid_name, int sub_grid1_id, int sub_grid2_id, int sub_grid3_id, int size_mask, int *mask, const char *annotation)
 {
-	char full_grid_name[NAME_STR_SIZE];
-	Remap_grid_class *CoR_V1D_grid;
-	
-	
-	check_API_parameter_int(comp_id, API_id, comp_comm_group_mgt_mgr->get_comm_group_of_local_comp(comp_id,"in register_V1D_grid_via_data"), NULL, grid_size, "implicit grid size", annotation);
-	check_API_parameter_data_array(comp_id, API_id, comp_comm_group_mgt_mgr->get_comm_group_of_local_comp(comp_id,"in register_V1D_grid_via_data"), "registering a V1D grid", 1, sizeof(double), (const char*)(&value1), "floating-point parameters", annotation);
-	check_API_parameter_data_array(comp_id, API_id, comp_comm_group_mgt_mgr->get_comm_group_of_local_comp(comp_id,"in register_V1D_grid_via_data"), "registering a V1D grid", grid_size, sizeof(double), (const char*)(value2), "floating-point parameters", annotation);
-	check_API_parameter_data_array(comp_id, API_id, comp_comm_group_mgt_mgr->get_comm_group_of_local_comp(comp_id,"in register_V1D_grid_via_data"), "registering a V1D grid", grid_size, sizeof(double), (const char*)(value3), "floating-point parameters", annotation);
-
-	sprintf(full_grid_name, "%s@%s", grid_name, comp_comm_group_mgt_mgr->get_global_node_of_local_comp(comp_id,false,"in register_V1D_grid_via_data")->get_full_name());
-	CoR_V1D_grid = new Remap_grid_class(full_grid_name, COORD_LABEL_LEV, coord_unit, NULL, grid_size);
-	if (grid_type == 1)
-		CoR_V1D_grid->read_grid_data_from_array("center", COORD_LABEL_LEV, DATA_TYPE_DOUBLE, (const char*)value2, 0);
-	else if (grid_type == 2)
-		CoR_V1D_grid->set_lev_grid_sigma_info(value1, value2, NULL, 1.0);
-	else CoR_V1D_grid->set_lev_grid_sigma_info(value1, value2, value3, 1.0);
-
-	original_grids.push_back(new Original_grid_info(comp_id, original_grids.size()|TYPE_GRID_LOCAL_ID_PREFIX, grid_name, annotation, CoR_V1D_grid, true));
-
-	remap_grid_manager->add_remap_grid(CoR_V1D_grid);
-	
-	return original_grids[original_grids.size()-1]->get_grid_id();	
+    int num_sub_grids = 2, num_H2D_grid = 0, num_V1D_grid = 0, num_T1D_grid = 0;
+    char full_grid_name[NAME_STR_SIZE];
+    Remap_grid_class *CoR_MD_grid, *sub_grids[3];
+
+    
+    MPI_Comm local_comm = comp_comm_group_mgt_mgr->get_comm_group_of_local_comp(comp_id, "in Original_grid_mgt::register_md_grid_via_multi_grids");
+    EXECUTION_REPORT(REPORT_ERROR, comp_id, original_grid_mgr->is_grid_id_legal(sub_grid1_id), "Error happens when calling the API \"CCPL_register_MD_grid_via_multi_grids\" to register a multi-dimension grid \"%s\": \"sub_grid1_id\" (currently 0x%x) is wrong. Please check the model code related to the annotation \"%s\".", grid_name, sub_grid1_id, annotation);
+    EXECUTION_REPORT(REPORT_ERROR, comp_id, original_grid_mgr->get_comp_id_of_grid(sub_grid1_id) == comp_id, "Error happens when calling the API \"CCPL_register_MD_grid_via_multi_grids\" to register a multi-dimension grid \"%s\": the component model corresponding to the grid with id of \"sub_grid1_id\" is different from the current component with the id of comp_id. Please check the model code related to the annotation \"%s\".", grid_name, annotation);
+    check_API_parameter_string(comp_id, API_ID_GRID_MGT_REG_MD_GRID_VIA_MULTI_GRIDS, local_comm, "for registering a multi-dimension grid", original_grid_mgr->get_name_of_grid(sub_grid1_id), "\"sub_grid1_id\" (the corresponding grid name)", annotation);        
+    EXECUTION_REPORT(REPORT_ERROR, comp_id, original_grid_mgr->is_grid_id_legal(sub_grid2_id), "Error happens when calling the API \"CCPL_register_MD_grid_via_multi_grids\" to register a multi-dimension grid \"%s\": \"sub_grid2_id\" is wrong. Please check the model code related to the annotation \"%s\".", grid_name, annotation);
+    EXECUTION_REPORT(REPORT_ERROR, comp_id, original_grid_mgr->get_comp_id_of_grid(sub_grid2_id) == comp_id, "Error happens when calling the API \"CCPL_register_MD_grid_via_multi_grids\" to register a multi-dimension grid \"%s\": the component corresponding to the grid with id of \"sub_grid2_id\" is different from the current component with the id of comp_id. Please check the model code related to the annotation \"%s\".", grid_name, annotation);
+    check_API_parameter_data_array(comp_id, API_ID_GRID_MGT_REG_MD_GRID_VIA_MULTI_GRIDS, comp_comm_group_mgt_mgr->get_comm_group_of_local_comp(comp_id,"in register_h2d_grid_with_data"), "registering a multi-dimension grid", size_mask, sizeof(int), (const char*)mask, "mask", annotation);    
+    check_API_parameter_string(comp_id, API_ID_GRID_MGT_REG_MD_GRID_VIA_MULTI_GRIDS, local_comm, "for registering a multi-dimension grid", original_grid_mgr->get_name_of_grid(sub_grid2_id), "\"sub_grid2_id\" (the corresponding grid name)", annotation);
+    sub_grids[0] = original_grid_mgr->get_original_CoR_grid(sub_grid1_id);
+    sub_grids[1] = original_grid_mgr->get_original_CoR_grid(sub_grid2_id);
+    int have_sub_grid3 = sub_grid3_id != -1? 1: 0;
+    check_API_parameter_int(comp_id, API_ID_GRID_MGT_REG_MD_GRID_VIA_MULTI_GRIDS, local_comm, NULL, have_sub_grid3, "\"sub_grid3_id\" (specified or not)", annotation);
+    if (sub_grid3_id != -1) {
+        EXECUTION_REPORT(REPORT_ERROR, comp_id, original_grid_mgr->is_grid_id_legal(sub_grid3_id), "Error happens when calling the API \"CCPL_register_MD_grid_via_multi_grids\" to register a multi-dimension grid \"%s\": \"sub_grid3_id\" is wrong. Please check the model code related to the annotation \"%s\".", grid_name, annotation);        
+        check_API_parameter_string(comp_id, API_ID_GRID_MGT_REG_MD_GRID_VIA_MULTI_GRIDS, local_comm, "for registering a multi-dimension grid", original_grid_mgr->get_name_of_grid(sub_grid3_id), "\"sub_grid3_id\" (the corresponding grid name)", annotation);
+        EXECUTION_REPORT(REPORT_ERROR, comp_id, original_grid_mgr->get_comp_id_of_grid(sub_grid3_id) == comp_id, "Error happens when calling the API \"CCPL_register_MD_grid_via_multi_grids\" to register a multi-dimension grid \"%s\": the component corresponding to the grid with id of \"sub_grid3_id\" is different from the current component with the id of comp_id. Please check the model code related to the annotation \"%s\".", grid_name, annotation);
+        sub_grids[num_sub_grids++] = original_grid_mgr->get_original_CoR_grid(sub_grid3_id);
+    }    
+
+    for (int i = 0; i < num_sub_grids; i ++)
+        if (sub_grids[i]->get_is_sphere_grid())
+            num_H2D_grid ++;
+        else if (sub_grids[i]->has_grid_coord_label(COORD_LABEL_LEV))
+            num_V1D_grid ++;
+        else if (sub_grids[i]->has_grid_coord_label(COORD_LABEL_TIME))
+            num_T1D_grid ++;
+        else EXECUTION_REPORT(REPORT_ERROR, comp_id, false, "Error happens when calling the API \"CCPL_register_MD_grid_via_multi_grids\" to register a multi-dimension grid \"%s\": grid \"%s\" cannot be used to generate a multi-dimension grid. Please check the model code related to the annotation \"%s\".", grid_name, sub_grids[i]->get_grid_name(), annotation);
+
+    EXECUTION_REPORT(REPORT_ERROR, comp_id, num_H2D_grid <= 1, "Error happens when calling the API \"CCPL_register_MD_grid_via_multi_grids\" to register a multi-dimension grid \"%s\": more than one H2D grid are used to generate a multi-dimension grid. Please check the model code related to the annotation \"%s\".", grid_name, annotation);
+    EXECUTION_REPORT(REPORT_ERROR, comp_id, num_V1D_grid <= 1, "Error happens when calling the API \"CCPL_register_MD_grid_via_multi_grids\" to register a multi-dimension grid \"%s\": more than one V1D grid are used to generate a multi-dimension grid. Please check the model code related to the annotation \"%s\".", grid_name, annotation);
+    EXECUTION_REPORT(REPORT_ERROR, comp_id, num_T1D_grid <= 1, "Error happens when calling the API \"CCPL_register_MD_grid_via_multi_grids\" to register a multi-dimension grid \"%s\": more than one T1D grid are used to generate a multi-dimension grid. Please check the model code related to the annotation \"%s\".", grid_name, annotation);
+    
+    sprintf(full_grid_name, "%s@%s", grid_name, comp_comm_group_mgt_mgr->get_global_node_of_local_comp(comp_id,false,"register_md_grid_via_multi_grids")->get_full_name());
+    CoR_MD_grid = new Remap_grid_class(full_grid_name, num_sub_grids, sub_grids, 0);
+    if (size_mask > 0)    {
+        EXECUTION_REPORT(REPORT_ERROR, comp_id, size_mask == CoR_MD_grid->get_grid_size(), "Error happens when calling the API \"CCPL_register_MD_grid_via_multi_grids\" to register a multi-dimension grid \"%s\": the array size (currently is %d) of \"mask\" is different from the grid size (currently is %d). Please check the model code related to the annotation \"%s\".", grid_name, size_mask, CoR_MD_grid->get_grid_size(), annotation);
+        EXECUTION_REPORT(REPORT_ERROR, comp_id, are_array_values_between_boundaries("integer", mask, size_mask, 0, 1, 0, false), "Error happens when calling the API \"CCPL_register_MD_grid_via_multi_grids\" to register a multi-dimension grid \"%s\": some values of the parameter \"mask\" are wrong (not 0 and 1). Please check the model code related to the annotation \"%s\".", grid_name, annotation);
+        CoR_MD_grid->read_grid_data_from_array("mask", "mask", DATA_TYPE_INT, (const char*)mask, 0);
+    }    
+
+    original_grids.push_back(new Original_grid_info(comp_id, original_grids.size()|TYPE_GRID_LOCAL_ID_PREFIX, grid_name, annotation, CoR_MD_grid, true));    
+    remap_grid_manager->add_remap_grid(CoR_MD_grid);
+    
+    return original_grids[original_grids.size()-1]->get_grid_id();
 }
 
 
-int Original_grid_mgt::register_md_grid_via_multi_grids(int comp_id, const char *grid_name, int sub_grid1_id, int sub_grid2_id, int sub_grid3_id, int size_mask, int *mask, const char *annotation)
+void Original_grid_mgt::set_3D_grid_3D_vertical_coord_field_inst(int grid_id, int field_id, const char *static_or_dynamic, const char *annotation)
 {
-	int num_sub_grids = 2, num_H2D_grid = 0, num_V1D_grid = 0, num_T1D_grid = 0;
-	char full_grid_name[NAME_STR_SIZE];
-	Remap_grid_class *CoR_MD_grid, *sub_grids[3];
-
-	
-	MPI_Comm local_comm = comp_comm_group_mgt_mgr->get_comm_group_of_local_comp(comp_id, "in Original_grid_mgt::register_md_grid_via_multi_grids");
-	EXECUTION_REPORT(REPORT_ERROR, comp_id, original_grid_mgr->is_grid_id_legal(sub_grid1_id), "Error happends when calling the API \"CCPL_register_MD_grid_via_multi_grids\" to register a multi-dimension grid \"%s\": \"sub_grid1_id\" (currently 0x%x) is wrong. Please check the model code related to the annotation \"%s\".", grid_name, sub_grid1_id, annotation);
-	EXECUTION_REPORT(REPORT_ERROR, comp_id, original_grid_mgr->get_comp_id_of_grid(sub_grid1_id) == comp_id, "Error happends when calling the API \"CCPL_register_MD_grid_via_multi_grids\" to register a multi-dimension grid \"%s\": the component model corresponding to the grid with id of \"sub_grid1_id\" is different from the current component with the id of comp_id. Please check the model code related to the annotation \"%s\".", grid_name, annotation);
-	check_API_parameter_string(comp_id, API_ID_GRID_MGT_REG_MD_GRID_VIA_MULTI_GRIDS, local_comm, "for registering a multi-dimension grid", original_grid_mgr->get_name_of_grid(sub_grid1_id), "\"sub_grid1_id\" (the corresponding grid name)", annotation);		
-	EXECUTION_REPORT(REPORT_ERROR, comp_id, original_grid_mgr->is_grid_id_legal(sub_grid2_id), "Error happends when calling the API \"CCPL_register_MD_grid_via_multi_grids\" to register a multi-dimension grid \"%s\": \"sub_grid2_id\" is wrong. Please check the model code related to the annotation \"%s\".", grid_name, annotation);
-	EXECUTION_REPORT(REPORT_ERROR, comp_id, original_grid_mgr->get_comp_id_of_grid(sub_grid2_id) == comp_id, "Error happends when calling the API \"CCPL_register_MD_grid_via_multi_grids\" to register a multi-dimension grid \"%s\": the component corresponding to the grid with id of \"sub_grid2_id\" is different from the current component with the id of comp_id. Please check the model code related to the annotation \"%s\".", grid_name, annotation);
-	check_API_parameter_data_array(comp_id, API_ID_GRID_MGT_REG_MD_GRID_VIA_MULTI_GRIDS, comp_comm_group_mgt_mgr->get_comm_group_of_local_comp(comp_id,"in register_h2d_grid_with_data"), "registering a multi-dimension grid", size_mask, sizeof(int), (const char*)mask, "mask", annotation);	
-	check_API_parameter_string(comp_id, API_ID_GRID_MGT_REG_MD_GRID_VIA_MULTI_GRIDS, local_comm, "for registering a multi-dimension grid", original_grid_mgr->get_name_of_grid(sub_grid2_id), "\"sub_grid2_id\" (the corresponding grid name)", annotation);
-	sub_grids[0] = original_grid_mgr->get_original_CoR_grid(sub_grid1_id);
-	sub_grids[1] = original_grid_mgr->get_original_CoR_grid(sub_grid2_id);
-	int have_sub_grid3 = sub_grid3_id != -1? 1: 0;
-	check_API_parameter_int(comp_id, API_ID_GRID_MGT_REG_MD_GRID_VIA_MULTI_GRIDS, local_comm, NULL, have_sub_grid3, "\"sub_grid3_id\" (specified or not)", annotation);
-	if (sub_grid3_id != -1) {
-		EXECUTION_REPORT(REPORT_ERROR, comp_id, original_grid_mgr->is_grid_id_legal(sub_grid3_id), "Error happends when calling the API \"CCPL_register_MD_grid_via_multi_grids\" to register a multi-dimension grid \"%s\": \"sub_grid3_id\" is wrong. Please check the model code related to the annotation \"%s\".", grid_name, annotation);		
-		check_API_parameter_string(comp_id, API_ID_GRID_MGT_REG_MD_GRID_VIA_MULTI_GRIDS, local_comm, "for registering a multi-dimension grid", original_grid_mgr->get_name_of_grid(sub_grid3_id), "\"sub_grid3_id\" (the corresponding grid name)", annotation);
-		EXECUTION_REPORT(REPORT_ERROR, comp_id, original_grid_mgr->get_comp_id_of_grid(sub_grid3_id) == comp_id, "Error happends when calling the API \"CCPL_register_MD_grid_via_multi_grids\" to register a multi-dimension grid \"%s\": the component corresponding to the grid with id of \"sub_grid3_id\" is different from the current component with the id of comp_id. Please check the model code related to the annotation \"%s\".", grid_name, annotation);
-		sub_grids[num_sub_grids++] = original_grid_mgr->get_original_CoR_grid(sub_grid3_id);
-	}	
-
-	for (int i = 0; i < num_sub_grids; i ++)
-		if (sub_grids[i]->get_is_sphere_grid())
-			num_H2D_grid ++;
-		else if (sub_grids[i]->has_grid_coord_label(COORD_LABEL_LEV))
-			num_V1D_grid ++;
-		else if (sub_grids[i]->has_grid_coord_label(COORD_LABEL_TIME))
-			num_T1D_grid ++;
-		else EXECUTION_REPORT(REPORT_ERROR, comp_id, false, "Error happends when calling the API \"CCPL_register_MD_grid_via_multi_grids\" to register a multi-dimension grid \"%s\": grid \"%s\" cannot be used to generate a multi-dimension grid. Please check the model code related to the annotation \"%s\".", grid_name, annotation);
-
-	EXECUTION_REPORT(REPORT_ERROR, comp_id, num_H2D_grid <= 1, "Error happends when calling the API \"CCPL_register_MD_grid_via_multi_grids\" to register a multi-dimension grid \"%s\": more than one H2D grid are used to generate a multi-dimension grid. Please check the model code related to the annotation \"%s\".", grid_name, annotation);
-	EXECUTION_REPORT(REPORT_ERROR, comp_id, num_V1D_grid <= 1, "Error happends when calling the API \"CCPL_register_MD_grid_via_multi_grids\" to register a multi-dimension grid \"%s\": more than one V1D grid are used to generate a multi-dimension grid. Please check the model code related to the annotation \"%s\".", grid_name, annotation);
-	EXECUTION_REPORT(REPORT_ERROR, comp_id, num_T1D_grid <= 1, "Error happends when calling the API \"CCPL_register_MD_grid_via_multi_grids\" to register a multi-dimension grid \"%s\": more than one T1D grid are used to generate a multi-dimension grid. Please check the model code related to the annotation \"%s\".", grid_name, annotation);
-	
-	sprintf(full_grid_name, "%s@%s", grid_name, comp_comm_group_mgt_mgr->get_global_node_of_local_comp(comp_id,false,"register_md_grid_via_multi_grids")->get_full_name());
-	CoR_MD_grid = new Remap_grid_class(full_grid_name, num_sub_grids, sub_grids, 0);
-	if (size_mask > 0)	{
-		EXECUTION_REPORT(REPORT_ERROR, comp_id, size_mask == CoR_MD_grid->get_grid_size(), "Error happends when calling the API \"CCPL_register_MD_grid_via_multi_grids\" to register a multi-dimension grid \"%s\": the array size (currently is %d) of \"mask\" is different from the grid size (currently is %d). Please check the model code related to the annotation \"%s\".", grid_name, size_mask, CoR_MD_grid->get_grid_size(), annotation);
-		EXECUTION_REPORT(REPORT_ERROR, comp_id, are_array_values_between_boundaries("integer", mask, size_mask, 0, 1, 0, false), "Error happends when calling the API \"CCPL_register_MD_grid_via_multi_grids\" to register a multi-dimension grid \"%s\": some values of the parameter \"mask\" are wrong (not 0 and 1). Please check the model code related to the annotation \"%s\".", grid_name, annotation);
-		CoR_MD_grid->read_grid_data_from_array("mask", "mask", DATA_TYPE_INT, (const char*)mask, 0);
-	}	
-
-	original_grids.push_back(new Original_grid_info(comp_id, original_grids.size()|TYPE_GRID_LOCAL_ID_PREFIX, grid_name, annotation, CoR_MD_grid, true));	
-	remap_grid_manager->add_remap_grid(CoR_MD_grid);
-	
-	return original_grids[original_grids.size()-1]->get_grid_id();
+	char API_label[NAME_STR_SIZE];
+	Original_grid_info *original_grid;
+	Field_mem_info *field_inst;
+	int comp_id;
+	MPI_Comm local_comm;
+
+
+	get_API_hint(-1, API_ID_GRID_MGT_SET_3D_GRID_3D_VERT_FLD, API_label); 
+	EXECUTION_REPORT_ERROR_OPTIONALLY(REPORT_ERROR, -1, is_grid_id_legal(grid_id), "Error happens when calling the API \"CCPL_set_3D_grid_3D_vertical_coord_field\" to set the 3-D vertical coordinate field of a 3-D grid: the parameter of \"grid_id\" is wrong. Please verify the model code with the annotation \"%s\".", annotation);
+	original_grid = original_grid_mgr->get_original_grid(grid_id);
+	comp_id = original_grid->get_comp_id();
+    local_comm = comp_comm_group_mgt_mgr->get_comm_group_of_local_comp(comp_id, "in Original_grid_mgt::set_3D_grid_3D_vertical_coord_field_inst");
+    check_API_parameter_string(comp_id, API_ID_GRID_MGT_SET_3D_GRID_3D_VERT_FLD, local_comm, "setting the 3-D vertical coordinate field of a 3-D grid", original_grid->get_grid_name(), "\"grid_id\" (the name of the 3-D grid)", annotation);
+    EXECUTION_REPORT_ERROR_OPTIONALLY(REPORT_ERROR, comp_id, original_grid->is_3D_grid(), "Error happens when calling the API \"%s\" to set the 3-D vertical coordinate field of the grid \"%s\": this grid is not a 3-D grid. Please check the model code related to the annotation \"%s\".", API_label, original_grid->get_grid_name(), annotation);
+	EXECUTION_REPORT_ERROR_OPTIONALLY(REPORT_ERROR, comp_id, !original_grid->get_original_CoR_grid()->is_sigma_grid(), "Error happens when calling the API \"%s\" to set the 3-D vertical coordinate field of the grid \"%s\": cannot set a 3-D vertical field to this grid because its V1D sub grid is a SIGMA or HYBRID grid. Please verify the model code with the annotation \"%s\".", API_label, original_grid->get_grid_name(), annotation);
+	EXECUTION_REPORT_ERROR_OPTIONALLY(REPORT_ERROR, comp_id, !original_grid->get_original_CoR_grid()->does_use_V3D_level_coord(), "Error happens when calling the API \"%s\" to set the 3-D vertical coordinate field of the grid \"%s\": cannot set a 3-D vertical field to this grid because its vertical coordinate values have already been set. Please verify the model code with the annotation \"%s\".", API_label, original_grid->get_grid_name(), annotation);
+	EXECUTION_REPORT_ERROR_OPTIONALLY(REPORT_ERROR, comp_id, memory_manager->check_is_legal_field_instance_id(field_id), "Error happens when calling the API \"%s\" to set the 3-D vertical coordinate field of the grid \"%s\": the parameter of \"field_id\" is wrong. Please verify the model code with the annotation \"%s\".", API_label, original_grid->get_grid_name(), annotation);
+	check_API_parameter_field_instance(comp_id, API_ID_GRID_MGT_SET_3D_GRID_3D_VERT_FLD, local_comm, "setting the 3-D vertical coordinate field of a 3-D grid", field_id, "\"field_id\" (the corresponding 3-D field)", annotation);
+	field_inst = memory_manager->get_field_instance(field_id);
+	EXECUTION_REPORT_ERROR_OPTIONALLY(REPORT_ERROR, comp_id, field_inst->get_grid_id() == grid_id, "Error happens when calling the API \"CCPL_set_3D_grid_3D_vertical_coord_field\" to set the 3-D vertical coordinate field of the 3-D grid \"%s\": the given field instance is not on the given 3-D grid. Please verify the model code with the annotation \"%s\".", original_grid->get_grid_name(), annotation);
+	EXECUTION_REPORT_ERROR_OPTIONALLY(REPORT_ERROR, comp_id, words_are_the_same(original_grid->get_original_CoR_grid()->get_a_leaf_grid(COORD_LABEL_LEV)->get_coord_unit(), field_inst->get_unit()), "Error happens when calling the API \"CCPL_set_3D_grid_3D_vertical_coord_field\" to set the 3-D vertical coordinate field of the 3-D grid \"%s\": The unit (\"%s\") of the grid coordinate is different from the unit (\"%s\") of the given field instance (\"%s\"). Please verify the model code with the annotation \"%s\".", original_grid->get_grid_name(), original_grid->get_original_CoR_grid()->get_a_leaf_grid(COORD_LABEL_LEV)->get_coord_unit(), field_inst->get_unit(), field_inst->get_field_name(), annotation);
+	EXECUTION_REPORT_ERROR_OPTIONALLY(REPORT_ERROR, comp_id, words_are_the_same(static_or_dynamic, "constant") || words_are_the_same(static_or_dynamic, "variable"), "Error happens when calling the API \"CCPL_set_3D_grid_3D_vertical_coord_field\" to set the 3-D vertical coordinate field of the 3-D grid \"%s\": the input parameter of \"label\" (the current value is \"%s\") must be \"constant\" or \"variable\". Please verify the model code with the annotation \"%s\".", original_grid->get_grid_name(), static_or_dynamic, annotation);
+    check_API_parameter_string(comp_id, API_ID_GRID_MGT_SET_3D_GRID_3D_VERT_FLD, local_comm, "setting the 3-D vertical coordinate field of a 3-D grid", original_grid->get_grid_name(), "\"label\" (specification for constant or variable of 3-D field)", annotation);
+    if (original_grid->get_V3D_lev_field_variation_type() != BOTTOM_FIELD_VARIATION_UNSET)
+        EXECUTION_REPORT(REPORT_ERROR, comp_id, false, "Error happens when calling the API \"%s\" to set the 3-D vertical coordinate field of the 3-D grid \"%s\": the 3-D vertical coordinate field has been set before at the model code with the annotation \"%s\" and cannot be set again at the model code with the annotation \"%s\".", API_label, original_grid->get_grid_name(), annotation_mgr->get_annotation(grid_id, "set 3-D level field"), annotation);
+	original_grid->set_unique_3D_lev_field(field_id, static_or_dynamic, annotation);	
+	original_grid->get_original_CoR_grid()->set_using_V3D_level_coord();
+	decomp_grids_mgr->set_decomp_grids_using_3D_level_coord(original_grid->get_original_CoR_grid());
 }
 
 
 void Original_grid_mgt::set_3d_grid_bottom_field(int comp_id, int grid_id, int field_id, int static_or_dynamic_or_external, int API_id, const char *API_label, const char *annotation)
 {
-	Original_grid_info *original_grid = original_grid_mgr->get_original_grid(grid_id);
-	Original_grid_info *field_original_grid;
-	MPI_Comm local_comm = comp_comm_group_mgt_mgr->get_comm_group_of_local_comp(comp_id, "in Original_grid_mgt::set_3d_grid_bottom_field");
-
-
-	synchronize_comp_processes_for_API(comp_id, API_id, local_comm, "setting the surface field of a 3-D grid", annotation);
-	check_API_parameter_string(comp_id, API_id, local_comm, "setting the surface field of a 3-D grid", original_grid->get_grid_name(), "\"grid_id\" (the name of the 3-D grid)", annotation);
-	EXECUTION_REPORT(REPORT_ERROR, comp_id, original_grid->is_3D_grid(), "Error happens when calling the API \"%s\" to set the surface field of a 3-D grid \"%s\": this grid is not a 3-D grid. Please check the model code related to the annotation \"%s\".", API_label, original_grid->get_grid_name(), annotation);
-	EXECUTION_REPORT(REPORT_ERROR, comp_id, original_grid->get_original_CoR_grid()->is_sigma_grid(), "Error happens when calling the API \"%s\" to set the surface field of the 3-D grid \"%s\": cannot set the surface field to this grid because its V1D sub grid is not a SIGMA or HYBRID grid. Please check the model code related to the annotation \"%s\".", API_label, original_grid->get_grid_name(), annotation);
-	if (original_grid->get_bottom_field_variation_type() != BOTTOM_FIELD_VARIATION_UNSET)
-		EXECUTION_REPORT(REPORT_ERROR, comp_id, false, "Error happens when calling the API \"%s\" to set the surface field of the 3-D grid \"%s\": the surface field has been set before at the model code with the annotation \"%s\" and cannot be set again at the model code with the annotation \"%s\".", API_label, original_grid->get_grid_name(), annotation_mgr->get_annotation(grid_id, "set surface field"), annotation);
-	if (static_or_dynamic_or_external != BOTTOM_FIELD_VARIATION_EXTERNAL) {
-		check_API_parameter_field_instance(comp_id, API_id, local_comm, "setting the surface field of a 3-D grid", field_id, "\"field_id\" (the corresponding surface field)", annotation);
-		Field_mem_info *field_inst = memory_manager->get_field_instance(field_id);
-		EXECUTION_REPORT(REPORT_ERROR, comp_id, field_inst->get_grid_id() != -1, "Error happens when calling the API \"%s\" to set the surface field of the 3-D grid \"%s\": the surface field \"%s\" is not on a grid. Please check the model code related to the annotation \"%s\".", API_label, original_grid->get_grid_name(), field_inst->get_field_name(), annotation);
-		field_original_grid = original_grid_mgr->get_original_grid(field_inst->get_grid_id());
-		EXECUTION_REPORT(REPORT_ERROR, comp_id, field_original_grid->is_H2D_grid(), "Error happens when calling the API \"%s\" to set the surface field of the 3-D grid \"%s\": the grid \"%s\" corresponding to the surface field \"%s\" is not a H2D grid. Please check the model code related to the annotation \"%s\".", API_label, original_grid->get_grid_name(), field_original_grid->get_grid_name(), field_inst->get_field_name(), annotation);
-		EXECUTION_REPORT(REPORT_ERROR, comp_id, field_original_grid->get_original_CoR_grid()->is_subset_of_grid(original_grid->get_original_CoR_grid()), "Error happens when calling the API \"%s\" to set the surface field of the 3-D grid \"%s\": the grid \"%s\" corresponding to the surface field \"%s\" is not a sub grid of the 3-D grid. Please check the model code related to the annotation \"%s\".", API_label, original_grid->get_grid_name(), field_original_grid->get_grid_name(), field_inst->get_field_name(), annotation);
-		EXECUTION_REPORT(REPORT_ERROR, comp_id, words_are_the_same(field_inst->get_field_data()->get_grid_data_field()->data_type_in_application, DATA_TYPE_FLOAT) || words_are_the_same(field_inst->get_field_data()->get_grid_data_field()->data_type_in_application, DATA_TYPE_DOUBLE), "Error happens when calling the API \"%s\" to set the surface field of the 3-D grid \"%s\": the data type of the surface field \"%s\" is not floating-point. Please check the model code related to the annotation \"%s\".", API_label, original_grid->get_grid_name(), field_inst->get_field_name(), annotation);
-	}
-	original_grid->set_unique_bottom_field(field_id, static_or_dynamic_or_external, annotation);
-	if (original_grid->get_mid_point_grid() != NULL)
-		original_grid->get_mid_point_grid()->set_unique_bottom_field(field_id, static_or_dynamic_or_external, annotation);
-	if (original_grid->get_interface_level_grid() != NULL)
-		original_grid->get_interface_level_grid()->set_unique_bottom_field(field_id, static_or_dynamic_or_external, annotation);
+    Original_grid_info *original_grid = original_grid_mgr->get_original_grid(grid_id);
+    Original_grid_info *field_original_grid;
+    MPI_Comm local_comm = comp_comm_group_mgt_mgr->get_comm_group_of_local_comp(comp_id, "in Original_grid_mgt::set_3d_grid_bottom_field");
+
+
+    synchronize_comp_processes_for_API(comp_id, API_id, local_comm, "setting the surface field of a 3-D grid", annotation);
+    check_API_parameter_string(comp_id, API_id, local_comm, "setting the surface field of a 3-D grid", original_grid->get_grid_name(), "\"grid_id\" (the name of the 3-D grid)", annotation);
+    EXECUTION_REPORT(REPORT_ERROR, comp_id, original_grid->is_3D_grid(), "Error happens when calling the API \"%s\" to set the surface field of the grid \"%s\": this grid is not a 3-D grid. Please check the model code related to the annotation \"%s\".", API_label, original_grid->get_grid_name(), annotation);
+    EXECUTION_REPORT(REPORT_ERROR, comp_id, original_grid->get_original_CoR_grid()->is_sigma_grid(), "Error happens when calling the API \"%s\" to set the surface field of the 3-D grid \"%s\": cannot set the surface field to this grid because its V1D sub grid is not a SIGMA or HYBRID grid. Please check the model code related to the annotation \"%s\".", API_label, original_grid->get_grid_name(), annotation);
+    if (original_grid->get_bottom_field_variation_type() != BOTTOM_FIELD_VARIATION_UNSET)
+        EXECUTION_REPORT(REPORT_ERROR, comp_id, false, "Error happens when calling the API \"%s\" to set the surface field of the 3-D grid \"%s\": the surface field has been set before at the model code with the annotation \"%s\" and cannot be set again at the model code with the annotation \"%s\".", API_label, original_grid->get_grid_name(), annotation_mgr->get_annotation(grid_id, "set surface field"), annotation);
+    if (static_or_dynamic_or_external != BOTTOM_FIELD_VARIATION_EXTERNAL) {
+        check_API_parameter_field_instance(comp_id, API_id, local_comm, "setting the surface field of a 3-D grid", field_id, "\"field_id\" (the corresponding surface field)", annotation);
+        Field_mem_info *field_inst = memory_manager->get_field_instance(field_id);
+        EXECUTION_REPORT(REPORT_ERROR, comp_id, field_inst->get_grid_id() != -1, "Error happens when calling the API \"%s\" to set the surface field of the 3-D grid \"%s\": the surface field \"%s\" is not on a grid. Please check the model code related to the annotation \"%s\".", API_label, original_grid->get_grid_name(), field_inst->get_field_name(), annotation);
+        field_original_grid = original_grid_mgr->get_original_grid(field_inst->get_grid_id());
+        EXECUTION_REPORT(REPORT_ERROR, comp_id, field_original_grid->is_H2D_grid(), "Error happens when calling the API \"%s\" to set the surface field of the 3-D grid \"%s\": the grid \"%s\" corresponding to the surface field \"%s\" is not a H2D grid. Please check the model code related to the annotation \"%s\".", API_label, original_grid->get_grid_name(), field_original_grid->get_grid_name(), field_inst->get_field_name(), annotation);
+        EXECUTION_REPORT(REPORT_ERROR, comp_id, field_original_grid->get_original_CoR_grid()->is_subset_of_grid(original_grid->get_original_CoR_grid()), "Error happens when calling the API \"%s\" to set the surface field of the 3-D grid \"%s\": the grid \"%s\" corresponding to the surface field \"%s\" is not a sub grid of the 3-D grid. Please check the model code related to the annotation \"%s\".", API_label, original_grid->get_grid_name(), field_original_grid->get_grid_name(), field_inst->get_field_name(), annotation);
+        EXECUTION_REPORT(REPORT_ERROR, comp_id, words_are_the_same(field_inst->get_field_data()->get_grid_data_field()->data_type_in_application, DATA_TYPE_FLOAT) || words_are_the_same(field_inst->get_field_data()->get_grid_data_field()->data_type_in_application, DATA_TYPE_DOUBLE), "Error happens when calling the API \"%s\" to set the surface field of the 3-D grid \"%s\": the data type of the surface field \"%s\" is not floating-point. Please check the model code related to the annotation \"%s\".", API_label, original_grid->get_grid_name(), field_inst->get_field_name(), annotation);
+    }
+    original_grid->set_unique_bottom_field(field_id, static_or_dynamic_or_external, annotation);
+    if (original_grid->get_mid_point_grid() != NULL)
+        original_grid->get_mid_point_grid()->set_unique_bottom_field(field_id, static_or_dynamic_or_external, annotation);
+    if (original_grid->get_interface_level_grid() != NULL)
+        original_grid->get_interface_level_grid()->set_unique_bottom_field(field_id, static_or_dynamic_or_external, annotation);
 }
 
 
 int Original_grid_mgt::get_CoR_defined_grid(int comp_id, const char *grid_name, const char *CoR_grid_name, const char *annotation)
 {
-	Original_grid_info *original_grid;
-	Remap_grid_class *original_CoR_grid;
-	char CoR_script_file_name[NAME_STR_SIZE];
-
-	
-	sprintf(CoR_script_file_name, "%s/CCPL_grid.cor", comp_comm_group_mgt_mgr->get_root_comp_config_dir());
-	original_CoR_grid = remap_grid_manager->search_remap_grid_with_grid_name(CoR_grid_name);
-	if (original_CoR_grid == NULL)
-		if (strlen(CoR_script_name) > 0)
-			EXECUTION_REPORT(REPORT_ERROR, comp_id, false, "Error happens when calling the API \"CCPL_register_CoR_defined_grid\" to register grid \"%s\" based on the CoR grid \"%s\": the CoR script \"%s\" does not define the corresponding CoR grid. Please check the CoR script or the model code corresponding to the annotation \"%s\"",
-				             grid_name, CoR_grid_name, CoR_script_name, annotation);	
-		else EXECUTION_REPORT(REPORT_ERROR, comp_id, false, "Error happens when calling the API \"CCPL_register_CoR_defined_grid\" to register grid \"%s\" based on the CoR grid \"%s\": the CoR script \"%s\" does not exist. Please verify", 
-				              grid_name, CoR_grid_name, CoR_script_file_name);
-	EXECUTION_REPORT(REPORT_ERROR, comp_id, original_CoR_grid->format_sub_grids(original_CoR_grid), "Please modify the definition of grid \"%s\" in the CoR script \"%s\". We propose to order the dimensions of the grid into the order such as lon, lat, level and time");
-	original_CoR_grid->end_grid_definition_stage(NULL);
-	if (original_CoR_grid->get_is_sphere_grid() && are_floating_values_equal(NULL_COORD_VALUE, original_CoR_grid->get_boundary_min_lon()))
-		original_CoR_grid->set_grid_boundary(0, 360.0, -90.0, 90.0);
-	original_grid = new Original_grid_info(comp_id, original_grids.size()|TYPE_GRID_LOCAL_ID_PREFIX, grid_name, annotation, original_CoR_grid, true);
-	original_grids.push_back(original_grid);
-	if (original_grid->get_H2D_sub_CoR_grid() != NULL) {
-		EXECUTION_REPORT(REPORT_ERROR, comp_id, original_CoR_grid->get_grid_center_field(COORD_LABEL_LON) != NULL, "Error happens when calling the API \"CCPL_register_CoR_defined_grid\" to register grid \"%s\" based on the CoR grid \"%s\": the CoR script \"%s\" does not specify the center values of longitude (X) of the CoR grid. Please verify.", grid_name, CoR_grid_name, CoR_script_file_name);
-		EXECUTION_REPORT(REPORT_ERROR, comp_id, original_CoR_grid->get_grid_center_field(COORD_LABEL_LAT) != NULL, "Error happens when calling the API \"CCPL_register_CoR_defined_grid\" to register grid \"%s\" based on the CoR grid \"%s\": the CoR script \"%s\" does not specify the center values of latitude (Y) of the CoR grid. Please verify.", grid_name, CoR_grid_name, CoR_script_file_name);
-	}
-	if (original_grid->get_V1D_sub_CoR_grid() != NULL) {
-		Remap_grid_data_class *level_field = original_CoR_grid->get_grid_center_field(COORD_LABEL_LEV);
-		EXECUTION_REPORT(REPORT_ERROR, comp_id, level_field != NULL && level_field->get_coord_value_grid()->get_grid_size() == original_grid->get_V1D_sub_CoR_grid()->get_grid_size(),
-						 "Error happens when calling the API \"CCPL_register_CoR_defined_grid\" to register grid \"%s\" based on the CoR grid \"%s\": the CoR script \"%s\" does not specify the center values of the vertical coordinate of the CoR grid or the vertical coordinate is not a Z grid. Please verify.", grid_name, CoR_grid_name, CoR_script_file_name);
-	}
-	return original_grid->get_local_grid_id();
+    Original_grid_info *original_grid;
+    Remap_grid_class *original_CoR_grid;
+    char CoR_script_file_name[NAME_STR_SIZE];
+
+    
+    sprintf(CoR_script_file_name, "%s/CCPL_grid.cor", comp_comm_group_mgt_mgr->get_root_comp_config_dir());
+    original_CoR_grid = remap_grid_manager->search_remap_grid_with_grid_name(CoR_grid_name);
+    if (original_CoR_grid == NULL)
+        if (strlen(CoR_script_name) > 0)
+            EXECUTION_REPORT(REPORT_ERROR, comp_id, false, "Error happens when calling the API \"CCPL_register_CoR_defined_grid\" to register grid \"%s\" based on the CoR grid \"%s\": the CoR script \"%s\" does not define the corresponding CoR grid. Please check the CoR script or the model code corresponding to the annotation \"%s\"",
+                             grid_name, CoR_grid_name, CoR_script_name, annotation);    
+        else EXECUTION_REPORT(REPORT_ERROR, comp_id, false, "Error happens when calling the API \"CCPL_register_CoR_defined_grid\" to register grid \"%s\" based on the CoR grid \"%s\": the CoR script \"%s\" does not exist. Please verify", 
+                              grid_name, CoR_grid_name, CoR_script_file_name);
+    EXECUTION_REPORT(REPORT_ERROR, comp_id, original_CoR_grid->format_sub_grids(original_CoR_grid), "Please modify the definition of grid \"%s\" in the CoR script \"%s\". We propose to order the dimensions of the grid into the order such as lon, lat, level and time");
+    original_CoR_grid->end_grid_definition_stage(NULL);
+    if (original_CoR_grid->get_is_sphere_grid() && are_floating_values_equal(NULL_COORD_VALUE, original_CoR_grid->get_boundary_min_lon()))
+        original_CoR_grid->set_grid_boundary(0, 360.0, -90.0, 90.0);
+    original_grid = new Original_grid_info(comp_id, original_grids.size()|TYPE_GRID_LOCAL_ID_PREFIX, grid_name, annotation, original_CoR_grid, true);
+    original_grids.push_back(original_grid);
+    if (original_grid->get_H2D_sub_CoR_grid() != NULL) {
+        EXECUTION_REPORT(REPORT_ERROR, comp_id, original_CoR_grid->get_grid_center_field(COORD_LABEL_LON) != NULL, "Error happens when calling the API \"CCPL_register_CoR_defined_grid\" to register grid \"%s\" based on the CoR grid \"%s\": the CoR script \"%s\" does not specify the center values of longitude (X) of the CoR grid. Please verify.", grid_name, CoR_grid_name, CoR_script_file_name);
+        EXECUTION_REPORT(REPORT_ERROR, comp_id, original_CoR_grid->get_grid_center_field(COORD_LABEL_LAT) != NULL, "Error happens when calling the API \"CCPL_register_CoR_defined_grid\" to register grid \"%s\" based on the CoR grid \"%s\": the CoR script \"%s\" does not specify the center values of latitude (Y) of the CoR grid. Please verify.", grid_name, CoR_grid_name, CoR_script_file_name);
+    }
+    if (original_grid->get_V1D_sub_CoR_grid() != NULL) {
+        Remap_grid_data_class *level_field = original_CoR_grid->get_grid_center_field(COORD_LABEL_LEV);
+        EXECUTION_REPORT(REPORT_ERROR, comp_id, level_field != NULL && level_field->get_coord_value_grid()->get_grid_size() == original_grid->get_V1D_sub_CoR_grid()->get_grid_size(),
+                         "Error happens when calling the API \"CCPL_register_CoR_defined_grid\" to register grid \"%s\" based on the CoR grid \"%s\": the CoR script \"%s\" does not specify the center values of the vertical coordinate of the CoR grid or the vertical coordinate is not a Z grid. Please verify.", grid_name, CoR_grid_name, CoR_script_file_name);
+    }
+    return original_grid->get_local_grid_id();
 }
 
 
 bool Original_grid_mgt::is_grid_id_legal(int grid_id) const
 {
-	int true_grid_id = grid_id & TYPE_ID_SUFFIX_MASK;
+    int true_grid_id = grid_id & TYPE_ID_SUFFIX_MASK;
 
 
-	if ((grid_id & TYPE_ID_PREFIX_MASK) != TYPE_GRID_LOCAL_ID_PREFIX)
-		return false;
+    if ((grid_id & TYPE_ID_PREFIX_MASK) != TYPE_GRID_LOCAL_ID_PREFIX)
+        return false;
 
-	if (true_grid_id < 0 || true_grid_id >= original_grids.size())
-		return false;
+    if (true_grid_id < 0 || true_grid_id >= original_grids.size())
+        return false;
 
-	return true;
+    return true;
 }
 
 
 int Original_grid_mgt::get_comp_id_of_grid(int grid_id) const
 {
-	EXECUTION_REPORT(REPORT_ERROR, -1, is_grid_id_legal(grid_id) && original_grids[grid_id&TYPE_ID_SUFFIX_MASK] != NULL, "Software error in Original_grid_mgt::get_comp_id_of_grid");
-	return original_grids[grid_id&TYPE_ID_SUFFIX_MASK]->get_comp_id();
+    EXECUTION_REPORT(REPORT_ERROR, -1, is_grid_id_legal(grid_id) && original_grids[grid_id&TYPE_ID_SUFFIX_MASK] != NULL, "Software error in Original_grid_mgt::get_comp_id_of_grid");
+    return original_grids[grid_id&TYPE_ID_SUFFIX_MASK]->get_comp_id();
 }
 
 
 const char *Original_grid_mgt::get_name_of_grid(int grid_id) const
 {
-	EXECUTION_REPORT(REPORT_ERROR, -1, is_grid_id_legal(grid_id) && original_grids[grid_id&TYPE_ID_SUFFIX_MASK] != NULL, "Software error in Original_grid_mgt::get_name_of_grid");
-	return original_grids[grid_id&TYPE_ID_SUFFIX_MASK]->get_grid_name();
+    EXECUTION_REPORT(REPORT_ERROR, -1, is_grid_id_legal(grid_id) && original_grids[grid_id&TYPE_ID_SUFFIX_MASK] != NULL, "Software error in Original_grid_mgt::get_name_of_grid");
+    return original_grids[grid_id&TYPE_ID_SUFFIX_MASK]->get_grid_name();
 }
 
 
 Remap_grid_class *Original_grid_mgt::get_original_CoR_grid(int grid_id) const
 {
-	EXECUTION_REPORT(REPORT_ERROR, -1, is_grid_id_legal(grid_id) && original_grids[grid_id&TYPE_ID_SUFFIX_MASK] != NULL, "Software error in Original_grid_mgt::get_original_CoR_grid");
-	return original_grids[grid_id&TYPE_ID_SUFFIX_MASK]->get_original_CoR_grid();
+    EXECUTION_REPORT(REPORT_ERROR, -1, is_grid_id_legal(grid_id) && original_grids[grid_id&TYPE_ID_SUFFIX_MASK] != NULL, "Software error in Original_grid_mgt::get_original_CoR_grid");
+    return original_grids[grid_id&TYPE_ID_SUFFIX_MASK]->get_original_CoR_grid();
 }
 
 
 Original_grid_info *Original_grid_mgt::get_original_grid(int grid_id) const
 {
-	if (!is_grid_id_legal(grid_id))
-		return NULL;
-	
-	return original_grids[grid_id&TYPE_ID_SUFFIX_MASK];
+    if (!is_grid_id_legal(grid_id))
+        return NULL;
+    
+    return original_grids[grid_id&TYPE_ID_SUFFIX_MASK];
 }
 
 int Original_grid_mgt::get_grid_size(int grid_id, const char *annotation) const
 {
-	EXECUTION_REPORT(REPORT_ERROR, -1, is_grid_id_legal(grid_id), "Error happens when getting the size of a grid: the parameter of grid ID is wrong. Please verify the model code corresponding to the annotation \"%s\"", annotation);		
-	return get_original_CoR_grid(grid_id)->get_grid_size();
+    EXECUTION_REPORT(REPORT_ERROR, -1, is_grid_id_legal(grid_id), "Error happens when getting the size of a grid: the parameter of grid ID is wrong. Please verify the model code corresponding to the annotation \"%s\"", annotation);        
+    return get_original_CoR_grid(grid_id)->get_grid_size();
 }
 
 
 int Original_grid_mgt::get_grid_id(int comp_id, const char *grid_name, const char *annotation)
 {
-	EXECUTION_REPORT(REPORT_ERROR, -1, comp_comm_group_mgt_mgr->is_legal_local_comp_id(comp_id,false), "Error happens when getting the ID of a grid: the parameter of component ID is wrong. Please verify the model code corresponding to the annotation \"%s\"", annotation);
-	Original_grid_info *original_grid = search_grid_info(grid_name, comp_id);
-	if (original_grid == NULL)
-		return -1;
-	else return original_grid->get_grid_id();
+    EXECUTION_REPORT(REPORT_ERROR, -1, comp_comm_group_mgt_mgr->is_legal_local_comp_id(comp_id,false), "Error happens when getting the ID of a grid: the parameter of component ID is wrong. Please verify the model code corresponding to the annotation \"%s\"", annotation);
+    Original_grid_info *original_grid = search_grid_info(grid_name, comp_id);
+    if (original_grid == NULL)
+        return -1;
+    else return original_grid->get_grid_id();
 }
 
 
 int Original_grid_mgt::add_original_grid(int comp_id, const char *grid_name, Remap_grid_class *original_CoR_grid)
 {
-	Original_grid_info *existing_grid = search_grid_info(grid_name, comp_id);
-	if (existing_grid != NULL) {
-		EXECUTION_REPORT(REPORT_ERROR, comp_id, original_CoR_grid == existing_grid->get_original_CoR_grid(), "Software error in Original_grid_mgt::add_original_grid");
-		return existing_grid->get_local_grid_id();
-	}
-
-	original_grids.push_back(new Original_grid_info(comp_id, original_grids.size()|TYPE_GRID_LOCAL_ID_PREFIX, grid_name, "Original_grid_mgt::add_original_grid", original_CoR_grid, false));
-	return original_grids[original_grids.size()-1]->get_local_grid_id();
+    Original_grid_info *existing_grid = search_grid_info(grid_name, comp_id);
+    if (existing_grid != NULL) {
+        EXECUTION_REPORT(REPORT_ERROR, comp_id, original_CoR_grid == existing_grid->get_original_CoR_grid(), "Software error in Original_grid_mgt::add_original_grid");
+        return existing_grid->get_local_grid_id();
+    }
+
+    original_grids.push_back(new Original_grid_info(comp_id, original_grids.size()|TYPE_GRID_LOCAL_ID_PREFIX, grid_name, "Original_grid_mgt::add_original_grid", original_CoR_grid, false));
+    return original_grids[original_grids.size()-1]->get_local_grid_id();
 }
 
 
 int Original_grid_mgt::get_num_grid_levels(int grid_id)
 {
-	EXECUTION_REPORT(REPORT_ERROR, -1, is_grid_id_legal(grid_id) && original_grids[grid_id&TYPE_ID_SUFFIX_MASK] != NULL, "Software error in Original_grid_mgt::get_num_grid_levels: wrong grid id");		
-	if (original_grids[grid_id&TYPE_ID_SUFFIX_MASK]->get_V1D_sub_CoR_grid() == NULL)
-		return 1;
+    EXECUTION_REPORT(REPORT_ERROR, -1, is_grid_id_legal(grid_id) && original_grids[grid_id&TYPE_ID_SUFFIX_MASK] != NULL, "Software error in Original_grid_mgt::get_num_grid_levels: wrong grid id");        
+    if (original_grids[grid_id&TYPE_ID_SUFFIX_MASK]->get_V1D_sub_CoR_grid() == NULL)
+        return 1;
 
-	EXECUTION_REPORT(REPORT_ERROR, -1, original_grids[grid_id&TYPE_ID_SUFFIX_MASK]->get_V1D_sub_CoR_grid()->get_grid_size() > 0, "Software error in Original_grid_mgt::get_num_grid_levels: wrong size of vertical grid");
-	return original_grids[grid_id&TYPE_ID_SUFFIX_MASK]->get_V1D_sub_CoR_grid()->get_grid_size();
+    EXECUTION_REPORT(REPORT_ERROR, -1, original_grids[grid_id&TYPE_ID_SUFFIX_MASK]->get_V1D_sub_CoR_grid()->get_grid_size() > 0, "Software error in Original_grid_mgt::get_num_grid_levels: wrong size of vertical grid");
+    return original_grids[grid_id&TYPE_ID_SUFFIX_MASK]->get_V1D_sub_CoR_grid()->get_grid_size();
 }
 
 
 bool Original_grid_mgt::is_V1D_sub_grid_after_H2D_sub_grid(int grid_id)
 {
-	EXECUTION_REPORT(REPORT_ERROR, -1, is_grid_id_legal(grid_id) && original_grids[grid_id&TYPE_ID_SUFFIX_MASK] != NULL, "Original_grid_info::is_V1D_sub_grid_after_H2D_sub_grid: wrong grid id");		
-	return original_grids[grid_id&TYPE_ID_SUFFIX_MASK]->is_V1D_sub_grid_after_H2D_sub_grid();
+    EXECUTION_REPORT(REPORT_ERROR, -1, is_grid_id_legal(grid_id) && original_grids[grid_id&TYPE_ID_SUFFIX_MASK] != NULL, "Original_grid_info::is_V1D_sub_grid_after_H2D_sub_grid: wrong grid id");        
+    return original_grids[grid_id&TYPE_ID_SUFFIX_MASK]->is_V1D_sub_grid_after_H2D_sub_grid();
 }
 
 
 void Original_grid_mgt::register_mid_point_grid(int level_3D_grid_id, int *mid_3D_grid_id, int *mid_1D_grid_id, int size_mask, const int *mask, const char *annotation, const char *API_label)
 {
-	Original_grid_info *level_3D_grid, *mid_3D_grid, *mid_1D_grid;
-	Remap_grid_class *level_1D_CoR_grid, *level_H2D_CoR_grid, *mid_1D_CoR_grid, *mid_3D_CoR_grid, *sub_grids[256];
-	char grid_name[NAME_STR_SIZE];
-
-
-	level_3D_grid = get_original_grid(level_3D_grid_id);
-	MPI_Comm comm = comp_comm_group_mgt_mgr->get_comm_group_of_local_comp(level_3D_grid->get_comp_id(), "in Original_grid_mgt::register_mid_point_grid");
-	synchronize_comp_processes_for_API(level_3D_grid->get_comp_id(), API_ID_GRID_MGT_REG_MID_POINT_GRID, comm, "registering a mid-point grid", annotation);
-	check_API_parameter_string(level_3D_grid->get_comp_id(), API_ID_GRID_MGT_REG_MID_POINT_GRID, comm, "registering a mid-point grid", level_3D_grid->get_grid_name(), "\"level_3D_grid_id\" (the name of the interface-level grid)", annotation);
-	EXECUTION_REPORT(REPORT_ERROR, level_3D_grid->get_comp_id(), level_3D_grid->is_3D_grid(), "Error happens when calling the API \"%s\" to register the mid-point grid of a grid: the grid specified by the parameter \"level_3D_grid_id\" is not a 3-D grid. Please verify the model code with the annotation \"%s.", API_label, annotation);
-	if (level_3D_grid->get_mid_point_grid() != NULL)	
-		EXECUTION_REPORT(REPORT_ERROR, level_3D_grid->get_comp_id(), false, "Error happens when calling the API \"%s\" to register the mid-point grid of a grid: the mid-point grid of the grid \"%s\" has been registered before (at the model code with the annotation \"%s\"). Please verify the model code with the annotation \"%s\".", API_label, level_3D_grid->get_grid_name(), level_3D_grid->get_mid_point_grid()->get_annotation(), annotation);
-	if (level_3D_grid->get_interface_level_grid() != NULL)
-		EXECUTION_REPORT(REPORT_ERROR, level_3D_grid->get_comp_id(), false, "Error happens when calling the API \"%s\" to register the mid-point grid of a grid: the specified interface-level grid itself is a mid-point grid (registered at the model code with the annotation \"%s\") of the grid \"%s\". It cannot be used to register another mid-point grid. Please verify the model code with the annotation \"%s.", API_label, level_3D_grid->get_annotation(), level_3D_grid->get_interface_level_grid()->get_grid_name(), annotation);
-	check_API_parameter_data_array(level_3D_grid->get_comp_id(), API_ID_GRID_MGT_REG_MID_POINT_GRID, comm, "registering a mid-point grid", size_mask, sizeof(int), (const char*)mask, "\"mask\"", annotation);
-	level_1D_CoR_grid = level_3D_grid->get_V1D_sub_CoR_grid();
-	level_H2D_CoR_grid = level_3D_grid->get_H2D_sub_CoR_grid(); 
-	EXECUTION_REPORT(REPORT_ERROR, -1, level_1D_CoR_grid != NULL && level_H2D_CoR_grid != NULL, "Software error in Original_grid_mgt::register_mid_point_grid: NULL level_1D_CoR_grid or NULL level_H2D_CoR_grid");
-	mid_1D_CoR_grid = level_1D_CoR_grid->generate_mid_point_grid();
-	sub_grids[0] = level_H2D_CoR_grid;
-	sub_grids[1] = mid_1D_CoR_grid;
-	sprintf(grid_name, "mid_grid_for_%s", level_3D_grid->get_original_CoR_grid()->get_grid_name());
-	mid_3D_CoR_grid = new Remap_grid_class(grid_name, 2, sub_grids, 0);
-	remap_grid_manager->add_remap_grid(mid_3D_CoR_grid);
-	mid_1D_CoR_grid->end_grid_definition_stage(NULL);
-	mid_3D_CoR_grid->end_grid_definition_stage(NULL);
-	mid_1D_grid = search_grid_info(mid_1D_CoR_grid->get_grid_name(), level_3D_grid->get_comp_id());
-	if (mid_1D_grid == NULL) {
-		mid_1D_grid = new Original_grid_info(level_3D_grid->get_comp_id(), original_grids.size()|TYPE_GRID_LOCAL_ID_PREFIX, mid_1D_CoR_grid->get_grid_name(), annotation, mid_1D_CoR_grid, true);
-		original_grids.push_back(mid_1D_grid);
-		remap_grid_manager->add_remap_grid(mid_1D_grid->get_original_CoR_grid());
-	}
-	*mid_1D_grid_id = mid_1D_grid->get_grid_id();
-	mid_3D_grid = search_grid_info(mid_3D_CoR_grid->get_grid_name(), level_3D_grid->get_comp_id());
-	EXECUTION_REPORT(REPORT_ERROR, -1, mid_3D_grid == NULL, "Software error in Original_grid_mgt::register_mid_point_grid: mid_3D_grid exists");
-	mid_3D_grid = new Original_grid_info(level_3D_grid->get_comp_id(), original_grids.size()|TYPE_GRID_LOCAL_ID_PREFIX, mid_3D_CoR_grid->get_grid_name(), annotation, mid_3D_CoR_grid, true);
-	original_grids.push_back(mid_3D_grid);
-	*mid_3D_grid_id = mid_3D_grid->get_grid_id();
-	level_3D_grid->set_mid_point_grid(mid_3D_grid);
-	if (size_mask > 0) {
-		EXECUTION_REPORT(REPORT_ERROR, level_3D_grid->get_comp_id(), size_mask == mid_3D_CoR_grid->get_grid_size(), "Error happens when calling the API \"%s\" to register the mid-point grid of a grid: the array size of \"mask\" is different from the size of the mid-point grid. Please verify the model code with the annotation \"%s.", API_label, annotation);
-		EXECUTION_REPORT(REPORT_ERROR, level_3D_grid->get_comp_id(), are_array_values_between_boundaries("integer", mask, size_mask, 0, 1, 0, false), "Error happens when calling the API \"%s\" to register the mid-point grid of a grid: some values of the parameter \"mask\" are wrong (not 0 and 1). Please check the model code related to the annotation \"%s\".", API_label, annotation);
-		mid_3D_CoR_grid->read_grid_data_from_array("mask", "mask", DATA_TYPE_INT, (const char*)mask, 0);
+    Original_grid_info *level_3D_grid, *mid_3D_grid, *mid_1D_grid;
+    Remap_grid_class *level_1D_CoR_grid, *level_H2D_CoR_grid, *mid_1D_CoR_grid, *mid_3D_CoR_grid, *sub_grids[256], *existing_level_1D_CoR_grid;
+    char grid_name[NAME_STR_SIZE];
+
+
+    level_3D_grid = get_original_grid(level_3D_grid_id);
+    MPI_Comm comm = comp_comm_group_mgt_mgr->get_comm_group_of_local_comp(level_3D_grid->get_comp_id(), "in Original_grid_mgt::register_mid_point_grid");
+    synchronize_comp_processes_for_API(level_3D_grid->get_comp_id(), API_ID_GRID_MGT_REG_MID_POINT_GRID, comm, "registering a mid-point grid", annotation);
+    check_API_parameter_string(level_3D_grid->get_comp_id(), API_ID_GRID_MGT_REG_MID_POINT_GRID, comm, "registering a mid-point grid", level_3D_grid->get_grid_name(), "\"level_3D_grid_id\" (the name of the interface-level grid)", annotation);
+    EXECUTION_REPORT(REPORT_ERROR, level_3D_grid->get_comp_id(), level_3D_grid->is_3D_grid(), "Error happens when calling the API \"%s\" to register the mid-point grid of a grid: the grid specified by the parameter \"level_3D_grid_id\" is not a 3-D grid. Please verify the model code with the annotation \"%s\".", API_label, annotation);
+    if (level_3D_grid->get_mid_point_grid() != NULL)    
+        EXECUTION_REPORT(REPORT_ERROR, level_3D_grid->get_comp_id(), false, "Error happens when calling the API \"%s\" to register the mid-point grid of a grid: the mid-point grid of the grid \"%s\" has been registered before (at the model code with the annotation \"%s\"). Please verify the model code with the annotation \"%s\".", API_label, level_3D_grid->get_grid_name(), level_3D_grid->get_mid_point_grid()->get_annotation(), annotation);
+    if (level_3D_grid->get_interface_level_grid() != NULL)
+        EXECUTION_REPORT(REPORT_ERROR, level_3D_grid->get_comp_id(), false, "Error happens when calling the API \"%s\" to register the mid-point grid of a grid: the specified interface-level grid itself is a mid-point grid (registered at the model code with the annotation \"%s\") of the grid \"%s\". It cannot be used to register another mid-point grid. Please verify the model code with the annotation \"%s\".", API_label, level_3D_grid->get_annotation(), level_3D_grid->get_interface_level_grid()->get_grid_name(), annotation);
+    check_API_parameter_data_array(level_3D_grid->get_comp_id(), API_ID_GRID_MGT_REG_MID_POINT_GRID, comm, "registering a mid-point grid", size_mask, sizeof(int), (const char*)mask, "\"mask\"", annotation);
+    level_1D_CoR_grid = level_3D_grid->get_V1D_sub_CoR_grid();
+    level_H2D_CoR_grid = level_3D_grid->get_H2D_sub_CoR_grid(); 
+    EXECUTION_REPORT(REPORT_ERROR, -1, level_1D_CoR_grid != NULL && level_H2D_CoR_grid != NULL, "Software error in Original_grid_mgt::register_mid_point_grid: NULL level_1D_CoR_grid or NULL level_H2D_CoR_grid");
+	existing_level_1D_CoR_grid = level_1D_CoR_grid->get_mid_point_grid();
+    mid_1D_CoR_grid = level_1D_CoR_grid->generate_mid_point_grid();
+    sub_grids[0] = level_H2D_CoR_grid;
+    sub_grids[1] = mid_1D_CoR_grid;
+    sprintf(grid_name, "mid_grid_for_%s", level_3D_grid->get_original_CoR_grid()->get_grid_name());
+	mid_3D_CoR_grid = level_3D_grid->get_original_CoR_grid()->get_mid_point_grid();
+	if (mid_3D_CoR_grid == NULL) {
+	    mid_3D_CoR_grid = new Remap_grid_class(grid_name, 2, sub_grids, 0);
+    	remap_grid_manager->add_remap_grid(mid_3D_CoR_grid);
 	}
+    mid_1D_CoR_grid->end_grid_definition_stage(NULL);
+    mid_3D_CoR_grid->end_grid_definition_stage(NULL);
+    mid_1D_grid = search_grid_info(mid_1D_CoR_grid->get_grid_name(), level_3D_grid->get_comp_id());
+    if (mid_1D_grid == NULL) {
+        mid_1D_grid = new Original_grid_info(level_3D_grid->get_comp_id(), original_grids.size()|TYPE_GRID_LOCAL_ID_PREFIX, mid_1D_CoR_grid->get_grid_name(), annotation, mid_1D_CoR_grid, true);
+        original_grids.push_back(mid_1D_grid);
+		if (existing_level_1D_CoR_grid == NULL)
+	        remap_grid_manager->add_remap_grid(mid_1D_grid->get_original_CoR_grid());
+    }
+    *mid_1D_grid_id = mid_1D_grid->get_grid_id();
+    mid_3D_grid = search_grid_info(mid_3D_CoR_grid->get_grid_name(), level_3D_grid->get_comp_id());
+    EXECUTION_REPORT(REPORT_ERROR, -1, mid_3D_grid == NULL, "Software error in Original_grid_mgt::register_mid_point_grid: mid_3D_grid exists");
+    mid_3D_grid = new Original_grid_info(level_3D_grid->get_comp_id(), original_grids.size()|TYPE_GRID_LOCAL_ID_PREFIX, mid_3D_CoR_grid->get_grid_name(), annotation, mid_3D_CoR_grid, true);
+    original_grids.push_back(mid_3D_grid);
+    *mid_3D_grid_id = mid_3D_grid->get_grid_id();
+    level_3D_grid->set_mid_point_grid(mid_3D_grid);
+    if (size_mask > 0) {
+        EXECUTION_REPORT(REPORT_ERROR, level_3D_grid->get_comp_id(), size_mask == mid_3D_CoR_grid->get_grid_size(), "Error happens when calling the API \"%s\" to register the mid-point grid of a grid: the array size of \"mask\" is different from the size of the mid-point grid. Please verify the model code with the annotation \"%s\".", API_label, annotation);
+        EXECUTION_REPORT(REPORT_ERROR, level_3D_grid->get_comp_id(), are_array_values_between_boundaries("integer", mask, size_mask, 0, 1, 0, false), "Error happens when calling the API \"%s\" to register the mid-point grid of a grid: some values of the parameter \"mask\" are wrong (not 0 and 1). Please check the model code related to the annotation \"%s\".", API_label, annotation);
+        mid_3D_CoR_grid->read_grid_data_from_array("mask", "mask", DATA_TYPE_INT, (const char*)mask, 0);
+    }
+    if (level_1D_CoR_grid->get_super_grid_of_setting_coord_values() == level_1D_CoR_grid)
+        mid_1D_CoR_grid->set_super_grid_of_setting_coord_values(mid_1D_CoR_grid);
+	else if (level_1D_CoR_grid->get_super_grid_of_setting_coord_values() != NULL && level_1D_CoR_grid->get_super_grid_of_setting_coord_values()->get_num_dimensions() == 3)
+		mid_1D_CoR_grid->set_super_grid_of_setting_coord_values(mid_3D_CoR_grid);
+	level_3D_grid->get_original_CoR_grid()->set_mid_point_grid(mid_3D_CoR_grid);
+}
+
+
+Original_grid_info *Original_grid_mgt::search_or_register_internal_grid(int comp_id, Remap_grid_class *CoR_grid)
+{
+	for (int i = 0; i < original_grids.size(); i ++)
+		if (original_grids[i]->get_comp_id() == comp_id && CoR_grid == original_grids[i]->get_original_CoR_grid())
+			return original_grids[i];
+	original_grids.push_back(new Original_grid_info(comp_id, original_grids.size()|TYPE_GRID_LOCAL_ID_PREFIX, CoR_grid->get_grid_name(), "Original_grid_mgt::add_original_grid", CoR_grid, false));
+	return original_grids[original_grids.size()-1];
 }
 
 
diff --git a/src/Data_MGT/original_grid_mgt.h b/src/Data_MGT/original_grid_mgt.h
old mode 100644
new mode 100755
index 685f288..24752a5
--- a/src/Data_MGT/original_grid_mgt.h
+++ b/src/Data_MGT/original_grid_mgt.h
@@ -24,102 +24,108 @@
 
 class Original_grid_info
 {
-	private: 
-		int comp_id;
-		int grid_id;
-		const char *grid_name;
-		const char *bottom_field_name;
-		const char *comp_full_name;
-		Remap_grid_class *original_CoR_grid;
-		Remap_grid_class *H2D_sub_CoR_grid;
-		Remap_grid_class *V1D_sub_CoR_grid;
-		Remap_grid_class *T1D_sub_CoR_grid;
-		int H2D_sub_grid_order;
-		int V1D_sub_grid_order;
-		int T1D_sub_grid_order;
-		int bottom_field_id;
-		int bottom_field_variation_type;   // 0: static; 1: dynamic; 2: external
-		Original_grid_info *mid_point_grid;
-		Original_grid_info *interface_level_grid;
-		double *center_lon_values;
-		double *center_lat_values;
-		long checksum_H2D_mask;
-
-		void generate_remapping_grids();
-		
-	public:
-		Original_grid_info(int, int, const char*, const char*, Remap_grid_class*, bool);
-		const char *get_annotation();
-		const char *get_grid_name() const { return grid_name; }
-		int get_local_grid_id() const { return grid_id; }
-		~Original_grid_info();
-		int get_comp_id() const { return comp_id; }
-		int get_grid_id() const { return grid_id; }
-		int get_bottom_field_variation_type() const { return bottom_field_variation_type; }
-		const char *get_bottom_field_name() const { return bottom_field_name; }
-		void set_bottom_field_variation_type(int type) { bottom_field_variation_type = type; }
-		void set_grid_checksum(long);
-		void set_unique_bottom_field(int field_id, int type, const char*);
-		Remap_grid_class *get_original_CoR_grid() const { return original_CoR_grid; }
-		Remap_grid_class *get_H2D_sub_CoR_grid() { return H2D_sub_CoR_grid; }
-		Remap_grid_class *get_V1D_sub_CoR_grid() { return V1D_sub_CoR_grid; }
-		Remap_grid_class *get_T1D_sub_CoR_grid() { return T1D_sub_CoR_grid; }
-		bool is_V1D_sub_grid_after_H2D_sub_grid();
-		bool is_3D_grid() { return H2D_sub_CoR_grid != NULL && V1D_sub_CoR_grid != NULL && T1D_sub_CoR_grid == NULL; }
-		bool is_H2D_grid() { return H2D_sub_CoR_grid != NULL && V1D_sub_CoR_grid == NULL && T1D_sub_CoR_grid == NULL; } 
-		void write_grid_into_array(char **, long &, long &);
-		int get_bottom_field_id() { return bottom_field_id; }		
-		void get_grid_data(int, const char*, const char*, int, char*, const char*, const char*);
-		Original_grid_info *get_interface_level_grid() { return interface_level_grid; }
-		Original_grid_info *get_mid_point_grid() { return mid_point_grid; }
-		void set_mid_point_grid(Original_grid_info*);
-		long get_checksum_H2D_mask() { return checksum_H2D_mask; }
-		bool is_H2D_grid_and_the_same_as_another_grid(Original_grid_info *);
-		double *get_center_lon_values() { return center_lon_values; }
-		double *get_center_lat_values() { return center_lat_values; }
-		void reset_grid_data();
-		const char *get_comp_full_name() { return comp_full_name; }
+    private: 
+        int comp_id;
+        int grid_id;
+        const char *grid_name;
+        const char *bottom_field_name;
+        const char *comp_full_name;
+        Remap_grid_class *original_CoR_grid;
+        Remap_grid_class *H2D_sub_CoR_grid;
+        Remap_grid_class *V1D_sub_CoR_grid;
+        Remap_grid_class *T1D_sub_CoR_grid;
+        int H2D_sub_grid_order;
+        int V1D_sub_grid_order;
+        int T1D_sub_grid_order;
+		int V3D_lev_field_id;
+		int V3D_lev_field_variation_type;   // 0: static; 1: dynamic
+        int bottom_field_id;
+        int bottom_field_variation_type;   // 0: static; 1: dynamic; 2: external
+        Original_grid_info *mid_point_grid;
+        Original_grid_info *interface_level_grid;
+        long checksum_H2D_mask;
+
+        void generate_remapping_grids();
+        
+    public:
+        Original_grid_info(int, int, const char*, const char*, Remap_grid_class*, bool);
+        const char *get_annotation();
+        const char *get_grid_name() const { return grid_name; }
+        int get_local_grid_id() const { return grid_id; }
+        ~Original_grid_info();
+        int get_comp_id() const { return comp_id; }
+        int get_grid_id() const { return grid_id; }
+        int get_bottom_field_variation_type() const { return bottom_field_variation_type; }
+		int get_V3D_lev_field_variation_type() const { return V3D_lev_field_variation_type; }
+        const char *get_bottom_field_name() const { return bottom_field_name; }
+        void set_bottom_field_variation_type(int type) { bottom_field_variation_type = type; }
+		void set_V3D_lev_field_variation_type(int type) { V3D_lev_field_variation_type = type; }
+        void set_grid_checksum(long);
+        void set_unique_bottom_field(int, int, const char*);
+		void set_unique_3D_lev_field(int, const char *, const char *);
+        Remap_grid_class *get_original_CoR_grid() const { return original_CoR_grid; }
+        Remap_grid_class *get_H2D_sub_CoR_grid() { return H2D_sub_CoR_grid; }
+        Remap_grid_class *get_V1D_sub_CoR_grid() { return V1D_sub_CoR_grid; }
+        Remap_grid_class *get_T1D_sub_CoR_grid() { return T1D_sub_CoR_grid; }
+        bool is_V1D_sub_grid_after_H2D_sub_grid();
+        bool is_3D_grid() { return H2D_sub_CoR_grid != NULL && V1D_sub_CoR_grid != NULL && T1D_sub_CoR_grid == NULL; }
+        bool is_H2D_grid() { return H2D_sub_CoR_grid != NULL && V1D_sub_CoR_grid == NULL && T1D_sub_CoR_grid == NULL; } 
+        void write_grid_into_array(char **, long &, long &);
+        int get_bottom_field_id() { return bottom_field_id; }        
+		int get_V3D_lev_field_id() { return V3D_lev_field_id; }
+        void get_grid_data(int, const char*, const char*, int, char*, const char*, const char*);
+        Original_grid_info *get_interface_level_grid() { return interface_level_grid; }
+        Original_grid_info *get_mid_point_grid() { return mid_point_grid; }
+        void set_mid_point_grid(Original_grid_info*);
+        long get_checksum_H2D_mask() { return checksum_H2D_mask; }
+        bool is_H2D_grid_and_the_same_as_another_grid(Original_grid_info *);
+        double *get_center_lon_values();
+        double *get_center_lat_values();
+        void reset_grid_data();
+        const char *get_comp_full_name() { return comp_full_name; }
 };
 
 
 class Original_grid_mgt
 {
-	private:
-		std::vector<Original_grid_info*> original_grids;
-		char CoR_script_name[NAME_STR_SIZE];
-		Remap_mgt *CoR_grids;
-
-	public:
-		Original_grid_mgt();
-		~Original_grid_mgt();
-		void initialize_CoR_grids();
-		int get_CoR_defined_grid(int, const char*, const char*, const char*);
-		Original_grid_info *search_grid_info(const char*, int);
-		Original_grid_info *search_grid_info(int);
-		Remap_grid_class *get_original_CoR_grid(int) const;
-		Original_grid_info *get_original_grid(int) const;
-		bool is_grid_id_legal(int) const;		
-		int get_comp_id_of_grid(int) const;
-		const char *get_name_of_grid(int) const;
-		int get_grid_size(int, const char*) const;
-		int get_grid_id(int, const char*, const char*);
-		int add_original_grid(int, const char*, Remap_grid_class*);
-		int get_num_grid_levels(int);
-		bool is_V1D_sub_grid_after_H2D_sub_grid(int);
-		void common_checking_for_H2D_registration_via_data(int, const char *, const char *, const char *, char *, const char *, int, int, int, int, int, int *, char *, char *, char *, char *, char *, char *, char *, char *, const char *, int);
-		int create_H2D_grid_from_global_data(int, const char *, const char *, const char *, const char *, int, int, int, int, int, int, int, int, int, char *, char *, char *, char *, char *, char *, int *, char *, char *, char *, const char *);
-		int register_H2D_grid_via_global_data(int, const char *, const char *, const char *, char *, const char *, int, int, int, int, 
-											   int, int, int, int, char *, char *, char *, char *, char *, char *, int *, char *, char *, char *, const char *, int);
-		int register_H2D_grid_via_local_data(int, const char *, const char *, const char *, char *, const char *, int, int, int, int, int, 
-											 int, int, int, int, int *, char *, char *, char *, char *, char *, char *, int *, char *, char *, char *, const char *, int *, const char *, int);
-		int register_H2D_grid_via_file(int, const char *, const char *, const char *);
-		int register_H2D_grid_via_comp(int, const char *, const char *);
-		int register_V1D_grid_via_data(int, int, const char *, int, const char *, int, double, const double *, const double *, const char *);
-		int register_md_grid_via_multi_grids(int, const char*, int, int, int, int, int *, const char*);
-		void set_3d_grid_bottom_field(int, int, int, int, int, const char*, const char*);
-		void register_mid_point_grid(int, int*, int*, int, const int*, const char*, const char *);
-		void delete_external_original_grids();
-		void calculate_min_max_H2D_coord_value(int, char *, char *, int, int, const char *, double &, double &);
+    private:
+        std::vector<Original_grid_info*> original_grids;
+        char CoR_script_name[NAME_STR_SIZE];
+        Remap_mgt *CoR_grids;
+
+    public:
+        Original_grid_mgt();
+        ~Original_grid_mgt();
+        void initialize_CoR_grids();
+        int get_CoR_defined_grid(int, const char*, const char*, const char*);
+        Original_grid_info *search_grid_info(const char*, int);
+        Original_grid_info *search_grid_info(int);
+        Remap_grid_class *get_original_CoR_grid(int) const;
+        Original_grid_info *get_original_grid(int) const;
+        bool is_grid_id_legal(int) const;        
+        int get_comp_id_of_grid(int) const;
+        const char *get_name_of_grid(int) const;
+        int get_grid_size(int, const char*) const;
+        int get_grid_id(int, const char*, const char*);
+        int add_original_grid(int, const char*, Remap_grid_class*);
+        int get_num_grid_levels(int);
+        bool is_V1D_sub_grid_after_H2D_sub_grid(int);
+        void common_checking_for_H2D_registration_via_data(int, const char *, const char *, const char *, char *, const char *, int, int, int, int, int, int *, char *, char *, char *, char *, char *, char *, char *, char *, const char *, int);
+        int create_H2D_grid_from_global_data(int, const char *, const char *, const char *, const char *, int, int, int, int, int, int, int, int, int, char *, char *, char *, char *, char *, char *, int *, char *, char *, char *, const char *);
+        int register_H2D_grid_via_global_data(int, const char *, const char *, const char *, char *, const char *, int, int, int, int, 
+                                               int, int, int, int, char *, char *, char *, char *, char *, char *, int *, char *, char *, char *, const char *, int);
+        int register_H2D_grid_via_local_data(int, const char *, const char *, const char *, char *, const char *, int, int, int, int, int, 
+                                             int, int, int, int, int *, char *, char *, char *, char *, char *, char *, int *, char *, char *, char *, const char *, int *, const char *, int);
+        int register_H2D_grid_via_file(int, const char *, const char *, const char *);
+        int register_H2D_grid_via_comp(int, const char *, const char *);
+        int register_V1D_grid_via_data(int, int, const char *, int, const char *, int, double, const double *, const double *, const char *);
+        int register_md_grid_via_multi_grids(int, const char*, int, int, int, int, int *, const char*);
+        void set_3d_grid_bottom_field(int, int, int, int, int, const char*, const char*);		
+		void set_3D_grid_3D_vertical_coord_field_inst(int, int, const char *, const char *);
+        void register_mid_point_grid(int, int*, int*, int, const int*, const char*, const char *);
+        void delete_external_original_grids();
+        void calculate_min_max_H2D_coord_value(int, char *, char *, int, int, const char *, double &, double &);
+		Original_grid_info *search_or_register_internal_grid(int, Remap_grid_class *);
 };
 
 
diff --git a/src/Data_MGT/restart_mgt.cxx b/src/Data_MGT/restart_mgt.cxx
old mode 100644
new mode 100755
index 0054fc4..9299960
--- a/src/Data_MGT/restart_mgt.cxx
+++ b/src/Data_MGT/restart_mgt.cxx
@@ -14,495 +14,521 @@
 
 Restart_buffer_container::Restart_buffer_container(const char *comp_full_name, const char *buf_type, const char *keyword, Restart_mgt *restart_mgr)
 {
-	strcpy(this->comp_full_name, comp_full_name);
-	strcpy(this->buf_type, buf_type);
-	strcpy(this->keyword, keyword);
-	buffer_max_size = 1000;
-	buffer_content = new char [buffer_max_size];
-	buffer_content_iter = 0;
-	buffer_content_size = 0;
-	this->restart_mgr = restart_mgr;
+    strcpy(this->comp_full_name, comp_full_name);
+    strcpy(this->buf_type, buf_type);
+    strcpy(this->keyword, keyword);
+    buffer_max_size = 1000;
+    buffer_content = new char [buffer_max_size];
+    buffer_content_iter = 0;
+    buffer_content_size = 0;
+    this->restart_mgr = restart_mgr;
 }
 
 
 Restart_buffer_container::Restart_buffer_container(const char *array_buffer, long &buffer_content_iter, const char *file_name, Restart_mgt *restart_mgr)
 {
-	long total_size, str_size;
-
-
-	EXECUTION_REPORT(REPORT_ERROR, -1, read_data_from_array_buffer(&total_size, sizeof(long), array_buffer, buffer_content_iter, file_name == NULL), "Fail to load the restart data file \"%s\": its format is wrong, or the information it includes is not complete. Please try a different restart time with complete restart data files.", file_name);
-	
-	buffer_content = load_string(NULL, str_size, -1, array_buffer, buffer_content_iter, file_name);
-	this->buffer_content_iter = str_size;
-	this->buffer_content_size = str_size;
-	this->restart_mgr = restart_mgr;
-	load_string(keyword, str_size, NAME_STR_SIZE, array_buffer, buffer_content_iter, file_name);
-	load_string(buf_type, str_size, NAME_STR_SIZE, array_buffer, buffer_content_iter, file_name);
-	load_string(comp_full_name, str_size, NAME_STR_SIZE, array_buffer, buffer_content_iter, file_name);
-	EXECUTION_REPORT(REPORT_ERROR, -1, total_size == strlen(comp_full_name) + strlen(buf_type) + strlen(keyword) + sizeof(long)*3 + this->buffer_content_iter, "Restart_buffer_container::Restart_buffer_container: wrong format of restart data file");
+    long total_size, str_size;
+
+
+    EXECUTION_REPORT(REPORT_ERROR, -1, read_data_from_array_buffer(&total_size, sizeof(long), array_buffer, buffer_content_iter, file_name == NULL), "Fail to load the restart data file \"%s\": its format is wrong, or the information it includes is not complete. Please try a different restart time with complete restart data files.", file_name);
+    
+    buffer_content = load_string(NULL, str_size, -1, array_buffer, buffer_content_iter, file_name);
+    this->buffer_content_iter = str_size;
+    this->buffer_content_size = str_size;
+    this->restart_mgr = restart_mgr;
+    load_string(keyword, str_size, NAME_STR_SIZE, array_buffer, buffer_content_iter, file_name);
+    load_string(buf_type, str_size, NAME_STR_SIZE, array_buffer, buffer_content_iter, file_name);
+    load_string(comp_full_name, str_size, NAME_STR_SIZE, array_buffer, buffer_content_iter, file_name);
+    EXECUTION_REPORT(REPORT_ERROR, -1, total_size == strlen(comp_full_name) + strlen(buf_type) + strlen(keyword) + sizeof(long)*3 + this->buffer_content_iter, "Restart_buffer_container::Restart_buffer_container: wrong format of restart data file");
 }
 
 
 void Restart_buffer_container::dump_in_string(const char *str, long str_size)
 {
-	dump_string(str, str_size, &buffer_content, buffer_max_size, buffer_content_iter);
-	buffer_content_size = buffer_content_iter;
+    dump_string(str, str_size, &buffer_content, buffer_max_size, buffer_content_iter);
+    buffer_content_size = buffer_content_iter;
 }
 
 
 void Restart_buffer_container::dump_in_data(const void *data, long size)
 {
-	write_data_into_array_buffer(data, size, &buffer_content, buffer_max_size, buffer_content_iter);
-	buffer_content_size = buffer_content_iter;
+    write_data_into_array_buffer(data, size, &buffer_content, buffer_max_size, buffer_content_iter);
+    buffer_content_size = buffer_content_iter;
 }
 
 
 void Restart_buffer_container::load_restart_data(void *data, long data_size)
 {
-	EXECUTION_REPORT(REPORT_ERROR, -1, read_data_from_array_buffer(data, data_size, buffer_content, buffer_content_iter, false), "Fail to load the restart data file \"%s\": its format is wrong, or the information it includes is not complete. Please try a different restart time with complete restart data files.", restart_mgr->get_input_restart_mgt_info_file());
+    EXECUTION_REPORT(REPORT_ERROR, -1, read_data_from_array_buffer(data, data_size, buffer_content, buffer_content_iter, false), "Fail to load the restart data file \"%s\": its format is wrong, or the information it includes is not complete. Please try a different restart time with complete restart data files.", restart_mgr->get_input_restart_mgt_info_file());
 }
 
 
 char *Restart_buffer_container::load_restart_string(char *str, long &str_size, long max_size)
 {
-	return load_string(str, str_size, max_size, buffer_content, buffer_content_iter, restart_mgr->get_input_restart_mgt_info_file());
+    return load_string(str, str_size, max_size, buffer_content, buffer_content_iter, restart_mgr->get_input_restart_mgt_info_file());
 }
 
 
 void Restart_buffer_container::dump_out(char **array_buffer, long &buffer_max_size, long &buffer_content_size)
 {
-	dump_string(comp_full_name, -1, array_buffer, buffer_max_size, buffer_content_size);
-	dump_string(buf_type, -1, array_buffer, buffer_max_size, buffer_content_size);
-	dump_string(keyword, -1, array_buffer, buffer_max_size, buffer_content_size);
-	dump_string(buffer_content, buffer_content_iter, array_buffer, buffer_max_size, buffer_content_size);
-	long total_size = strlen(comp_full_name) + strlen(buf_type) + strlen(keyword) + sizeof(long)*3 + buffer_content_iter;
-	write_data_into_array_buffer(&total_size, sizeof(long), array_buffer, buffer_max_size, buffer_content_size);
+    dump_string(comp_full_name, -1, array_buffer, buffer_max_size, buffer_content_size);
+    dump_string(buf_type, -1, array_buffer, buffer_max_size, buffer_content_size);
+    dump_string(keyword, -1, array_buffer, buffer_max_size, buffer_content_size);
+    dump_string(buffer_content, buffer_content_iter, array_buffer, buffer_max_size, buffer_content_size);
+    long total_size = strlen(comp_full_name) + strlen(buf_type) + strlen(keyword) + sizeof(long)*3 + buffer_content_iter;
+    write_data_into_array_buffer(&total_size, sizeof(long), array_buffer, buffer_max_size, buffer_content_size);
 }
 
 
 bool Restart_buffer_container::match(const char *buf_type, const char *keyword)
 {
-	return words_are_the_same(this->buf_type, buf_type) && words_are_the_same(this->keyword, keyword);
+    return words_are_the_same(this->buf_type, buf_type) && words_are_the_same(this->keyword, keyword);
 }
 
 
 const char *Restart_buffer_container::get_input_restart_mgt_info_file()
 {
-	return restart_mgr->get_input_restart_mgt_info_file();
+    return restart_mgr->get_input_restart_mgt_info_file();
 }
 
 
 Restart_mgt::Restart_mgt(Comp_comm_group_mgt_node *comp_node)
 { 
-	this->comp_node = comp_node; 
-	last_restart_write_full_time = -1;
-	last_restart_write_elapsed_time = -1;
-	input_restart_mgt_info_file = NULL;
-	restart_read_annotation = NULL;
-	restart_mgt_info_written = true;
-	time_mgr = NULL;
-	restart_write_data_file = NULL;
-	restart_read_data_file_name = NULL;
-	are_all_restarted_fields_read = false;
-	restart_normal_fields_enabled = false;
+    this->comp_node = comp_node; 
+    last_restart_write_full_time = -1;
+    last_restart_write_elapsed_time = -1;
+    input_restart_mgt_info_file = NULL;
+    restart_read_annotation = NULL;
+    restart_mgt_info_written = true;
+    time_mgr = NULL;
+    restart_write_data_file = NULL;
+    backup_restart_write_data_file = NULL;
+    restart_read_data_file_name = NULL;
+    are_all_restarted_fields_read = false;
+    restart_normal_fields_enabled = false;
 }
 
 
 Restart_mgt::~Restart_mgt()
 {
-	clean(true);
-	clean(false);
-	if (input_restart_mgt_info_file != NULL)
-		delete [] input_restart_mgt_info_file;
-	if (restart_read_annotation != NULL)
-		delete [] restart_read_annotation;
-	if (restart_read_data_file_name != NULL)
-		delete restart_read_data_file_name;
-	if (restart_write_data_file != NULL)
-		delete restart_write_data_file;
+    clean(true);
+    clean(false);
+    if (input_restart_mgt_info_file != NULL)
+        delete [] input_restart_mgt_info_file;
+    if (restart_read_annotation != NULL)
+        delete [] restart_read_annotation;
+    if (restart_read_data_file_name != NULL)
+        delete restart_read_data_file_name;
+    if (backup_restart_write_data_file != NULL)
+        delete backup_restart_write_data_file;
 }
 
 
 int Restart_mgt::get_comp_id() 
 { 
-	return comp_node->get_comp_id(); 
+    return comp_node->get_comp_id(); 
 }
 
 
 
 void Restart_mgt::clean(bool is_write_buffers)
 {
-	if (is_write_buffers) {
-		for (int i = 0; i < restart_write_buffer_containers.size(); i ++)
-			delete restart_write_buffer_containers[i];
-		restart_write_buffer_containers.clear();
-	}
-	else {
-		for (int i = 0; i < restart_read_buffer_containers.size(); i ++)
-			delete restart_read_buffer_containers[i];
-		restart_read_buffer_containers.clear();		
-	}
+    if (is_write_buffers) {
+        for (int i = 0; i < restart_write_buffer_containers.size(); i ++)
+            delete restart_write_buffer_containers[i];
+        restart_write_buffer_containers.clear();
+    }
+    else {
+        for (int i = 0; i < restart_read_buffer_containers.size(); i ++)
+            delete restart_read_buffer_containers[i];
+        restart_read_buffer_containers.clear();        
+    }
 }
 
 
 Restart_buffer_container *Restart_mgt::search_restart_buffer(const char *buf_type, const char *keyword)
 {
-	for (int i = 0; i < restart_read_buffer_containers.size(); i ++)
-		if (restart_read_buffer_containers[i]->match(buf_type, keyword))
-			return restart_read_buffer_containers[i];
+    for (int i = 0; i < restart_read_buffer_containers.size(); i ++)
+        if (restart_read_buffer_containers[i]->match(buf_type, keyword))
+            return restart_read_buffer_containers[i];
 
-	return NULL;
+    return NULL;
 }
 
 
 void Restart_mgt::read_restart_mgt_info(const char *specified_file_name, const char *annotation)
 {
-	char restart_file_full_name[NAME_STR_SIZE], restart_file_short_name[NAME_STR_SIZE];
-			
-
-	if (time_mgr == NULL)
-		time_mgr = components_time_mgrs->get_time_mgr(comp_node->get_comp_id());
-	
-	if ((time_mgr->get_runtype_mark() == RUNTYPE_MARK_INITIAL)) {
-		EXECUTION_REPORT(REPORT_PROGRESS, comp_node->get_comp_id(), true, "C-Coupler does not read the restart data file because it is a initial run (the run_type is initial)");
-		return;
-	}
-	
-	if (strlen(specified_file_name) == 0) {
-		if ((time_mgr->get_runtype_mark() == RUNTYPE_MARK_CONTINUE)) {
-			get_file_name_in_rpointer_file(restart_file_short_name);
-			int special_pos;
-			for (special_pos = strlen(restart_file_short_name)-1; special_pos >= 0; special_pos --)
-				if (restart_file_short_name[special_pos] == '-')
-					break;
-			sprintf(restart_file_short_name+special_pos-8, "%08d-%05d", time_mgr->get_common_restart_full_time()/100000, time_mgr->get_common_restart_full_time()%100000);
-			EXECUTION_REPORT_LOG(REPORT_LOG, comp_node->get_comp_id(), true, "The active restart data file is %s corresponding to the restart full time %ld", restart_file_short_name, time_mgr->get_common_restart_full_time());
-		}
-		else sprintf(restart_file_short_name, "%s.%s.r.%08d-%05d", time_mgr->get_rest_refcase(), comp_node->get_comp_full_name(), time_mgr->get_rest_refdate(), time_mgr->get_rest_refsecond());
-	}
-	else strcpy(restart_file_short_name, specified_file_name);
-	sprintf(restart_file_full_name, "%s/%s", comp_node->get_working_dir(), restart_file_short_name);
-	if (input_restart_mgt_info_file != NULL)
-		EXECUTION_REPORT(REPORT_ERROR, comp_node->get_comp_id(), false, "Error happens when reading the restart data file \"%s\" at the model code with the annotation \"%s\": a restart data file \"%s\" has already been read before at the model code with the annotation \"%s\", which indicates that the current component model calls the API \"CCPL_start_restart_read_IO\" more than once. Please note that a component model can call this API only once. Please verify.", restart_file_full_name, annotation, input_restart_mgt_info_file, restart_read_annotation);
-	input_restart_mgt_info_file = strdup(restart_file_full_name);
-	restart_read_annotation = strdup(annotation);
-
-	if (time_mgr->get_runtype_mark() == RUNTYPE_MARK_CONTINUE || time_mgr->get_runtype_mark() == RUNTYPE_MARK_BRANCH)
-		EXECUTION_REPORT(REPORT_ERROR, comp_node->get_comp_id(), !time_mgr->get_time_has_been_advanced(), "Error happens when reading the restart file \"%s\": the model time has been advanced, while a component model cannot read any restart file after its model time has been advanced. Please check the model code with the annotation \"%s\"", restart_file_full_name, annotation);
-	read_restart_mgt_info((time_mgr->get_runtype_mark() == RUNTYPE_MARK_CONTINUE) || (time_mgr->get_runtype_mark() == RUNTYPE_MARK_BRANCH), restart_file_full_name, annotation);
+    char restart_file_full_name[NAME_STR_SIZE], restart_file_short_name[NAME_STR_SIZE];
+            
+
+    if (time_mgr == NULL)
+        time_mgr = components_time_mgrs->get_time_mgr(comp_node->get_comp_id());
+    
+    if ((time_mgr->get_runtype_mark() == RUNTYPE_MARK_INITIAL)) {
+        EXECUTION_REPORT(REPORT_PROGRESS, comp_node->get_comp_id(), true, "C-Coupler does not read the restart data file because it is a initial run (the run_type is initial)");
+        return;
+    }
+    
+    if (strlen(specified_file_name) == 0) {
+        if ((time_mgr->get_runtype_mark() == RUNTYPE_MARK_CONTINUE)) {
+            get_file_name_in_rpointer_file(restart_file_short_name);
+            int special_pos;
+            for (special_pos = strlen(restart_file_short_name)-1; special_pos >= 0; special_pos --)
+                if (restart_file_short_name[special_pos] == '-')
+                    break;
+            sprintf(restart_file_short_name+special_pos-8, "%08d-%05d", time_mgr->get_common_restart_full_time()/100000, time_mgr->get_common_restart_full_time()%100000);
+            EXECUTION_REPORT_LOG(REPORT_LOG, comp_node->get_comp_id(), true, "The active restart data file is %s corresponding to the restart full time %ld", restart_file_short_name, time_mgr->get_common_restart_full_time());
+        }
+        else sprintf(restart_file_short_name, "%s.%s.r.%08d-%05d", time_mgr->get_rest_refcase(), comp_node->get_comp_full_name(), time_mgr->get_rest_refdate(), time_mgr->get_rest_refsecond());
+    }
+    else strcpy(restart_file_short_name, specified_file_name);
+    sprintf(restart_file_full_name, "%s/%s", comp_node->get_working_dir(), restart_file_short_name);
+    if (input_restart_mgt_info_file != NULL)
+        EXECUTION_REPORT(REPORT_ERROR, comp_node->get_comp_id(), false, "Error happens when reading the restart data file \"%s\" at the model code with the annotation \"%s\": a restart data file \"%s\" has already been read before at the model code with the annotation \"%s\", which indicates that the current component model calls the API \"CCPL_start_restart_read_IO\" more than once. Please note that a component model can call this API only once. Please verify.", restart_file_full_name, annotation, input_restart_mgt_info_file, restart_read_annotation);
+    input_restart_mgt_info_file = strdup(restart_file_full_name);
+    restart_read_annotation = strdup(annotation);
+
+    if (time_mgr->get_runtype_mark() == RUNTYPE_MARK_CONTINUE || time_mgr->get_runtype_mark() == RUNTYPE_MARK_BRANCH)
+        EXECUTION_REPORT(REPORT_ERROR, comp_node->get_comp_id(), !time_mgr->get_time_has_been_advanced(), "Error happens when reading the restart file \"%s\": the model time has been advanced, while a component model cannot read any restart file after its model time has been advanced. Please check the model code with the annotation \"%s\"", restart_file_full_name, annotation);
+    read_restart_mgt_info((time_mgr->get_runtype_mark() == RUNTYPE_MARK_CONTINUE) || (time_mgr->get_runtype_mark() == RUNTYPE_MARK_BRANCH), restart_file_full_name, annotation);
 }
 
 
 void Restart_mgt::read_restart_mgt_info(bool check_existing_data, const char *file_name, const char *annotation)
 {
-	int local_proc_id = comp_comm_group_mgt_mgr->get_current_proc_id_in_comp(comp_node->get_comp_id(), "in Restart_mgt::do_restart");
-	char *array_buffer = NULL;
-	char temp_restart_read_data_file_name[NAME_STR_SIZE*2];
-	long buffer_content_iter;
-
-
-	restart_normal_fields_enabled = true;
-
-	if (time_mgr == NULL)
-		time_mgr = components_time_mgrs->get_time_mgr(comp_node->get_comp_id());
-
-	if (local_proc_id == 0) {
-		FILE *restart_fp = fopen(file_name, "r");
-		EXECUTION_REPORT(REPORT_ERROR, comp_node->get_comp_id(), restart_fp != NULL, "Error happens when trying to read restart data at the model code with the annotation \"%s\": the data file \"%s\" does not exist. Please verify.", annotation, file_name);
-		fseek(restart_fp, 0, SEEK_END);
-		buffer_content_iter = ftell(restart_fp);
-		array_buffer = new char [buffer_content_iter];
-		fseek(restart_fp, 0, SEEK_SET);
-		fread(array_buffer, buffer_content_iter, 1, restart_fp);
-	}
-	bcast_array_in_one_comp(local_proc_id, &array_buffer, buffer_content_iter, comp_node->get_comm_group());
-
-	int num_restart_buffer_containers;
-	EXECUTION_REPORT(REPORT_ERROR, -1, read_data_from_array_buffer(&num_restart_buffer_containers, sizeof(int), array_buffer, buffer_content_iter, false), "Fail to load the restart data file \"%s\": its format is wrong, or the information it includes is not complete. Please try a different restart time with complete restart data files.", file_name);
-	for (int i = 0; i < num_restart_buffer_containers; i ++) {
-		EXECUTION_REPORT(REPORT_ERROR, comp_node->get_comp_id(), buffer_content_iter > 0, "Software error in Restart_mgt::read_restart_mgt_info: wrong organization of restart data file");
-		restart_read_buffer_containers.push_back(new Restart_buffer_container(array_buffer, buffer_content_iter, file_name, this));
-	}
-	EXECUTION_REPORT(REPORT_ERROR, comp_node->get_comp_id(), buffer_content_iter == 0, "Software error in Restart_mgt::read_restart_mgt_info: wrong organization of restart data file");
-	delete [] array_buffer;
-
-	if ((time_mgr->get_runtype_mark() == RUNTYPE_MARK_CONTINUE) || (time_mgr->get_runtype_mark() == RUNTYPE_MARK_BRANCH)) {
-		Restart_buffer_container *time_mgr_restart_buffer = search_restart_buffer(RESTART_BUF_TYPE_TIME, "local time manager");
-		EXECUTION_REPORT(REPORT_ERROR, comp_node->get_comp_id(), time_mgr_restart_buffer != NULL, "Error happens when loading the restart file \"%s\" at the model code with the annotation \"%s\": this file does not include the data for restarting the time information", file_name, annotation);
-		long buffer_size = time_mgr_restart_buffer->get_buffer_content_iter();
-		time_mgr->import_restart_data(time_mgr_restart_buffer->get_buffer_content(), buffer_size, file_name, check_existing_data);
-	}
-
-	sprintf(temp_restart_read_data_file_name, "%s.nc", file_name);
-	EXECUTION_REPORT(REPORT_ERROR, comp_node->get_comp_id(), does_file_exist(temp_restart_read_data_file_name), "Error happens when loading the restart data file \"%s\" at the model code with the annotation \"%s\": the file does not exist", temp_restart_read_data_file_name);
-	restart_read_data_file_name = strdup(temp_restart_read_data_file_name);
+    int local_proc_id = comp_comm_group_mgt_mgr->get_current_proc_id_in_comp(comp_node->get_comp_id(), "in Restart_mgt::do_restart");
+    int temp_int;
+    char *array_buffer = NULL;
+    char temp_restart_read_data_file_name[NAME_STR_SIZE*2];
+    long buffer_content_iter;
+
+
+    restart_normal_fields_enabled = true;
+
+    if (time_mgr == NULL)
+        time_mgr = components_time_mgrs->get_time_mgr(comp_node->get_comp_id());
+
+    if (local_proc_id == 0) {
+        FILE *restart_fp = fopen(file_name, "r");
+        EXECUTION_REPORT(REPORT_ERROR, comp_node->get_comp_id(), restart_fp != NULL, "Error happens when trying to read restart data at the model code with the annotation \"%s\": the data file \"%s\" does not exist. Please verify.", annotation, file_name);
+        fseek(restart_fp, 0, SEEK_END);
+        buffer_content_iter = ftell(restart_fp);
+        array_buffer = new char [buffer_content_iter];
+        fseek(restart_fp, 0, SEEK_SET);
+        fread(array_buffer, buffer_content_iter, 1, restart_fp);
+    }
+    bcast_array_in_one_comp(local_proc_id, &array_buffer, buffer_content_iter, comp_node->get_comm_group());
+
+    int num_restart_buffer_containers;
+    EXECUTION_REPORT(REPORT_ERROR, -1, read_data_from_array_buffer(&num_restart_buffer_containers, sizeof(int), array_buffer, buffer_content_iter, false), "Fail to load the restart data file \"%s\": its format is wrong, or the information it includes is not complete. Please try a different restart time with complete restart data files.", file_name);
+    for (int i = 0; i < num_restart_buffer_containers; i ++) {
+        EXECUTION_REPORT(REPORT_ERROR, comp_node->get_comp_id(), buffer_content_iter > 0, "Software error in Restart_mgt::read_restart_mgt_info: wrong organization of restart data file");
+        restart_read_buffer_containers.push_back(new Restart_buffer_container(array_buffer, buffer_content_iter, file_name, this));
+    }
+    EXECUTION_REPORT(REPORT_ERROR, -1, read_data_from_array_buffer(&temp_int, sizeof(int), array_buffer, buffer_content_iter, false), "Fail to load the restart data file \"%s\": its format is wrong, or the information it includes is not complete. Please try a different restart time with complete restart data files.", file_name);
+    bypass_import_fields_at_read = (temp_int == 1);
+    EXECUTION_REPORT(REPORT_ERROR, comp_node->get_comp_id(), buffer_content_iter == 0, "Software error in Restart_mgt::read_restart_mgt_info: wrong organization of restart data file");
+    delete [] array_buffer;
+
+    if ((time_mgr->get_runtype_mark() == RUNTYPE_MARK_CONTINUE) || (time_mgr->get_runtype_mark() == RUNTYPE_MARK_BRANCH)) {
+        Restart_buffer_container *time_mgr_restart_buffer = search_restart_buffer(RESTART_BUF_TYPE_TIME, "local time manager");
+        EXECUTION_REPORT(REPORT_ERROR, comp_node->get_comp_id(), time_mgr_restart_buffer != NULL, "Error happens when loading the restart file \"%s\" at the model code with the annotation \"%s\": this file does not include the data for restarting the time information", file_name, annotation);
+        long buffer_size = time_mgr_restart_buffer->get_buffer_content_iter();
+        time_mgr->import_restart_data(time_mgr_restart_buffer->get_buffer_content(), buffer_size, file_name, check_existing_data);
+    }
+
+    sprintf(temp_restart_read_data_file_name, "%s.nc", file_name);
+    EXECUTION_REPORT(REPORT_ERROR, comp_node->get_comp_id(), does_file_exist(temp_restart_read_data_file_name), "Error happens when loading the restart data file \"%s\" at the model code with the annotation \"%s\": the file does not exist", temp_restart_read_data_file_name);
+    restart_read_data_file_name = strdup(temp_restart_read_data_file_name);
 }
 
 
-void Restart_mgt::do_restart_write(const char *annotation, bool bypass_timer)
+void Restart_mgt::do_restart_write(const char *annotation, bool bypass_timer, bool bypass_imported_fields)
 {
-	int local_proc_id = comp_node->get_current_proc_local_id();
-	const char *comp_full_name = comp_node->get_full_name();
-	long current_full_time;
-	Restart_buffer_container *time_mgr_restart_buffer;
-
-
-	if (time_mgr == NULL)
-		time_mgr = components_time_mgrs->get_time_mgr(comp_node->get_comp_id());
-	current_full_time = time_mgr->get_current_full_time();
-
-	if (bypass_timer || time_mgr->is_restart_timer_on()) {
-		EXECUTION_REPORT(REPORT_ERROR, comp_node->get_comp_id(), current_full_time != last_restart_write_full_time, "Error happens when the component model tries to write restart data files: the corresponding API \"CCPL_do_restart_write_IO\" has been called more than once at the same time step. Please verify the model code with the annotation \"%s\"", annotation);
-		if (time_mgr->get_runtype_mark() == RUNTYPE_MARK_CONTINUE || time_mgr->get_runtype_mark() == RUNTYPE_MARK_BRANCH) {
-			EXECUTION_REPORT(REPORT_ERROR, comp_node->get_comp_id(), time_mgr->get_restart_full_time() != ((long)time_mgr->get_current_num_elapsed_day()*((long)100000))+time_mgr->get_current_second(), "Error happens when the component model calls the API \"CCPL_do_restart_write_IO\" to write restart data at the model time %ld: the current model run is a %s run restarted at the same model time, while the model time to write restart data cannot be the same as the restarted model time. Please verify the model code with the annotation \"%s\".", current_full_time, time_mgr->get_run_type(), annotation);
-		}	
-		last_restart_write_full_time = current_full_time;
-		last_restart_write_elapsed_time = time_mgr->get_current_num_elapsed_day()*((long)100000)+time_mgr->get_current_second();
-		int date = last_restart_write_full_time/(long)100000;
-		int second = last_restart_write_full_time%(long)100000;
-		if (local_proc_id == 0) {
-			EXECUTION_REPORT(REPORT_ERROR, comp_node->get_comp_id(), restart_write_data_file == NULL, "Error happens when the component model tries to write restart data files: restart writing is too frequent so that a new restart writing starts before the previous restart writing does not finish. Please verify the model code with the annotation \"%s\"", annotation);
-			time_mgr_restart_buffer = apply_restart_buffer(comp_full_name, RESTART_BUF_TYPE_TIME, "local time manager");
-			time_mgr->write_time_mgt_into_array(time_mgr_restart_buffer->get_buffer_content_ptr(), *(time_mgr_restart_buffer->get_buffer_max_size_ptr()), *(time_mgr_restart_buffer->get_buffer_content_iter_ptr()));
-			char restart_data_file_name[NAME_STR_SIZE];
-			sprintf(restart_data_file_name, "%s/%s.%s.r.%08d-%05d.nc", comp_node->get_working_dir(), time_mgr->get_case_name(), comp_node->get_comp_full_name(), date, second);
-			restart_write_data_file = new IO_netcdf(restart_data_file_name, restart_data_file_name, "w", false);
-			sprintf(restart_data_file_name, "%s/%s.%s.r.%08d-%05d", comp_node->get_working_dir(), time_mgr->get_case_name(), comp_node->get_comp_full_name(), date, second);
-			FILE *restart_mgt_info_file = fopen(restart_data_file_name, "w+");
-			fclose(restart_mgt_info_file);
-		}
-		inout_interface_mgr->write_into_restart_buffers(comp_node->get_comp_id());
-		restart_mgt_info_written = false;
-		for (int i = 0; i < restarted_field_instances.size(); i ++)
-			write_restart_field_data(restarted_field_instances[i], NULL, NULL, false);
-	}
+    int local_proc_id = comp_node->get_current_proc_local_id();
+    const char *comp_full_name = comp_node->get_full_name();
+    long current_full_time;
+    Restart_buffer_container *time_mgr_restart_buffer;
+
+
+    bypass_import_fields_at_write = bypass_imported_fields;
+
+    if (time_mgr == NULL)
+        time_mgr = components_time_mgrs->get_time_mgr(comp_node->get_comp_id());
+    current_full_time = time_mgr->get_current_full_time();
+
+    check_API_parameter_bool(comp_node->get_comp_id(), API_ID_RESTART_MGT_WRITE_IO, comp_node->get_comm_group(), "generating restart data files", bypass_timer, "bypass_timer", annotation);
+    check_API_parameter_bool(comp_node->get_comp_id(), API_ID_RESTART_MGT_WRITE_IO, comp_node->get_comm_group(), "generating restart data files", bypass_imported_fields, "bypass_timer", annotation);
+
+    if (bypass_timer || time_mgr->is_restart_timer_on()) {
+        EXECUTION_REPORT(REPORT_ERROR, comp_node->get_comp_id(), current_full_time != last_restart_write_full_time, "Error happens when the component model tries to write restart data files: the corresponding API \"CCPL_do_restart_write_IO\" has been called more than once at the same time step. Please verify the model code with the annotation \"%s\"", annotation);
+        if (time_mgr->get_runtype_mark() == RUNTYPE_MARK_CONTINUE || time_mgr->get_runtype_mark() == RUNTYPE_MARK_BRANCH) {
+            EXECUTION_REPORT(REPORT_ERROR, comp_node->get_comp_id(), time_mgr->get_restart_full_time() != ((long)time_mgr->get_current_num_elapsed_day()*((long)100000))+time_mgr->get_current_second(), "Error happens when the component model calls the API \"CCPL_do_restart_write_IO\" to write restart data at the model time %ld: the current model run is a %s run restarted at the same model time, while the model time to write restart data cannot be the same as the restarted model time. Please verify the model code with the annotation \"%s\".", current_full_time, time_mgr->get_run_type(), annotation);
+        }    
+        last_restart_write_full_time = current_full_time;
+        last_restart_write_elapsed_time = time_mgr->get_current_num_elapsed_day()*((long)100000)+time_mgr->get_current_second();
+        int date = last_restart_write_full_time/(long)100000;
+        int second = last_restart_write_full_time%(long)100000;
+        if (local_proc_id == 0) {
+            EXECUTION_REPORT(REPORT_ERROR, comp_node->get_comp_id(), restart_write_data_file == NULL, "Error happens when the component model tries to write restart data files: restart writing is too frequent so that a new restart writing starts before the previous restart writing does not finish. Please verify the model code with the annotation \"%s\"", annotation);
+            time_mgr_restart_buffer = apply_restart_buffer(comp_full_name, RESTART_BUF_TYPE_TIME, "local time manager");
+            time_mgr->write_time_mgt_into_array(time_mgr_restart_buffer->get_buffer_content_ptr(), *(time_mgr_restart_buffer->get_buffer_max_size_ptr()), *(time_mgr_restart_buffer->get_buffer_content_iter_ptr()));
+            char restart_data_file_name[NAME_STR_SIZE];
+            sprintf(restart_data_file_name, "%s/%s.%s.r.%08d-%05d.nc", comp_node->get_working_dir(), time_mgr->get_case_name(), comp_node->get_comp_full_name(), date, second);
+            if (backup_restart_write_data_file != NULL) {
+                delete backup_restart_write_data_file;
+                backup_restart_write_data_file = NULL;
+            }
+            restart_write_data_file = new IO_netcdf(restart_data_file_name, restart_data_file_name, "w", false);
+            sprintf(restart_data_file_name, "%s/%s.%s.r.%08d-%05d", comp_node->get_working_dir(), time_mgr->get_case_name(), comp_node->get_comp_full_name(), date, second);
+            FILE *restart_mgt_info_file = fopen(restart_data_file_name, "w+");
+            fclose(restart_mgt_info_file);
+        }
+        inout_interface_mgr->write_into_restart_buffers(comp_node->get_comp_id());
+        restart_mgt_info_written = false;
+        for (int i = 0; i < restarted_field_instances.size(); i ++) {
+            if (!bypass_imported_fields)
+                write_restart_field_data(restarted_field_instances[i].first, NULL, NULL, false);
+            else if (!restarted_field_instances[i].second)
+                write_restart_field_data(restarted_field_instances[i].first, NULL, NULL, false);
+        }
+    }
 }
 
 
 void Restart_mgt::get_field_IO_name(char *field_IO_name, Field_mem_info *field_instance, const char *interface_name, const char*label, bool use_time_info)
 {
-	Field_mem_info *global_field = fields_gather_scatter_mgr->gather_field(field_instance);
-
-
-	if (interface_name != NULL) {
-		if (use_time_info)
-			sprintf(field_IO_name, "%s.%s.%s.%13ld", field_instance->get_field_name(), interface_name, label, time_mgr->get_current_full_time());
-		else sprintf(field_IO_name, "%s.%s.%s", field_instance->get_field_name(), interface_name, label);	
-	}
-	else {
-		char grid_name[NAME_STR_SIZE], decomp_name[NAME_STR_SIZE];
-		sprintf(grid_name, "NULL");
-		sprintf(decomp_name, "NULL");
-		if (field_instance->get_grid_name() != NULL)
-			strcpy(grid_name, field_instance->get_grid_name());
-		if (field_instance->get_decomp_name() != NULL)
-			strcpy(decomp_name, field_instance->get_decomp_name());
-		sprintf(field_IO_name, "%s.%s.%s.%d", field_instance->get_field_name(), grid_name, decomp_name, field_instance->get_buf_mark());
-	}
+    Field_mem_info *global_field = fields_gather_scatter_mgr->gather_field(field_instance);
+
+
+    if (interface_name != NULL) {
+        if (use_time_info)
+            sprintf(field_IO_name, "%s.%s.%s.%13ld", field_instance->get_field_name(), interface_name, label, time_mgr->get_current_full_time());
+        else sprintf(field_IO_name, "%s.%s.%s", field_instance->get_field_name(), interface_name, label);    
+    }
+    else {
+        char grid_name[NAME_STR_SIZE], decomp_name[NAME_STR_SIZE];
+        sprintf(grid_name, "NULL");
+        sprintf(decomp_name, "NULL");
+        if (field_instance->get_grid_name() != NULL)
+            strcpy(grid_name, field_instance->get_grid_name());
+        if (field_instance->get_decomp_name() != NULL)
+            strcpy(decomp_name, field_instance->get_decomp_name());
+        sprintf(field_IO_name, "%s.%s.%s.%d", field_instance->get_field_name(), grid_name, decomp_name, field_instance->get_buf_mark());
+    }
 }
 
 
 void Restart_mgt::write_restart_field_data(Field_mem_info *field_instance, const char *interface_name, const char*label, bool use_time_info)
 {
-	Field_mem_info *global_field = fields_gather_scatter_mgr->gather_field(field_instance);
-	char field_IO_name[NAME_STR_SIZE*2], hint[NAME_STR_SIZE*2];
-
-
-	get_field_IO_name(field_IO_name, field_instance, interface_name, label, use_time_info);
-	if (comp_node->get_current_proc_local_id() == 0) {
-		strcpy(global_field->get_field_data()->get_grid_data_field()->field_name_in_IO_file, field_IO_name);
-		EXECUTION_REPORT(REPORT_ERROR, -1, restart_write_data_file != NULL, "Software error in Restart_mgt::write_restart_field_data");
-		EXECUTION_REPORT_LOG(REPORT_LOG, comp_node->get_comp_id(), true, "Write variable \"%s\" into restart data file \"%s\"", global_field->get_field_data()->get_grid_data_field()->field_name_in_IO_file, restart_write_data_file->get_file_name());
-		restart_write_data_file->write_grided_data(global_field->get_field_data(), true, -1, -1, true);
-		sprintf(hint, "restart writing field \"%s\" to the file \"%s\"", field_IO_name, restart_write_data_file->get_file_name());
-	}
-	else sprintf(hint, "restart writing field \"%s\" to the file", field_IO_name);
-	field_instance->check_field_sum(hint);
+    Field_mem_info *global_field = fields_gather_scatter_mgr->gather_field(field_instance);
+    char field_IO_name[NAME_STR_SIZE*2], hint[NAME_STR_SIZE*2];
+
+
+    get_field_IO_name(field_IO_name, field_instance, interface_name, label, use_time_info);
+    if (comp_node->get_current_proc_local_id() == 0) {
+        strcpy(global_field->get_field_data()->get_grid_data_field()->field_name_in_IO_file, field_IO_name);
+        EXECUTION_REPORT(REPORT_ERROR, -1, restart_write_data_file != NULL && backup_restart_write_data_file == NULL || restart_write_data_file == NULL && backup_restart_write_data_file != NULL, "Software error in Restart_mgt::write_restart_field_data");
+        IO_netcdf *active_restart_write_data_file = restart_write_data_file != NULL? restart_write_data_file : backup_restart_write_data_file;
+        EXECUTION_REPORT_LOG(REPORT_LOG, comp_node->get_comp_id(), true, "Write variable \"%s\" into restart data file \"%s\"", global_field->get_field_data()->get_grid_data_field()->field_name_in_IO_file, active_restart_write_data_file->get_file_name());
+        active_restart_write_data_file->write_grided_data(global_field->get_field_data(), true, -1, -1, true);
+        sprintf(hint, "restart writing field \"%s\" to the file \"%s\"", field_IO_name, active_restart_write_data_file->get_file_name());
+    }
+    else sprintf(hint, "restart writing field \"%s\" to the file", field_IO_name);
+    field_instance->check_field_sum(hint);
 }
 
 
 void Restart_mgt::read_all_restarted_fields(const char *annotation)
 {
-	if (time_mgr == NULL)
-		time_mgr = components_time_mgrs->get_time_mgr(comp_node->get_comp_id());		
-	if (time_mgr->get_runtype_mark() == RUNTYPE_MARK_INITIAL)
-		return;
-
-	are_all_restarted_fields_read = true;
-	EXECUTION_REPORT(REPORT_ERROR, comp_node->get_comp_id(), input_restart_mgt_info_file != NULL,  "Error happens when calling the API \"CCPL_restart_read_fields_all\" to read restart fields: the API \"CCPL_start_restart_read_IO\" has not been called before. Please verify the model code corresponding to the annotation \"%s\"", annotation);
-	EXECUTION_REPORT(REPORT_ERROR, comp_node->get_comp_id(), !time_mgr->get_time_has_been_advanced(), "Error happens when calling the API \"CCPL_restart_read_fields_all\" to read restart fields: the model time has already been advanced before. Please verify the model code corresponding to the annotation \"%s\"", annotation);
-	EXECUTION_REPORT(REPORT_ERROR, comp_node->get_comp_id(), restart_normal_fields_enabled, "Error happens when calling the API \"CCPL_restart_read_fields_all\" to read restart fields: some import interfaces have been executed without bypassing the timer, which is not allowed. Please verify the model code corresponding to the annotation \"%s\"", annotation);
-
-	for (int i = 0; i < restarted_field_instances.size(); i ++)
-		read_restart_field_data(restarted_field_instances[i], NULL, NULL, false, NULL, annotation);
+    if (time_mgr == NULL)
+        time_mgr = components_time_mgrs->get_time_mgr(comp_node->get_comp_id());        
+    if (time_mgr->get_runtype_mark() == RUNTYPE_MARK_INITIAL)
+        return;
+
+    are_all_restarted_fields_read = true;
+    EXECUTION_REPORT(REPORT_ERROR, comp_node->get_comp_id(), input_restart_mgt_info_file != NULL,  "Error happens when calling the API \"CCPL_restart_read_fields_all\" to read restart fields: the API \"CCPL_start_restart_read_IO\" has not been called before. Please verify the model code corresponding to the annotation \"%s\"", annotation);
+    EXECUTION_REPORT(REPORT_ERROR, comp_node->get_comp_id(), !time_mgr->get_time_has_been_advanced(), "Error happens when calling the API \"CCPL_restart_read_fields_all\" to read restart fields: the model time has already been advanced before. Please verify the model code corresponding to the annotation \"%s\"", annotation);
+    EXECUTION_REPORT(REPORT_ERROR, comp_node->get_comp_id(), restart_normal_fields_enabled, "Error happens when calling the API \"CCPL_restart_read_fields_all\" to read restart fields: some import interfaces have been executed without bypassing the timer, which is not allowed. Please verify the model code corresponding to the annotation \"%s\"", annotation);
+
+    for (int i = 0; i < restarted_field_instances.size(); i ++)
+        read_restart_field_data(restarted_field_instances[i].first, NULL, NULL, false, NULL, bypass_import_fields_at_read&&restarted_field_instances[i].second, annotation);
 }
 
 
-void Restart_mgt::read_restart_field_data(Field_mem_info *field_instance, const char *interface_name, const char *label, bool use_time_info, const char *API_label, const char *annotation)
+void Restart_mgt::read_restart_field_data(Field_mem_info *field_instance, const char *interface_name, const char *label, bool use_time_info, const char *API_label, bool optional, const char *annotation)
 {
-	char field_IO_name[NAME_STR_SIZE*2], hint[NAME_STR_SIZE*2];
-
-		
-	get_field_IO_name(field_IO_name, field_instance, interface_name, label, use_time_info);
-
-	if (interface_name == NULL && !field_instance->is_checksum_changed()) {
-		EXECUTION_REPORT_LOG(REPORT_LOG, comp_node->get_comp_id(), true, "Does not read restart field \"%s\" from the file \"%s\" again at the model code with the annotation \"%s\".", field_IO_name, restart_read_data_file_name, annotation);
-		return;
-	}
-
-	if (interface_name != NULL)
-		restart_normal_fields_enabled = false;
-
-	EXECUTION_REPORT(REPORT_ERROR, comp_node->get_comp_id(), does_file_exist(restart_read_data_file_name), "Error happens when loading the restart data file \"%s\" at the model code with the annotation \"%s\": the file does not exist", restart_read_data_file_name, annotation);
-	IO_netcdf *restart_read_data_file = new IO_netcdf(restart_read_data_file_name, restart_read_data_file_name, "r", false);
-	bool has_data_in_file = fields_gather_scatter_mgr->read_scatter_field(restart_read_data_file, field_instance, field_IO_name, -1, false);
-	delete restart_read_data_file;
-	if (time_mgr->get_runtype_mark() == RUNTYPE_MARK_CONTINUE || time_mgr->get_runtype_mark() == RUNTYPE_MARK_BRANCH)
-		EXECUTION_REPORT(REPORT_ERROR, comp_node->get_comp_id(), has_data_in_file, "Error happens when loading the restart data file \"%s\" at the model code with the annotation \"%s\": the data file does not contain the variable \"%s\" for the field \"%s\" of the coupling interface %s", restart_read_data_file_name, annotation, field_IO_name, field_instance->get_field_name(), interface_name);
-	sprintf(hint, "restart reading field \"%s\" from the file \"%s\"", field_IO_name, restart_read_data_file_name);
-	field_instance->check_field_sum(hint);
-	field_instance->define_field_values(false);
-	field_instance->reset_checksum();
+    char field_IO_name[NAME_STR_SIZE*2], hint[NAME_STR_SIZE*2];
+
+        
+    get_field_IO_name(field_IO_name, field_instance, interface_name, label, use_time_info);
+
+    if (interface_name == NULL && !field_instance->is_checksum_changed()) {
+        EXECUTION_REPORT_LOG(REPORT_LOG, comp_node->get_comp_id(), true, "Does not read restart field \"%s\" from the file \"%s\" again at the model code with the annotation \"%s\".", field_IO_name, restart_read_data_file_name, annotation);
+        return;
+    }
+
+    if (interface_name != NULL)
+        restart_normal_fields_enabled = false;
+
+    EXECUTION_REPORT(REPORT_ERROR, comp_node->get_comp_id(), does_file_exist(restart_read_data_file_name), "Error happens when loading the restart data file \"%s\" at the model code with the annotation \"%s\": the file does not exist", restart_read_data_file_name, annotation);
+    IO_netcdf *restart_read_data_file = new IO_netcdf(restart_read_data_file_name, restart_read_data_file_name, "r", false);
+    bool has_data_in_file = fields_gather_scatter_mgr->read_scatter_field(restart_read_data_file, field_instance, field_IO_name, -1, false);
+    delete restart_read_data_file;
+    if (!optional && (time_mgr->get_runtype_mark() == RUNTYPE_MARK_CONTINUE || time_mgr->get_runtype_mark() == RUNTYPE_MARK_BRANCH))
+        if (interface_name != NULL)
+            EXECUTION_REPORT(REPORT_ERROR, comp_node->get_comp_id(), has_data_in_file, "Error happens when loading the restart data file \"%s\" at the model code with the annotation \"%s\": the data file does not contain the variable \"%s\" for the field \"%s\" of the coupling interface \"%s\"", restart_read_data_file_name, annotation, field_IO_name, field_instance->get_field_name(), interface_name);
+        else EXECUTION_REPORT(REPORT_ERROR, comp_node->get_comp_id(), has_data_in_file, "Error happens when loading the restart data file \"%s\" at the model code with the annotation \"%s\": the data file does not contain the variable \"%s\" for the field \"%s\"", restart_read_data_file_name, annotation, field_IO_name, field_instance->get_field_name());
+    sprintf(hint, "restart reading field \"%s\" from the file \"%s\"", field_IO_name, restart_read_data_file_name);
+    field_instance->check_field_sum(hint);
+    field_instance->define_field_values(false);
+    field_instance->reset_checksum();
 }
 
 
 void Restart_mgt::get_file_name_in_rpointer_file(char *restart_file_name)
 {
-	char rpointer_file_name[NAME_STR_SIZE], line[NAME_STR_SIZE*16], *line_p;
-	FILE *rpointer_file;
+    char rpointer_file_name[NAME_STR_SIZE], line[NAME_STR_SIZE*16], *line_p;
+    FILE *rpointer_file;
 
 
-	sprintf(rpointer_file_name, "%s/rpointer.%s", comp_comm_group_mgt_mgr->get_restart_common_dir(), comp_node->get_full_name());
-	EXECUTION_REPORT(REPORT_ERROR, comp_node->get_comp_id(), does_file_exist(rpointer_file_name), "Error happens when try to restart a continue/branch run: file \"%s\" does not exist", rpointer_file_name);
-	rpointer_file = fopen(rpointer_file_name, "r");
-	get_next_line(line, rpointer_file);
-	line_p = line;
-	get_next_attr(restart_file_name, &line_p);
-	fclose(rpointer_file);
+    sprintf(rpointer_file_name, "%s/rpointer.%s", comp_comm_group_mgt_mgr->get_restart_common_dir(), comp_node->get_full_name());
+    EXECUTION_REPORT(REPORT_ERROR, comp_node->get_comp_id(), does_file_exist(rpointer_file_name), "Error happens when try to restart a continue/branch run: file \"%s\" does not exist", rpointer_file_name);
+    rpointer_file = fopen(rpointer_file_name, "r");
+    get_next_line(line, rpointer_file);
+    line_p = line;
+    get_next_attr(restart_file_name, &line_p);
+    fclose(rpointer_file);
 }
 
 
 void Restart_mgt::write_restart_mgt_into_file()
 {
-	char *array_buffer = NULL;
-	long buffer_max_size, buffer_content_size;
-	int temp_int;
-	char restart_file_name[NAME_STR_SIZE], prev_rpointer_file_name[NAME_STR_SIZE], rpointer_file_name[NAME_STR_SIZE], line[NAME_STR_SIZE*16];
-	FILE *restart_file, *rpointer_file;
-	
-
-	if (comp_node->get_current_proc_local_id() != 0) {
-		clean(true);
-		return;
-	}
-
-	if (restart_mgt_info_written)
-		return;
-
-	if (inout_interface_mgr->is_comp_in_restart_write_window(comp_node->get_comp_id()))
-		return;
-
-	restart_mgt_info_written = true;
-	
-	for (int i = restart_write_buffer_containers.size()-1; i >= 0; i --)
-		restart_write_buffer_containers[i]->dump_out(&array_buffer, buffer_max_size, buffer_content_size);
-	temp_int = restart_write_buffer_containers.size();
-	write_data_into_array_buffer(&temp_int, sizeof(int), &array_buffer, buffer_max_size, buffer_content_size);
-
-	int date = last_restart_write_full_time/(long)100000;
-	int second = last_restart_write_full_time%(long)100000;
-	sprintf(restart_file_name, "%s/%s.%s.r.%08d-%05d", comp_node->get_working_dir(), time_mgr->get_case_name(), comp_node->get_comp_full_name(), date, second);
-	restart_file = fopen(restart_file_name, "w+");
-	EXECUTION_REPORT(REPORT_ERROR, comp_node->get_comp_id(), restart_file != NULL, "Failed to open the file \"%s\" for writing restart data", restart_file_name);
-	fwrite(array_buffer, buffer_content_size, 1, restart_file);
-	fclose(restart_file);
-	delete [] array_buffer;	
-	sprintf(rpointer_file_name, "%s/rpointer.%s", comp_comm_group_mgt_mgr->get_restart_common_dir(), comp_node->get_full_name());
-	if (does_file_exist(rpointer_file_name)) {
-		rpointer_file = fopen(rpointer_file_name, "r");
-		get_next_line(line, rpointer_file);
-		fclose(rpointer_file);		
-		sprintf(prev_rpointer_file_name, "%s/prev.rpointer.%s", comp_comm_group_mgt_mgr->get_restart_common_dir(), comp_node->get_full_name());
-		FILE *prev_rpointer_file = fopen(prev_rpointer_file_name, "w+");
-		fprintf(prev_rpointer_file, "%s\n", line);
-		fclose(prev_rpointer_file);
-	}
-	rpointer_file = fopen(rpointer_file_name, "w+");	
-	fprintf(rpointer_file, "%s.%s.r.%08d-%05d\n", time_mgr->get_case_name(), comp_node->get_comp_full_name(), date, second);
-	fclose(rpointer_file);
-	EXECUTION_REPORT_LOG(REPORT_LOG, comp_node->get_comp_id(), true, "Write restart mgt information into the file \"%s\"", restart_file_name);
-	EXECUTION_REPORT(REPORT_ERROR, -1, restart_write_data_file != NULL, "Software error in Restart_mgt::write_restart_mgt_into_file");
-
-	delete restart_write_data_file;
-	restart_write_data_file = NULL;
-
-	clean(true);
+    char *array_buffer = NULL;
+    long buffer_max_size, buffer_content_size;
+    int temp_int;
+    char restart_file_name[NAME_STR_SIZE], prev_rpointer_file_name[NAME_STR_SIZE], rpointer_file_name[NAME_STR_SIZE], line[NAME_STR_SIZE*16];
+    FILE *restart_file, *rpointer_file;
+    
+
+    if (comp_node->get_current_proc_local_id() != 0) {
+        clean(true);
+        return;
+    }
+
+    if (restart_mgt_info_written)
+        return;
+
+    if (inout_interface_mgr->is_comp_in_restart_write_window(comp_node->get_comp_id()))
+        return;
+
+    restart_mgt_info_written = true;
+
+    temp_int = bypass_import_fields_at_write? 1 : 0;
+    write_data_into_array_buffer(&temp_int, sizeof(int), &array_buffer, buffer_max_size, buffer_content_size);
+    
+    for (int i = restart_write_buffer_containers.size()-1; i >= 0; i --)
+        restart_write_buffer_containers[i]->dump_out(&array_buffer, buffer_max_size, buffer_content_size);
+    temp_int = restart_write_buffer_containers.size();
+    write_data_into_array_buffer(&temp_int, sizeof(int), &array_buffer, buffer_max_size, buffer_content_size);
+
+    int date = last_restart_write_full_time/(long)100000;
+    int second = last_restart_write_full_time%(long)100000;
+    sprintf(restart_file_name, "%s/%s.%s.r.%08d-%05d", comp_node->get_working_dir(), time_mgr->get_case_name(), comp_node->get_comp_full_name(), date, second);
+    restart_file = fopen(restart_file_name, "w+");
+    EXECUTION_REPORT(REPORT_ERROR, comp_node->get_comp_id(), restart_file != NULL, "Failed to open the file \"%s\" for writing restart data", restart_file_name);
+    fwrite(array_buffer, buffer_content_size, 1, restart_file);
+    fclose(restart_file);
+    delete [] array_buffer;    
+    sprintf(rpointer_file_name, "%s/rpointer.%s", comp_comm_group_mgt_mgr->get_restart_common_dir(), comp_node->get_full_name());
+    if (does_file_exist(rpointer_file_name)) {
+        rpointer_file = fopen(rpointer_file_name, "r");
+        get_next_line(line, rpointer_file);
+        fclose(rpointer_file);        
+        sprintf(prev_rpointer_file_name, "%s/prev.rpointer.%s", comp_comm_group_mgt_mgr->get_restart_common_dir(), comp_node->get_full_name());
+        FILE *prev_rpointer_file = fopen(prev_rpointer_file_name, "w+");
+        fprintf(prev_rpointer_file, "%s\n", line);
+        fclose(prev_rpointer_file);
+    }
+    rpointer_file = fopen(rpointer_file_name, "w+");    
+    fprintf(rpointer_file, "%s.%s.r.%08d-%05d\n", time_mgr->get_case_name(), comp_node->get_comp_full_name(), date, second);
+    fclose(rpointer_file);
+    EXECUTION_REPORT_LOG(REPORT_LOG, comp_node->get_comp_id(), true, "Write restart mgt information into the file \"%s\"", restart_file_name);
+    EXECUTION_REPORT(REPORT_ERROR, -1, restart_write_data_file != NULL, "Software error in Restart_mgt::write_restart_mgt_into_file");
+
+    backup_restart_write_data_file = restart_write_data_file;
+    restart_write_data_file = NULL;
+
+    clean(true);
 }
 
 
 const char *Restart_mgt::get_input_restart_mgt_info_file()
 {
-	EXECUTION_REPORT(REPORT_ERROR, comp_node->get_comp_id(), input_restart_mgt_info_file != NULL, "Failed to run the model in a continue or branch run: the restart file has not been read in. Please make sure that the API \"CCPL_start_restart_read_IO\" has been called");
-	return input_restart_mgt_info_file;
+    EXECUTION_REPORT(REPORT_ERROR, comp_node->get_comp_id(), input_restart_mgt_info_file != NULL, "Failed to run the model in a continue or branch run: the restart file has not been read in. Please make sure that the API \"CCPL_start_restart_read_IO\" has been called");
+    return input_restart_mgt_info_file;
 }
 
 
 const char *Restart_mgt::get_restart_read_annotation()
 {
-	EXECUTION_REPORT(REPORT_ERROR, comp_node->get_comp_id(), restart_read_annotation != NULL, "Failed to run the model in a continue or branch run: the restart file has not been read in. Please make sure that the API \"CCPL_start_restart_read_IO\" has been called");
-	return restart_read_annotation;
+    EXECUTION_REPORT(REPORT_ERROR, comp_node->get_comp_id(), restart_read_annotation != NULL, "Failed to run the model in a continue or branch run: the restart file has not been read in. Please make sure that the API \"CCPL_start_restart_read_IO\" has been called");
+    return restart_read_annotation;
 }
 
 
 Restart_buffer_container *Restart_mgt::apply_restart_buffer(const char *comp_full_name, const char *buf_type, const char *keyword)
 {
-	Restart_buffer_container *new_restart_buffer = new Restart_buffer_container(comp_full_name, buf_type, keyword, this);
-	restart_write_buffer_containers.push_back(new_restart_buffer);
+    Restart_buffer_container *new_restart_buffer = new Restart_buffer_container(comp_full_name, buf_type, keyword, this);
+    restart_write_buffer_containers.push_back(new_restart_buffer);
 
-	return new_restart_buffer;
+    return new_restart_buffer;
 }
 
 
 bool Restart_mgt::is_in_restart_write_window(long full_time, bool is_in_interface_execution)
 {
-	if (last_restart_write_elapsed_time == -1)
-		return false;
-
-	if (full_time == -1)
-		return time_mgr->get_current_num_elapsed_day()*((long)100000)+time_mgr->get_current_second() <= last_restart_write_elapsed_time;
-	else if (is_in_interface_execution) 
-		return full_time <= last_restart_write_elapsed_time || time_mgr->get_current_num_elapsed_day()*((long)100000)+time_mgr->get_current_second() <= last_restart_write_elapsed_time;
-	else return full_time < last_restart_write_elapsed_time || time_mgr->get_current_num_elapsed_day()*((long)100000)+time_mgr->get_current_second() <= last_restart_write_elapsed_time;
+    if (last_restart_write_elapsed_time == -1)
+        return false;
+
+    if (full_time == -1)
+        return time_mgr->get_current_num_elapsed_day()*((long)100000)+time_mgr->get_current_second() <= last_restart_write_elapsed_time;
+    else if (is_in_interface_execution) 
+        return full_time <= last_restart_write_elapsed_time || time_mgr->get_current_num_elapsed_day()*((long)100000)+time_mgr->get_current_second() <= last_restart_write_elapsed_time;
+    else return full_time < last_restart_write_elapsed_time || time_mgr->get_current_num_elapsed_day()*((long)100000)+time_mgr->get_current_second() <= last_restart_write_elapsed_time;
 }
 
 
 bool Restart_mgt::is_in_restart_read_window(long full_time)
 {
-	if (time_mgr == NULL)
-		time_mgr = components_time_mgrs->get_time_mgr(comp_node->get_comp_id());
+    if (time_mgr == NULL)
+        time_mgr = components_time_mgrs->get_time_mgr(comp_node->get_comp_id());
 
-	if (time_mgr->get_runtype_mark() == RUNTYPE_MARK_INITIAL || time_mgr->get_runtype_mark() == RUNTYPE_MARK_HYBRID)
-		return false;
+    if (time_mgr->get_runtype_mark() == RUNTYPE_MARK_INITIAL || time_mgr->get_runtype_mark() == RUNTYPE_MARK_HYBRID)
+        return false;
 
-	if (full_time == -1)
-		return false;
+    if (full_time == -1)
+        return false;
 
-	return full_time <= time_mgr->get_restart_full_time() || time_mgr->get_current_num_elapsed_day()*((long)100000)+time_mgr->get_current_second() <= time_mgr->get_restart_full_time();
+    return full_time <= time_mgr->get_restart_full_time() || time_mgr->get_current_num_elapsed_day()*((long)100000)+time_mgr->get_current_second() <= time_mgr->get_restart_full_time();
 }
 
 
-void Restart_mgt::add_restarted_field_instances(Field_mem_info *field_instance)
+void Restart_mgt::add_restarted_field_instance(Field_mem_info *field_instance, bool is_imported_field)
 {
-	for (int i = 0; i < restarted_field_instances.size(); i ++)
-		if (restarted_field_instances[i] == field_instance)
-			return;
-
-	restarted_field_instances.push_back(field_instance);
+    for (int i = 0; i < restarted_field_instances.size(); i ++)
+        if (restarted_field_instances[i].first == field_instance) {
+            if (!is_imported_field)
+                restarted_field_instances[i].second = is_imported_field;
+            return;
+        }
+
+    restarted_field_instances.push_back(std::make_pair(field_instance, is_imported_field));
 }
 
 
 bool Restart_mgt::check_restart_read_started()
 {
-	return input_restart_mgt_info_file != NULL;
+    return input_restart_mgt_info_file != NULL;
 }
 
diff --git a/src/Data_MGT/restart_mgt.h b/src/Data_MGT/restart_mgt.h
old mode 100644
new mode 100755
index bb0c786..c04cc87
--- a/src/Data_MGT/restart_mgt.h
+++ b/src/Data_MGT/restart_mgt.h
@@ -28,80 +28,83 @@ class Comp_comm_group_mgt_node;
 
 class Restart_buffer_container
 {
-	private:
-		char comp_full_name[NAME_STR_SIZE];
-		char buf_type[NAME_STR_SIZE];
-		char keyword[NAME_STR_SIZE];
-		char *buffer_content;
-		long buffer_content_iter;
-		long buffer_content_size;
-		long buffer_max_size;
-		Restart_mgt *restart_mgr;
-
-	public:
-		Restart_buffer_container(const char *, const char *, const char *, Restart_mgt *);
-		Restart_buffer_container(const char *, long &, const char *, Restart_mgt *);
-		~Restart_buffer_container() { delete [] buffer_content; }		
-		const char *get_buffer_content() { return buffer_content; }
-		long get_buffer_content_iter() { return buffer_content_iter; }
-		void dump_out(char **, long &, long &);
-		bool match(const char *, const char *);
-		void dump_in_string(const char *, long);
-		void dump_in_data(const void *, long);	
-		char **get_buffer_content_ptr() { return &buffer_content; }
-		long *get_buffer_content_iter_ptr() { return &buffer_content_iter; }
-		long *get_buffer_max_size_ptr() { return &buffer_max_size; }
-		void load_restart_data(void *, long);		
-		char *load_restart_string(char *, long &, long);
-		const char *get_input_restart_mgt_info_file();
-		Restart_mgt *get_restart_mgr() { return restart_mgr; }
+    private:
+        char comp_full_name[NAME_STR_SIZE];
+        char buf_type[NAME_STR_SIZE];
+        char keyword[NAME_STR_SIZE];
+        char *buffer_content;
+        long buffer_content_iter;
+        long buffer_content_size;
+        long buffer_max_size;
+        Restart_mgt *restart_mgr;
+
+    public:
+        Restart_buffer_container(const char *, const char *, const char *, Restart_mgt *);
+        Restart_buffer_container(const char *, long &, const char *, Restart_mgt *);
+        ~Restart_buffer_container() { delete [] buffer_content; }        
+        const char *get_buffer_content() { return buffer_content; }
+        long get_buffer_content_iter() { return buffer_content_iter; }
+        void dump_out(char **, long &, long &);
+        bool match(const char *, const char *);
+        void dump_in_string(const char *, long);
+        void dump_in_data(const void *, long);    
+        char **get_buffer_content_ptr() { return &buffer_content; }
+        long *get_buffer_content_iter_ptr() { return &buffer_content_iter; }
+        long *get_buffer_max_size_ptr() { return &buffer_max_size; }
+        void load_restart_data(void *, long);        
+        char *load_restart_string(char *, long &, long);
+        const char *get_input_restart_mgt_info_file();
+        Restart_mgt *get_restart_mgr() { return restart_mgr; }
 };
 
 
 class Restart_mgt
 {
-	private:
-		long last_restart_write_full_time;
-		long last_restart_write_elapsed_time;
-		std::vector<Restart_buffer_container*> restart_write_buffer_containers;
-		std::vector<Restart_buffer_container*> restart_read_buffer_containers;
-		std::vector<Field_mem_info*> restarted_field_instances;
-		Comp_comm_group_mgt_node *comp_node;
-		Time_mgt *time_mgr;
-		char *input_restart_mgt_info_file;
-		char *restart_read_annotation;
-		bool restart_mgt_info_written;
-		IO_netcdf *restart_write_data_file;
-		char *restart_read_data_file_name;
-		bool restart_normal_fields_enabled;
-		bool are_all_restarted_fields_read;
-
-	public:
-		Restart_mgt(Comp_comm_group_mgt_node*);
-		~Restart_mgt();
-		void clean(bool);
-		void do_restart_write(const char *, bool);
-		void write_restart_mgt_into_file();
-		void read_restart_mgt_info(bool, const char *, const char *);
-		void read_restart_mgt_info(const char *, const char *);
-		Restart_buffer_container *search_restart_buffer(const char *, const char*);
-		int get_comp_id();
-		void get_file_name_in_rpointer_file(char *);
-		const char *get_input_restart_mgt_info_file();
-		const char *get_restart_read_annotation();
-		Restart_buffer_container *apply_restart_buffer(const char *, const char *, const char *);
-		bool is_in_restart_write_window(long, bool);
-		bool is_in_restart_read_window(long);
-		void write_restart_field_data(Field_mem_info *, const char*, const char*, bool);
-		void read_restart_field_data(Field_mem_info *, const char *, const char *, bool, const char *, const char*);
-		const char *get_restart_read_data_file_name() { return restart_read_data_file_name; }
-		void add_restarted_field_instances(Field_mem_info*);
-		void get_field_IO_name(char *, Field_mem_info*, const char *, const char*, bool);
-		void read_all_restarted_fields(const char*);
-		bool check_restart_read_started();
-		bool get_are_all_restarted_fields_read() { return are_all_restarted_fields_read; }
+    private:
+        long last_restart_write_full_time;
+        long last_restart_write_elapsed_time;
+        std::vector<Restart_buffer_container*> restart_write_buffer_containers;
+        std::vector<Restart_buffer_container*> restart_read_buffer_containers;
+        std::vector<std::pair<Field_mem_info*, bool> > restarted_field_instances;
+        Comp_comm_group_mgt_node *comp_node;
+        Time_mgt *time_mgr;
+        char *input_restart_mgt_info_file;
+        char *restart_read_annotation;
+        bool restart_mgt_info_written;
+        IO_netcdf *restart_write_data_file;
+        IO_netcdf *backup_restart_write_data_file;
+        char *restart_read_data_file_name;
+        bool restart_normal_fields_enabled;
+        bool are_all_restarted_fields_read;
+        bool bypass_import_fields_at_read;
+        bool bypass_import_fields_at_write;
+
+    public:
+        Restart_mgt(Comp_comm_group_mgt_node*);
+        ~Restart_mgt();
+        void clean(bool);
+        void do_restart_write(const char *, bool, bool);
+        void write_restart_mgt_into_file();
+        void read_restart_mgt_info(bool, const char *, const char *);
+        void read_restart_mgt_info(const char *, const char *);
+        Restart_buffer_container *search_restart_buffer(const char *, const char*);
+        int get_comp_id();
+        void get_file_name_in_rpointer_file(char *);
+        const char *get_input_restart_mgt_info_file();
+        const char *get_restart_read_annotation();
+        Restart_buffer_container *apply_restart_buffer(const char *, const char *, const char *);
+        bool is_in_restart_write_window(long, bool);
+        bool is_in_restart_read_window(long);
+        void write_restart_field_data(Field_mem_info *, const char*, const char*, bool);
+        void read_restart_field_data(Field_mem_info *, const char *, const char *, bool, const char *, bool, const char*);
+        const char *get_restart_read_data_file_name() { return restart_read_data_file_name; }
+        void add_restarted_field_instance(Field_mem_info*, bool);
+        void get_field_IO_name(char *, Field_mem_info*, const char *, const char*, bool);
+        void read_all_restarted_fields(const char*);
+        bool check_restart_read_started();
+        bool get_are_all_restarted_fields_read() { return are_all_restarted_fields_read; }
+        bool get_bypass_import_fields_at_read() { return bypass_import_fields_at_read; }
 };
 
 
-
 #endif
diff --git a/src/Driver/CCPL_api_mgt.cxx b/src/Driver/CCPL_api_mgt.cxx
old mode 100644
new mode 100755
index 19ed2b2..b50b89d
--- a/src/Driver/CCPL_api_mgt.cxx
+++ b/src/Driver/CCPL_api_mgt.cxx
@@ -16,769 +16,779 @@
 
 long calculate_checksum_of_array(const char *data_array, int array_size, int data_type_size, const char *original_data_type, const char *new_data_type)
 {
-	const char *local_buffer = data_array;
-	long total_checksum = 0, temp_checksum = 0;
+    const char *local_buffer = data_array;
+    long total_checksum = 0, temp_checksum = 0;
 
 
-	for (int i = 0; i < array_size*data_type_size/sizeof(long); i ++)
-		total_checksum += ((const long*) local_buffer)[i] * (i+1);
-	for (int i = (array_size*data_type_size/sizeof(long))*sizeof(long); i < array_size*data_type_size; i ++) 
-		temp_checksum = (temp_checksum << 8) | local_buffer[i];
-	total_checksum += temp_checksum * ((array_size*data_type_size/sizeof(long))+1);
+    for (int i = 0; i < array_size*data_type_size/sizeof(long); i ++)
+        total_checksum += ((const long*) local_buffer)[i] * (i+1);
+    for (int i = (array_size*data_type_size/sizeof(long))*sizeof(long); i < array_size*data_type_size; i ++) 
+        temp_checksum = (temp_checksum << 8) | local_buffer[i];
+    total_checksum += temp_checksum * ((array_size*data_type_size/sizeof(long))+1);
 
-	if (local_buffer != data_array)
-		delete [] local_buffer;
+    if (local_buffer != data_array)
+        delete [] local_buffer;
 
-	return total_checksum;
+    return total_checksum;
 }
 
 
 void get_API_hint(int comp_id, int API_id, char *API_label)
 {
-	switch(API_id) {
+    switch(API_id) {
         case API_ID_FINALIZE:
-			sprintf(API_label, "CCPL_finalize");
-			break;
+            sprintf(API_label, "CCPL_finalize");
+            break;
         case API_ID_COMP_MGT_REG_COMP:
-			sprintf(API_label, "CCPL_register_component");
-			break;
-		case API_ID_COMP_MGT_GET_COMP_LOG_FILE_NAME:
-			sprintf(API_label, "CCPL_get_comp_log_file_name");
-			break;			
-		case API_ID_COMP_MGT_GET_COMP_LOG_FILE_DEVICE:
-			sprintf(API_label, "CCPL_get_comp_log_file_device");
-			break;
+            sprintf(API_label, "CCPL_register_component");
+            break;
+        case API_ID_COMP_MGT_GET_COMP_LOG_FILE_NAME:
+            sprintf(API_label, "CCPL_get_comp_log_file_name");
+            break;            
+        case API_ID_COMP_MGT_GET_COMP_LOG_FILE_DEVICE:
+            sprintf(API_label, "CCPL_get_comp_log_file_device");
+            break;
         case API_ID_COMP_MGT_END_COMP_REG:
-			sprintf(API_label, "CCPL_end_coupling_configuration");
-			break;
-		case API_ID_COMP_MGT_GET_COMP_ID:
-			sprintf(API_label, "CCPL_get_component_id");
-			break;
-		case API_ID_COMP_MGT_IS_COMP_TYPE_COUPLED:
-			sprintf(API_label, "CCPL_is_comp_type_coupled");
-			break;			
-		case API_ID_COMP_MGT_IS_CURRENT_PROC_IN_COMP:
-			sprintf(API_label, "CCPL_is_current_process_in_component");
-			break;
-		case API_ID_COMP_MGT_GET_CURRENT_PROC_ID_IN_COMP:
-			sprintf(API_label, "CCPL_get_current_process_id_in_component");
-			break;
-		case API_ID_COMP_MGT_GET_NUM_PROC_IN_COMP:
-			sprintf(API_label, "CCPL_get_num_process_in_component");
-			break;	
-		case API_ID_COMP_MGT_GET_COMP_PROC_GLOBAL_ID:
-			sprintf(API_label, "CCPL_get_component_process_global_id");
-			break;	
-		case API_ID_GRID_MGT_REG_H2D_GRID_VIA_LOCAL_DATA:
-			sprintf(API_label, "CCPL_register_H2D_grid_via_local_data");
-			break;
+            sprintf(API_label, "CCPL_end_coupling_configuration");
+            break;
+        case API_ID_COMP_MGT_GET_COMP_ID:
+            sprintf(API_label, "CCPL_get_component_id");
+            break;
+        case API_ID_COMP_MGT_IS_COMP_TYPE_COUPLED:
+            sprintf(API_label, "CCPL_is_comp_type_coupled");
+            break;            
+        case API_ID_COMP_MGT_IS_CURRENT_PROC_IN_COMP:
+            sprintf(API_label, "CCPL_is_current_process_in_component");
+            break;
+        case API_ID_COMP_MGT_GET_CURRENT_PROC_ID_IN_COMP:
+            sprintf(API_label, "CCPL_get_current_process_id_in_component");
+            break;
+        case API_ID_COMP_MGT_GET_NUM_PROC_IN_COMP:
+            sprintf(API_label, "CCPL_get_num_process_in_component");
+            break;    
+        case API_ID_COMP_MGT_GET_COMP_PROC_GLOBAL_ID:
+            sprintf(API_label, "CCPL_get_component_process_global_id");
+            break;    
+        case API_ID_GRID_MGT_REG_H2D_GRID_VIA_LOCAL_DATA:
+            sprintf(API_label, "CCPL_register_H2D_grid_via_local_data");
+            break;
         case API_ID_GRID_MGT_REG_H2D_GRID_VIA_GLOBAL_DATA:
-			sprintf(API_label, "CCPL_register_H2D_grid_via_global_data");
-			break;
+            sprintf(API_label, "CCPL_register_H2D_grid_via_global_data");
+            break;
         case API_ID_GRID_MGT_REG_H2D_GRID_VIA_FILE:
-			sprintf(API_label, "CCPL_register_H2D_grid_via_data_file");
-			break;
+            sprintf(API_label, "CCPL_register_H2D_grid_via_data_file");
+            break;
         case API_ID_GRID_MGT_REG_1D_GRID_ONLINE:
-			sprintf(API_label, "CCPL_register_1D_grid");
-			break;
+            sprintf(API_label, "CCPL_register_1D_grid");
+            break;
         case API_ID_GRID_MGT_REG_GRID_VIA_COR:
-			sprintf(API_label, "CCPL_register_CoR_defined_grid");
-			break;
-		case API_ID_GRID_MGT_GET_GRID_SIZE:
-			sprintf(API_label, "CCPL_get_grid_size");
-			break;			
+            sprintf(API_label, "CCPL_register_CoR_defined_grid");
+            break;
+        case API_ID_GRID_MGT_GET_GRID_SIZE:
+            sprintf(API_label, "CCPL_get_grid_size");
+            break;            
         case API_ID_GRID_MGT_REG_GRID_VIA_LOCAL:
-			sprintf(API_label, "CCPL_get_local_grid");
-			break;
+            sprintf(API_label, "CCPL_get_local_grid");
+            break;
         case API_ID_GRID_MGT_REG_H2D_GRID_VIA_COMP:
-			sprintf(API_label, "CCPL_register_H2D_grid_from_another_component");
-			break;
+            sprintf(API_label, "CCPL_register_H2D_grid_from_another_component");
+            break;
         case API_ID_GRID_MGT_CMP_GRID_VIA_REMOTE:
-			sprintf(API_label, "CCPL_compare_to_remote_grid");
-			break;
+            sprintf(API_label, "CCPL_compare_to_remote_grid");
+            break;
         case API_ID_GRID_MGT_GET_GRID_ID:
-			sprintf(API_label, "CCPL_get_grid_id");
-			break;
+            sprintf(API_label, "CCPL_get_grid_id");
+            break;
         case API_ID_GRID_MGT_SET_GRID_DATA:
-			sprintf(API_label, "CCPL_set_grid_data");
-			break;
+            sprintf(API_label, "CCPL_set_grid_data");
+            break;
+        case API_ID_GRID_MGT_SET_3D_GRID_3D_VERT_FLD:
+            sprintf(API_label, "CCPL_set_3D_grid_3D_vertical_coord_field");
+            break;
         case API_ID_GRID_MGT_SET_3D_GRID_DYN_BOT_FLD:
-			sprintf(API_label, "CCPL_set_3D_grid_dynamic_surface_field");
-			break;
+            sprintf(API_label, "CCPL_set_3D_grid_dynamic_surface_field");
+            break;
         case API_ID_GRID_MGT_SET_3D_GRID_STATIC_BOT_FLD:
-			sprintf(API_label, "CCPL_set_3D_grid_static_surface_field");
-			break;
-		case API_ID_GRID_MGT_SET_3D_GRID_EXTERNAL_BOT_FLD:
-			sprintf(API_label, "CCPL_set_3D_grid_external_surface_field");
-			break;			
+            sprintf(API_label, "CCPL_set_3D_grid_static_surface_field");
+            break;
+        case API_ID_GRID_MGT_SET_3D_GRID_EXTERNAL_BOT_FLD:
+            sprintf(API_label, "CCPL_set_3D_grid_external_surface_field");
+            break;            
         case API_ID_GRID_MGT_GET_H2D_GRID_DATA:
-			sprintf(API_label, "CCPL_get_H2D_grid_data");
-			break;
-		case API_ID_GRID_MGT_GET_H2D_GRID_AREA_FROM_WGTS:
-			sprintf(API_label, "CCPL_get_H2D_grid_area_in_remapping_wgts");
-			break;
+            sprintf(API_label, "CCPL_get_H2D_grid_data");
+            break;
+        case API_ID_GRID_MGT_GET_H2D_GRID_AREA_FROM_WGTS:
+            sprintf(API_label, "CCPL_get_H2D_grid_area_in_remapping_wgts");
+            break;
         case API_ID_GRID_MGT_REG_MID_POINT_GRID:
-			sprintf(API_label, "CCPL_register_mid_point_grid");
-			break;
-		case API_ID_GRID_MGT_REG_V1D_Z_GRID_VIA_MODEL:
-			sprintf(API_label, "CCPL_register_V1D_Z_grid_via_model_data");
-			break;	
-		case API_ID_GRID_MGT_REG_V1D_SIGMA_GRID_VIA_MODEL:
-			sprintf(API_label, "CCPL_register_V1D_SIGMA_grid_via_model_data");
-			break;	
-		case API_ID_GRID_MGT_REG_V1D_HYBRID_GRID_VIA_MODEL:
-			sprintf(API_label, "CCPL_register_V1D_HYBRID_grid_via_model_data");
-			break;	
-		case API_ID_GRID_MGT_REG_MD_GRID_VIA_MULTI_GRIDS:
-			sprintf(API_label, "CCPL_register_MD_grid_via_multi_grids");
-			break;			
-		case API_ID_DECOMP_MGT_REG_DECOMP:
-			sprintf(API_label, "CCPL_register_normal_parallel_decomp");
-			break;
-		case API_ID_FIELD_MGT_REG_FIELD_INST:
-			sprintf(API_label, "CCPL_register_field_instance");
-			break;
-		case API_ID_TIME_MGT_SET_NORMAL_TIME_STEP:
-			sprintf(API_label, "CCPL_set_normal_time_step");
-			break;
-		case API_ID_TIME_MGT_RESET_TIME_TO_START:
-			sprintf(API_label, "CCPL_reset_current_time_to_start_time");
-			break;			
-		case API_ID_TIME_MGT_ADVANCE_TIME:
-			sprintf(API_label, "CCPL_advance_time");
-			break;
-		case API_ID_TIME_MGT_GET_CURRENT_NUM_DAYS_IN_YEAR:
-			sprintf(API_label, "CCPL_get_current_num_days_in_year");
-			break;			
-		case API_ID_TIME_MGT_GET_CURRENT_YEAR:
-			sprintf(API_label, "CCPL_get_current_year");
-			break;						
-		case API_ID_TIME_MGT_GET_CURRENT_DATE:
-			sprintf(API_label, "CCPL_get_current_date");
-			break;						
-		case API_ID_TIME_MGT_GET_CURRENT_SECOND:
-			sprintf(API_label, "CCPL_get_current_second");
-			break;						
-		case API_ID_TIME_MGT_GET_START_TIME:
-			sprintf(API_label, "CCPL_get_start_time");
-			break;						
-		case API_ID_TIME_MGT_GET_STOP_TIME:
-			sprintf(API_label, "CCPL_get_stop_time");
-			break;			
-		case API_ID_TIME_MGT_GET_PREVIOUS_TIME:
-			sprintf(API_label, "CCPL_get_previous_time");
-			break;						
-		case API_ID_TIME_MGT_GET_CURRENT_TIME:
-			sprintf(API_label, "CCPL_get_current_time");
-			break;			
-		case API_ID_TIME_MGT_GET_ELAPSED_DAYS_FROM_REF:
-			sprintf(API_label, "CCPL_get_num_elapsed_days_from_reference");
-			break;			
-		case API_ID_TIME_MGT_GET_ELAPSED_DAYS_FROM_START:
-			sprintf(API_label, "CCPL_get_num_elapsed_days_from_start");
-			break;			
-		case API_ID_TIME_MGT_IS_END_CURRENT_DAY:
-			sprintf(API_label, "CCPL_is_end_current_day");
-			break;			
-		case API_ID_TIME_MGT_IS_END_CURRENT_MONTH:
-			sprintf(API_label, "CCPL_is_end_current_month");
-			break;			
-		case API_ID_TIME_MGT_GET_CURRENT_CAL_TIME:
-			sprintf(API_label, "CCPL_get_current_calendar_time");
-			break;											
-		case API_ID_TIME_MGT_IS_FIRST_STEP:
-			sprintf(API_label, "CCPL_is_first_step");
-			break;
-		case API_ID_TIME_MGT_IS_FIRST_RESTART_STEP:
-			sprintf(API_label, "CCPL_is_first_restart_step");
-			break;			
-		case API_ID_TIME_MGT_GET_NUM_CURRENT_STEP:
-			sprintf(API_label, "CCPL_get_number_of_current_step");
-			break;
-		case API_ID_TIME_MGT_GET_NUM_TOTAL_STEPS:
-			sprintf(API_label, "CCPL_get_number_of_total_steps");
-			break;
-		case API_ID_TIME_MGT_GET_NORMAL_TIME_STEP:
-			sprintf(API_label, "CCPL_get_normal_time_step");
-			break;
-		case API_ID_TIME_MGT_CHECK_CURRENT_TIME:
-			sprintf(API_label, "CCPL_check_current_time");
-			break;
-		case API_ID_TIME_MGT_IS_TIMER_ON:
-			sprintf(API_label, "CCPL_is_timer_on");
-			break;
-		case API_ID_TIME_MGT_IS_MODEL_RUN_ENDED:
-			sprintf(API_label, "CCPL_is_model_run_ended");
-			break;
-		case API_ID_TIME_MGT_IS_MODEL_LAST_STEP:
-			sprintf(API_label, "CCPL_is_last_step_of_model_run");
-			break;			
-		case API_ID_INTERFACE_REG_IMPORT:
-			sprintf(API_label, "CCPL_register_import_interface");
-			break;
-		case API_ID_INTERFACE_REG_EXPORT:
-			sprintf(API_label, "CCPL_register_export_interface");
-			break;
-		case API_ID_INTERFACE_REG_NORMAL_REMAP: 
-			sprintf(API_label, "CCPL_register_normal_remap_interface");
-			break;
-		case API_ID_INTERFACE_REG_FRAC_REMAP:
-			sprintf(API_label, "CCPL_register_frac_based_remap_interface");
-			break;
-		case API_ID_INTERFACE_EXECUTE_WITH_ID:
-			sprintf(API_label, "CCPL_execute_interface_using_id");
-			break;
-		case API_ID_INTERFACE_EXECUTE_WITH_NAME:
-			sprintf(API_label, "CCPL_execute_interface_using_name");
-			break;
-		case API_ID_INTERFACE_CHECK_IMPORT_FIELD_CONNECTED:
-			sprintf(API_label, "CCPL_check_is_import_field_connected");
-			break;
-		case API_ID_INTERFACE_GET_LOCAL_COMP_FULL_NAME:
-			sprintf(API_label, "CCPL_get_local_comp_full_name");
-			break;
-		case API_ID_TIME_MGT_DEFINE_SINGLE_TIMER:
-			sprintf(API_label, "CCPL_define_single_timer");
-			break;
-		case API_ID_TIME_MGT_DEFINE_COMPLEX_TIMER:
-			sprintf(API_label, "CCPL_define_complex_timer");
-			break;
-		case API_ID_FIELD_MGT_REG_IO_FIELD_from_INST:
-			sprintf(API_label, "CCPL_register_IO_field_from_field_instance");
-			break;
-		case API_ID_FIELD_MGT_REG_IO_FIELDs_from_INSTs:
-			sprintf(API_label, "CCPL_register_IO_fields_from_field_instances");
-			break;
-		case API_ID_FIELD_MGT_REG_IO_FIELD_from_BUFFER:
-			sprintf(API_label, "CCPL_register_IO_field_from_data_buffer");
-			break;
-		case API_ID_REPORT_LOG:
-			sprintf(API_label, "CCPL_report_log");
-			break;			
-		case API_ID_REPORT_PROGRESS:
-			sprintf(API_label, "CCPL_report_progress");
-			break;	
-		case API_ID_REPORT_ERROR:
-			sprintf(API_label, "CCPL_report_error");
-			break;	
-		case API_ID_RESTART_MGT_START_READ_IO:
-			sprintf(API_label, "CCPL_start_restart_read_IO");
-			break;
-		case API_ID_RESTART_MGT_READ_ALL:
-			sprintf(API_label, "CCPL_restart_read_fields_all");
-			break;			
-		case API_ID_RESTART_MGT_READ_INTERFACE:
-			sprintf(API_label, "CCPL_restart_read_fields_interface");
-			break;	
-		case API_ID_RESTART_MGT_GET_SETTING:
-			sprintf(API_label, "CCPL_get_restart_setting");
-			break;				
-		case API_ID_RESTART_MGT_IS_TIMER_ON:
-			sprintf(API_label, "CCPL_is_restart_timer_on");
-			break;
-		case API_ID_RESTART_MGT_WRITE_IO:
-			sprintf(API_label, "CCPL_do_restart_write_IO");
-			break;
-		case API_ID_COUPLING_GEN_FAMILY:
-			sprintf(API_label, "CCPL_do_family_coupling_generation");
-			break;
-		case API_ID_COUPLING_GEN_INDIVIDUAL:
-			sprintf(API_label, "CCPL_do_individual_coupling_generation");
-			break;
-		case API_ID_COUPLING_GEN_EXTERNAL:
-			sprintf(API_label, "CCPL_do_external_coupling_generation");
-			break;
-		case API_ID_COUPLING_GEN_GET_COMPS:
-			sprintf(API_label, "CCPL_get_configurable_comps_full_names");
-			break;
-		default:
-			EXECUTION_REPORT(REPORT_ERROR, comp_id, false, "software error1 in get_API_hint %x", API_id);
-			break;
-	}
+            sprintf(API_label, "CCPL_register_mid_point_grid");
+            break;
+        case API_ID_GRID_MGT_REG_V1D_GRID_NO_DATA:
+            sprintf(API_label, "CCPL_register_V1D_grid_without_data");
+            break; 
+        case API_ID_GRID_MGT_REG_V1D_Z_GRID_VIA_MODEL:
+            sprintf(API_label, "CCPL_register_V1D_Z_grid_via_model_data");
+            break;    
+        case API_ID_GRID_MGT_REG_V1D_SIGMA_GRID_VIA_MODEL:
+            sprintf(API_label, "CCPL_register_V1D_SIGMA_grid_via_model_data");
+            break;    
+        case API_ID_GRID_MGT_REG_V1D_HYBRID_GRID_VIA_MODEL:
+            sprintf(API_label, "CCPL_register_V1D_HYBRID_grid_via_model_data");
+            break;    
+        case API_ID_GRID_MGT_REG_MD_GRID_VIA_MULTI_GRIDS:
+            sprintf(API_label, "CCPL_register_MD_grid_via_multi_grids");
+            break;            
+        case API_ID_DECOMP_MGT_REG_DECOMP:
+            sprintf(API_label, "CCPL_register_normal_parallel_decomp");
+            break;
+        case API_ID_FIELD_MGT_REG_FIELD_INST:
+            sprintf(API_label, "CCPL_register_field_instance");
+            break;
+        case API_ID_TIME_MGT_SET_NORMAL_TIME_STEP:
+            sprintf(API_label, "CCPL_set_normal_time_step");
+            break;
+        case API_ID_TIME_MGT_RESET_TIME_TO_START:
+            sprintf(API_label, "CCPL_reset_current_time_to_start_time");
+            break;            
+        case API_ID_TIME_MGT_ADVANCE_TIME:
+            sprintf(API_label, "CCPL_advance_time");
+            break;
+        case API_ID_TIME_MGT_GET_CURRENT_NUM_DAYS_IN_YEAR:
+            sprintf(API_label, "CCPL_get_current_num_days_in_year");
+            break;            
+        case API_ID_TIME_MGT_GET_CURRENT_YEAR:
+            sprintf(API_label, "CCPL_get_current_year");
+            break;                        
+        case API_ID_TIME_MGT_GET_CURRENT_DATE:
+            sprintf(API_label, "CCPL_get_current_date");
+            break;                        
+        case API_ID_TIME_MGT_GET_CURRENT_SECOND:
+            sprintf(API_label, "CCPL_get_current_second");
+            break;                        
+        case API_ID_TIME_MGT_GET_START_TIME:
+            sprintf(API_label, "CCPL_get_start_time");
+            break;                        
+        case API_ID_TIME_MGT_GET_STOP_TIME:
+            sprintf(API_label, "CCPL_get_stop_time");
+            break;            
+        case API_ID_TIME_MGT_GET_PREVIOUS_TIME:
+            sprintf(API_label, "CCPL_get_previous_time");
+            break;                        
+        case API_ID_TIME_MGT_GET_CURRENT_TIME:
+            sprintf(API_label, "CCPL_get_current_time");
+            break;            
+        case API_ID_TIME_MGT_GET_ELAPSED_DAYS_FROM_REF:
+            sprintf(API_label, "CCPL_get_num_elapsed_days_from_reference");
+            break;            
+        case API_ID_TIME_MGT_GET_ELAPSED_DAYS_FROM_START:
+            sprintf(API_label, "CCPL_get_num_elapsed_days_from_start");
+            break;            
+        case API_ID_TIME_MGT_IS_END_CURRENT_DAY:
+            sprintf(API_label, "CCPL_is_end_current_day");
+            break;            
+        case API_ID_TIME_MGT_IS_END_CURRENT_MONTH:
+            sprintf(API_label, "CCPL_is_end_current_month");
+            break;            
+        case API_ID_TIME_MGT_GET_CURRENT_CAL_TIME:
+            sprintf(API_label, "CCPL_get_current_calendar_time");
+            break;                                            
+        case API_ID_TIME_MGT_IS_FIRST_STEP:
+            sprintf(API_label, "CCPL_is_first_step");
+            break;
+        case API_ID_TIME_MGT_IS_FIRST_RESTART_STEP:
+            sprintf(API_label, "CCPL_is_first_restart_step");
+            break;            
+        case API_ID_TIME_MGT_GET_NUM_CURRENT_STEP:
+            sprintf(API_label, "CCPL_get_number_of_current_step");
+            break;
+        case API_ID_TIME_MGT_GET_NUM_TOTAL_STEPS:
+            sprintf(API_label, "CCPL_get_number_of_total_steps");
+            break;
+        case API_ID_TIME_MGT_GET_NORMAL_TIME_STEP:
+            sprintf(API_label, "CCPL_get_normal_time_step");
+            break;
+        case API_ID_TIME_MGT_CHECK_CURRENT_TIME:
+            sprintf(API_label, "CCPL_check_current_time");
+            break;
+        case API_ID_TIME_MGT_IS_TIMER_ON:
+            sprintf(API_label, "CCPL_is_timer_on");
+            break;
+        case API_ID_TIME_MGT_IS_MODEL_RUN_ENDED:
+            sprintf(API_label, "CCPL_is_model_run_ended");
+            break;
+        case API_ID_TIME_MGT_IS_MODEL_LAST_STEP:
+            sprintf(API_label, "CCPL_is_last_step_of_model_run");
+            break;            
+        case API_ID_INTERFACE_REG_IMPORT:
+            sprintf(API_label, "CCPL_register_import_interface");
+            break;
+        case API_ID_INTERFACE_REG_EXPORT:
+            sprintf(API_label, "CCPL_register_export_interface");
+            break;
+        case API_ID_INTERFACE_REG_NORMAL_REMAP: 
+            sprintf(API_label, "CCPL_register_normal_remap_interface");
+            break;
+        case API_ID_INTERFACE_REG_FRAC_REMAP:
+            sprintf(API_label, "CCPL_register_frac_based_remap_interface");
+            break;
+        case API_ID_INTERFACE_EXECUTE_WITH_ID:
+            sprintf(API_label, "CCPL_execute_interface_using_id");
+            break;
+        case API_ID_INTERFACE_EXECUTE_WITH_NAME:
+            sprintf(API_label, "CCPL_execute_interface_using_name");
+            break;
+        case API_ID_INTERFACE_CHECK_IMPORT_FIELD_CONNECTED:
+            sprintf(API_label, "CCPL_check_is_import_field_connected");
+            break;
+		case API_ID_INTERFACE_GET_SENDER_TIME:
+			sprintf(API_label, "CCPL_get_import_fields_sender_time");
+			break;
+        case API_ID_COMP_MGT_GET_LOCAL_COMP_FULL_NAME:
+            sprintf(API_label, "CCPL_get_local_comp_full_name");
+            break;
+        case API_ID_TIME_MGT_DEFINE_SINGLE_TIMER:
+            sprintf(API_label, "CCPL_define_single_timer");
+            break;
+        case API_ID_TIME_MGT_DEFINE_COMPLEX_TIMER:
+            sprintf(API_label, "CCPL_define_complex_timer");
+            break;
+        case API_ID_FIELD_MGT_REG_IO_FIELD_from_INST:
+            sprintf(API_label, "CCPL_register_IO_field_from_field_instance");
+            break;
+        case API_ID_FIELD_MGT_REG_IO_FIELDs_from_INSTs:
+            sprintf(API_label, "CCPL_register_IO_fields_from_field_instances");
+            break;
+        case API_ID_FIELD_MGT_REG_IO_FIELD_from_BUFFER:
+            sprintf(API_label, "CCPL_register_IO_field_from_data_buffer");
+            break;
+        case API_ID_REPORT_LOG:
+            sprintf(API_label, "CCPL_report_log");
+            break;            
+        case API_ID_REPORT_PROGRESS:
+            sprintf(API_label, "CCPL_report_progress");
+            break;    
+        case API_ID_REPORT_ERROR:
+            sprintf(API_label, "CCPL_report_error");
+            break;    
+        case API_ID_RESTART_MGT_START_READ_IO:
+            sprintf(API_label, "CCPL_start_restart_read_IO");
+            break;
+        case API_ID_RESTART_MGT_READ_ALL:
+            sprintf(API_label, "CCPL_restart_read_fields_all");
+            break;            
+        case API_ID_RESTART_MGT_READ_INTERFACE:
+            sprintf(API_label, "CCPL_restart_read_fields_interface");
+            break;    
+        case API_ID_RESTART_MGT_GET_SETTING:
+            sprintf(API_label, "CCPL_get_restart_setting");
+            break;                
+        case API_ID_RESTART_MGT_IS_TIMER_ON:
+            sprintf(API_label, "CCPL_is_restart_timer_on");
+            break;
+        case API_ID_RESTART_MGT_WRITE_IO:
+            sprintf(API_label, "CCPL_do_restart_write_IO");
+            break;
+        case API_ID_COUPLING_GEN_FAMILY:
+            sprintf(API_label, "CCPL_do_family_coupling_generation");
+            break;
+        case API_ID_COUPLING_GEN_INDIVIDUAL:
+            sprintf(API_label, "CCPL_do_individual_coupling_generation");
+            break;
+        case API_ID_COUPLING_GEN_EXTERNAL:
+            sprintf(API_label, "CCPL_do_external_coupling_generation");
+            break;
+        case API_ID_COUPLING_GEN_GET_COMPS:
+            sprintf(API_label, "CCPL_get_configurable_comps_full_names");
+            break;
+        default:
+            EXECUTION_REPORT(REPORT_ERROR, comp_id, false, "software error1 in get_API_hint %x", API_id);
+            break;
+    }
 }
 
 
 void synchronize_comp_processes_for_API(int comp_id, int API_id, MPI_Comm comm, const char *hint, const char *annotation)
 {
-	char API_label_local[NAME_STR_SIZE], API_label_another[NAME_STR_SIZE];
-	int local_process_id, num_processes;
-	int *API_ids;
-	char *annotations, *comp_names, local_annotation[NAME_STR_SIZE];
-
-
-	if (!report_error_enabled)
-		return;
-	
-	get_API_hint(-1, API_id, API_label_local);
-
-	if (comp_id != -1)
-		EXECUTION_REPORT(REPORT_ERROR, -1, comp_comm_group_mgt_mgr->is_legal_local_comp_id(comp_id, false), "Error happens when calling the interface \"%s\" for %s: the given component model ID (0x%x). Please check the model code with the annotation \"%s\"", API_label_local, hint, comp_id, annotation);
-
-	if (comm == MPI_COMM_NULL)
-		comm = comp_comm_group_mgt_mgr->get_comm_group_of_local_comp(comp_id, "in synchronize_comp_processes_for_API");
-
-	if (hint != NULL)
-		EXECUTION_REPORT_LOG(REPORT_LOG, comp_id, true, "Before the MPI_barrier for synchronizing all processes of a communicator for %s at C-Coupler API \"%s\" with model code annotation \"%s\"", hint, API_label_local, annotation);	
-	else EXECUTION_REPORT_LOG(REPORT_LOG, comp_id, true, "Before the MPI_barrier for synchronizing all processes of a communicator at C-Coupler API \"%s\" with model code annotation \"%s\"", API_label_local, annotation);
-	MPI_Barrier(comm);
-	if (hint != NULL) {
-		EXECUTION_REPORT_LOG(REPORT_LOG, comp_id, true, "After the MPI_barrier for synchronizing all processes of a communicator for %s at C-Coupler API \"%s\" with model code annotation \"%s\"", hint, API_label_local, annotation);	
-	}	
-	else EXECUTION_REPORT_LOG(REPORT_LOG, comp_id, true, "After the MPI_barrier for synchronizing all processes of a communicator at C-Coupler API \"%s\" with model code annotation \"%s\"", API_label_local, annotation);
-	EXECUTION_REPORT(REPORT_ERROR, -1, MPI_Comm_rank(comm, &local_process_id) == MPI_SUCCESS);
-	EXECUTION_REPORT(REPORT_ERROR,-1, MPI_Comm_size(comm, &num_processes) == MPI_SUCCESS);
-	API_ids = new int [num_processes];
-	annotations = new char [num_processes*NAME_STR_SIZE];
-	EXECUTION_REPORT(REPORT_ERROR,-1, MPI_Gather(&API_id, 1, MPI_INT, API_ids, 1, MPI_INT, 0, comm) == MPI_SUCCESS);
-	EXECUTION_REPORT_LOG(REPORT_LOG, comp_id, true, "annotation is \"%s\"", annotation);
-	EXECUTION_REPORT(REPORT_ERROR, -1, strlen(annotation) < NAME_STR_SIZE, "Error happens when calling the API \"%s\": the annotation is too long (%d characters, larger than %d). Please verify", annotation, strlen(annotation), NAME_STR_SIZE);
-	strcpy(local_annotation, annotation);
-	EXECUTION_REPORT(REPORT_ERROR,-1, MPI_Gather((void*)local_annotation, NAME_STR_SIZE, MPI_CHAR, annotations, NAME_STR_SIZE, MPI_CHAR, 0, comm) == MPI_SUCCESS);
-	if (local_process_id == 0) {
-		for (int i = 1; i < num_processes; i ++) {
-			get_API_hint(comp_id, API_ids[i], API_label_another);
-			EXECUTION_REPORT(REPORT_ERROR, comp_id, API_id == API_ids[i], "Different kinds of C-Coupler API calls (\"%s\" and \"%s\") are mapped to the same synchronization. Please check the model code related to the annotations \"%s\" and \"%s\".",
-							 API_label_local, API_label_another, annotation, annotations+NAME_STR_SIZE*i);			
-		}	
-	}
-	if (comp_id != -1) {
-		comp_names = new char [num_processes*NAME_STR_SIZE];
-		EXECUTION_REPORT(REPORT_ERROR, -1, MPI_Gather((void*)comp_comm_group_mgt_mgr->get_global_node_of_local_comp(comp_id,false,"C-Coupler gets component node in synchronize_comp_processes_for_API")->get_comp_full_name(), NAME_STR_SIZE, MPI_CHAR, comp_names, NAME_STR_SIZE, MPI_CHAR, 0, comm) == MPI_SUCCESS);
-		if (local_process_id == 0) {
-			for (int i = 1; i < num_processes; i ++)
-				EXECUTION_REPORT(REPORT_ERROR, comp_id, words_are_the_same(comp_names, comp_names+NAME_STR_SIZE*i), "It is wrong that two different component models (\"%s\" and \"%s\") take part in the same API (\"%s\"). Please check the model code related to the annotations \"%s\" and \"%s\".",
-							 comp_names, comp_names+NAME_STR_SIZE*i, API_label_local, annotation, annotations+NAME_STR_SIZE*i);		
-		}
-		delete [] comp_names;
-	}
-	
-	delete [] API_ids;
-	delete [] annotations;
+    char API_label_local[NAME_STR_SIZE], API_label_another[NAME_STR_SIZE];
+    int local_process_id, num_processes;
+    int *API_ids;
+    char *annotations, *comp_names, local_annotation[NAME_STR_SIZE];
+
+
+    if (!report_error_enabled)
+        return;
+    
+    get_API_hint(-1, API_id, API_label_local);
+
+    if (comp_id != -1)
+        EXECUTION_REPORT(REPORT_ERROR, -1, comp_comm_group_mgt_mgr->is_legal_local_comp_id(comp_id, false), "Error happens when calling the interface \"%s\" for %s: the given component model ID (0x%x). Please check the model code with the annotation \"%s\"", API_label_local, hint, comp_id, annotation);
+
+    if (comm == MPI_COMM_NULL)
+        comm = comp_comm_group_mgt_mgr->get_comm_group_of_local_comp(comp_id, "in synchronize_comp_processes_for_API");
+
+    if (hint != NULL) {
+        EXECUTION_REPORT_LOG(REPORT_LOG, comp_id, true, "Before the MPI_barrier for synchronizing all processes of a communicator for %s at C-Coupler API \"%s\" with model code annotation \"%s\"", hint, API_label_local, annotation);    
+    }
+    else EXECUTION_REPORT_LOG(REPORT_LOG, comp_id, true, "Before the MPI_barrier for synchronizing all processes of a communicator at C-Coupler API \"%s\" with model code annotation \"%s\"", API_label_local, annotation);
+    MPI_Barrier(comm);
+    if (hint != NULL) {
+        EXECUTION_REPORT_LOG(REPORT_LOG, comp_id, true, "After the MPI_barrier for synchronizing all processes of a communicator for %s at C-Coupler API \"%s\" with model code annotation \"%s\"", hint, API_label_local, annotation);    
+    }    
+    else EXECUTION_REPORT_LOG(REPORT_LOG, comp_id, true, "After the MPI_barrier for synchronizing all processes of a communicator at C-Coupler API \"%s\" with model code annotation \"%s\"", API_label_local, annotation);
+    EXECUTION_REPORT(REPORT_ERROR, -1, MPI_Comm_rank(comm, &local_process_id) == MPI_SUCCESS);
+    EXECUTION_REPORT(REPORT_ERROR,-1, MPI_Comm_size(comm, &num_processes) == MPI_SUCCESS);
+    API_ids = new int [num_processes];
+    annotations = new char [num_processes*NAME_STR_SIZE];
+    EXECUTION_REPORT(REPORT_ERROR,-1, MPI_Gather(&API_id, 1, MPI_INT, API_ids, 1, MPI_INT, 0, comm) == MPI_SUCCESS);
+    EXECUTION_REPORT_LOG(REPORT_LOG, comp_id, true, "annotation is \"%s\"", annotation);
+    EXECUTION_REPORT(REPORT_ERROR, -1, strlen(annotation) < NAME_STR_SIZE, "Error happens when calling the API \"%s\": the annotation is too long (%d characters, larger than %d). Please verify", annotation, strlen(annotation), NAME_STR_SIZE);
+    strcpy(local_annotation, annotation);
+    EXECUTION_REPORT(REPORT_ERROR,-1, MPI_Gather((void*)local_annotation, NAME_STR_SIZE, MPI_CHAR, annotations, NAME_STR_SIZE, MPI_CHAR, 0, comm) == MPI_SUCCESS);
+    if (local_process_id == 0) {
+        for (int i = 1; i < num_processes; i ++) {
+            get_API_hint(comp_id, API_ids[i], API_label_another);
+            EXECUTION_REPORT(REPORT_ERROR, comp_id, API_id == API_ids[i], "Different kinds of C-Coupler API calls (\"%s\" and \"%s\") are mapped to the same synchronization. Please check the model code related to the annotations \"%s\" and \"%s\".",
+                             API_label_local, API_label_another, annotation, annotations+NAME_STR_SIZE*i);            
+        }    
+    }
+    if (comp_id != -1) {
+        comp_names = new char [num_processes*NAME_STR_SIZE];
+        EXECUTION_REPORT(REPORT_ERROR, -1, MPI_Gather((void*)comp_comm_group_mgt_mgr->get_global_node_of_local_comp(comp_id,false,"C-Coupler gets component node in synchronize_comp_processes_for_API")->get_comp_full_name(), NAME_STR_SIZE, MPI_CHAR, comp_names, NAME_STR_SIZE, MPI_CHAR, 0, comm) == MPI_SUCCESS);
+        if (local_process_id == 0) {
+            for (int i = 1; i < num_processes; i ++)
+                EXECUTION_REPORT(REPORT_ERROR, comp_id, words_are_the_same(comp_names, comp_names+NAME_STR_SIZE*i), "It is wrong that two different component models (\"%s\" and \"%s\") take part in the same API (\"%s\"). Please check the model code related to the annotations \"%s\" and \"%s\".",
+                             comp_names, comp_names+NAME_STR_SIZE*i, API_label_local, annotation, annotations+NAME_STR_SIZE*i);        
+        }
+        delete [] comp_names;
+    }
+    
+    delete [] API_ids;
+    delete [] annotations;
 }
 
 
 template <class T> void check_API_parameter_scalar(int comp_id, int API_id, MPI_Comm comm, const char *hint, T value, const char *parameter_name, const char *annotation)
 {
-	int i, local_process_id, num_processes;
-	T *values;
-	char API_label[NAME_STR_SIZE];
-	
-
-	if (!report_error_enabled)
-		return;
-
-	EXECUTION_REPORT(REPORT_ERROR, -1, MPI_Comm_rank(comm, &local_process_id) == MPI_SUCCESS);
-	EXECUTION_REPORT(REPORT_ERROR, -1, MPI_Comm_size(comm, &num_processes) == MPI_SUCCESS);	
-
-	values = new T [num_processes];
-	if (sizeof(T) == 1)
-		EXECUTION_REPORT(REPORT_ERROR, -1, MPI_Gather(&value, 1, MPI_CHAR, values, 1, MPI_CHAR, 0, comm) == MPI_SUCCESS);
-	else if (sizeof(T) == 2)
-		EXECUTION_REPORT(REPORT_ERROR, -1, MPI_Gather(&value, 1, MPI_SHORT, values, 1, MPI_SHORT, 0, comm) == MPI_SUCCESS);
-	else if (sizeof(T) == 4)
-		EXECUTION_REPORT(REPORT_ERROR, -1, MPI_Gather(&value, 1, MPI_INT, values, 1, MPI_INT, 0, comm) == MPI_SUCCESS);
-	else if (sizeof(T) == 8)
-		EXECUTION_REPORT(REPORT_ERROR, -1, MPI_Gather(&value, 1, MPI_DOUBLE, values, 1, MPI_DOUBLE, 0, comm) == MPI_SUCCESS);
-	else EXECUTION_REPORT(REPORT_ERROR, comp_id, true, "software error in check_API_parameter_scalar");
-	if (local_process_id == 0) {
-		get_API_hint(comp_id, API_id, API_label);
-		for (i = 1; i < num_processes; i ++) {
-			if (hint != NULL)
-				EXECUTION_REPORT(REPORT_ERROR, comp_id, values[0] == values[i], "Error happens when calling the API \"%s\" for %s: parameter %s is not consistent among processes of component \"%s\". Please check the model code related to the annotation \"%s\"",
-				                 API_label, hint, parameter_name, comp_comm_group_mgt_mgr->search_global_node(comp_id)->get_comp_name(), annotation);
-			else EXECUTION_REPORT(REPORT_ERROR, comp_id, values[0] == values[i], "Error happens when calling the API \"%s\": parameter %s is not consistent among processes of component \"%s\". Please check the model code related to the annotation \"%s\"",
-				                  API_label, parameter_name, comp_comm_group_mgt_mgr->search_global_node(comp_id)->get_comp_name(), annotation);
-		}
-	}
-
-	delete [] values;
+    int i, local_process_id, num_processes;
+    T *values;
+    char API_label[NAME_STR_SIZE];
+    
+
+    if (!report_error_enabled)
+        return;
+
+    EXECUTION_REPORT(REPORT_ERROR, -1, MPI_Comm_rank(comm, &local_process_id) == MPI_SUCCESS);
+    EXECUTION_REPORT(REPORT_ERROR, -1, MPI_Comm_size(comm, &num_processes) == MPI_SUCCESS);    
+
+    values = new T [num_processes];
+    if (sizeof(T) == 1)
+        EXECUTION_REPORT(REPORT_ERROR, -1, MPI_Gather(&value, 1, MPI_CHAR, values, 1, MPI_CHAR, 0, comm) == MPI_SUCCESS);
+    else if (sizeof(T) == 2)
+        EXECUTION_REPORT(REPORT_ERROR, -1, MPI_Gather(&value, 1, MPI_SHORT, values, 1, MPI_SHORT, 0, comm) == MPI_SUCCESS);
+    else if (sizeof(T) == 4)
+        EXECUTION_REPORT(REPORT_ERROR, -1, MPI_Gather(&value, 1, MPI_INT, values, 1, MPI_INT, 0, comm) == MPI_SUCCESS);
+    else if (sizeof(T) == 8)
+        EXECUTION_REPORT(REPORT_ERROR, -1, MPI_Gather(&value, 1, MPI_DOUBLE, values, 1, MPI_DOUBLE, 0, comm) == MPI_SUCCESS);
+    else EXECUTION_REPORT(REPORT_ERROR, comp_id, true, "software error in check_API_parameter_scalar");
+    if (local_process_id == 0) {
+        get_API_hint(comp_id, API_id, API_label);
+        for (i = 1; i < num_processes; i ++) {
+            if (hint != NULL)
+                EXECUTION_REPORT(REPORT_ERROR, comp_id, values[0] == values[i], "Error happens when calling the API \"%s\" for %s: parameter %s is not consistent among processes of component \"%s\". Please check the model code related to the annotation \"%s\"",
+                                 API_label, hint, parameter_name, comp_comm_group_mgt_mgr->search_global_node(comp_id)->get_comp_name(), annotation);
+            else EXECUTION_REPORT(REPORT_ERROR, comp_id, values[0] == values[i], "Error happens when calling the API \"%s\": parameter %s is not consistent among processes of component \"%s\". Please check the model code related to the annotation \"%s\"",
+                                  API_label, parameter_name, comp_comm_group_mgt_mgr->search_global_node(comp_id)->get_comp_name(), annotation);
+        }
+    }
+
+    delete [] values;
 }
 
 
 char *check_and_aggregate_local_grid_data(int comp_id, int API_id, MPI_Comm comm, const char *hint, int grid_size, int array_size, int data_type_size, char *array_value, 
-	                                      const char *parameter_name, int num_local_cells, int *local_cells_global_index, int &grid_data_size, const char *annotation)
+                                          const char *parameter_name, int num_local_cells, int *local_cells_global_index, int &grid_data_size, const char *annotation)
 {
-	char API_label[NAME_STR_SIZE];
-	int local_process_id, num_processes, *counts_for_cell_index, *displs_for_cell_index, *counts_for_array, *displs_for_array;
-	int num_total_cells, total_array_size, *all_local_cells_global_index, num_point;
-	char *all_array_values, *grid_data;
-
-
-	grid_data_size = 0;
-	get_API_hint(comp_id, API_id, API_label);
-	
-	int parameter_specified = array_size >= 0 ? 1 : 0;
-	check_API_parameter_int(comp_id, API_id, comm, "specification (or not)", parameter_specified, parameter_name, annotation);
-	if (parameter_specified == 0)
-		return NULL;
-
-	check_API_parameter_int(comp_id, API_id, comm, "data type", data_type_size, parameter_name, annotation);
-	if (words_are_the_same(parameter_name, "vertex_lon") || words_are_the_same(parameter_name, "vertex_lat"))
-		EXECUTION_REPORT(REPORT_ERROR, comp_id, array_size == 0 && num_local_cells == 0 || (array_size % num_local_cells) == 0, "Error happens when calling the API \"%s\" for %s: the array size (currently is %d) of the parameter \"%s\" is not an integer multiple of parameter \"num_local_cells\" (currently is %d). Please check the model code related to the annotation \"%s\"", API_label, hint, array_size, parameter_name, num_local_cells, annotation);
-	else EXECUTION_REPORT(REPORT_ERROR, comp_id, array_size == num_local_cells, "Error happens when calling the API \"%s\" for %s: the array size (currently is %d) of the parameter \"%s\" must be the same as \"num_local_cells\" (currently is %d). Please check the model code related to the annotation \"%s\"", API_label, hint, array_size, parameter_name, num_local_cells, annotation);
-
-	EXECUTION_REPORT(REPORT_ERROR, -1, MPI_Comm_rank(comm, &local_process_id) == MPI_SUCCESS);
-	EXECUTION_REPORT(REPORT_ERROR, -1, MPI_Comm_size(comm, &num_processes) == MPI_SUCCESS);	
-
-	if (local_process_id == 0) {
-		counts_for_cell_index = new int [num_processes];
-		displs_for_cell_index = new int [num_processes];
-		counts_for_array = new int [num_processes];
-		displs_for_array = new int [num_processes];
-	}
-	EXECUTION_REPORT(REPORT_ERROR, -1, MPI_Gather(&num_local_cells, 1, MPI_INT, counts_for_cell_index, 1, MPI_INT, 0, comm) == MPI_SUCCESS);
-	EXECUTION_REPORT(REPORT_ERROR, -1, MPI_Gather(&array_size, 1, MPI_INT, counts_for_array, 1, MPI_INT, 0, comm) == MPI_SUCCESS);
-	if (local_process_id == 0) {
-		num_total_cells = 0;
-		total_array_size = 0;
-		for (int i = 0; i < num_processes; i ++) {
-			displs_for_cell_index[i] = num_total_cells;
-			displs_for_array[i] = total_array_size;
-			num_total_cells += counts_for_cell_index[i];
-			total_array_size += counts_for_array[i];
-		}
-		if (num_total_cells != 0)
-			all_local_cells_global_index = new int [num_total_cells];
-		else all_local_cells_global_index = new int [1];
-		if (total_array_size != 0)
-			all_array_values = new char [total_array_size*data_type_size];
-		else all_array_values = new char [8];
-	}
-	EXECUTION_REPORT(REPORT_ERROR,-1, MPI_Gatherv(local_cells_global_index, num_local_cells, MPI_INT, all_local_cells_global_index, counts_for_cell_index, displs_for_cell_index, MPI_INT, 0, comm) == MPI_SUCCESS);
-	if (data_type_size == 4)
-		EXECUTION_REPORT(REPORT_ERROR,-1, MPI_Gatherv(array_value, array_size, MPI_INT, all_array_values, counts_for_array, displs_for_array, MPI_INT, 0, comm) == MPI_SUCCESS);
-	else EXECUTION_REPORT(REPORT_ERROR,-1, MPI_Gatherv(array_value, array_size, MPI_DOUBLE, all_array_values, counts_for_array, displs_for_array, MPI_DOUBLE, 0, comm) == MPI_SUCCESS);
-		
-	if (local_process_id == 0) {
-		if (words_are_the_same(parameter_name, "vertex_lon") || words_are_the_same(parameter_name, "vertex_lat")) {
-			num_point = 0;
-			for (int i = 0; i < num_processes; i ++) {
-				if (counts_for_cell_index[i] == 0)
-					continue;
-				if (num_point == 0)
-					num_point = counts_for_array[i] / counts_for_cell_index[i];
-				EXECUTION_REPORT(REPORT_ERROR, comp_id, num_point == counts_for_array[i] / counts_for_cell_index[i], "Error happens when calling the API \"%s\" for %s: the number of vertexes corresponding to parameter \"%s\" does not keep the same among the processes. Please check the model code related to the annotation \"%s\"", API_label, hint, parameter_name, annotation);
-			}
-
-		}
-		else num_point = 1;
-		if (num_point == 0) {
-			grid_data_size = 0;
-			grid_data = NULL;
-		}
-		else {
-			grid_data_size = grid_size * num_point;
-			grid_data = new char [grid_data_size*data_type_size];
-		}
-		if (grid_data_size > 0) {
-			memset(grid_data, 0, grid_data_size*data_type_size);
-			int *grid_data_mark = new int [grid_size];
-			memset(grid_data_mark, 0, grid_size*sizeof(int));
-			for (int i = 0; i < num_processes; i ++)
-				for (int j = 0; j < counts_for_cell_index[i]; j ++) {
-					int global_index = all_local_cells_global_index[displs_for_cell_index[i]+j]-1;
-					if (grid_data_mark[global_index] == 0) {
-						grid_data_mark[global_index] = 1;
-						memcpy(grid_data+global_index*num_point*data_type_size, all_array_values+(displs_for_array[i]+j*num_point)*data_type_size, num_point*data_type_size);
-					}
-					else {
-						bool is_the_same = memcmp(grid_data+global_index*num_point*data_type_size, all_array_values+(displs_for_array[i]+j*num_point)*data_type_size, num_point*data_type_size) == 0;
-						EXECUTION_REPORT(REPORT_ERROR, comp_id, is_the_same, "Error happens when calling the API \"%s\" for %s: the grid data (\"%s\") of some common cells is not the same among the processes. Please check the model code related to the annotation \"%s\"", API_label, hint, parameter_name, annotation);
-					}
-				}
-			delete [] grid_data_mark;
-			if (report_error_enabled) {
-				do_quick_sort(all_local_cells_global_index, (int*)NULL, 0, num_total_cells-1);
-				EXECUTION_REPORT(REPORT_ERROR, comp_id, all_local_cells_global_index[0] == 1, "Error happens when calling the API \"%s\" for %s: no process provide grid data (\"%s\") for the first grid cell. Please check the model code related to the annotation \"%s\"", API_label, hint, parameter_name, annotation);
-				EXECUTION_REPORT(REPORT_ERROR, comp_id, all_local_cells_global_index[num_total_cells-1] == grid_size, "Error happens when calling the API \"%s\" for %s: no process provide grid data (\"%s\") for the last (%dth) grid cell. Please check the model code related to the annotation \"%s\"", API_label, hint, parameter_name, grid_size, annotation);
-				for (int i = 1; i < num_total_cells; i ++)					
-					EXECUTION_REPORT(REPORT_ERROR, comp_id, all_local_cells_global_index[i] == all_local_cells_global_index[i-1] || all_local_cells_global_index[i] == all_local_cells_global_index[i-1]+1, "Error happens when calling the API \"%s\" for %s: no process provide grid data (\"%s\") for the %dth grid cell. Please check the model code related to the annotation \"%s\"", API_label, hint, parameter_name, all_local_cells_global_index[i-1]+1, annotation);
-			}
-		}
-	}
-
-	EXECUTION_REPORT(REPORT_ERROR, -1, MPI_Bcast(&grid_data_size, 1, MPI_INT, 0, comm) == MPI_SUCCESS);
-
-	if (grid_data_size == 0)
-		return NULL;
-
-	if (local_process_id != 0)
-		grid_data = new char [grid_data_size*data_type_size];
-	EXECUTION_REPORT(REPORT_ERROR,-1, MPI_Bcast(grid_data, grid_data_size*data_type_size, MPI_CHAR, 0, comm) == MPI_SUCCESS);
-
-	if (local_process_id == 0) {
-		delete [] counts_for_cell_index;
-		delete [] displs_for_cell_index;
-		delete [] counts_for_array;
-		delete [] displs_for_array;
-		delete [] all_array_values;
-		delete [] all_local_cells_global_index;
-	}
-
-	return grid_data;
+    char API_label[NAME_STR_SIZE];
+    int local_process_id, num_processes, *counts_for_cell_index, *displs_for_cell_index, *counts_for_array, *displs_for_array;
+    int num_total_cells, total_array_size, *all_local_cells_global_index, num_point;
+    char *all_array_values, *grid_data;
+
+
+    grid_data_size = 0;
+    get_API_hint(comp_id, API_id, API_label);
+    
+    int parameter_specified = array_size >= 0 ? 1 : 0;
+    check_API_parameter_int(comp_id, API_id, comm, "specification (or not)", parameter_specified, parameter_name, annotation);
+    if (parameter_specified == 0)
+        return NULL;
+
+    check_API_parameter_int(comp_id, API_id, comm, "data type", data_type_size, parameter_name, annotation);
+    if (words_are_the_same(parameter_name, "vertex_lon") || words_are_the_same(parameter_name, "vertex_lat"))
+        EXECUTION_REPORT(REPORT_ERROR, comp_id, array_size == 0 && num_local_cells == 0 || (array_size % num_local_cells) == 0, "Error happens when calling the API \"%s\" for %s: the array size (currently is %d) of the parameter \"%s\" is not an integer multiple of parameter \"num_local_cells\" (currently is %d). Please check the model code related to the annotation \"%s\"", API_label, hint, array_size, parameter_name, num_local_cells, annotation);
+    else EXECUTION_REPORT(REPORT_ERROR, comp_id, array_size == num_local_cells, "Error happens when calling the API \"%s\" for %s: the array size (currently is %d) of the parameter \"%s\" must be the same as \"num_local_cells\" (currently is %d). Please check the model code related to the annotation \"%s\"", API_label, hint, array_size, parameter_name, num_local_cells, annotation);
+
+    EXECUTION_REPORT(REPORT_ERROR, -1, MPI_Comm_rank(comm, &local_process_id) == MPI_SUCCESS);
+    EXECUTION_REPORT(REPORT_ERROR, -1, MPI_Comm_size(comm, &num_processes) == MPI_SUCCESS);    
+
+    if (local_process_id == 0) {
+        counts_for_cell_index = new int [num_processes];
+        displs_for_cell_index = new int [num_processes];
+        counts_for_array = new int [num_processes];
+        displs_for_array = new int [num_processes];
+    }
+    EXECUTION_REPORT(REPORT_ERROR, -1, MPI_Gather(&num_local_cells, 1, MPI_INT, counts_for_cell_index, 1, MPI_INT, 0, comm) == MPI_SUCCESS);
+    EXECUTION_REPORT(REPORT_ERROR, -1, MPI_Gather(&array_size, 1, MPI_INT, counts_for_array, 1, MPI_INT, 0, comm) == MPI_SUCCESS);
+    if (local_process_id == 0) {
+        num_total_cells = 0;
+        total_array_size = 0;
+        for (int i = 0; i < num_processes; i ++) {
+            displs_for_cell_index[i] = num_total_cells;
+            displs_for_array[i] = total_array_size;
+            num_total_cells += counts_for_cell_index[i];
+            total_array_size += counts_for_array[i];
+        }
+        if (num_total_cells != 0)
+            all_local_cells_global_index = new int [num_total_cells];
+        else all_local_cells_global_index = new int [1];
+        if (total_array_size != 0)
+            all_array_values = new char [total_array_size*data_type_size];
+        else all_array_values = new char [8];
+    }
+    EXECUTION_REPORT(REPORT_ERROR,-1, MPI_Gatherv(local_cells_global_index, num_local_cells, MPI_INT, all_local_cells_global_index, counts_for_cell_index, displs_for_cell_index, MPI_INT, 0, comm) == MPI_SUCCESS);
+    if (data_type_size == 4)
+        EXECUTION_REPORT(REPORT_ERROR,-1, MPI_Gatherv(array_value, array_size, MPI_INT, all_array_values, counts_for_array, displs_for_array, MPI_INT, 0, comm) == MPI_SUCCESS);
+    else EXECUTION_REPORT(REPORT_ERROR,-1, MPI_Gatherv(array_value, array_size, MPI_DOUBLE, all_array_values, counts_for_array, displs_for_array, MPI_DOUBLE, 0, comm) == MPI_SUCCESS);
+        
+    if (local_process_id == 0) {
+        if (words_are_the_same(parameter_name, "vertex_lon") || words_are_the_same(parameter_name, "vertex_lat")) {
+            num_point = 0;
+            for (int i = 0; i < num_processes; i ++) {
+                if (counts_for_cell_index[i] == 0)
+                    continue;
+                if (num_point == 0)
+                    num_point = counts_for_array[i] / counts_for_cell_index[i];
+                EXECUTION_REPORT(REPORT_ERROR, comp_id, num_point == counts_for_array[i] / counts_for_cell_index[i], "Error happens when calling the API \"%s\" for %s: the number of vertexes corresponding to parameter \"%s\" does not keep the same among the processes. Please check the model code related to the annotation \"%s\"", API_label, hint, parameter_name, annotation);
+            }
+
+        }
+        else num_point = 1;
+        if (num_point == 0) {
+            grid_data_size = 0;
+            grid_data = NULL;
+        }
+        else {
+            grid_data_size = grid_size * num_point;
+            grid_data = new char [grid_data_size*data_type_size];
+        }
+        if (grid_data_size > 0) {
+            memset(grid_data, 0, grid_data_size*data_type_size);
+            int *grid_data_mark = new int [grid_size];
+            memset(grid_data_mark, 0, grid_size*sizeof(int));
+            for (int i = 0; i < num_processes; i ++)
+                for (int j = 0; j < counts_for_cell_index[i]; j ++) {
+                    int global_index = all_local_cells_global_index[displs_for_cell_index[i]+j]-1;
+                    if (grid_data_mark[global_index] == 0) {
+                        grid_data_mark[global_index] = 1;
+                        memcpy(grid_data+global_index*num_point*data_type_size, all_array_values+(displs_for_array[i]+j*num_point)*data_type_size, num_point*data_type_size);
+                    }
+                    else {
+                        bool is_the_same = memcmp(grid_data+global_index*num_point*data_type_size, all_array_values+(displs_for_array[i]+j*num_point)*data_type_size, num_point*data_type_size) == 0;
+                        EXECUTION_REPORT(REPORT_ERROR, comp_id, is_the_same, "Error happens when calling the API \"%s\" for %s: the grid data (\"%s\") of some common cells is not the same among the processes. Please check the model code related to the annotation \"%s\"", API_label, hint, parameter_name, annotation);
+                    }
+                }
+            delete [] grid_data_mark;
+            if (report_error_enabled) {
+                do_quick_sort(all_local_cells_global_index, (int*)NULL, 0, num_total_cells-1);
+                EXECUTION_REPORT(REPORT_ERROR, comp_id, all_local_cells_global_index[0] == 1, "Error happens when calling the API \"%s\" for %s: no process provide grid data (\"%s\") for the first grid cell. Please check the model code related to the annotation \"%s\"", API_label, hint, parameter_name, annotation);
+                EXECUTION_REPORT(REPORT_ERROR, comp_id, all_local_cells_global_index[num_total_cells-1] == grid_size, "Error happens when calling the API \"%s\" for %s: no process provide grid data (\"%s\") for the last (%dth) grid cell. Please check the model code related to the annotation \"%s\"", API_label, hint, parameter_name, grid_size, annotation);
+                for (int i = 1; i < num_total_cells; i ++)                    
+                    EXECUTION_REPORT(REPORT_ERROR, comp_id, all_local_cells_global_index[i] == all_local_cells_global_index[i-1] || all_local_cells_global_index[i] == all_local_cells_global_index[i-1]+1, "Error happens when calling the API \"%s\" for %s: no process provide grid data (\"%s\") for the %dth grid cell. Please check the model code related to the annotation \"%s\"", API_label, hint, parameter_name, all_local_cells_global_index[i-1]+1, annotation);
+            }
+        }
+    }
+
+    EXECUTION_REPORT(REPORT_ERROR, -1, MPI_Bcast(&grid_data_size, 1, MPI_INT, 0, comm) == MPI_SUCCESS);
+
+    if (grid_data_size == 0)
+        return NULL;
+
+    if (local_process_id != 0)
+        grid_data = new char [grid_data_size*data_type_size];
+    EXECUTION_REPORT(REPORT_ERROR,-1, MPI_Bcast(grid_data, grid_data_size*data_type_size, MPI_CHAR, 0, comm) == MPI_SUCCESS);
+
+    if (local_process_id == 0) {
+        delete [] counts_for_cell_index;
+        delete [] displs_for_cell_index;
+        delete [] counts_for_array;
+        delete [] displs_for_array;
+        delete [] all_array_values;
+        delete [] all_local_cells_global_index;
+    }
+
+    return grid_data;
 }
 
 
 void check_API_parameter_data_array(int comp_id, int API_id, MPI_Comm comm, const char *hint, int array_size, int data_type_size, const char *array_value, const char *parameter_name, const char *annotation)
 {
-	long total_checksum = 0;
-	char API_label[NAME_STR_SIZE];
+    long total_checksum = 0;
+    char API_label[NAME_STR_SIZE];
 
 
-	get_API_hint(comp_id, API_id, API_label);
-	EXECUTION_REPORT(REPORT_ERROR, comp_id, array_size != 0, "Error happens when calling the API \"%s\" for %s: the parameter array of \"%s\" may have not been allocated. Please check the model code related to the annotation \"%s\"", API_label, hint, parameter_name, annotation);
+    get_API_hint(comp_id, API_id, API_label);
+    EXECUTION_REPORT(REPORT_ERROR, comp_id, array_size != 0, "Error happens when calling the API \"%s\" for %s: the parameter array of \"%s\" may have not been allocated. Please check the model code related to the annotation \"%s\"", API_label, hint, parameter_name, annotation);
 
-	int parameter_specified = array_size >= 0 ? 1 : 0;
-	check_API_parameter_int(comp_id, API_id, comm, "specification (or not)", parameter_specified, parameter_name, annotation);
-	check_API_parameter_int(comp_id, API_id, comm, "array size", array_size, parameter_name, annotation);
-	check_API_parameter_int(comp_id, API_id, comm, "data type", data_type_size, parameter_name, annotation);
+    int parameter_specified = array_size >= 0 ? 1 : 0;
+    check_API_parameter_int(comp_id, API_id, comm, "specification (or not)", parameter_specified, parameter_name, annotation);
+    check_API_parameter_int(comp_id, API_id, comm, "array size", array_size, parameter_name, annotation);
+    check_API_parameter_int(comp_id, API_id, comm, "data type", data_type_size, parameter_name, annotation);
 
-	if (array_size <= 0)
-		return;
+    if (array_size <= 0)
+        return;
 
-	total_checksum = calculate_checksum_of_array(array_value, array_size, data_type_size, NULL, NULL);
-	check_API_parameter_long(comp_id, API_id, comm, "array value", total_checksum, parameter_name, annotation);
+    total_checksum = calculate_checksum_of_array(array_value, array_size, data_type_size, NULL, NULL);
+    check_API_parameter_long(comp_id, API_id, comm, "array value", total_checksum, parameter_name, annotation);
 }
 
 
 void check_API_parameter_float(int comp_id, int API_id, MPI_Comm comm, const char *hint, float value, const char *parameter_name, const char *annotation)
 {
-	check_API_parameter_scalar(comp_id, API_id, comm, hint, value, parameter_name, annotation);
+    check_API_parameter_scalar(comp_id, API_id, comm, hint, value, parameter_name, annotation);
 }
 
 
 void check_API_parameter_double(int comp_id, int API_id, MPI_Comm comm, const char *hint, double value, const char *parameter_name, const char *annotation)
 {
-	check_API_parameter_scalar(comp_id, API_id, comm, hint, value, parameter_name, annotation);
+    check_API_parameter_scalar(comp_id, API_id, comm, hint, value, parameter_name, annotation);
 }
 
 
 void check_API_parameter_bool(int comp_id, int API_id, MPI_Comm comm, const char *hint, bool value, const char *parameter_name, const char *annotation)
 {
-	check_API_parameter_scalar(comp_id, API_id, comm, hint, value, parameter_name, annotation);
+    check_API_parameter_scalar(comp_id, API_id, comm, hint, value, parameter_name, annotation);
 }
 
 
 void check_API_parameter_int(int comp_id, int API_id, MPI_Comm comm, const char *hint, int value, const char *parameter_name, const char *annotation)
 {
-	check_API_parameter_scalar(comp_id, API_id, comm, hint, value, parameter_name, annotation);
+    check_API_parameter_scalar(comp_id, API_id, comm, hint, value, parameter_name, annotation);
 }
 
 
 void check_API_parameter_long(int comp_id, int API_id, MPI_Comm comm, const char *hint, long value, const char *parameter_name, const char *annotation)
 {
-	check_API_parameter_scalar(comp_id, API_id, comm, hint, value, parameter_name, annotation);
+    check_API_parameter_scalar(comp_id, API_id, comm, hint, value, parameter_name, annotation);
 }
 
 
 void check_API_parameter_timer(int comp_id, int API_id, MPI_Comm comm, const char *hint, int timer_id, const char *parameter_name, const char *annotation)
 {
-	Coupling_timer *timer;
-
-	
-	EXECUTION_REPORT(REPORT_ERROR, comp_id, timer_mgr->check_is_legal_timer_id(timer_id), "Software error in check_API_parameter_timer");
-	timer = timer_mgr->get_timer(timer_id);
-	check_API_parameter_int(comp_id, API_id, comm, hint, timer->get_frequency_count(), parameter_name, annotation);
-	check_API_parameter_int(comp_id, API_id, comm, hint, timer->get_local_lag_count(), parameter_name, annotation);
-	check_API_parameter_int(comp_id, API_id, comm, hint, timer->get_remote_lag_count(), parameter_name, annotation);
-	check_API_parameter_string(comp_id, API_id, comm, hint, timer->get_frequency_unit(), parameter_name, annotation);
+    Coupling_timer *timer;
+
+    
+    EXECUTION_REPORT(REPORT_ERROR, comp_id, timer_mgr->check_is_legal_timer_id(timer_id), "Software error in check_API_parameter_timer");
+    timer = timer_mgr->get_timer(timer_id);
+    check_API_parameter_int(comp_id, API_id, comm, hint, timer->get_frequency_count(), parameter_name, annotation);
+    check_API_parameter_int(comp_id, API_id, comm, hint, timer->get_local_lag_count(), parameter_name, annotation);
+    check_API_parameter_int(comp_id, API_id, comm, hint, timer->get_remote_lag_count(), parameter_name, annotation);
+    check_API_parameter_string(comp_id, API_id, comm, hint, timer->get_frequency_unit(), parameter_name, annotation);
 }
 
 
 void check_API_parameter_field_instance(int comp_id, int API_id, MPI_Comm comm, const char *hint, int field_id, const char *parameter_name, const char *annotation)
 {
-	Field_mem_info *field_instance;
-	int decomp_class, is_registerred;
-
-
-	EXECUTION_REPORT(REPORT_ERROR, comp_id, memory_manager->check_is_legal_field_instance_id(field_id), "Software error in check_API_parameter_field_instance");
-	field_instance = memory_manager->get_field_instance(field_id);
-	if (field_instance->get_decomp_id() == -1)
-		decomp_class = -1;
-	else decomp_class = 0;
-	check_API_parameter_int(comp_id, API_id, comm, hint, decomp_class, parameter_name, annotation);	
-	check_API_parameter_string(comp_id, API_id, comm, hint, field_instance->get_field_name(), parameter_name, annotation);
-	if (field_instance->get_decomp_id() != -1) {
-		check_API_parameter_string(comp_id, API_id, comm, hint, decomps_info_mgr->get_decomp_info(field_instance->get_decomp_id())->get_decomp_name(), parameter_name, annotation);
-		check_API_parameter_string(comp_id, API_id, comm, hint, original_grid_mgr->get_name_of_grid(field_instance->get_grid_id()), parameter_name, annotation);
-	}
-	if (field_instance->get_is_registered_model_buf())
-		is_registerred = 1;
-	else is_registerred = 0;
-	check_API_parameter_int(comp_id, API_id, comm, hint, is_registerred, parameter_name, annotation);	
-	if (field_instance->get_is_registered_model_buf())
-		check_API_parameter_int(comp_id, API_id, comm, hint, field_instance->get_buf_mark(), parameter_name, annotation);
+    Field_mem_info *field_instance;
+    int decomp_class, is_registered;
+
+
+    EXECUTION_REPORT(REPORT_ERROR, comp_id, memory_manager->check_is_legal_field_instance_id(field_id), "Software error in check_API_parameter_field_instance");
+    field_instance = memory_manager->get_field_instance(field_id);
+    if (field_instance->get_decomp_id() == -1)
+        decomp_class = -1;
+    else decomp_class = 0;
+    check_API_parameter_int(comp_id, API_id, comm, hint, decomp_class, parameter_name, annotation);    
+    check_API_parameter_string(comp_id, API_id, comm, hint, field_instance->get_field_name(), parameter_name, annotation);
+    if (field_instance->get_decomp_id() != -1) {
+        check_API_parameter_string(comp_id, API_id, comm, hint, decomps_info_mgr->get_decomp_info(field_instance->get_decomp_id())->get_decomp_name(), parameter_name, annotation);
+        check_API_parameter_string(comp_id, API_id, comm, hint, original_grid_mgr->get_name_of_grid(field_instance->get_grid_id()), parameter_name, annotation);
+    }
+    if (field_instance->get_is_registered_model_buf())
+        is_registered = 1;
+    else is_registered = 0;
+    check_API_parameter_int(comp_id, API_id, comm, hint, is_registered, parameter_name, annotation);    
+    if (field_instance->get_is_registered_model_buf())
+        check_API_parameter_int(comp_id, API_id, comm, hint, field_instance->get_buf_mark(), parameter_name, annotation);
 }
 
 
 void check_API_parameter_string(int comp_id, int API_id, MPI_Comm comm, const char *hint, const char *string, const char *parameter_name, const char *annotation)
 {
-	int local_process_id, num_processes, local_string_size, *all_string_size;
-	char API_label[NAME_STR_SIZE], *all_string_para;
-
-
-	if (!report_error_enabled)
-		return;
-
-	local_string_size = strlen(string);
-	EXECUTION_REPORT(REPORT_ERROR, comp_id, local_string_size > 0, "Error happens when calling the API \"%s\" for %s: parameter %s is an empty string. Please check the model code related to the annotation \"%s\"", API_label, hint, parameter_name, annotation);
-	EXECUTION_REPORT(REPORT_ERROR, -1, MPI_Comm_rank(comm, &local_process_id) == MPI_SUCCESS);
-	EXECUTION_REPORT(REPORT_ERROR, -1, MPI_Comm_size(comm, &num_processes) == MPI_SUCCESS);
-	all_string_size = new int [num_processes];
-	
-	EXECUTION_REPORT(REPORT_ERROR, -1, MPI_Gather(&local_string_size, 1, MPI_INT, all_string_size, 1, MPI_INT, 0, comm) == MPI_SUCCESS);
-	if (local_process_id == 0) {
-		get_API_hint(comp_id, API_id, API_label);
-		for (int i = 1; i < num_processes; i ++)
-			if (comp_id != -1)
-				EXECUTION_REPORT(REPORT_ERROR, comp_id, all_string_size[0] == all_string_size[i], "Error happens when calling the API \"%s\" for %s: parameter %s is not consistent among processes of component \"%s\". Please check the model code related to the annotation \"%s\"",
-				                 API_label, hint, parameter_name, comp_comm_group_mgt_mgr->search_global_node(comp_id)->get_comp_name(), annotation);
-			else EXECUTION_REPORT(REPORT_ERROR, comp_id, all_string_size[0] == all_string_size[i], "Error happens when calling the API \"%s\" for %s: parameter %s is not consistent among processes. Please check the model code related to the annotation \"%s\"",
-				                  API_label, hint, parameter_name, annotation);
-	}
-	all_string_para = new char [local_string_size*num_processes];
-	EXECUTION_REPORT(REPORT_ERROR, -1, MPI_Gather((void*)string, local_string_size, MPI_CHAR, all_string_para, local_string_size, MPI_CHAR, 0, comm) == MPI_SUCCESS);
-			
-	if (local_process_id == 0) {
-		for (int i = 1; i < num_processes; i ++)
-			if (comp_id != -1)
-				EXECUTION_REPORT(REPORT_ERROR, comp_id, strncmp(all_string_para, all_string_para+local_string_size*i, local_string_size) == 0, 
-				                 "Error happens when calling the API \"%s\" for %s: parameter %s is not consistent among processes of component \"%s\". Please check the model code related to the annotation \"%s\"",
-				                 API_label, hint, parameter_name, comp_comm_group_mgt_mgr->search_global_node(comp_id)->get_comp_name(), annotation);
-			else EXECUTION_REPORT(REPORT_ERROR, comp_id, strncmp(all_string_para, all_string_para+local_string_size*i, local_string_size) == 0, 
-				                  "Error happens when calling the API \"%s\" for %s: parameter %s is not consistent among processes. Please check the model code related to the annotation \"%s\"",
-				                  API_label, hint, parameter_name, annotation);			
-	}
-	
-	delete [] all_string_size;
-	delete [] all_string_para;
+    int local_process_id, num_processes, local_string_size, *all_string_size;
+    char API_label[NAME_STR_SIZE], *all_string_para;
+
+
+    if (!report_error_enabled)
+        return;
+
+    local_string_size = strlen(string);
+    EXECUTION_REPORT(REPORT_ERROR, comp_id, local_string_size > 0, "Error happens when calling the API \"%s\" for %s: parameter %s is an empty string. Please check the model code related to the annotation \"%s\"", API_label, hint, parameter_name, annotation);
+    EXECUTION_REPORT(REPORT_ERROR, -1, MPI_Comm_rank(comm, &local_process_id) == MPI_SUCCESS);
+    EXECUTION_REPORT(REPORT_ERROR, -1, MPI_Comm_size(comm, &num_processes) == MPI_SUCCESS);
+    all_string_size = new int [num_processes];
+    
+    EXECUTION_REPORT(REPORT_ERROR, -1, MPI_Gather(&local_string_size, 1, MPI_INT, all_string_size, 1, MPI_INT, 0, comm) == MPI_SUCCESS);
+    if (local_process_id == 0) {
+        get_API_hint(comp_id, API_id, API_label);
+        for (int i = 1; i < num_processes; i ++)
+            if (comp_id != -1)
+                EXECUTION_REPORT(REPORT_ERROR, comp_id, all_string_size[0] == all_string_size[i], "Error happens when calling the API \"%s\" for %s: parameter %s is not consistent among processes of component \"%s\". Please check the model code related to the annotation \"%s\"",
+                                 API_label, hint, parameter_name, comp_comm_group_mgt_mgr->search_global_node(comp_id)->get_comp_name(), annotation);
+            else EXECUTION_REPORT(REPORT_ERROR, comp_id, all_string_size[0] == all_string_size[i], "Error happens when calling the API \"%s\" for %s: parameter %s is not consistent among processes. Please check the model code related to the annotation \"%s\"",
+                                  API_label, hint, parameter_name, annotation);
+    }
+    all_string_para = new char [local_string_size*num_processes];
+    EXECUTION_REPORT(REPORT_ERROR, -1, MPI_Gather((void*)string, local_string_size, MPI_CHAR, all_string_para, local_string_size, MPI_CHAR, 0, comm) == MPI_SUCCESS);
+            
+    if (local_process_id == 0) {
+        for (int i = 1; i < num_processes; i ++)
+            if (comp_id != -1)
+                EXECUTION_REPORT(REPORT_ERROR, comp_id, strncmp(all_string_para, all_string_para+local_string_size*i, local_string_size) == 0, 
+                                 "Error happens when calling the API \"%s\" for %s: parameter %s is not consistent among processes of component \"%s\". Please check the model code related to the annotation \"%s\"",
+                                 API_label, hint, parameter_name, comp_comm_group_mgt_mgr->search_global_node(comp_id)->get_comp_name(), annotation);
+            else EXECUTION_REPORT(REPORT_ERROR, comp_id, strncmp(all_string_para, all_string_para+local_string_size*i, local_string_size) == 0, 
+                                  "Error happens when calling the API \"%s\" for %s: parameter %s is not consistent among processes. Please check the model code related to the annotation \"%s\"",
+                                  API_label, hint, parameter_name, annotation);            
+    }
+    
+    delete [] all_string_size;
+    delete [] all_string_para;
 }
 
 
 bool check_and_verify_name_format_of_string(const char *string)
 {
-	for (int i = 0; i < strlen(string); i ++)
-		if (!((string[i] >= 'a' && string[i] <= 'z') || (string[i] >= 'A' && string[i] <= 'Z') || (string[i] >= '0' && string[i] <= '9') || string[i] == '_' || string[i] == '-' || string[i] == '.'))
-			return false;
+    for (int i = 0; i < strlen(string); i ++)
+        if (!((string[i] >= 'a' && string[i] <= 'z') || (string[i] >= 'A' && string[i] <= 'Z') || (string[i] >= '0' && string[i] <= '9') || string[i] == '_' || string[i] == '-' || string[i] == '.'))
+            return false;
 
-	return true;
+    return true;
 }
 
 
 void check_and_verify_name_format_of_string_for_API(int comp_id, const char *string, int API_id, const char *name_owner, const char *annotation)
 {
-	char API_label[NAME_STR_SIZE];
-	int i;
+    char API_label[NAME_STR_SIZE];
+    int i;
 
 
-	get_API_hint(comp_id, API_id, API_label);
-	
-	EXECUTION_REPORT(REPORT_ERROR, comp_id, check_and_verify_name_format_of_string(string),
-					 "Error happens when calling the API \"%s\": the name of %s (currently is \"%s\") is in a wrong format. Each character in the name can only be '-', '_', 'a-z', 'A-Z', '0-9', or '.'. Please verify the model code with the annotation \"%s\".",
-					 API_label, name_owner, string, annotation);
+    get_API_hint(comp_id, API_id, API_label);
+    
+    EXECUTION_REPORT(REPORT_ERROR, comp_id, check_and_verify_name_format_of_string(string),
+                     "Error happens when calling the API \"%s\": the name of %s (currently is \"%s\") is in a wrong format. Each character in the name can only be '-', '_', 'a-z', 'A-Z', '0-9', or '.'. Please verify the model code with the annotation \"%s\".",
+                     API_label, name_owner, string, annotation);
 }
 
 
 void check_and_verify_name_format_of_string_for_XML(int comp_id, const char *string, const char *name_owner, const char *XML_file_name, int line_number)
 {
-	EXECUTION_REPORT(REPORT_ERROR, comp_id, check_and_verify_name_format_of_string(string),
-					 "When reading the XML file \"%s\", the format of the name of %s (currently is \"%s\") is wrong. Each character in the name can only be '-', '_', 'a-z', 'A-Z', '0-9', or '.'. Please check the XML file arround the line number %d",
-					 XML_file_name, name_owner, string, line_number);
+    EXECUTION_REPORT(REPORT_ERROR, comp_id, check_and_verify_name_format_of_string(string),
+                     "When reading the XML file \"%s\", the format of the name of %s (currently is \"%s\") is wrong. Each character in the name can only be '-', '_', 'a-z', 'A-Z', '0-9', or '.'. Please check the XML file arround the line number %d",
+                     XML_file_name, name_owner, string, line_number);
 }
 
 
 TiXmlNode *get_XML_first_child_of_unique_root(int comp_id, const char *XML_file_name, TiXmlDocument *XML_file)
 {
-	TiXmlNode *root_node = XML_file->FirstChildElement();
-	if (root_node == NULL)
-		return NULL;
+    TiXmlNode *root_node = XML_file->FirstChildElement();
+    if (root_node == NULL)
+        return NULL;
 
-	EXECUTION_REPORT(REPORT_ERROR, comp_id, root_node->NextSibling() == NULL && words_are_the_same(root_node->Value(), "root"), "ERROR happens when reading the XML configuration file \"%s\": it now has multiple root nodes while it is allowed to have at most one root node that is named \"root\". Please verify.", XML_file_name);
-	
-	return root_node->FirstChild();
+    EXECUTION_REPORT(REPORT_ERROR, comp_id, root_node->NextSibling() == NULL && words_are_the_same(root_node->Value(), "root"), "ERROR happens when reading the XML configuration file \"%s\": it now has multiple root nodes while it is allowed to have at most one root node that is named \"root\". Please verify.", XML_file_name);
+    
+    return root_node->FirstChild();
 }
 
 
 bool is_XML_setting_on(int comp_id, TiXmlElement *XML_element, const char *XML_file_name, const char *attribute_annotation, const char *XML_file_annotation)
 {
-	int line_number;
-	const char *status = get_XML_attribute(comp_id, -1, XML_element, "status", XML_file_name, line_number, attribute_annotation, XML_file_annotation, true);
-	EXECUTION_REPORT(REPORT_ERROR, comp_id, words_are_the_same(status, "on") || words_are_the_same(status, "off"), "In the XML file \"%s\" that is for %s, the value of %s is wrong (must be \"on\" or \"off\"). Please verify the XML file arround the line number %d.",
-		             XML_file_name, XML_file_annotation, attribute_annotation, line_number);
-	return words_are_the_same(status, "on");
+    int line_number;
+    const char *status = get_XML_attribute(comp_id, -1, XML_element, "status", XML_file_name, line_number, attribute_annotation, XML_file_annotation, true);
+    EXECUTION_REPORT(REPORT_ERROR, comp_id, words_are_the_same(status, "on") || words_are_the_same(status, "off"), "In the XML file \"%s\" that is for %s, the value of %s is wrong (must be \"on\" or \"off\"). Please verify the XML file arround the line number %d.",
+                     XML_file_name, XML_file_annotation, attribute_annotation, line_number);
+    return words_are_the_same(status, "on");
 }
 
 
 const char *get_XML_attribute(int comp_id, int max_string_length, TiXmlElement *XML_element, const char *attribute_keyword, const char *XML_file_name, int &line_number, const char *attribute_annotation, const char *XML_file_annotation, bool check_existence)
 {
-	const char *attribute_value = XML_element->Attribute(attribute_keyword, &line_number);
-	if (!check_existence && attribute_value == NULL)
-		return NULL;
-	EXECUTION_REPORT(REPORT_ERROR, comp_id, attribute_value != NULL, "In the XML file \"%s\" that is for %s, %s (the keyword is \"%s\") has not been specified. Please verify the XML file arround the line number %d.", 
-		             XML_file_name, XML_file_annotation, attribute_annotation, attribute_keyword, XML_element->Row());
-	EXECUTION_REPORT(REPORT_ERROR, comp_id, strlen(attribute_value) > 0, "In the XML file \"%s\" that is for %s, %s (the keyword is \"%s\") has been specified but with an empty string. Please verify the XML file arround the line number %d.", 
-		             XML_file_name, XML_file_annotation, attribute_annotation, attribute_keyword, line_number);
-	if (max_string_length > 0)	
-		EXECUTION_REPORT(REPORT_ERROR, comp_id, strlen(attribute_value) <= max_string_length, "Error happens when using the XML configuration file \"%s\": the string size (currently is %d) of the value (\"%s\") the XML attribute \"%s\" is larger than the limit (%d). Please verify XML file arround the line %d.", XML_file_name, strlen(attribute_value), attribute_value, attribute_keyword, max_string_length, line_number);
-	return attribute_value;
+    const char *attribute_value = XML_element->Attribute(attribute_keyword, &line_number);
+    if (!check_existence && attribute_value == NULL)
+        return NULL;
+    EXECUTION_REPORT(REPORT_ERROR, comp_id, attribute_value != NULL, "In the XML file \"%s\" that is for %s, %s (the keyword is \"%s\") has not been specified. Please verify the XML file arround the line number %d.", 
+                     XML_file_name, XML_file_annotation, attribute_annotation, attribute_keyword, XML_element->Row());
+    EXECUTION_REPORT(REPORT_ERROR, comp_id, strlen(attribute_value) > 0, "In the XML file \"%s\" that is for %s, %s (the keyword is \"%s\") has been specified but with an empty string. Please verify the XML file arround the line number %d.", 
+                     XML_file_name, XML_file_annotation, attribute_annotation, attribute_keyword, line_number);
+    if (max_string_length > 0)    
+        EXECUTION_REPORT(REPORT_ERROR, comp_id, strlen(attribute_value) <= max_string_length, "Error happens when using the XML configuration file \"%s\": the string size (currently is %d) of the value (\"%s\") the XML attribute \"%s\" is larger than the limit (%d). Please verify XML file arround the line %d.", XML_file_name, strlen(attribute_value), attribute_value, attribute_keyword, max_string_length, line_number);
+    return attribute_value;
 }
 
 
 void transfer_array_from_one_comp_to_another(int current_proc_local_id_src_comp, int root_proc_global_id_src_comp, int current_proc_local_id_dst_comp, 
-	                                         int root_proc_global_id_dst_comp, MPI_Comm comm_dst_comp, char **array, long &array_size)
+                                             int root_proc_global_id_dst_comp, MPI_Comm comm_dst_comp, char **array, long &array_size)
 {
-	MPI_Status status;
-
-	
-	if (current_proc_local_id_src_comp == 0 && current_proc_local_id_dst_comp != 0) {
-		MPI_Send(&array_size, 1, MPI_LONG, root_proc_global_id_dst_comp, 0, MPI_COMM_WORLD);
-		if (array_size > 0) {
-			EXECUTION_REPORT(REPORT_ERROR, -1, *array != NULL, "software error in transfer_array_from_one_comp_to_another");
-			MPI_Send(*array, array_size, MPI_CHAR, root_proc_global_id_dst_comp, 0, MPI_COMM_WORLD);
-		}
-	}
-	if (current_proc_local_id_src_comp != 0 && current_proc_local_id_dst_comp == 0) {
-		MPI_Recv(&array_size, 1, MPI_LONG, root_proc_global_id_src_comp, 0, MPI_COMM_WORLD, &status);
-		if (array_size > 0) {
-			if (*array != NULL)
-				delete [] *array;
-			*array = new char [array_size];
-			MPI_Recv(*array, array_size, MPI_CHAR, root_proc_global_id_src_comp, 0, MPI_COMM_WORLD, &status);
-		}
-	}
-
-	if (current_proc_local_id_dst_comp != -1)
-		bcast_array_in_one_comp(current_proc_local_id_dst_comp, array, array_size, comm_dst_comp);
+    MPI_Status status;
+
+    
+    if (current_proc_local_id_src_comp == 0 && current_proc_local_id_dst_comp != 0) {
+        MPI_Send(&array_size, 1, MPI_LONG, root_proc_global_id_dst_comp, 0, MPI_COMM_WORLD);
+        if (array_size > 0) {
+            EXECUTION_REPORT(REPORT_ERROR, -1, *array != NULL, "software error in transfer_array_from_one_comp_to_another");
+            MPI_Send(*array, array_size, MPI_CHAR, root_proc_global_id_dst_comp, 0, MPI_COMM_WORLD);
+        }
+    }
+    if (current_proc_local_id_src_comp != 0 && current_proc_local_id_dst_comp == 0) {
+        MPI_Recv(&array_size, 1, MPI_LONG, root_proc_global_id_src_comp, 0, MPI_COMM_WORLD, &status);
+        if (array_size > 0) {
+            if (*array != NULL)
+                delete [] *array;
+            *array = new char [array_size];
+            MPI_Recv(*array, array_size, MPI_CHAR, root_proc_global_id_src_comp, 0, MPI_COMM_WORLD, &status);
+        }
+    }
+
+    if (current_proc_local_id_dst_comp != -1)
+        bcast_array_in_one_comp(current_proc_local_id_dst_comp, array, array_size, comm_dst_comp);
 }
 
 
 void gather_array_in_one_comp(int num_total_local_proc, int current_proc_local_id, void *local_array, int local_array_size, 
-	                          int data_type_size, int *all_array_size, void **global_array, long &global_size, MPI_Comm comm)
+                              int data_type_size, int *all_array_size, void **global_array, long &global_size, MPI_Comm comm)
 {
     int *displs = new int [num_total_local_proc];
-	int *counts = new int [num_total_local_proc];
-	bool all_array_size_empty = all_array_size == NULL;
+    int *counts = new int [num_total_local_proc];
+    bool all_array_size_empty = all_array_size == NULL;
 
 
-	if (all_array_size_empty)
-		all_array_size = new int [num_total_local_proc];
+    if (all_array_size_empty)
+        all_array_size = new int [num_total_local_proc];
     MPI_Gather(&local_array_size, 1, MPI_INT, all_array_size, 1, MPI_INT, 0, comm);
-	global_size = 0;
+    global_size = 0;
     if (current_proc_local_id == 0) {
         displs[0] = 0;
-		counts[0] = all_array_size[0] * data_type_size;
-		global_size = all_array_size[0];
+        counts[0] = all_array_size[0] * data_type_size;
+        global_size = all_array_size[0];
         for (int i = 1; i < num_total_local_proc; i ++) {
-			global_size += all_array_size[i];
-			counts[i] = all_array_size[i] * data_type_size;
+            global_size += all_array_size[i];
+            counts[i] = all_array_size[i] * data_type_size;
             displs[i] = displs[i-1] + counts[i-1];
         }
         *global_array = new char [displs[num_total_local_proc-1]+counts[num_total_local_proc-1]];
     }
     MPI_Gatherv(local_array, local_array_size*data_type_size, MPI_CHAR, *global_array, counts, displs, MPI_CHAR, 0, comm);
 
-	if (all_array_size_empty)
-		delete [] all_array_size;
+    if (all_array_size_empty)
+        delete [] all_array_size;
     delete [] displs;
     delete [] counts;
 }
@@ -786,70 +796,70 @@ void gather_array_in_one_comp(int num_total_local_proc, int current_proc_local_i
 
 void bcast_array_in_one_comp(int current_proc_local_id, char **array, long &array_size, MPI_Comm comm)
 {
-	MPI_Bcast(&array_size, 1, MPI_LONG, 0, comm);
-	if (array_size > 0) {
-		if (current_proc_local_id != 0 && *array != NULL)
-			delete [] *array;
-		if (current_proc_local_id != 0)
-			*array = new char [array_size];
-		MPI_Bcast(*array, array_size, MPI_CHAR, 0, comm);
-	}
+    MPI_Bcast(&array_size, 1, MPI_LONG, 0, comm);
+    if (array_size > 0) {
+        if (current_proc_local_id != 0 && *array != NULL)
+            delete [] *array;
+        if (current_proc_local_id != 0)
+            *array = new char [array_size];
+        MPI_Bcast(*array, array_size, MPI_CHAR, 0, comm);
+    }
 }
 
 
 bool does_file_exist(const char *file_name)
 {
-	FILE *tmp_file = fopen(file_name, "r");
-	if (tmp_file != NULL)
-		fclose(tmp_file);
-	return tmp_file != NULL;
+    FILE *tmp_file = fopen(file_name, "r");
+    if (tmp_file != NULL)
+        fclose(tmp_file);
+    return tmp_file != NULL;
 }
 
 
 TiXmlDocument *open_XML_file_to_read(int comp_id, const char *XML_file_name, MPI_Comm comm, bool wait_file)
 {
-	int local_process_id = 0, file_existing = 0;
-	TiXmlDocument *XML_file;
-	bool successful;
-
-
-	EXECUTION_REPORT_LOG(REPORT_LOG, comp_id, true, "Try to load the XML configuration file \"%s\"", XML_file_name);
-	if (comm != MPI_COMM_NULL)
-		EXECUTION_REPORT(REPORT_ERROR, -1, MPI_Comm_rank(comm, &local_process_id) == MPI_SUCCESS);
-	if (local_process_id == 0) {
-		do {
-			file_existing = does_file_exist(XML_file_name)? 1 : 0;
-			if (file_existing == 1)
-				break;
-			if (wait_file)
-				sleep(1);
-		} while (wait_file);
-	}
-
-	if (comm != MPI_COMM_NULL)
-		EXECUTION_REPORT(REPORT_ERROR, -1, MPI_Bcast(&file_existing, 1, MPI_INT, 0, comm) == MPI_SUCCESS);
-	
-	if (file_existing == 0)
-		return NULL;
-
-	for (int i = 0; i < 10; i ++) {
-		XML_file = new TiXmlDocument(XML_file_name);
-		if (comm != MPI_COMM_NULL)
-			successful = XML_file->LoadFile(comm);
-		else successful = XML_file->LoadFile();
-		if (successful || !wait_file)
-			break;
-		delete XML_file;
-	} 
-
-	if (!successful) {
-		EXECUTION_REPORT(REPORT_ERROR, comp_id, false, "Fail to load the XML configuration file \"%s\": the file exists while the format of the content is not legal", XML_file_name);
-		delete XML_file;
-		return NULL;
-	}
-	
-	EXECUTION_REPORT_LOG(REPORT_LOG, comp_id, true, "Successfully load the XML configuration file \"%s\"", XML_file_name);
-
-	return XML_file;
+    int local_process_id = 0, file_existing = 0;
+    TiXmlDocument *XML_file;
+    bool successful;
+
+
+    EXECUTION_REPORT_LOG(REPORT_LOG, comp_id, true, "Try to load the XML configuration file \"%s\"", XML_file_name);
+    if (comm != MPI_COMM_NULL)
+        EXECUTION_REPORT(REPORT_ERROR, -1, MPI_Comm_rank(comm, &local_process_id) == MPI_SUCCESS);
+    if (local_process_id == 0) {
+        do {
+            file_existing = does_file_exist(XML_file_name)? 1 : 0;
+            if (file_existing == 1)
+                break;
+            if (wait_file)
+                sleep(1);
+        } while (wait_file);
+    }
+
+    if (comm != MPI_COMM_NULL)
+        EXECUTION_REPORT(REPORT_ERROR, -1, MPI_Bcast(&file_existing, 1, MPI_INT, 0, comm) == MPI_SUCCESS);
+    
+    if (file_existing == 0)
+        return NULL;
+
+    for (int i = 0; i < 10; i ++) {
+        XML_file = new TiXmlDocument(XML_file_name);
+        if (comm != MPI_COMM_NULL)
+            successful = XML_file->LoadFile(comm);
+        else successful = XML_file->LoadFile();
+        if (successful || !wait_file)
+            break;
+        delete XML_file;
+    } 
+
+    if (!successful) {
+        EXECUTION_REPORT(REPORT_ERROR, comp_id, false, "Fail to load the XML configuration file \"%s\": the file exists while the format of the content is not legal", XML_file_name);
+        delete XML_file;
+        return NULL;
+    }
+    
+    EXECUTION_REPORT_LOG(REPORT_LOG, comp_id, true, "Successfully load the XML configuration file \"%s\"", XML_file_name);
+
+    return XML_file;
 }
 
diff --git a/src/Driver/CCPL_api_mgt.h b/src/Driver/CCPL_api_mgt.h
old mode 100644
new mode 100755
index 3099e30..164546d
--- a/src/Driver/CCPL_api_mgt.h
+++ b/src/Driver/CCPL_api_mgt.h
@@ -17,93 +17,97 @@
 
 enum 
 {
-	API_ID_FINALIZE,
-	API_ID_COMP_MGT_REG_COMP,
-	API_ID_COMP_MGT_GET_COMP_LOG_FILE_NAME,
-	API_ID_COMP_MGT_GET_COMP_LOG_FILE_DEVICE,
-	API_ID_COMP_MGT_END_COMP_REG,
-	API_ID_COMP_MGT_IS_CURRENT_PROC_IN_COMP,
-	API_ID_COMP_MGT_GET_CURRENT_PROC_ID_IN_COMP,
-	API_ID_COMP_MGT_GET_NUM_PROC_IN_COMP,
-	API_ID_COMP_MGT_GET_COMP_PROC_GLOBAL_ID,
-	API_ID_COMP_MGT_GET_COMP_ID,
-	API_ID_COMP_MGT_IS_COMP_TYPE_COUPLED,
-	API_ID_GRID_MGT_REG_H2D_GRID_VIA_LOCAL_DATA,
-	API_ID_GRID_MGT_REG_H2D_GRID_VIA_GLOBAL_DATA,
-	API_ID_GRID_MGT_REG_H2D_GRID_VIA_FILE,
-	API_ID_GRID_MGT_REG_1D_GRID_ONLINE,
-	API_ID_GRID_MGT_REG_MD_GRID_VIA_MULTI_GRIDS,
-	API_ID_GRID_MGT_REG_GRID_VIA_COR,
-	API_ID_GRID_MGT_REG_GRID_VIA_LOCAL,
-	API_ID_GRID_MGT_REG_H2D_GRID_VIA_COMP,
-	API_ID_GRID_MGT_CMP_GRID_VIA_REMOTE,
-	API_ID_GRID_MGT_GET_GRID_ID,
-	API_ID_GRID_MGT_SET_GRID_DATA,
-	API_ID_GRID_MGT_SET_3D_GRID_DYN_BOT_FLD,
-	API_ID_GRID_MGT_SET_3D_GRID_STATIC_BOT_FLD,
-	API_ID_GRID_MGT_SET_3D_GRID_EXTERNAL_BOT_FLD,
-	API_ID_GRID_MGT_GET_H2D_GRID_DATA,
-	API_ID_GRID_MGT_GET_H2D_GRID_AREA_FROM_WGTS,
-	API_ID_GRID_MGT_REG_MID_POINT_GRID,
-	API_ID_GRID_MGT_GET_GRID_SIZE,
-	API_ID_GRID_MGT_REG_V1D_Z_GRID_VIA_MODEL,
-	API_ID_GRID_MGT_REG_V1D_SIGMA_GRID_VIA_MODEL,
-	API_ID_GRID_MGT_REG_V1D_HYBRID_GRID_VIA_MODEL,
-	API_ID_DECOMP_MGT_REG_DECOMP,
-	API_ID_FIELD_MGT_REG_FIELD_INST,
-	API_ID_FIELD_MGT_REG_IO_FIELD_from_INST,
-	API_ID_FIELD_MGT_REG_IO_FIELDs_from_INSTs,
-	API_ID_FIELD_MGT_REG_IO_FIELD_from_BUFFER,
-	API_ID_TIME_MGT_SET_NORMAL_TIME_STEP,
-	API_ID_TIME_MGT_ADVANCE_TIME,
-	API_ID_TIME_MGT_RESET_TIME_TO_START,
-	API_ID_TIME_MGT_DEFINE_SINGLE_TIMER,
-	API_ID_TIME_MGT_DEFINE_COMPLEX_TIMER,
-	API_ID_TIME_MGT_GET_CURRENT_NUM_DAYS_IN_YEAR,
-	API_ID_TIME_MGT_GET_CURRENT_YEAR,
-	API_ID_TIME_MGT_GET_CURRENT_DATE,
-	API_ID_TIME_MGT_GET_CURRENT_SECOND,
-	API_ID_TIME_MGT_GET_START_TIME,
-	API_ID_TIME_MGT_GET_STOP_TIME,
-	API_ID_TIME_MGT_GET_PREVIOUS_TIME,
-	API_ID_TIME_MGT_GET_CURRENT_TIME,
-	API_ID_TIME_MGT_GET_ELAPSED_DAYS_FROM_REF,
-	API_ID_TIME_MGT_GET_ELAPSED_DAYS_FROM_START,
-	API_ID_TIME_MGT_IS_END_CURRENT_DAY,
-	API_ID_TIME_MGT_IS_END_CURRENT_MONTH,
-	API_ID_TIME_MGT_GET_CURRENT_CAL_TIME,
-	API_ID_TIME_MGT_IS_FIRST_STEP,
-	API_ID_TIME_MGT_IS_FIRST_RESTART_STEP,
-	API_ID_TIME_MGT_GET_NUM_CURRENT_STEP,
-	API_ID_TIME_MGT_GET_NUM_TOTAL_STEPS,
-	API_ID_TIME_MGT_GET_NORMAL_TIME_STEP,
-	API_ID_TIME_MGT_CHECK_CURRENT_TIME,
-	API_ID_TIME_MGT_IS_TIMER_ON,
-	API_ID_TIME_MGT_IS_MODEL_LAST_STEP,
-	API_ID_TIME_MGT_IS_MODEL_RUN_ENDED,
-	API_ID_INTERFACE_REG_IMPORT,
-	API_ID_INTERFACE_REG_EXPORT,
-	API_ID_INTERFACE_REG_NORMAL_REMAP,
-	API_ID_INTERFACE_REG_FRAC_REMAP,
-	API_ID_INTERFACE_EXECUTE_WITH_ID,
-	API_ID_INTERFACE_EXECUTE_WITH_NAME,
-	API_ID_INTERFACE_CHECK_IMPORT_FIELD_CONNECTED,
-	API_ID_INTERFACE_GET_LOCAL_COMP_FULL_NAME,
-	API_ID_REPORT_LOG,
-	API_ID_REPORT_ERROR,
-	API_ID_REPORT_PROGRESS,
-	API_ID_RESTART_MGT_WRITE_IO,
-	API_ID_RESTART_MGT_START_READ_IO,
-	API_ID_RESTART_MGT_IS_TIMER_ON,
-	API_ID_RESTART_MGT_READ_ALL,
-	API_ID_RESTART_MGT_READ_INTERFACE,
-	API_ID_RESTART_MGT_GET_SETTING,
-	API_ID_COUPLING_GEN_FAMILY,
-	API_ID_COUPLING_GEN_EXTERNAL,
-	API_ID_COUPLING_GEN_INDIVIDUAL,
-	API_ID_COUPLING_GEN_GET_COMPS
+    API_ID_FINALIZE,
+    API_ID_COMP_MGT_REG_COMP,
+    API_ID_COMP_MGT_GET_COMP_LOG_FILE_NAME,
+    API_ID_COMP_MGT_GET_COMP_LOG_FILE_DEVICE,
+    API_ID_COMP_MGT_END_COMP_REG,
+    API_ID_COMP_MGT_IS_CURRENT_PROC_IN_COMP,
+    API_ID_COMP_MGT_GET_CURRENT_PROC_ID_IN_COMP,
+    API_ID_COMP_MGT_GET_NUM_PROC_IN_COMP,
+    API_ID_COMP_MGT_GET_COMP_PROC_GLOBAL_ID,
+    API_ID_COMP_MGT_GET_COMP_ID,
+    API_ID_COMP_MGT_IS_COMP_TYPE_COUPLED,
+    API_ID_COMP_MGT_GET_LOCAL_COMP_FULL_NAME,
+    API_ID_GRID_MGT_REG_H2D_GRID_VIA_LOCAL_DATA,
+    API_ID_GRID_MGT_REG_H2D_GRID_VIA_GLOBAL_DATA,
+    API_ID_GRID_MGT_REG_H2D_GRID_VIA_FILE,
+    API_ID_GRID_MGT_REG_1D_GRID_ONLINE,
+    API_ID_GRID_MGT_REG_MD_GRID_VIA_MULTI_GRIDS,
+    API_ID_GRID_MGT_REG_GRID_VIA_COR,
+    API_ID_GRID_MGT_REG_GRID_VIA_LOCAL,
+    API_ID_GRID_MGT_REG_H2D_GRID_VIA_COMP,
+    API_ID_GRID_MGT_CMP_GRID_VIA_REMOTE,
+    API_ID_GRID_MGT_GET_GRID_ID,
+    API_ID_GRID_MGT_SET_GRID_DATA,
+    API_ID_GRID_MGT_SET_3D_GRID_3D_VERT_FLD,
+    API_ID_GRID_MGT_SET_3D_GRID_DYN_BOT_FLD,
+    API_ID_GRID_MGT_SET_3D_GRID_STATIC_BOT_FLD,
+    API_ID_GRID_MGT_SET_3D_GRID_EXTERNAL_BOT_FLD,
+    API_ID_GRID_MGT_GET_H2D_GRID_DATA,
+    API_ID_GRID_MGT_GET_H2D_GRID_AREA_FROM_WGTS,
+    API_ID_GRID_MGT_REG_MID_POINT_GRID,
+    API_ID_GRID_MGT_GET_GRID_SIZE,
+    API_ID_GRID_MGT_REG_V1D_GRID_NO_DATA,
+    API_ID_GRID_MGT_REG_V1D_Z_GRID_VIA_MODEL,
+    API_ID_GRID_MGT_REG_V1D_SIGMA_GRID_VIA_MODEL,
+    API_ID_GRID_MGT_REG_V1D_HYBRID_GRID_VIA_MODEL,
+    API_ID_DECOMP_MGT_REG_DECOMP,
+    API_ID_FIELD_MGT_REG_FIELD_INST,
+    API_ID_FIELD_MGT_REG_IO_FIELD_from_INST,
+    API_ID_FIELD_MGT_REG_IO_FIELDs_from_INSTs,
+    API_ID_FIELD_MGT_REG_IO_FIELD_from_BUFFER,
+    API_ID_TIME_MGT_SET_NORMAL_TIME_STEP,
+    API_ID_TIME_MGT_ADVANCE_TIME,
+    API_ID_TIME_MGT_RESET_TIME_TO_START,
+    API_ID_TIME_MGT_DEFINE_SINGLE_TIMER,
+    API_ID_TIME_MGT_DEFINE_COMPLEX_TIMER,
+    API_ID_TIME_MGT_GET_CURRENT_NUM_DAYS_IN_YEAR,
+    API_ID_TIME_MGT_GET_CURRENT_YEAR,
+    API_ID_TIME_MGT_GET_CURRENT_DATE,
+    API_ID_TIME_MGT_GET_CURRENT_SECOND,
+    API_ID_TIME_MGT_GET_START_TIME,
+    API_ID_TIME_MGT_GET_STOP_TIME,
+    API_ID_TIME_MGT_GET_PREVIOUS_TIME,
+    API_ID_TIME_MGT_GET_CURRENT_TIME,
+    API_ID_TIME_MGT_GET_ELAPSED_DAYS_FROM_REF,
+    API_ID_TIME_MGT_GET_ELAPSED_DAYS_FROM_START,
+    API_ID_TIME_MGT_IS_END_CURRENT_DAY,
+    API_ID_TIME_MGT_IS_END_CURRENT_MONTH,
+    API_ID_TIME_MGT_GET_CURRENT_CAL_TIME,
+    API_ID_TIME_MGT_IS_FIRST_STEP,
+    API_ID_TIME_MGT_IS_FIRST_RESTART_STEP,
+    API_ID_TIME_MGT_GET_NUM_CURRENT_STEP,
+    API_ID_TIME_MGT_GET_NUM_TOTAL_STEPS,
+    API_ID_TIME_MGT_GET_NORMAL_TIME_STEP,
+    API_ID_TIME_MGT_CHECK_CURRENT_TIME,
+    API_ID_TIME_MGT_IS_TIMER_ON,
+    API_ID_TIME_MGT_IS_MODEL_LAST_STEP,
+    API_ID_TIME_MGT_IS_MODEL_RUN_ENDED,
+    API_ID_INTERFACE_REG_IMPORT,
+    API_ID_INTERFACE_REG_EXPORT,
+    API_ID_INTERFACE_REG_NORMAL_REMAP,
+    API_ID_INTERFACE_REG_FRAC_REMAP,
+    API_ID_INTERFACE_EXECUTE_WITH_ID,
+    API_ID_INTERFACE_EXECUTE_WITH_NAME,
+    API_ID_INTERFACE_CHECK_IMPORT_FIELD_CONNECTED,
+    API_ID_INTERFACE_GET_SENDER_TIME,
+    API_ID_REPORT_LOG,
+    API_ID_REPORT_ERROR,
+    API_ID_REPORT_PROGRESS,
+    API_ID_RESTART_MGT_WRITE_IO,
+    API_ID_RESTART_MGT_START_READ_IO,
+    API_ID_RESTART_MGT_IS_TIMER_ON,
+    API_ID_RESTART_MGT_READ_ALL,
+    API_ID_RESTART_MGT_READ_INTERFACE,
+    API_ID_RESTART_MGT_GET_SETTING,
+    API_ID_COUPLING_GEN_FAMILY,
+    API_ID_COUPLING_GEN_EXTERNAL,
+    API_ID_COUPLING_GEN_INDIVIDUAL,
+    API_ID_COUPLING_GEN_GET_COMPS
 };
 
+
 extern void synchronize_comp_processes_for_API(int, int, MPI_Comm, const char *, const char *);
 extern void check_API_parameter_string(int, int, MPI_Comm, const char*, const char*, const char*, const char*);
 extern void check_API_parameter_int(int, int, MPI_Comm, const char*, int, const char*, const char*);
diff --git a/src/Driver/c_coupler_interface_mod.F90 b/src/Driver/c_coupler_interface_mod.F90
old mode 100644
new mode 100755
index c3499a8..d53fed4
--- a/src/Driver/c_coupler_interface_mod.F90
+++ b/src/Driver/c_coupler_interface_mod.F90
@@ -17,6 +17,7 @@
    public :: CCPL_register_field_instance
    public :: CCPL_register_IO_field_from_data_buffer
    public :: CCPL_get_current_calendar_time
+   public :: CCPL_register_V1D_grid_without_data
    public :: CCPL_register_V1D_Z_grid_via_model_data
    public :: CCPL_register_V1D_SIGMA_grid_via_model_data 
    public :: CCPL_register_V1D_HYBRID_grid_via_model_data
@@ -29,7 +30,7 @@
    public :: CCPL_register_IO_fields_from_field_instances 
    public :: CCPL_get_number_of_current_step 
    public :: CCPL_get_number_of_total_steps 
-   public :: CCPL_normal_time_step
+   public :: CCPL_get_normal_time_step
    public :: CCPL_is_first_step
    public :: CCPL_is_first_restart_step
    public :: CCPL_get_current_num_days_in_year
@@ -58,6 +59,7 @@
    public :: CCPL_register_CoR_defined_grid
    public :: CCPL_register_H2D_grid_via_file
    public :: CCPL_register_H2D_grid_from_another_component
+   public :: CCPL_set_3D_grid_3D_vertical_coord_field
    public :: CCPL_set_3D_grid_variable_surface_field
    public :: CCPL_set_3D_grid_constant_surface_field
    public :: CCPL_set_3D_grid_external_surface_field
@@ -82,6 +84,7 @@
    public :: CCPL_execute_interface_using_id 
    public :: CCPL_execute_interface_using_name
    public :: CCPL_check_is_import_field_connected
+   public :: CCPL_get_import_fields_sender_time
    public :: CCPL_get_local_comp_full_name 
    public :: CCPL_report_log 
    public :: CCPL_report_progress 
@@ -1146,7 +1149,7 @@
 
 
 
- integer FUNCTION CCPL_normal_time_step(comp_id, annotation)
+ integer FUNCTION CCPL_get_normal_time_step(comp_id, annotation)
    implicit none  
    integer, intent(in) :: comp_id
    character(len=*), intent(in), optional :: annotation
@@ -1157,9 +1160,9 @@
    else 
       call get_ccpl_time_step(comp_id, step_size, trim("")//char(0))
    endif
-   CCPL_normal_time_step = step_size
+   CCPL_get_normal_time_step = step_size
 
- END FUNCTION CCPL_normal_time_step
+ END FUNCTION CCPL_get_normal_time_step
 
 
 
@@ -1448,7 +1451,6 @@
 
  SUBROUTINE CCPL_allreduce_real16(input_data, output_data, num_data, comm, num_proc)
    implicit none
-   include 'mpif.h'
    real(R16)         :: input_data(:), output_data(:)
    integer           :: num_data, comm
    integer           :: ierr
@@ -2159,6 +2161,27 @@
 
 
 
+   integer FUNCTION CCPL_register_V1D_grid_without_data(comp_id, grid_name, coord_unit, grid_size, annotation)
+   implicit none
+   integer, intent(in)                                     :: comp_id
+   integer, intent(in)                                     :: grid_size
+   character(len=*), intent(in)                            :: grid_name
+   character(len=*), intent(in)                            :: coord_unit
+   character(len=*), intent(in),               optional    :: annotation
+   integer                                                 :: grid_id
+
+   if (present(annotation)) then
+       call register_V1D_grid_without_data(comp_id, grid_id, trim(grid_name)//char(0), trim(coord_unit)//char(0), grid_size, trim(annotation)//char(0))
+   else
+       call register_V1D_grid_without_data(comp_id, grid_id, trim(grid_name)//char(0), trim(coord_unit)//char(0), grid_size, trim("")//char(0))
+   endif
+
+   CCPL_register_V1D_grid_without_data = grid_id
+
+   END FUNCTION CCPL_register_V1D_grid_without_data
+
+
+
    integer FUNCTION CCPL_register_V1D_Z_grid_via_double_data(comp_id, grid_name, coord_unit, coord_values, annotation)
    implicit none
    integer, intent(in)                                     :: comp_id
@@ -2169,9 +2192,9 @@
    integer                                                 :: grid_id
 
    if (present(annotation)) then
-       call register_V1D_grid_with_data(comp_id, grid_id, trim(grid_name)//char(0), 1, trim(coord_unit)//char(0), size(coord_values), size(coord_values), trim("real8")//char(0), coord_values, coord_values, coord_values, coord_values, trim(annotation)//char(0))
+       call register_V1D_grid_with_data(comp_id, grid_id, trim(grid_name)//char(0), 1, trim(coord_unit)//char(0), size(coord_values), size(coord_values), trim("real8")//char(0), coord_values, coord_values, coord_values, trim(annotation)//char(0))
    else
-       call register_V1D_grid_with_data(comp_id, grid_id, trim(grid_name)//char(0), 1, trim(coord_unit)//char(0), size(coord_values), size(coord_values), trim("real8")//char(0), coord_values, coord_values, coord_values, coord_values, trim("")//char(0))
+       call register_V1D_grid_with_data(comp_id, grid_id, trim(grid_name)//char(0), 1, trim(coord_unit)//char(0), size(coord_values), size(coord_values), trim("real8")//char(0), coord_values, coord_values, coord_values, trim("")//char(0))
    endif
 
    CCPL_register_V1D_Z_grid_via_double_data = grid_id
@@ -2190,9 +2213,9 @@
    integer                                                 :: grid_id
 
    if (present(annotation)) then
-       call register_V1D_grid_with_data(comp_id, grid_id, trim(grid_name)//char(0), 1, trim(coord_unit)//char(0), size(coord_values), size(coord_values), trim("real4")//char(0), coord_values, coord_values, coord_values, coord_values, trim(annotation)//char(0))
+       call register_V1D_grid_with_data(comp_id, grid_id, trim(grid_name)//char(0), 1, trim(coord_unit)//char(0), size(coord_values), size(coord_values), trim("real4")//char(0), coord_values, coord_values, coord_values, trim(annotation)//char(0))
    else
-       call register_V1D_grid_with_data(comp_id, grid_id, trim(grid_name)//char(0), 1, trim(coord_unit)//char(0), size(coord_values), size(coord_values), trim("real4")//char(0), coord_values, coord_values, coord_values, coord_values, trim("")//char(0))
+       call register_V1D_grid_with_data(comp_id, grid_id, trim(grid_name)//char(0), 1, trim(coord_unit)//char(0), size(coord_values), size(coord_values), trim("real4")//char(0), coord_values, coord_values, coord_values, trim("")//char(0))
    endif
 
    CCPL_register_V1D_Z_grid_via_float_data = grid_id
@@ -2328,6 +2351,23 @@
 
 
 
+   SUBROUTINE CCPL_set_3D_grid_3D_vertical_coord_field(grid_id, field_id, label, annotation)
+   implicit none
+   integer, intent(in)                                     :: grid_id
+   integer, intent(in)                                     :: field_id
+   character(len=*), intent(in)                            :: label
+   character(len=*), intent(in),               optional    :: annotation
+
+   if (present(annotation)) then
+       call set_3D_grid_3D_vertical_coord_field(grid_id, field_id, trim(label)//char(0), trim(annotation)//char(0))
+   else
+       call set_3D_grid_3D_vertical_coord_field(grid_id, field_id, trim(label)//char(0), trim("")//char(0))
+   endif
+
+   END SUBROUTINE CCPL_set_3D_grid_3D_vertical_coord_field
+
+
+
    SUBROUTINE CCPL_set_3D_grid_variable_surface_field(grid_id, field_id, annotation)
    implicit none
    integer, intent(in)                                     :: grid_id
@@ -2693,7 +2733,6 @@
 
    SUBROUTINE CCPL_finalize(to_finalize_MPI, annotation)
    implicit none
-   include 'mpif.h'
    logical,          intent(in)                :: to_finalize_MPI
    integer                                     :: local_to_finalize_MPI
    character(len=*), intent(in), optional      :: annotation
@@ -2802,7 +2841,7 @@
    if (present(annotation)) local_annotation = annotation
 
    call register_frac_based_remap_interface(trim(interface_name)//char(0), interface_id, num_field_instances, field_instance_IDs_source, field_instance_IDs_target, timer_ID, &
-                                            inst_or_aver, size(field_instance_IDs_source), size(field_instance_IDs_target), frac_src, temp_frac_dst, size(frac_src), &
+                                            inst_or_aver, size(field_instance_IDs_source), size(field_instance_IDs_target), loc(frac_src), loc(temp_frac_dst), size(frac_src), &
                                             size_frac_dst, trim("real4")//char(0), trim(local_annotation)//char(0))
 
    deallocate(temp_float_1d)
@@ -2840,7 +2879,7 @@
    if (present(annotation)) local_annotation = annotation
 
    call register_frac_based_remap_interface(trim(interface_name)//char(0), interface_id, num_field_instances, field_instance_IDs_source, field_instance_IDs_target, timer_ID, &
-                                            inst_or_aver, size(field_instance_IDs_source), size(field_instance_IDs_target), frac_src, temp_frac_dst, size(frac_src), &
+                                            inst_or_aver, size(field_instance_IDs_source), size(field_instance_IDs_target), loc(frac_src), loc(temp_frac_dst), size(frac_src), &
                                             size_frac_dst, trim("real8")//char(0), trim(local_annotation)//char(0))
 
    deallocate(temp_double_1d)
@@ -2851,9 +2890,9 @@
 
 
 
-   logical FUNCTION CCPL_check_is_import_field_connected(interface_id, field_instance_id, annotation)
+   logical FUNCTION CCPL_check_is_import_field_connected(import_interface_id, field_instance_id, annotation)
    implicit none
-   integer,          intent(in)                         :: interface_id
+   integer,          intent(in)                         :: import_interface_id
    integer,          intent(in)                         :: field_instance_id
    character(len=*), intent(in), optional               :: annotation
    character *2048                                      :: local_annotation
@@ -2861,7 +2900,7 @@
 
    local_annotation = ""
    if (present(annotation)) local_annotation = annotation
-   call check_is_ccpl_import_field_connected(interface_id, field_instance_id, check_result, trim(local_annotation)//char(0))
+   call check_is_ccpl_import_field_connected(import_interface_id, field_instance_id, check_result, trim(local_annotation)//char(0))
    CCPL_check_is_import_field_connected = .true.
    if (check_result .eq. 0) CCPL_check_is_import_field_connected = .false.
    
@@ -2869,6 +2908,30 @@
    
 
 
+   SUBROUTINE CCPL_get_import_fields_sender_time(import_interface_id, sender_date, sender_second, sender_elapased_days, annotation)
+   implicit none
+   integer,          intent(in)                          :: import_interface_id
+   integer,          intent(out), dimension(:)           :: sender_date
+   integer,          intent(out), dimension(:)           :: sender_second
+   integer,          intent(out), dimension(:),optional  :: sender_elapased_days ! number of elapased days since 0000-01-01
+   character(len=*), intent(in), optional                :: annotation
+   character *2048                                       :: local_annotation
+   integer                                               :: temp_sender_elapased_days(4096) 
+
+   local_annotation = ""
+   if (present(annotation)) then
+       local_annotation = annotation
+   endif
+   if (present(sender_elapased_days)) then
+      call get_ccpl_import_fields_sender_time(import_interface_id, size(sender_date), size(sender_elapased_days), size(sender_second), sender_date, sender_elapased_days, sender_second, trim(local_annotation)//char(0))
+   else
+      call get_ccpl_import_fields_sender_time(import_interface_id, size(sender_date), size(temp_sender_elapased_days), size(sender_second), sender_date, temp_sender_elapased_days, sender_second, trim(local_annotation)//char(0))
+   endif
+   
+   END SUBROUTINE CCPL_get_import_fields_sender_time
+
+
+
    integer FUNCTION CCPL_register_import_interface(interface_name, num_field_instances, field_instance_IDs, timer_ID, inst_or_aver, necessity, annotation)
    implicit none
    character(len=*), intent(in)                         :: interface_name
@@ -2924,7 +2987,7 @@
    integer                                               :: local_bypass_timer
    integer,          intent(out), dimension(:), optional :: field_update_status
    integer                                               :: temp_field_update_status(4096), i, num_dst_fields
-   character *2048                                        :: local_annotation
+   character *2048                                       :: local_annotation
 
 
    if (bypass_timer) then
@@ -3064,20 +3127,24 @@
 
 
 
-   SUBROUTINE CCPL_do_restart_write_IO(comp_id, bypass_timer, annotation)
+   SUBROUTINE CCPL_do_restart_write_IO(comp_id, bypass_timer, bypass_import_fields, annotation)
    implicit none
    integer,          intent(in)                :: comp_id
    logical,          intent(in)                :: bypass_timer
+   logical,          intent(in), optional      :: bypass_import_fields
    character(len=*), intent(in), optional      :: annotation
    integer                                     :: local_bypass_timer
+   integer                                     :: local_bypass_import_fields
 
    local_bypass_timer = 0
    if (bypass_timer) local_bypass_timer = 1
+   local_bypass_import_fields = 0
+   if (present(bypass_import_fields) .and. bypass_import_fields) local_bypass_import_fields = 1
 
    if (present(annotation)) then
-       call CCPL_write_restart(comp_id, local_bypass_timer, trim(annotation)//char(0))
+       call CCPL_write_restart(comp_id, local_bypass_timer, local_bypass_import_fields, trim(annotation)//char(0))
    else 
-       call CCPL_write_restart(comp_id, local_bypass_timer, trim("")//char(0))
+       call CCPL_write_restart(comp_id, local_bypass_timer, local_bypass_import_fields, trim("")//char(0))
    endif
    
    END SUBROUTINE CCPL_do_restart_write_IO
diff --git a/src/Driver/coupling_interface.cxx b/src/Driver/coupling_interface.cxx
old mode 100644
new mode 100755
index cdf048a..d451747
--- a/src/Driver/coupling_interface.cxx
+++ b/src/Driver/coupling_interface.cxx
@@ -23,29 +23,29 @@ int coupling_process_control_counter = 0;
 
 void check_for_component_registered(int comp_id, int API_ID, const char *annotation, bool enable_minus_1)
 {
-	char API_label[NAME_STR_SIZE];
-	
+    char API_label[NAME_STR_SIZE];
+    
 
-	get_API_hint(-1, API_ID, API_label);
-	check_for_ccpl_managers_allocated(API_ID, annotation);
+    get_API_hint(-1, API_ID, API_label);
+    check_for_ccpl_managers_allocated(API_ID, annotation);
 
-	if (comp_id == -1)
-		EXECUTION_REPORT(REPORT_ERROR, comp_id, enable_minus_1, "Error happens when calling the API \"%s\": the given component model ID (-1) is not valid. Please check the model code with the annotation \"%s\"", API_label, annotation);
-	else EXECUTION_REPORT(REPORT_ERROR, -1, comp_comm_group_mgt_mgr->is_legal_local_comp_id(comp_id, true) && comp_comm_group_mgt_mgr->get_current_proc_id_in_comp(comp_id, "in check_for_component_registered") >= 0, "Error happens when calling the API \"%s\": the given component ID (0x%d) is wrong. Please check the model code with the annotation \"%s\"", API_label, comp_id, annotation);
+    if (comp_id == -1)
+        EXECUTION_REPORT(REPORT_ERROR, comp_id, enable_minus_1, "Error happens when calling the API \"%s\": the given component model ID (-1) is not valid. Please check the model code with the annotation \"%s\"", API_label, annotation);
+    else EXECUTION_REPORT(REPORT_ERROR, -1, comp_comm_group_mgt_mgr->is_legal_local_comp_id(comp_id, true) && comp_comm_group_mgt_mgr->get_current_proc_id_in_comp(comp_id, "in check_for_component_registered") >= 0, "Error happens when calling the API \"%s\": the given component ID (0x%d) is wrong. Please check the model code with the annotation \"%s\"", API_label, comp_id, annotation);
 }
 
 
 void copy_out_string_to_Fortran_API(int comp_id, int size_API_string, char *API_string, const char *CCPL_string, int API_id, const char *parameter_name, const char *annotation)
 {
-	char API_label[NAME_STR_SIZE];
+    char API_label[NAME_STR_SIZE];
 
 
-	get_API_hint(comp_id, API_id,API_label);
-	
-	EXECUTION_REPORT(REPORT_ERROR, comp_id, size_API_string >= strlen(CCPL_string), "Error happens when calling the API \"%s\": the parameter string \"%s\" is too short: only %d while the required size is %d. Please verify the model code with the annotation \"%s\"", API_label, parameter_name, size_API_string, strlen(CCPL_string));
-	strncpy(API_string, CCPL_string, strlen(CCPL_string));
-	for (int i = strlen(CCPL_string); i < size_API_string; i ++)
-		API_string[i] = ' ';	
+    get_API_hint(comp_id, API_id,API_label);
+    
+    EXECUTION_REPORT(REPORT_ERROR, comp_id, size_API_string >= strlen(CCPL_string), "Error happens when calling the API \"%s\": the parameter string \"%s\" is too short: only %d while the required size is %d. Please verify the model code with the annotation \"%s\"", API_label, parameter_name, size_API_string, strlen(CCPL_string), annotation);
+    strncpy(API_string, CCPL_string, strlen(CCPL_string));
+    for (int i = strlen(CCPL_string); i < size_API_string; i ++)
+        API_string[i] = ' ';    
 }
 
 
@@ -56,37 +56,37 @@ extern "C" void finalize_ccpl_
 #endif
 (int *to_finalize_MPI, const char *annotation)
 {
-	if (comp_comm_group_mgt_mgr->get_current_proc_global_id() == 0)
-		EXECUTION_REPORT(REPORT_PROGRESS, -1, true, "Start to finalize C-Coupler at the model code with the annotation \"%s\"", annotation);
-
-	comp_comm_group_mgt_mgr->output_performance_timing();
-	inout_interface_mgr->free_all_MPI_wins();
-
-	delete annotation_mgr;
-	delete decomps_info_mgr;
-	delete decomp_grids_mgr;
-	delete components_time_mgrs;
-	delete timer_mgr;
-	delete inout_interface_mgr;
-	delete routing_info_mgr;
-	delete IO_fields_mgr;
-	delete components_IO_output_procedures_mgr;
-	delete fields_gather_scatter_mgr;
-	delete remapping_configuration_mgr;
-	delete runtime_remapping_weights_mgr;
-	delete fields_info;
-	delete original_grid_mgr;
-	delete memory_manager;
-	delete coupling_generator;
-	delete comp_comm_group_mgt_mgr;
-	comp_comm_group_mgt_mgr = NULL;
-
-	if (*to_finalize_MPI == 0)
-		return;
-	int flag;
-	MPI_Finalized(&flag);
-	if (!flag)
-		MPI_Finalize();
+    if (comp_comm_group_mgt_mgr->get_current_proc_global_id() == 0)
+        EXECUTION_REPORT(REPORT_PROGRESS, -1, true, "Start to finalize C-Coupler at the model code with the annotation \"%s\"", annotation);
+
+    comp_comm_group_mgt_mgr->output_performance_timing();
+    inout_interface_mgr->free_all_MPI_wins();
+
+    delete annotation_mgr;
+    delete decomps_info_mgr;
+    delete decomp_grids_mgr;
+    delete components_time_mgrs;
+    delete timer_mgr;
+    delete inout_interface_mgr;
+    delete routing_info_mgr;
+    delete IO_fields_mgr;
+    delete components_IO_output_procedures_mgr;
+    delete fields_gather_scatter_mgr;
+    delete remapping_configuration_mgr;
+    delete runtime_remapping_weights_mgr;
+    delete fields_info;
+    delete original_grid_mgr;
+    delete memory_manager;
+    delete coupling_generator;
+    delete comp_comm_group_mgt_mgr;
+    comp_comm_group_mgt_mgr = NULL;
+
+    if (*to_finalize_MPI == 0)
+        return;
+    int flag;
+    MPI_Finalized(&flag);
+    if (!flag)
+        MPI_Finalize();
 }
 
 
@@ -97,7 +97,7 @@ extern "C" void get_ccpl_double_current_calendar_time_
 #endif
 (int *comp_id, double *cal_time, int *shift_seconds, const char *annotation)
 {
-	check_for_component_registered(*comp_id, API_ID_TIME_MGT_GET_CURRENT_CAL_TIME, annotation, false);
+    check_for_component_registered(*comp_id, API_ID_TIME_MGT_GET_CURRENT_CAL_TIME, annotation, false);
     *cal_time = components_time_mgrs->get_time_mgr(*comp_id)->get_double_current_calendar_time(*shift_seconds, annotation);
 }
 
@@ -109,7 +109,7 @@ extern "C" void get_ccpl_float_current_calendar_time_
 #endif
 (int *comp_id, float *cal_time, int *shift_seconds, const char *annotation)
 {
-	check_for_component_registered(*comp_id, API_ID_TIME_MGT_GET_CURRENT_CAL_TIME, annotation, false);
+    check_for_component_registered(*comp_id, API_ID_TIME_MGT_GET_CURRENT_CAL_TIME, annotation, false);
     *cal_time = components_time_mgrs->get_time_mgr(*comp_id)->get_float_current_calendar_time(*shift_seconds, annotation);
 }
 
@@ -121,7 +121,7 @@ extern "C" void get_ccpl_current_date_
 #endif
 (int *comp_id, int *date, const char *annotation)
 {
-	check_for_component_registered(*comp_id, API_ID_TIME_MGT_GET_CURRENT_DATE, annotation, false);
+    check_for_component_registered(*comp_id, API_ID_TIME_MGT_GET_CURRENT_DATE, annotation, false);
     *date = components_time_mgrs->get_time_mgr(*comp_id)->get_current_date();
 }
 
@@ -133,7 +133,7 @@ extern "C" void get_ccpl_current_second_
 #endif
 (int *comp_id, int *second, const char *annotation)
 {
-	check_for_component_registered(*comp_id, API_ID_TIME_MGT_GET_CURRENT_SECOND, annotation, false);
+    check_for_component_registered(*comp_id, API_ID_TIME_MGT_GET_CURRENT_SECOND, annotation, false);
     *second = components_time_mgrs->get_time_mgr(*comp_id)->get_current_second();
 }
 
@@ -145,8 +145,8 @@ extern "C" void is_comp_first_step_
 #endif
 (int *comp_id, int *result, const char *annotation)
 {
-	check_for_component_registered(*comp_id, API_ID_TIME_MGT_IS_FIRST_STEP, annotation, false);
-	*result = components_time_mgrs->get_time_mgr(*comp_id)->get_current_num_time_step() == 0? 1 : 0;
+    check_for_component_registered(*comp_id, API_ID_TIME_MGT_IS_FIRST_STEP, annotation, false);
+    *result = components_time_mgrs->get_time_mgr(*comp_id)->get_current_num_time_step() == 0? 1 : 0;
 }
 
 
@@ -157,8 +157,8 @@ extern "C" void is_comp_first_restart_step_
 #endif
 (int *comp_id, int *result, const char *annotation)
 {
-	check_for_component_registered(*comp_id, API_ID_TIME_MGT_IS_FIRST_RESTART_STEP, annotation, false);
-	*result = components_time_mgrs->get_time_mgr(*comp_id)->is_first_restart_step()? 1 : 0;
+    check_for_component_registered(*comp_id, API_ID_TIME_MGT_IS_FIRST_RESTART_STEP, annotation, false);
+    *result = components_time_mgrs->get_time_mgr(*comp_id)->is_first_restart_step()? 1 : 0;
 }
 
 
@@ -169,8 +169,8 @@ extern "C" void get_ccpl_current_number_of_step_
 #endif
 (int *comp_id, int *nstep, const char *annotation)
 {
-	check_for_component_registered(*comp_id, API_ID_TIME_MGT_GET_NUM_CURRENT_STEP, annotation, false);
-	*nstep = components_time_mgrs->get_time_mgr(*comp_id)->get_current_num_time_step();
+    check_for_component_registered(*comp_id, API_ID_TIME_MGT_GET_NUM_CURRENT_STEP, annotation, false);
+    *nstep = components_time_mgrs->get_time_mgr(*comp_id)->get_current_num_time_step();
 }
 
 
@@ -181,8 +181,8 @@ extern "C" void get_ccpl_num_total_step_
 #endif
 (int *comp_id, int *nstep, const char *annotation)
 {
-	check_for_component_registered(*comp_id, API_ID_TIME_MGT_GET_NUM_TOTAL_STEPS, annotation, false);
-	*nstep = (int) components_time_mgrs->get_time_mgr(*comp_id)->get_num_total_step();
+    check_for_component_registered(*comp_id, API_ID_TIME_MGT_GET_NUM_TOTAL_STEPS, annotation, false);
+    *nstep = (int) components_time_mgrs->get_time_mgr(*comp_id)->get_num_total_step();
 }
 
 
@@ -193,7 +193,7 @@ extern "C" void get_ccpl_time_step_
 #endif
 (int *comp_id, int *time_step, const char *annotation)
 {
-	check_for_component_registered(*comp_id, API_ID_TIME_MGT_GET_NORMAL_TIME_STEP, annotation, false);
+    check_for_component_registered(*comp_id, API_ID_TIME_MGT_GET_NORMAL_TIME_STEP, annotation, false);
     *time_step = components_time_mgrs->get_time_mgr(*comp_id)->get_time_step_in_second();
 }
 
@@ -205,12 +205,12 @@ extern "C" void get_ccpl_start_time_
 #endif
 (int *comp_id, int *year, int *month, int *day, int *seconds, const char *annotation)
 {
-	check_for_component_registered(*comp_id, API_ID_TIME_MGT_GET_START_TIME, annotation, false);
+    check_for_component_registered(*comp_id, API_ID_TIME_MGT_GET_START_TIME, annotation, false);
 
-	*year = components_time_mgrs->get_time_mgr(*comp_id)->get_start_full_time() / 1000000000;
-	*month = (components_time_mgrs->get_time_mgr(*comp_id)->get_start_full_time() / 10000000)%100;
-	*day = (components_time_mgrs->get_time_mgr(*comp_id)->get_start_full_time() / 100000)%100;
-	*seconds = components_time_mgrs->get_time_mgr(*comp_id)->get_start_full_time() % 100000;
+    *year = components_time_mgrs->get_time_mgr(*comp_id)->get_start_full_time() / 1000000000;
+    *month = (components_time_mgrs->get_time_mgr(*comp_id)->get_start_full_time() / 10000000)%100;
+    *day = (components_time_mgrs->get_time_mgr(*comp_id)->get_start_full_time() / 100000)%100;
+    *seconds = components_time_mgrs->get_time_mgr(*comp_id)->get_start_full_time() % 100000;
 }
 
 
@@ -221,12 +221,12 @@ extern "C" void get_ccpl_stop_time_
 #endif
 (int *comp_id, int *year, int *month, int *day, int *second, const char *annotation)
 {
-	check_for_component_registered(*comp_id, API_ID_TIME_MGT_GET_STOP_TIME, annotation, false);
+    check_for_component_registered(*comp_id, API_ID_TIME_MGT_GET_STOP_TIME, annotation, false);
 
-	*year = components_time_mgrs->get_time_mgr(*comp_id)->get_stop_year();
-	*month = components_time_mgrs->get_time_mgr(*comp_id)->get_stop_month();
-	*day = components_time_mgrs->get_time_mgr(*comp_id)->get_stop_day();
-	*second = components_time_mgrs->get_time_mgr(*comp_id)->get_stop_second();
+    *year = components_time_mgrs->get_time_mgr(*comp_id)->get_stop_year();
+    *month = components_time_mgrs->get_time_mgr(*comp_id)->get_stop_month();
+    *day = components_time_mgrs->get_time_mgr(*comp_id)->get_stop_day();
+    *second = components_time_mgrs->get_time_mgr(*comp_id)->get_stop_second();
 }
 
 
@@ -237,12 +237,12 @@ extern "C" void get_ccpl_previous_time_
 #endif
 (int *comp_id, int *year, int *month, int *day, int *seconds, const char *annotation)
 {
-	check_for_component_registered(*comp_id, API_ID_TIME_MGT_GET_PREVIOUS_TIME, annotation, false);
+    check_for_component_registered(*comp_id, API_ID_TIME_MGT_GET_PREVIOUS_TIME, annotation, false);
 
-	*year = components_time_mgrs->get_time_mgr(*comp_id)->get_previous_full_time() / 1000000000;
-	*month = (components_time_mgrs->get_time_mgr(*comp_id)->get_previous_full_time() / 10000000)%100;
-	*day = (components_time_mgrs->get_time_mgr(*comp_id)->get_previous_full_time() / 100000)%100;
-	*seconds = components_time_mgrs->get_time_mgr(*comp_id)->get_previous_full_time() % 100000;
+    *year = components_time_mgrs->get_time_mgr(*comp_id)->get_previous_full_time() / 1000000000;
+    *month = (components_time_mgrs->get_time_mgr(*comp_id)->get_previous_full_time() / 10000000)%100;
+    *day = (components_time_mgrs->get_time_mgr(*comp_id)->get_previous_full_time() / 100000)%100;
+    *seconds = components_time_mgrs->get_time_mgr(*comp_id)->get_previous_full_time() % 100000;
 }
 
 
@@ -253,8 +253,8 @@ extern "C" void get_ccpl_current_time_
 #endif
 (int *comp_id, int *year, int *month, int *day, int *second, int *shift_second, const char *annotation)
 {
-	check_for_component_registered(*comp_id, API_ID_TIME_MGT_GET_CURRENT_TIME, annotation, false);
-	components_time_mgrs->get_time_mgr(*comp_id)->get_current_time(*year, *month, *day, *second, *shift_second, annotation);
+    check_for_component_registered(*comp_id, API_ID_TIME_MGT_GET_CURRENT_TIME, annotation, false);
+    components_time_mgrs->get_time_mgr(*comp_id)->get_current_time(*year, *month, *day, *second, *shift_second, annotation);
 }
 
 
@@ -265,8 +265,8 @@ extern "C" void get_ccpl_current_num_days_in_year_
 #endif
 (int *comp_id, int *days, const char *annotation)
 {
-	check_for_component_registered(*comp_id, API_ID_TIME_MGT_GET_CURRENT_NUM_DAYS_IN_YEAR, annotation, false);
-	*days = components_time_mgrs->get_time_mgr(*comp_id)->get_current_num_days_in_year();
+    check_for_component_registered(*comp_id, API_ID_TIME_MGT_GET_CURRENT_NUM_DAYS_IN_YEAR, annotation, false);
+    *days = components_time_mgrs->get_time_mgr(*comp_id)->get_current_num_days_in_year();
 }
 
 
@@ -277,8 +277,8 @@ extern "C" void get_ccpl_current_year_
 #endif
 (int *comp_id, int *year, const char *annotation)
 {
-	check_for_component_registered(*comp_id, API_ID_TIME_MGT_GET_CURRENT_YEAR, annotation, false);
-	*year = components_time_mgrs->get_time_mgr(*comp_id)->get_current_year();
+    check_for_component_registered(*comp_id, API_ID_TIME_MGT_GET_CURRENT_YEAR, annotation, false);
+    *year = components_time_mgrs->get_time_mgr(*comp_id)->get_current_year();
 }
 
 
@@ -289,8 +289,8 @@ extern "C" void get_ccpl_num_elapsed_days_from_start_date_
 #endif
 (int *comp_id, int *days, int *seconds, const char *annotation)
 {
-	check_for_component_registered(*comp_id, API_ID_TIME_MGT_GET_ELAPSED_DAYS_FROM_START, annotation, false);
-	components_time_mgrs->get_time_mgr(*comp_id)->get_elapsed_days_from_start_date(days, seconds);
+    check_for_component_registered(*comp_id, API_ID_TIME_MGT_GET_ELAPSED_DAYS_FROM_START, annotation, false);
+    components_time_mgrs->get_time_mgr(*comp_id)->get_elapsed_days_from_start_date(days, seconds);
 }
 
 
@@ -301,8 +301,8 @@ extern "C" void get_ccpl_num_elapsed_days_from_reference_date_
 #endif
 (int *comp_id, int *days, int *seconds, const char *annotation)
 {
-	check_for_component_registered(*comp_id, API_ID_TIME_MGT_GET_ELAPSED_DAYS_FROM_REF, annotation, false);
-	components_time_mgrs->get_time_mgr(*comp_id)->get_elapsed_days_from_reference_date(days, seconds);
+    check_for_component_registered(*comp_id, API_ID_TIME_MGT_GET_ELAPSED_DAYS_FROM_REF, annotation, false);
+    components_time_mgrs->get_time_mgr(*comp_id)->get_elapsed_days_from_reference_date(days, seconds);
 }
 
 
@@ -324,23 +324,23 @@ extern "C" void initialize_ccpl_mgrs_
 #endif
 ()
 {
-	execution_phase_number = 1;
-	annotation_mgr = new Annotation_mgt();
-	decomps_info_mgr = new Decomp_info_mgt();
-	decomp_grids_mgr = new Decomp_grid_mgt();
-	memory_manager = new Memory_mgt();
-	components_time_mgrs = new Components_time_mgt();
-	timer_mgr = new Timer_mgt();
-	execution_phase_number = 2;
-	inout_interface_mgr = new Inout_interface_mgt();
-	IO_fields_mgr = new IO_field_mgt();
-	components_IO_output_procedures_mgr = new Components_IO_output_procedures_mgt();
-	fields_gather_scatter_mgr = new Fields_gather_scatter_mgt();
-	remapping_configuration_mgr = new Remapping_configuration_mgt();
-	routing_info_mgr = new Routing_info_mgt();
-	runtime_remapping_weights_mgr = new Runtime_remapping_weights_mgt();
-	all_H2D_remapping_wgt_files_info = new H2D_remapping_wgt_file_container();
-	coupling_generator = new Coupling_generator();
+    execution_phase_number = 1;
+    annotation_mgr = new Annotation_mgt();
+    decomps_info_mgr = new Decomp_info_mgt();
+    decomp_grids_mgr = new Decomp_grid_mgt();
+    memory_manager = new Memory_mgt();
+    components_time_mgrs = new Components_time_mgt();
+    timer_mgr = new Timer_mgt();
+    execution_phase_number = 2;
+    inout_interface_mgr = new Inout_interface_mgt();
+    IO_fields_mgr = new IO_field_mgt();
+    components_IO_output_procedures_mgr = new Components_IO_output_procedures_mgt();
+    fields_gather_scatter_mgr = new Fields_gather_scatter_mgt();
+    remapping_configuration_mgr = new Remapping_configuration_mgt();
+    routing_info_mgr = new Routing_info_mgt();
+    runtime_remapping_weights_mgr = new Runtime_remapping_weights_mgt();
+    all_H2D_remapping_wgt_files_info = new H2D_remapping_wgt_file_container();
+    coupling_generator = new Coupling_generator();
 }
 
 
@@ -351,7 +351,7 @@ extern "C" void check_fortran_api_int_type_
 #endif
 (int *fortran_int_size)
 {
-	EXECUTION_REPORT(REPORT_ERROR, -1, *fortran_int_size == 4, "Error happens when using C-Coupler for model coupling: the size of an integer value in C-Coupler FORTRAN APIs is not 4 types. Please verify the compiler flag for C-Coupler and then recompile C-Coupler, to force the usage of 4-byte integer.");
+    EXECUTION_REPORT(REPORT_ERROR, -1, *fortran_int_size == 4, "Error happens when using C-Coupler for model coupling: the size of an integer value in C-Coupler FORTRAN APIs is not 4 types. Please verify the compiler flag for C-Coupler and then recompile C-Coupler, to force the usage of 4-byte integer.");
 }
 
 
@@ -363,79 +363,80 @@ extern "C" void register_root_component_
 (MPI_Fint *f_comm, const char *comp_name, const char *local_comp_type, const char *annotation, int *comp_id, 
 int *enabled_in_parent_coupling_gen, int *change_dir, const char *executable_name)
 {
-	int flag;
-	MPI_Comm local_comm = MPI_COMM_NULL;
-	int root_comp_id;
-	int current_proc_global_id;
-	char file_name[NAME_STR_SIZE];
-	MPI_Comm cpp_comm = MPI_Comm_f2c(*f_comm);
-
-
-	EXECUTION_REPORT_LOG(REPORT_LOG, -1, true, "start to register the root component model");
-
-	check_and_verify_name_format_of_string_for_API(-1, comp_name, API_ID_COMP_MGT_REG_COMP, "the root component", annotation);
-	check_API_parameter_string_length(-1, API_ID_COMP_MGT_REG_COMP, CCPL_NAME_STR_LEN, comp_name, "comp_name", annotation);
-
-	if (comp_comm_group_mgt_mgr != NULL) 
-		EXECUTION_REPORT(REPORT_ERROR, -1, false, "Error happens when registering the root component (\"%s\") at the model code with the annotation \"%s\": the root compnent (\"%s\") has been registered before, at the model code with the annotation \"%s\". Please note that there must be only one root component model at each MPI process", comp_name, annotation, comp_comm_group_mgt_mgr->get_root_component_model()->get_comp_name(), comp_comm_group_mgt_mgr->get_annotation_start());
-	MPI_Initialized(&flag);
-	if (flag == 0) {
-		EXECUTION_REPORT_LOG(REPORT_LOG, -1, true, "Initialize MPI when registerring the root component \"%s\"", comp_name);
-		MPI_Init(NULL, NULL);
-	}
-
-	synchronize_comp_processes_for_API(-1, API_ID_COMP_MGT_REG_COMP, MPI_COMM_WORLD, "registering root component", annotation);
-
-	comp_comm_group_mgt_mgr = new Comp_comm_group_mgt_mgr(executable_name);
-	import_report_setting();
-
-	if (cpp_comm != MPI_COMM_NULL) {
-		EXECUTION_REPORT_LOG(REPORT_LOG, -1, true, "Before MPI_barrier at root component \"%s\" for synchronizing the processes of the component (the corresponding model code annotation is \"%s\").", comp_name, annotation);
-		EXECUTION_REPORT(REPORT_ERROR,-1, MPI_Barrier(cpp_comm) == MPI_SUCCESS);
-		EXECUTION_REPORT_LOG(REPORT_LOG, -1, true, "After MPI_barrier at root component \"%s\" for synchronizing the processes of the component (the corresponding model code annotation is \"%s\").", comp_name, annotation);
-		
-	}
-
-	original_grid_mgr = new Original_grid_mgt();
-	root_comp_id = comp_comm_group_mgt_mgr->register_component(comp_name, local_comp_type, local_comm, -1, (*enabled_in_parent_coupling_gen) == 1, *change_dir, annotation);
-
-	if (cpp_comm != MPI_COMM_NULL) {
-		int input_comm_size, new_comm_size;
-		int *input_comm_process_ids, *new_comm_process_ids, *temp_array;
-		int current_proc_global_id, current_proc_local_id;
-		MPI_Comm new_comm;
-		EXECUTION_REPORT(REPORT_ERROR,-1, MPI_Comm_size(cpp_comm, &input_comm_size) == MPI_SUCCESS);
-		new_comm = comp_comm_group_mgt_mgr->get_comm_group_of_local_comp(root_comp_id, "C-Coupler code in register_root_component for getting component management node");
-		EXECUTION_REPORT(REPORT_ERROR,-1, MPI_Comm_size(new_comm, &new_comm_size) == MPI_SUCCESS);
-		EXECUTION_REPORT(REPORT_ERROR,-1, input_comm_size == new_comm_size);  // add debug information
-		EXECUTION_REPORT(REPORT_ERROR,-1, MPI_Comm_rank(MPI_COMM_WORLD, &current_proc_global_id) == MPI_SUCCESS);
-		input_comm_process_ids = new int [input_comm_size];
-		new_comm_process_ids = new int [new_comm_size];
-		temp_array = new int [new_comm_size];
-		EXECUTION_REPORT(REPORT_ERROR,-1, MPI_Allgather(&current_proc_global_id, 1, MPI_INT, input_comm_process_ids, 1, MPI_INT, cpp_comm) == MPI_SUCCESS);
-		EXECUTION_REPORT(REPORT_ERROR,-1, MPI_Allgather(&current_proc_global_id, 1, MPI_INT, new_comm_process_ids, 1, MPI_INT, new_comm) == MPI_SUCCESS);
-		do_quick_sort(input_comm_process_ids, temp_array, 0, input_comm_size-1);
-		do_quick_sort(new_comm_process_ids, temp_array, 0, new_comm_size-1);
-		for (int i = 0; i < input_comm_size; i ++)
-			EXECUTION_REPORT(REPORT_ERROR,-1, input_comm_process_ids[i] == new_comm_process_ids[i], 
-			                 "The communicator of root component model \"%s\" does not match the communicator generated (processes of the two communicators are not the same). Please check the model code with the annotation \"%s\"",
-			                 comp_name, annotation);
-		delete [] input_comm_process_ids;
-		delete [] new_comm_process_ids;
-		delete [] temp_array;
-	}
-	else *f_comm = MPI_Comm_c2f(local_comm);
-
-	*comp_id = root_comp_id;
-
-	sprintf(file_name, "%s/all/env_run.xml", comp_comm_group_mgt_mgr->get_config_root_dir());
-	components_time_mgrs->define_root_comp_time_mgr(root_comp_id, file_name);
-	fields_info = new Field_info_mgt();
-	remapping_configuration_mgr->add_remapping_configuration(comp_comm_group_mgt_mgr->get_global_node_root()->get_comp_id());
-	if (comp_comm_group_mgt_mgr->get_global_node_of_local_comp(root_comp_id, true, "")->is_real_component_model())
-		remapping_configuration_mgr->add_remapping_configuration(root_comp_id);
-
-	EXECUTION_REPORT_LOG(REPORT_LOG, -1, true, "Finish registering the root component model");
+    int flag;
+    MPI_Comm local_comm = MPI_COMM_NULL;
+    int root_comp_id;
+    int current_proc_global_id;
+    char file_name[NAME_STR_SIZE];
+    MPI_Comm cpp_comm;
+
+
+    EXECUTION_REPORT_LOG(REPORT_LOG, -1, true, "start to register the root component model");
+
+    check_and_verify_name_format_of_string_for_API(-1, comp_name, API_ID_COMP_MGT_REG_COMP, "the root component", annotation);
+    check_API_parameter_string_length(-1, API_ID_COMP_MGT_REG_COMP, CCPL_NAME_STR_LEN, comp_name, "comp_name", annotation);
+
+    if (comp_comm_group_mgt_mgr != NULL) 
+        EXECUTION_REPORT(REPORT_ERROR, -1, false, "Error happens when registering the root component (\"%s\") at the model code with the annotation \"%s\": the root compnent (\"%s\") has been registered before, at the model code with the annotation \"%s\". Please note that there must be only one root component model at each MPI process", comp_name, annotation, comp_comm_group_mgt_mgr->get_root_component_model()->get_comp_name(), comp_comm_group_mgt_mgr->get_annotation_start());
+    MPI_Initialized(&flag);
+    if (flag == 0) {
+        EXECUTION_REPORT_LOG(REPORT_LOG, -1, true, "Initialize MPI when registering the root component \"%s\"", comp_name);
+        MPI_Init(NULL, NULL);
+    }
+
+    synchronize_comp_processes_for_API(-1, API_ID_COMP_MGT_REG_COMP, MPI_COMM_WORLD, "registering root component", annotation);
+
+    comp_comm_group_mgt_mgr = new Comp_comm_group_mgt_mgr(executable_name);
+    import_report_setting();
+	
+	cpp_comm = MPI_Comm_f2c(*f_comm);
+    if (cpp_comm != MPI_COMM_NULL) {
+        EXECUTION_REPORT_LOG(REPORT_LOG, -1, true, "Before MPI_barrier at root component \"%s\" for synchronizing the processes of the component (the corresponding model code annotation is \"%s\").", comp_name, annotation);
+        EXECUTION_REPORT(REPORT_ERROR,-1, MPI_Barrier(cpp_comm) == MPI_SUCCESS);
+        EXECUTION_REPORT_LOG(REPORT_LOG, -1, true, "After MPI_barrier at root component \"%s\" for synchronizing the processes of the component (the corresponding model code annotation is \"%s\").", comp_name, annotation);
+        
+    }
+
+    original_grid_mgr = new Original_grid_mgt();
+    root_comp_id = comp_comm_group_mgt_mgr->register_component(comp_name, local_comp_type, local_comm, -1, (*enabled_in_parent_coupling_gen) == 1, *change_dir, annotation);
+
+    if (cpp_comm != MPI_COMM_NULL) {
+        int input_comm_size, new_comm_size;
+        int *input_comm_process_ids, *new_comm_process_ids, *temp_array;
+        int current_proc_global_id, current_proc_local_id;
+        MPI_Comm new_comm;
+        EXECUTION_REPORT(REPORT_ERROR,-1, MPI_Comm_size(cpp_comm, &input_comm_size) == MPI_SUCCESS);
+        new_comm = comp_comm_group_mgt_mgr->get_comm_group_of_local_comp(root_comp_id, "C-Coupler code in register_root_component for getting component management node");
+        EXECUTION_REPORT(REPORT_ERROR,-1, MPI_Comm_size(new_comm, &new_comm_size) == MPI_SUCCESS);
+        EXECUTION_REPORT(REPORT_ERROR,-1, input_comm_size == new_comm_size, "Error happens when calling the API \"CCPL_register_component\" to register the root component model \"%s\": its input communicator does not match the communicator generated (the number of processes of the two communicators are different (%d VS %d)). Please check the model code with the annotation \"%s\"", comp_name, input_comm_size, new_comm_size, annotation);
+        EXECUTION_REPORT(REPORT_ERROR,-1, MPI_Comm_rank(MPI_COMM_WORLD, &current_proc_global_id) == MPI_SUCCESS);
+        input_comm_process_ids = new int [input_comm_size];
+        new_comm_process_ids = new int [new_comm_size];
+        temp_array = new int [new_comm_size];
+        EXECUTION_REPORT(REPORT_ERROR,-1, MPI_Allgather(&current_proc_global_id, 1, MPI_INT, input_comm_process_ids, 1, MPI_INT, cpp_comm) == MPI_SUCCESS);
+        EXECUTION_REPORT(REPORT_ERROR,-1, MPI_Allgather(&current_proc_global_id, 1, MPI_INT, new_comm_process_ids, 1, MPI_INT, new_comm) == MPI_SUCCESS);
+        do_quick_sort(input_comm_process_ids, temp_array, 0, input_comm_size-1);
+        do_quick_sort(new_comm_process_ids, temp_array, 0, new_comm_size-1);
+        for (int i = 0; i < input_comm_size; i ++)
+            EXECUTION_REPORT(REPORT_ERROR,-1, input_comm_process_ids[i] == new_comm_process_ids[i], 
+                             "Error happens when calling the API \"CCPL_register_component\" to register the root component model \"%s\": its input communicator does not match the communicator generated (processes of the two communicators are not the same). Please check the model code with the annotation \"%s\"",
+                             comp_name, annotation);
+        delete [] input_comm_process_ids;
+        delete [] new_comm_process_ids;
+        delete [] temp_array;
+    }
+    else *f_comm = MPI_Comm_c2f(local_comm);
+
+    *comp_id = root_comp_id;
+
+    sprintf(file_name, "%s/all/env_run.xml", comp_comm_group_mgt_mgr->get_config_root_dir());
+    components_time_mgrs->define_root_comp_time_mgr(root_comp_id, file_name);
+    fields_info = new Field_info_mgt();
+    remapping_configuration_mgr->add_remapping_configuration(comp_comm_group_mgt_mgr->get_global_node_root()->get_comp_id());
+    if (comp_comm_group_mgt_mgr->get_global_node_of_local_comp(root_comp_id, true, "")->is_real_component_model())
+        remapping_configuration_mgr->add_remapping_configuration(root_comp_id);
+
+    EXECUTION_REPORT_LOG(REPORT_LOG, -1, true, "Finish registering the root component model");
 }
 
 
@@ -446,30 +447,30 @@ extern "C" void register_component_
 #endif
 (int *parent_comp_id, const char *comp_name, const char *local_comp_type, MPI_Fint *f_comm, const char *annotation, int *enabled_in_parent_coupling_gen, int *change_dir, int *comp_id)
 {
-	MPI_Comm cpp_comm = MPI_Comm_f2c(*f_comm);
+    MPI_Comm cpp_comm = MPI_Comm_f2c(*f_comm);
 
 
-	EXECUTION_REPORT_LOG(REPORT_LOG, -1, true, "start to register component model \%s\"", comp_name);
+    EXECUTION_REPORT_LOG(REPORT_LOG, -1, true, "start to register component model \%s\"", comp_name);
 
-	check_and_verify_name_format_of_string_for_API(-1, comp_name, API_ID_COMP_MGT_REG_COMP, "the new component", annotation);
-	EXECUTION_REPORT(REPORT_ERROR, -1, comp_comm_group_mgt_mgr->is_legal_local_comp_id(*parent_comp_id, true), "Error happens when calling the API \"CCPL_register_component\" to register a component model \"%s\": The parameter of \"parent_id\" (currently is 0x%x) is wrong (not the legal ID of a component). Please check the model code with the annotation \"%s\"", comp_name, *parent_comp_id, annotation);
-	check_for_coupling_registration_stage(*parent_comp_id, API_ID_COMP_MGT_REG_COMP, false, annotation);
-	check_API_parameter_string_length(*parent_comp_id, API_ID_COMP_MGT_REG_COMP, CCPL_NAME_STR_LEN, comp_name, "comp_name", annotation);
+    check_and_verify_name_format_of_string_for_API(-1, comp_name, API_ID_COMP_MGT_REG_COMP, "the new component", annotation);
+    EXECUTION_REPORT(REPORT_ERROR, -1, comp_comm_group_mgt_mgr->is_legal_local_comp_id(*parent_comp_id, true), "Error happens when calling the API \"CCPL_register_component\" to register a component model \"%s\": The parameter of \"parent_id\" (currently is 0x%x) is wrong (not the legal ID of a component). Please check the model code with the annotation \"%s\"", comp_name, *parent_comp_id, annotation);
+    check_for_coupling_registration_stage(*parent_comp_id, API_ID_COMP_MGT_REG_COMP, false, annotation);
+    check_API_parameter_string_length(*parent_comp_id, API_ID_COMP_MGT_REG_COMP, CCPL_NAME_STR_LEN, comp_name, "comp_name", annotation);
 
-	if (cpp_comm != MPI_COMM_NULL) {
-		synchronize_comp_processes_for_API(*parent_comp_id, API_ID_COMP_MGT_REG_COMP, cpp_comm, "registering a component based on the parent component", annotation);
-		check_API_parameter_string(*parent_comp_id, API_ID_COMP_MGT_REG_COMP, cpp_comm, "registering a component based on an available communicator", comp_name, "comp_name", annotation);
-	}
-	else synchronize_comp_processes_for_API(*parent_comp_id, API_ID_COMP_MGT_REG_COMP, comp_comm_group_mgt_mgr->get_comm_group_of_local_comp(*parent_comp_id, "C-Coupler code for get comm group in register_component interface"), "registering component based on the parent component", annotation);
+    if (cpp_comm != MPI_COMM_NULL) {
+        synchronize_comp_processes_for_API(*parent_comp_id, API_ID_COMP_MGT_REG_COMP, cpp_comm, "registering a component based on the parent component", annotation);
+        check_API_parameter_string(*parent_comp_id, API_ID_COMP_MGT_REG_COMP, cpp_comm, "registering a component based on an available communicator", comp_name, "comp_name", annotation);
+    }
+    else synchronize_comp_processes_for_API(*parent_comp_id, API_ID_COMP_MGT_REG_COMP, comp_comm_group_mgt_mgr->get_comm_group_of_local_comp(*parent_comp_id, "C-Coupler code for get comm group in register_component interface"), "registering component based on the parent component", annotation);
 
-	*comp_id = comp_comm_group_mgt_mgr->register_component(comp_name, local_comp_type, cpp_comm, *parent_comp_id, (*enabled_in_parent_coupling_gen) == 1, *change_dir, annotation);
-	if (comp_comm_group_mgt_mgr->get_global_node_of_local_comp(*comp_id,true,"")->is_real_component_model())
-		remapping_configuration_mgr->add_remapping_configuration(*comp_id);
-	components_time_mgrs->clone_parent_comp_time_mgr(*comp_id, *parent_comp_id, annotation);
+    *comp_id = comp_comm_group_mgt_mgr->register_component(comp_name, local_comp_type, cpp_comm, *parent_comp_id, (*enabled_in_parent_coupling_gen) == 1, *change_dir, annotation);
+    if (comp_comm_group_mgt_mgr->get_global_node_of_local_comp(*comp_id,true,"")->is_real_component_model())
+        remapping_configuration_mgr->add_remapping_configuration(*comp_id);
+    components_time_mgrs->clone_parent_comp_time_mgr(*comp_id, *parent_comp_id, annotation);
 
-	*f_comm = MPI_Comm_c2f(cpp_comm);
+    *f_comm = MPI_Comm_c2f(cpp_comm);
 
-	EXECUTION_REPORT_LOG(REPORT_LOG, -1, true, "Finish registering component model \%s\"", comp_comm_group_mgt_mgr->get_global_node_of_local_comp(*comp_id,true,"")->get_full_name());
+    EXECUTION_REPORT_LOG(REPORT_LOG, -1, true, "Finish registering component model \%s\"", comp_comm_group_mgt_mgr->get_global_node_of_local_comp(*comp_id,true,"")->get_full_name());
 }
 
 
@@ -480,15 +481,15 @@ extern "C" void get_ccpl_comp_log_file_name_
 #endif
 (int *comp_id, char *file_name, int *size_file_name, int *log_file_opened, const char *annotation)
 {
-	int log_file_device_id;
+    int log_file_device_id;
 
-	
-	check_for_component_registered(*comp_id, API_ID_COMP_MGT_GET_COMP_LOG_FILE_NAME, annotation, true);
-	const char *log_file_name = comp_comm_group_mgt_mgr->get_comp_model_log_file(*comp_id, log_file_device_id);
-	if (log_file_device_id == -1)
-		*log_file_opened = 0;
-	else *log_file_opened = 1;
-	copy_out_string_to_Fortran_API(*comp_id, *size_file_name, file_name, log_file_name, API_ID_COMP_MGT_GET_COMP_LOG_FILE_NAME, "file_name", annotation);
+    
+    check_for_component_registered(*comp_id, API_ID_COMP_MGT_GET_COMP_LOG_FILE_NAME, annotation, true);
+    const char *log_file_name = comp_comm_group_mgt_mgr->get_comp_model_log_file(*comp_id, log_file_device_id);
+    if (log_file_device_id == -1)
+        *log_file_opened = 0;
+    else *log_file_opened = 1;
+    copy_out_string_to_Fortran_API(*comp_id, *size_file_name, file_name, log_file_name, API_ID_COMP_MGT_GET_COMP_LOG_FILE_NAME, "file_name", annotation);
 }
 
 
@@ -499,8 +500,8 @@ extern "C" void get_ccpl_comp_log_file_device_
 #endif
 (int *comp_id, int *log_file_device_id, int *log_file_opened, const char *annotation)
 {
-	check_for_component_registered(*comp_id, API_ID_COMP_MGT_GET_COMP_LOG_FILE_DEVICE, annotation, true);
-	*log_file_opened = comp_comm_group_mgt_mgr->get_global_node_of_local_comp(*comp_id, true, "get_ccpl_comp_log_file_device_")->open_comp_model_log_file(log_file_device_id);
+    check_for_component_registered(*comp_id, API_ID_COMP_MGT_GET_COMP_LOG_FILE_DEVICE, annotation, true);
+    *log_file_opened = comp_comm_group_mgt_mgr->get_global_node_of_local_comp(*comp_id, true, "get_ccpl_comp_log_file_device_")->open_comp_model_log_file(log_file_device_id);
 }
 
 
@@ -511,19 +512,19 @@ extern "C" void get_id_of_component_
 #endif
 (const char *comp_name, const char *annotation, int *comp_id)
 {
-	check_and_verify_name_format_of_string_for_API(-1, comp_name, API_ID_COMP_MGT_GET_COMP_ID, "the component", annotation);
-	check_for_component_registered(-1, API_ID_COMP_MGT_GET_COMP_ID, annotation, true);
-	check_API_parameter_string_length(-1, API_ID_COMP_MGT_GET_COMP_ID, CCPL_NAME_STR_LEN, comp_name, "comp_name", annotation);
+    check_and_verify_name_format_of_string_for_API(-1, comp_name, API_ID_COMP_MGT_GET_COMP_ID, "the component", annotation);
+    check_for_component_registered(-1, API_ID_COMP_MGT_GET_COMP_ID, annotation, true);
+    check_API_parameter_string_length(-1, API_ID_COMP_MGT_GET_COMP_ID, CCPL_NAME_STR_LEN, comp_name, "comp_name", annotation);
 
-	Comp_comm_group_mgt_node *node = comp_comm_group_mgt_mgr->search_comp_with_comp_name(comp_name);
-	if (comp_comm_group_mgt_mgr->does_comp_name_include_reserved_prefix(comp_name))
-		node = NULL;
+    Comp_comm_group_mgt_node *node = comp_comm_group_mgt_mgr->search_comp_with_comp_name(comp_name);
+    if (comp_comm_group_mgt_mgr->does_comp_name_include_reserved_prefix(comp_name))
+        node = NULL;
 
-	if (node == NULL) {
-		EXECUTION_REPORT(REPORT_ERROR, -1, false, "Error happens when calling the API \"CCPL_get_component_id\" to get the ID of a component model: no component model with the name of \"%s\" has been registerred. Please check the model code at the annotation \"%s\"", comp_name, annotation);
-		*comp_id = -1;
-	}
-	else *comp_id = node->get_local_node_id();	
+    if (node == NULL) {
+        EXECUTION_REPORT(REPORT_ERROR, -1, false, "Error happens when calling the API \"CCPL_get_component_id\" to get the ID of a component model: no component model with the name of \"%s\" has been registered. Please check the model code at the annotation \"%s\"", comp_name, annotation);
+        *comp_id = -1;
+    }
+    else *comp_id = node->get_local_node_id();    
 }
 
 
@@ -534,12 +535,12 @@ extern "C" void check_is_comp_type_coupled_
 #endif
 (int *comp_id, const char *comp_type, int *is_coupled, const char *annotation)
 {
-	check_for_component_registered(*comp_id, API_ID_COMP_MGT_IS_COMP_TYPE_COUPLED, annotation, true);
-	synchronize_comp_processes_for_API(*comp_id, API_ID_COMP_MGT_IS_COMP_TYPE_COUPLED, comp_comm_group_mgt_mgr->get_comm_group_of_local_comp(*comp_id, "check_is_comp_type_coupled_"), "synchorization for checking whether a type of component models is coupled", annotation);
-	check_API_parameter_string(*comp_id, API_ID_COMP_MGT_IS_COMP_TYPE_COUPLED, comp_comm_group_mgt_mgr->get_comm_group_of_local_comp(*comp_id, "check_is_comp_type_coupled_"), "checking whether a type of component models have been registered to C-Coupler", comp_type, "comp_type", annotation);
-	if (comp_comm_group_mgt_mgr->is_comp_type_coupled(*comp_id, comp_type, annotation))
-		*is_coupled = 1; 
-	else *is_coupled = 0;
+    check_for_component_registered(*comp_id, API_ID_COMP_MGT_IS_COMP_TYPE_COUPLED, annotation, true);
+    synchronize_comp_processes_for_API(*comp_id, API_ID_COMP_MGT_IS_COMP_TYPE_COUPLED, comp_comm_group_mgt_mgr->get_comm_group_of_local_comp(*comp_id, "check_is_comp_type_coupled_"), "synchorization for checking whether a type of component models is coupled", annotation);
+    check_API_parameter_string(*comp_id, API_ID_COMP_MGT_IS_COMP_TYPE_COUPLED, comp_comm_group_mgt_mgr->get_comm_group_of_local_comp(*comp_id, "check_is_comp_type_coupled_"), "checking whether a type of component models have been registered to C-Coupler", comp_type, "comp_type", annotation);
+    if (comp_comm_group_mgt_mgr->is_comp_type_coupled(*comp_id, comp_type, annotation))
+        *is_coupled = 1; 
+    else *is_coupled = 0;
 }
 
 
@@ -550,12 +551,12 @@ extern "C" void is_current_process_in_component_
 #endif
 (const char *comp_full_name, int *is_in_comp, const char *annotation)
 {
-	check_for_component_registered(-1, API_ID_COMP_MGT_IS_CURRENT_PROC_IN_COMP, annotation, true);
-	check_API_parameter_string_length(-1, API_ID_COMP_MGT_IS_CURRENT_PROC_IN_COMP, 512, comp_full_name, "comp_full_name", annotation);
-	Comp_comm_group_mgt_node *comp_node = comp_comm_group_mgt_mgr->search_global_node(comp_full_name);
-	if (comp_node != NULL && comp_comm_group_mgt_mgr->does_comp_name_include_reserved_prefix(comp_node->get_comp_name()))
-		comp_node = NULL;
-	*is_in_comp = comp_node != NULL && comp_node->get_current_proc_local_id() != -1? 1 : 0;
+    check_for_component_registered(-1, API_ID_COMP_MGT_IS_CURRENT_PROC_IN_COMP, annotation, true);
+    check_API_parameter_string_length(-1, API_ID_COMP_MGT_IS_CURRENT_PROC_IN_COMP, 512, comp_full_name, "comp_full_name", annotation);
+    Comp_comm_group_mgt_node *comp_node = comp_comm_group_mgt_mgr->search_global_node(comp_full_name);
+    if (comp_node != NULL && comp_comm_group_mgt_mgr->does_comp_name_include_reserved_prefix(comp_node->get_comp_name()))
+        comp_node = NULL;
+    *is_in_comp = comp_node != NULL && comp_node->get_current_proc_local_id() != -1? 1 : 0;
 }
 
 
@@ -566,8 +567,8 @@ extern "C" void get_current_proc_id_in_comp_
 #endif
 (int *comp_id, int *proc_id, const char * annotation)
 {
-	check_for_component_registered(*comp_id, API_ID_COMP_MGT_GET_CURRENT_PROC_ID_IN_COMP, annotation, false);
-	*proc_id = comp_comm_group_mgt_mgr->get_current_proc_id_in_comp(*comp_id, annotation);
+    check_for_component_registered(*comp_id, API_ID_COMP_MGT_GET_CURRENT_PROC_ID_IN_COMP, annotation, false);
+    *proc_id = comp_comm_group_mgt_mgr->get_current_proc_id_in_comp(*comp_id, annotation);
 }
 
 
@@ -578,8 +579,8 @@ extern "C" void get_num_proc_in_comp_
 #endif
 (int *comp_id, int *num_proc, const char * annotation)
 {
-	check_for_component_registered(*comp_id, API_ID_COMP_MGT_GET_NUM_PROC_IN_COMP, annotation, false);
-	*num_proc = comp_comm_group_mgt_mgr->get_num_proc_in_comp(*comp_id, annotation);
+    check_for_component_registered(*comp_id, API_ID_COMP_MGT_GET_NUM_PROC_IN_COMP, annotation, false);
+    *num_proc = comp_comm_group_mgt_mgr->get_num_proc_in_comp(*comp_id, annotation);
 }
 
 
@@ -590,10 +591,10 @@ extern "C" void get_comp_proc_global_id_
 #endif
 (int *comp_id, int *local_proc_id, int *global_proc_id, const char *annotation)
 {
-	check_for_component_registered(*comp_id, API_ID_COMP_MGT_GET_COMP_PROC_GLOBAL_ID, annotation, false);
-	int num_proc = comp_comm_group_mgt_mgr->get_num_proc_in_comp(*comp_id, annotation);
-	EXECUTION_REPORT(REPORT_ERROR, *comp_id, *local_proc_id >= 0 && *local_proc_id < num_proc, "Error happens when calling the API \"CCPL_get_component_process_global_id\": the parameter \"local_proc_id\" is wrong (its value (%d) is not between 0 and %d (maximum local process ID)). Please verify the model code corresponding to the annotation \"%s\"", *local_proc_id, num_proc-1, annotation);
-	*global_proc_id = comp_comm_group_mgt_mgr->search_global_node(*comp_id)->get_local_proc_global_id(*local_proc_id);
+    check_for_component_registered(*comp_id, API_ID_COMP_MGT_GET_COMP_PROC_GLOBAL_ID, annotation, false);
+    int num_proc = comp_comm_group_mgt_mgr->get_num_proc_in_comp(*comp_id, annotation);
+    EXECUTION_REPORT(REPORT_ERROR, *comp_id, *local_proc_id >= 0 && *local_proc_id < num_proc, "Error happens when calling the API \"CCPL_get_component_process_global_id\": the parameter \"local_proc_id\" is wrong (its value (%d) is not between 0 and %d (maximum local process ID)). Please verify the model code corresponding to the annotation \"%s\"", *local_proc_id, num_proc-1, annotation);
+    *global_proc_id = comp_comm_group_mgt_mgr->search_global_node(*comp_id)->get_local_proc_global_id(*local_proc_id);
 }
 
 
@@ -604,12 +605,12 @@ extern "C" void ccpl_load_comps_full_names_from_config_file_
 #endif
 (int *comp_id, const char *keyword, int *size_comps_full_names, int *size_individual_or_family, int *num_comps, const char *annotation)
 {
-	check_for_component_registered(*comp_id, API_ID_COUPLING_GEN_GET_COMPS, annotation, false);
-	EXECUTION_REPORT_LOG(REPORT_LOG, *comp_id, true, "start to the full names of a set of component models from the corresponding configuration file.");
-	synchronize_comp_processes_for_API(*comp_id, API_ID_COUPLING_GEN_GET_COMPS, comp_comm_group_mgt_mgr->get_comm_group_of_local_comp(*comp_id, "ccpl_load_omps_full_names_from_config_file_"), "first synchorization for getting the full names of a set of component models", annotation);
-	check_API_parameter_string_length(*comp_id, API_ID_COUPLING_GEN_GET_COMPS, CCPL_NAME_STR_LEN, keyword, "keyword", annotation);
-	coupling_generator->load_comps_full_names_from_config_file(*comp_id, keyword, *size_comps_full_names, *size_individual_or_family, num_comps, annotation);
-	EXECUTION_REPORT_LOG(REPORT_LOG, *comp_id, true, "finish ccpl_load_comps_full_names_from_config_file");
+    check_for_component_registered(*comp_id, API_ID_COUPLING_GEN_GET_COMPS, annotation, false);
+    EXECUTION_REPORT_LOG(REPORT_LOG, *comp_id, true, "start to the full names of a set of component models from the corresponding configuration file.");
+    synchronize_comp_processes_for_API(*comp_id, API_ID_COUPLING_GEN_GET_COMPS, comp_comm_group_mgt_mgr->get_comm_group_of_local_comp(*comp_id, "ccpl_load_omps_full_names_from_config_file_"), "first synchorization for getting the full names of a set of component models", annotation);
+    check_API_parameter_string_length(*comp_id, API_ID_COUPLING_GEN_GET_COMPS, CCPL_NAME_STR_LEN, keyword, "keyword", annotation);
+    coupling_generator->load_comps_full_names_from_config_file(*comp_id, keyword, *size_comps_full_names, *size_individual_or_family, num_comps, annotation);
+    EXECUTION_REPORT_LOG(REPORT_LOG, *comp_id, true, "finish ccpl_load_comps_full_names_from_config_file");
 }
 
 
@@ -620,9 +621,9 @@ extern "C" void ccpl_get_one_comp_full_name_
 #endif
 (int *comp_id, const char *keyword, int *str_size, int *index, char *comp_full_name, int *local_individual_or_family, const char *annotation)
 {
-	EXECUTION_REPORT_LOG(REPORT_LOG, *comp_id, true, "At the beginning of cpl_get_one_comp_full_name_");
-	coupling_generator->get_one_comp_full_name(*comp_id, keyword, *str_size, *index-1, comp_full_name, local_individual_or_family , annotation);
-	EXECUTION_REPORT_LOG(REPORT_LOG, *comp_id, true, "At the end of cpl_get_one_comp_full_name_");
+    EXECUTION_REPORT_LOG(REPORT_LOG, *comp_id, true, "At the beginning of cpl_get_one_comp_full_name_");
+    coupling_generator->get_one_comp_full_name(*comp_id, keyword, *str_size, *index-1, comp_full_name, local_individual_or_family , annotation);
+    EXECUTION_REPORT_LOG(REPORT_LOG, *comp_id, true, "At the end of cpl_get_one_comp_full_name_");
 }
 
 
@@ -633,9 +634,9 @@ extern "C" void ccpl_finish_getting_configurable_comps_full_names_
 #endif
 (int *comp_id, const char *annotation)
 {
-	EXECUTION_REPORT_LOG(REPORT_LOG, *comp_id, true, "At the beginning of ccpl_finish_getting_configurable_comps_full_names_");
-	coupling_generator->clear();
-	EXECUTION_REPORT_LOG(REPORT_LOG, *comp_id, true, "At the end of ccpl_finish_getting_configurable_comps_full_names_");
+    EXECUTION_REPORT_LOG(REPORT_LOG, *comp_id, true, "At the beginning of ccpl_finish_getting_configurable_comps_full_names_");
+    coupling_generator->clear();
+    EXECUTION_REPORT_LOG(REPORT_LOG, *comp_id, true, "At the end of ccpl_finish_getting_configurable_comps_full_names_");
 }
 
 
@@ -646,11 +647,11 @@ extern "C" void ccpl_family_coupling_generation_
 #endif
 (int *comp_id, const char * annotation)
 {
-	check_for_component_registered(*comp_id, API_ID_COUPLING_GEN_FAMILY, annotation, false);
-	EXECUTION_REPORT_LOG(REPORT_LOG, *comp_id, true, "start to generate coupling procedures for the component model \"%s\" and its descendants", comp_comm_group_mgt_mgr->get_global_node_of_local_comp(*comp_id,true,"")->get_full_name());
-	synchronize_comp_processes_for_API(*comp_id, API_ID_COUPLING_GEN_FAMILY, comp_comm_group_mgt_mgr->get_comm_group_of_local_comp(*comp_id, "C-Coupler code in ccpl_family_coupling_generation_"), "first synchorization for coupling generation of a component", annotation);	
-	coupling_generator->generate_coupling_procedures_internal(*comp_id, true, annotation);
-	EXECUTION_REPORT_LOG(REPORT_LOG, *comp_id, true, "Finish generating coupling procedures for the component model \"%s\" and its descendants", comp_comm_group_mgt_mgr->get_global_node_of_local_comp(*comp_id,true,"")->get_full_name());
+    check_for_component_registered(*comp_id, API_ID_COUPLING_GEN_FAMILY, annotation, false);
+    EXECUTION_REPORT_LOG(REPORT_LOG, *comp_id, true, "start to generate coupling procedures for the component model \"%s\" and its descendants", comp_comm_group_mgt_mgr->get_global_node_of_local_comp(*comp_id,true,"")->get_full_name());
+    synchronize_comp_processes_for_API(*comp_id, API_ID_COUPLING_GEN_FAMILY, comp_comm_group_mgt_mgr->get_comm_group_of_local_comp(*comp_id, "C-Coupler code in ccpl_family_coupling_generation_"), "first synchorization for coupling generation of a component", annotation);    
+    coupling_generator->generate_coupling_procedures_internal(*comp_id, true, false, annotation);
+    EXECUTION_REPORT_LOG(REPORT_LOG, *comp_id, true, "Finish generating coupling procedures for the component model \"%s\" and its descendants", comp_comm_group_mgt_mgr->get_global_node_of_local_comp(*comp_id,true,"")->get_full_name());
 }
 
 
@@ -661,11 +662,11 @@ extern "C" void ccpl_individual_coupling_generation_
 #endif
 (int *comp_id, const char * annotation)
 {
-	check_for_component_registered(*comp_id, API_ID_COUPLING_GEN_INDIVIDUAL, annotation, false);
-	EXECUTION_REPORT_LOG(REPORT_LOG, *comp_id, true, "start to generate coupling procedures for the component model \"%s\"", comp_comm_group_mgt_mgr->get_global_node_of_local_comp(*comp_id,true,"")->get_full_name());
-	synchronize_comp_processes_for_API(*comp_id, API_ID_COUPLING_GEN_INDIVIDUAL, comp_comm_group_mgt_mgr->get_comm_group_of_local_comp(*comp_id, "C-Coupler code in ccpl_individual_coupling_generation_"), "first synchorization for coupling generation of a component", annotation);	
-	coupling_generator->generate_coupling_procedures_internal(*comp_id, false, annotation);
-	EXECUTION_REPORT_LOG(REPORT_LOG, *comp_id, true, "Finish generating coupling procedures for the component model \"%s\" and its descendants", comp_comm_group_mgt_mgr->get_global_node_of_local_comp(*comp_id,true,"")->get_full_name());
+    check_for_component_registered(*comp_id, API_ID_COUPLING_GEN_INDIVIDUAL, annotation, false);
+    EXECUTION_REPORT_LOG(REPORT_LOG, *comp_id, true, "start to generate coupling procedures for the component model \"%s\"", comp_comm_group_mgt_mgr->get_global_node_of_local_comp(*comp_id,true,"")->get_full_name());
+    synchronize_comp_processes_for_API(*comp_id, API_ID_COUPLING_GEN_INDIVIDUAL, comp_comm_group_mgt_mgr->get_comm_group_of_local_comp(*comp_id, "C-Coupler code in ccpl_individual_coupling_generation_"), "first synchorization for coupling generation of a component", annotation);    
+    coupling_generator->generate_coupling_procedures_internal(*comp_id, false, true, annotation);
+    EXECUTION_REPORT_LOG(REPORT_LOG, *comp_id, true, "Finish generating coupling procedures for the component model \"%s\" and its descendants", comp_comm_group_mgt_mgr->get_global_node_of_local_comp(*comp_id,true,"")->get_full_name());
 }
 
 
@@ -676,12 +677,12 @@ extern "C" void ccpl_begin_external_coupling_generation_
 #endif
 (int *num_comps, int *size_comps_full_names, int *size_individual_or_family, const char *annotation)
 {
-	EXECUTION_REPORT_LOG(REPORT_LOG, -1, true, "start to generate coupling procedures for a set of specified component model");
-	EXECUTION_REPORT(REPORT_ERROR, -1, *num_comps >= 1, "ERROR happens when calling the API \"CCPL_do_external_coupling_generation\": the value of \"num_comps\" cannot be smaller than 1. Please verify the model code with the annotation \"%s\"", annotation);
-	EXECUTION_REPORT(REPORT_ERROR, -1, *num_comps <= *size_comps_full_names, "ERROR happens when calling the API \"CCPL_do_external_coupling_generation\": the value of \"num_comps\" cannot be bigger than the array size of \"comps_full_names\". Please verify the model code with the annotation \"%s\"", annotation); 
-	EXECUTION_REPORT(REPORT_ERROR, -1, *num_comps <= *size_individual_or_family, "ERROR happens when calling the API \"CCPL_do_external_coupling_generation\": the value of \"num_comps\" cannot be bigger than the array size of \"individual_or_family\". Please verify the model code with the annotation \"%s\"", annotation); 
-	coupling_generator->begin_external_coupling_generation();	
-	EXECUTION_REPORT_LOG(REPORT_LOG, -1, true, "Finish generating coupling procedures for a set of specified component model");
+    EXECUTION_REPORT_LOG(REPORT_LOG, -1, true, "start to generate coupling procedures for a set of specified component model");
+    EXECUTION_REPORT(REPORT_ERROR, -1, *num_comps >= 1, "ERROR happens when calling the API \"CCPL_do_external_coupling_generation\": the value of \"num_comps\" cannot be smaller than 1. Please verify the model code with the annotation \"%s\"", annotation);
+    EXECUTION_REPORT(REPORT_ERROR, -1, *num_comps <= *size_comps_full_names, "ERROR happens when calling the API \"CCPL_do_external_coupling_generation\": the value of \"num_comps\" cannot be bigger than the array size of \"comps_full_names\". Please verify the model code with the annotation \"%s\"", annotation); 
+    EXECUTION_REPORT(REPORT_ERROR, -1, *num_comps <= *size_individual_or_family, "ERROR happens when calling the API \"CCPL_do_external_coupling_generation\": the value of \"num_comps\" cannot be bigger than the array size of \"individual_or_family\". Please verify the model code with the annotation \"%s\"", annotation); 
+    coupling_generator->begin_external_coupling_generation();    
+    EXECUTION_REPORT_LOG(REPORT_LOG, -1, true, "Finish generating coupling procedures for a set of specified component model");
 }
 
 
@@ -692,7 +693,7 @@ extern "C" void ccpl_add_comp_for_external_coupling_generation_
 #endif
 (const char *comp_full_name, int *individual_or_family, const char *annotation)
 {
-	coupling_generator->add_comp_for_external_coupling_generation(comp_full_name, *individual_or_family, annotation);
+    coupling_generator->add_comp_for_external_coupling_generation(comp_full_name, *individual_or_family, annotation);
 }
 
 
@@ -703,7 +704,7 @@ extern "C" void ccpl_end_external_coupling_generation_
 #endif
 (const char *annotation)
 {
-	coupling_generator->do_external_coupling_generation(API_ID_COUPLING_GEN_EXTERNAL, annotation);
+    coupling_generator->do_external_coupling_generation(API_ID_COUPLING_GEN_EXTERNAL, annotation);
 }
 
 
@@ -714,20 +715,39 @@ extern "C" void ccpl_end_registration_
 #endif
 (int *comp_id, const char * annotation)
 {
-	check_for_component_registered(*comp_id, API_ID_COMP_MGT_END_COMP_REG, annotation, false);
-	
-	EXECUTION_REPORT_LOG(REPORT_LOG, -1, true, "start to end the coupling registration for the component model \"%s\"", comp_comm_group_mgt_mgr->get_global_node_of_local_comp(*comp_id,true,"")->get_full_name());	
-	synchronize_comp_processes_for_API(*comp_id, API_ID_COMP_MGT_END_COMP_REG, comp_comm_group_mgt_mgr->get_comm_group_of_local_comp(*comp_id, "ccpl_end_registration_"), "first synchorization for ending the registration of a component", annotation);
+    check_for_component_registered(*comp_id, API_ID_COMP_MGT_END_COMP_REG, annotation, false);
+    
+    EXECUTION_REPORT_LOG(REPORT_LOG, -1, true, "start to end the coupling registration for the component model \"%s\"", comp_comm_group_mgt_mgr->get_global_node_of_local_comp(*comp_id,true,"")->get_full_name());    
+    synchronize_comp_processes_for_API(*comp_id, API_ID_COMP_MGT_END_COMP_REG, comp_comm_group_mgt_mgr->get_comm_group_of_local_comp(*comp_id, "ccpl_end_registration_"), "first synchorization for ending the registration of a component", annotation);
 
-	if (((*comp_id) & TYPE_ID_SUFFIX_MASK) == 1) {
-		coupling_generator->do_overall_coupling_generation(comp_comm_group_mgt_mgr->get_global_node_of_local_comp(*comp_id, true, "in ccpl_end_registration_")->get_comp_full_name(), annotation);
- 		coupling_generator->generate_IO_procedures();
-		delete all_H2D_remapping_wgt_files_info;
-	}
-	synchronize_comp_processes_for_API(*comp_id, API_ID_COMP_MGT_END_COMP_REG, comp_comm_group_mgt_mgr->get_comm_group_of_local_comp(*comp_id, "C-Coupler code in register_component for getting component management node"), "second synchorization for ending the registration of a component", annotation);
+    if (((*comp_id) & TYPE_ID_SUFFIX_MASK) == 1) {
+        coupling_generator->do_overall_coupling_generation(comp_comm_group_mgt_mgr->get_global_node_of_local_comp(*comp_id, true, "in ccpl_end_registration_")->get_comp_full_name(), annotation);
+         coupling_generator->generate_IO_procedures();
+        delete all_H2D_remapping_wgt_files_info;
+    }
+    synchronize_comp_processes_for_API(*comp_id, API_ID_COMP_MGT_END_COMP_REG, comp_comm_group_mgt_mgr->get_comm_group_of_local_comp(*comp_id, "C-Coupler code in register_component for getting component management node"), "second synchorization for ending the registration of a component", annotation);
 
-	EXECUTION_REPORT_LOG(REPORT_LOG, -1, true, "Finish ending the coupling registration for the component model \"%s\"", comp_comm_group_mgt_mgr->get_global_node_of_local_comp(*comp_id, true, "")->get_full_name());
-	EXECUTION_REPORT(REPORT_PROGRESS, *comp_id, true, "The coupling registration stage of the component model \"%s\" is successfully ended at the model code with the annotation \"%s\"", comp_comm_group_mgt_mgr->get_global_node_of_local_comp(*comp_id,true,"")->get_full_name(), annotation);
+    EXECUTION_REPORT_LOG(REPORT_LOG, -1, true, "Finish ending the coupling registration for the component model \"%s\"", comp_comm_group_mgt_mgr->get_global_node_of_local_comp(*comp_id, true, "")->get_full_name());
+    EXECUTION_REPORT(REPORT_PROGRESS, *comp_id, true, "The coupling registration stage of the component model \"%s\" is successfully ended at the model code with the annotation \"%s\"", comp_comm_group_mgt_mgr->get_global_node_of_local_comp(*comp_id,true,"")->get_full_name(), annotation);
+}
+
+
+#ifdef LINK_WITHOUT_UNDERLINE
+extern "C" void register_v1d_grid_without_data
+#else
+extern "C" void register_v1d_grid_without_data_
+#endif
+(int *comp_id, int *grid_id, const char *grid_name, const char *coord_unit, int *grid_size, const char *annotation)
+{
+	char API_label[NAME_STR_SIZE];
+	
+	EXECUTION_REPORT_LOG(REPORT_LOG, -1, true, "start to register V1D grid %s", grid_name);
+	common_checking_for_grid_registration(*comp_id, grid_name, coord_unit, API_ID_GRID_MGT_REG_V1D_GRID_NO_DATA, annotation);
+    get_API_hint(*comp_id, API_ID_GRID_MGT_REG_V1D_GRID_NO_DATA, API_label);
+    EXECUTION_REPORT(REPORT_ERROR, *comp_id, *grid_size > 0, "Error happens when calling the API \"%s\" to register a vertical grid \"%s\": the input paramter \"grid_size\" is not larger than 0. Please verify the model code with the annotation \"%s\"", API_label, grid_name, annotation);
+    *grid_id = original_grid_mgr->register_V1D_grid_via_data(API_ID_GRID_MGT_REG_V1D_GRID_NO_DATA, *comp_id, grid_name, 4, coord_unit, *grid_size, 0.0, NULL, NULL, annotation);
+	
+	EXECUTION_REPORT_LOG(REPORT_LOG, -1, true, "Finish registering V1D grid %s", grid_name);
 }
 
 
@@ -739,54 +759,68 @@ extern "C" void register_v1d_grid_with_data_
 (int *comp_id, int *grid_id, const char *grid_name, int *grid_type, const char *coord_unit, int *dim_size2,  
  int *dim_size3, const char *data_type, void *value1, void *value2, void *value3, const char *annotation)
 {
-	double temp_value1, *temp_value2, *temp_value3;
-	int API_id;
-	char API_label[NAME_STR_SIZE];
+    double temp_value1, *temp_value2, *temp_value3;
+    int API_id;
+    char API_label[NAME_STR_SIZE];
 
 
-	EXECUTION_REPORT_LOG(REPORT_LOG, -1, true, "start to register V1D grid %s", grid_name);
-		
-	switch (*grid_type) {
-		case 1:
-			API_id = API_ID_GRID_MGT_REG_V1D_Z_GRID_VIA_MODEL;
-			break;	
-		case 2:			
-			API_id = API_ID_GRID_MGT_REG_V1D_SIGMA_GRID_VIA_MODEL;
-			break;
-		case 3:			
-			API_id = API_ID_GRID_MGT_REG_V1D_HYBRID_GRID_VIA_MODEL;
-			break;			
-		default:
-			EXECUTION_REPORT(REPORT_ERROR, -1, "Software error in register_V1D_grid_with_data: wrong caller_label");
-			break;
-	}
-
-	common_checking_for_grid_registration(*comp_id, grid_name, coord_unit, API_id, annotation);
-
-	get_API_hint(*comp_id, API_id, API_label);
-	EXECUTION_REPORT(REPORT_ERROR, *comp_id, *dim_size2 != 0 && *dim_size3 != 0, "Error happens when calling the API \"%s\" to register a V1D grid \"%s\": some parameters of array have not be allocated. Please verify the model code with the annotation \"%s\" (please make sure all the arrays of grid data have been allocated)", API_label, grid_name, annotation);
-	EXECUTION_REPORT(REPORT_ERROR, *comp_id, *dim_size2 > 1 && *dim_size3 == *dim_size2, "Error happens when calling the API \"%s\" to register a V1D grid \"%s\": the implicit grid size that is determined by the parameter arrays is wrong: the grid size (currently is %d) is smaller than 2 or the sizes of two paramenter arrays are different. Please verify the model code with the annotation \"%s\".", API_label, grid_name, dim_size2, annotation);
-	EXECUTION_REPORT(REPORT_ERROR, -1, words_are_the_same(data_type, DATA_TYPE_FLOAT) || words_are_the_same(data_type, DATA_TYPE_DOUBLE), "Software error in register_V1D_grid_with_data: wrong data type");
-	temp_value2 = new double [*dim_size2];
-	temp_value3 = new double [*dim_size3];
-	if (words_are_the_same(data_type, DATA_TYPE_FLOAT)) {
-		transform_datatype_of_arrays((float*)value1, &temp_value1, 1);
-		transform_datatype_of_arrays((float*)value2, temp_value2, *dim_size2);
-		transform_datatype_of_arrays((float*)value3, temp_value3, *dim_size3);
-	}
-	else {
-		transform_datatype_of_arrays((double*)value1, &temp_value1, 1);
-		transform_datatype_of_arrays((double*)value2, temp_value2, *dim_size2);
-		transform_datatype_of_arrays((double*)value3, temp_value3, *dim_size3);
-	}
-
-	EXECUTION_REPORT(REPORT_ERROR, *comp_id, is_array_in_sorting_order(temp_value2,*dim_size2) != 0, "Error happens when calling the API \"%s\" to register a V1D grid \"%s\": some arrays of parameters are not in a descending/ascending order. Please check the model code with the annotation \"%s\".", API_label, grid_name, annotation);
-	*grid_id = original_grid_mgr->register_V1D_grid_via_data(API_id, *comp_id, grid_name, *grid_type, coord_unit, *dim_size2, temp_value1, temp_value2, temp_value3, annotation);
-
-	delete [] temp_value2;
-	delete [] temp_value3;
-
-	EXECUTION_REPORT_LOG(REPORT_LOG, -1, true, "Finsh registering V1D grid %s", grid_name);
+    EXECUTION_REPORT_LOG(REPORT_LOG, -1, true, "start to register V1D grid %s", grid_name);
+        
+    switch (*grid_type) {
+        case 1:
+            API_id = API_ID_GRID_MGT_REG_V1D_Z_GRID_VIA_MODEL;
+            break;    
+        case 2:            
+            API_id = API_ID_GRID_MGT_REG_V1D_SIGMA_GRID_VIA_MODEL;
+            break;
+        case 3:            
+            API_id = API_ID_GRID_MGT_REG_V1D_HYBRID_GRID_VIA_MODEL;
+            break;            
+        default:
+            EXECUTION_REPORT(REPORT_ERROR, -1, "Software error in register_V1D_grid_with_data: wrong caller_label");
+            break;
+    }
+
+    common_checking_for_grid_registration(*comp_id, grid_name, coord_unit, API_id, annotation);
+
+    get_API_hint(*comp_id, API_id, API_label);
+    EXECUTION_REPORT(REPORT_ERROR, *comp_id, *dim_size2 != 0 && *dim_size3 != 0, "Error happens when calling the API \"%s\" to register a V1D grid \"%s\": some parameters of array have not be allocated. Please verify the model code with the annotation \"%s\" (please make sure all the arrays of grid data have been allocated)", API_label, grid_name, annotation);
+    EXECUTION_REPORT(REPORT_ERROR, *comp_id, *dim_size2 > 1 && *dim_size3 == *dim_size2, "Error happens when calling the API \"%s\" to register a V1D grid \"%s\": the implicit grid size that is determined by the parameter arrays is wrong: the grid size (currently is %d) is smaller than 2 or the sizes of two paramenter arrays are different. Please verify the model code with the annotation \"%s\".", API_label, grid_name, dim_size2, annotation);
+    EXECUTION_REPORT(REPORT_ERROR, -1, words_are_the_same(data_type, DATA_TYPE_FLOAT) || words_are_the_same(data_type, DATA_TYPE_DOUBLE), "Software error in register_V1D_grid_with_data: wrong data type");
+    temp_value2 = new double [*dim_size2];
+    temp_value3 = new double [*dim_size3];
+    if (words_are_the_same(data_type, DATA_TYPE_FLOAT)) {
+        transform_datatype_of_arrays((float*)value1, &temp_value1, 1);
+        transform_datatype_of_arrays((float*)value2, temp_value2, *dim_size2);
+        transform_datatype_of_arrays((float*)value3, temp_value3, *dim_size3);
+    }
+    else {
+        transform_datatype_of_arrays((double*)value1, &temp_value1, 1);
+        transform_datatype_of_arrays((double*)value2, temp_value2, *dim_size2);
+        transform_datatype_of_arrays((double*)value3, temp_value3, *dim_size3);
+    }
+
+    EXECUTION_REPORT(REPORT_ERROR, *comp_id, is_array_in_sorting_order(temp_value2,*dim_size2) != 0, "Error happens when calling the API \"%s\" to register a V1D grid \"%s\": some arrays of parameters are not in a descending/ascending order. Please check the model code with the annotation \"%s\".", API_label, grid_name, annotation);
+    *grid_id = original_grid_mgr->register_V1D_grid_via_data(API_id, *comp_id, grid_name, *grid_type, coord_unit, *dim_size2, temp_value1, temp_value2, temp_value3, annotation);
+
+    delete [] temp_value2;
+    delete [] temp_value3;
+
+    EXECUTION_REPORT_LOG(REPORT_LOG, -1, true, "Finish registering V1D grid %s", grid_name);
+}
+
+
+#ifdef LINK_WITHOUT_UNDERLINE
+extern "C" void set_3d_grid_3d_vertical_coord_field
+#else
+extern "C" void set_3d_grid_3d_vertical_coord_field_
+#endif
+(int *grid_id, int *field_id, const char *static_or_dynamic, const char *annotation)
+{
+    EXECUTION_REPORT_LOG(REPORT_LOG, -1, true, "Start to execute CCPL_set_3D_grid_3D_vertical_coord_field");
+	check_for_component_registered(-1, API_ID_GRID_MGT_SET_3D_GRID_3D_VERT_FLD, annotation, true);
+	original_grid_mgr->set_3D_grid_3D_vertical_coord_field_inst(*grid_id, *field_id, static_or_dynamic, annotation);
+	EXECUTION_REPORT_LOG(REPORT_LOG, -1, true, "Finish executing CCPL_set_3D_grid_3D_vertical_coord_field");
 }
 
 
@@ -797,34 +831,34 @@ extern "C" void set_3d_grid_surface_field_
 #endif
 (int *grid_id, int *field_id, int *static_or_dynamic_or_external, const char *annotation)
 {
-	char API_label[NAME_STR_SIZE];
-	int comp_id, API_id;
-
-
-	if (*static_or_dynamic_or_external == BOTTOM_FIELD_VARIATION_STATIC)
-		API_id = API_ID_GRID_MGT_SET_3D_GRID_STATIC_BOT_FLD;
-	else if (*static_or_dynamic_or_external == BOTTOM_FIELD_VARIATION_DYNAMIC) 
-		API_id = API_ID_GRID_MGT_SET_3D_GRID_DYN_BOT_FLD;
-	else if (*static_or_dynamic_or_external == BOTTOM_FIELD_VARIATION_EXTERNAL) 
-		API_id = API_ID_GRID_MGT_SET_3D_GRID_EXTERNAL_BOT_FLD;
-	else EXECUTION_REPORT(REPORT_ERROR, -1, false, "software error in set_3d_grid_surface_field_: wrong value of static_or_dynamic_or_external");
-	get_API_hint(-1, API_id, API_label);	
-	check_for_component_registered(-1, API_id, annotation, true);
-	EXECUTION_REPORT(REPORT_ERROR, -1, original_grid_mgr->is_grid_id_legal(*grid_id), "Error happens when calling the API \"%s\" to set the surface field of a 3-D grid: the parameter of \"grid_id\" is wrong. Please verify the model code with the annotation \"%s.", API_label, annotation);
-	
-	EXECUTION_REPORT_LOG(REPORT_LOG, -1, true, "Start to set surface field for the 3D grid %s", original_grid_mgr->get_name_of_grid(*grid_id));
-	
-	comp_id = original_grid_mgr->get_comp_id_of_grid(*grid_id);
-	if (*static_or_dynamic_or_external != BOTTOM_FIELD_VARIATION_EXTERNAL) {
-		EXECUTION_REPORT(REPORT_ERROR, comp_id, memory_manager->check_is_legal_field_instance_id(*field_id), "Error happens when calling the API \"%s\" to set the surface field of a 3-D grid: the parameter of \"field_id\" is wrong. Please verify the model code with the annotation \"%s.", API_label, annotation);
-		EXECUTION_REPORT(REPORT_ERROR, comp_id, comp_id == memory_manager->get_field_instance(*field_id)->get_comp_id(), "Error happens when calling the API \"%s\" to set the surface field of a 3-D grid: the components corresponding to the parameters of \"grid_id\" and \"field_id\" are different. Please verify the model code with the annotation \"%s.", API_label, annotation);
-	}	
-	check_for_coupling_registration_stage(comp_id, API_id, true, annotation);
-	original_grid_mgr->set_3d_grid_bottom_field(comp_id, *grid_id, *field_id, *static_or_dynamic_or_external, API_id, API_label, annotation);
-	if (*static_or_dynamic_or_external != BOTTOM_FIELD_VARIATION_EXTERNAL)
-		comp_comm_group_mgt_mgr->search_global_node(comp_id)->get_restart_mgr()->add_restarted_field_instances(memory_manager->get_field_instance(*field_id));
+    char API_label[NAME_STR_SIZE];
+    int comp_id, API_id;
 
-	EXECUTION_REPORT_LOG(REPORT_LOG, -1, true, "Finish to setting surface field for the 3D grid %s", original_grid_mgr->get_name_of_grid(*grid_id));
+
+    if (*static_or_dynamic_or_external == BOTTOM_FIELD_VARIATION_STATIC)
+        API_id = API_ID_GRID_MGT_SET_3D_GRID_STATIC_BOT_FLD;
+    else if (*static_or_dynamic_or_external == BOTTOM_FIELD_VARIATION_DYNAMIC) 
+        API_id = API_ID_GRID_MGT_SET_3D_GRID_DYN_BOT_FLD;
+    else if (*static_or_dynamic_or_external == BOTTOM_FIELD_VARIATION_EXTERNAL) 
+        API_id = API_ID_GRID_MGT_SET_3D_GRID_EXTERNAL_BOT_FLD;
+    else EXECUTION_REPORT(REPORT_ERROR, -1, false, "software error in set_3d_grid_surface_field_: wrong value of static_or_dynamic_or_external");
+    get_API_hint(-1, API_id, API_label);    
+    check_for_component_registered(-1, API_id, annotation, true);
+    EXECUTION_REPORT(REPORT_ERROR, -1, original_grid_mgr->is_grid_id_legal(*grid_id), "Error happens when calling the API \"%s\" to set the surface field of a 3-D grid: the parameter of \"grid_id\" is wrong. Please verify the model code with the annotation \"%s\".", API_label, annotation);
+    
+    EXECUTION_REPORT_LOG(REPORT_LOG, -1, true, "Start to set surface field for the 3D grid %s", original_grid_mgr->get_name_of_grid(*grid_id));
+    
+    comp_id = original_grid_mgr->get_comp_id_of_grid(*grid_id);
+    if (*static_or_dynamic_or_external != BOTTOM_FIELD_VARIATION_EXTERNAL) {
+        EXECUTION_REPORT(REPORT_ERROR, comp_id, memory_manager->check_is_legal_field_instance_id(*field_id), "Error happens when calling the API \"%s\" to set the surface field of a 3-D grid: the parameter of \"field_id\" is wrong. Please verify the model code with the annotation \"%s\".", API_label, annotation);
+        EXECUTION_REPORT(REPORT_ERROR, comp_id, comp_id == memory_manager->get_field_instance(*field_id)->get_comp_id(), "Error happens when calling the API \"%s\" to set the surface field of a 3-D grid: the components corresponding to the parameters of \"grid_id\" and \"field_id\" are different. Please verify the model code with the annotation \"%s\".", API_label, annotation);
+    }    
+    check_for_coupling_registration_stage(comp_id, API_id, true, annotation);
+    original_grid_mgr->set_3d_grid_bottom_field(comp_id, *grid_id, *field_id, *static_or_dynamic_or_external, API_id, API_label, annotation);
+    if (*static_or_dynamic_or_external != BOTTOM_FIELD_VARIATION_EXTERNAL)
+        comp_comm_group_mgt_mgr->search_global_node(comp_id)->get_restart_mgr()->add_restarted_field_instance(memory_manager->get_field_instance(*field_id), true);
+
+    EXECUTION_REPORT_LOG(REPORT_LOG, -1, true, "Finish to setting surface field for the 3D grid %s", original_grid_mgr->get_name_of_grid(*grid_id));
 }
 
 
@@ -835,12 +869,12 @@ extern "C" void register_md_grid_via_multi_grids_
 #endif
 (int *comp_id, int *grid_id, const char *grid_name, int *sub_grid1_id, int *sub_grid2_id, int *sub_grid3_id, int *size_mask, int *mask, const char *annotation)
 {
-	EXECUTION_REPORT_LOG(REPORT_LOG, -1, true, "Start to register an MD grid %s", grid_name);
+    EXECUTION_REPORT_LOG(REPORT_LOG, -1, true, "Start to register an MD grid %s", grid_name);
 
-	common_checking_for_grid_registration(*comp_id, grid_name, NULL, API_ID_GRID_MGT_REG_MD_GRID_VIA_MULTI_GRIDS, annotation);
-	*grid_id = original_grid_mgr->register_md_grid_via_multi_grids(*comp_id, grid_name, *sub_grid1_id, *sub_grid2_id, *sub_grid3_id, *size_mask, mask, annotation);
+    common_checking_for_grid_registration(*comp_id, grid_name, NULL, API_ID_GRID_MGT_REG_MD_GRID_VIA_MULTI_GRIDS, annotation);
+    *grid_id = original_grid_mgr->register_md_grid_via_multi_grids(*comp_id, grid_name, *sub_grid1_id, *sub_grid2_id, *sub_grid3_id, *size_mask, mask, annotation);
 
-	EXECUTION_REPORT_LOG(REPORT_LOG, -1, true, "Finish registering an MD grid %s", grid_name);
+    EXECUTION_REPORT_LOG(REPORT_LOG, -1, true, "Finish registering an MD grid %s", grid_name);
 }
 
 
@@ -852,34 +886,34 @@ extern "C" void register_h2d_grid_with_global_data_
 (int *comp_id, int *grid_id, const char *grid_name, const char *edge_type, const char *coord_unit, const char *cyclic_or_acyclic, const char *data_type, int *dim_size1, int *dim_size2, int *size_center_lon, int *size_center_lat, 
  int *size_mask, int *size_area, int *size_vertex_lon, int *size_vertex_lat, char *min_lon, char *max_lon, char *min_lat, char *max_lat, char *center_lon, char *center_lat, int *mask, char *area, char *vertex_lon, char *vertex_lat, const char *annotation)
 {
-	char tmp_min_lon[8], tmp_max_lon[8], tmp_min_lat[8], tmp_max_lat[8], tmp_cyclic_or_acyclic[NAME_STR_SIZE];
-	int data_type_size = 4;
+    char tmp_min_lon[8], tmp_max_lon[8], tmp_min_lat[8], tmp_max_lat[8], tmp_cyclic_or_acyclic[NAME_STR_SIZE];
+    int data_type_size = 4;
 
 
-	EXECUTION_REPORT_LOG(REPORT_LOG, -1, true, "Start to register an H2D grid \"%s\" with global data", grid_name);
+    EXECUTION_REPORT_LOG(REPORT_LOG, -1, true, "Start to register an H2D grid \"%s\" with global data", grid_name);
 
-	common_checking_for_grid_registration(*comp_id, grid_name, coord_unit, API_ID_GRID_MGT_REG_H2D_GRID_VIA_GLOBAL_DATA, annotation);
+    common_checking_for_grid_registration(*comp_id, grid_name, coord_unit, API_ID_GRID_MGT_REG_H2D_GRID_VIA_GLOBAL_DATA, annotation);
 
-	if (words_are_the_same(data_type, DATA_TYPE_DOUBLE))
-		data_type_size = 8;
-	memcpy(tmp_min_lon, min_lon, data_type_size);
-	memcpy(tmp_max_lon, max_lon, data_type_size);
-	memcpy(tmp_min_lat, min_lat, data_type_size);
-	memcpy(tmp_max_lat, max_lat, data_type_size);
-	strcpy(tmp_cyclic_or_acyclic, cyclic_or_acyclic);
+    if (words_are_the_same(data_type, DATA_TYPE_DOUBLE))
+        data_type_size = 8;
+    memcpy(tmp_min_lon, min_lon, data_type_size);
+    memcpy(tmp_max_lon, max_lon, data_type_size);
+    memcpy(tmp_min_lat, min_lat, data_type_size);
+    memcpy(tmp_max_lat, max_lat, data_type_size);
+    strcpy(tmp_cyclic_or_acyclic, cyclic_or_acyclic);
 
-	*grid_id = original_grid_mgr->register_H2D_grid_via_global_data(*comp_id, grid_name, edge_type, coord_unit, tmp_cyclic_or_acyclic, data_type, *dim_size1, *dim_size2, *size_center_lon, *size_center_lat, 
-												                    *size_mask, *size_area, *size_vertex_lon, *size_vertex_lat, tmp_min_lon, tmp_max_lon, tmp_min_lat, tmp_max_lat, center_lon, center_lat, mask, area, vertex_lon, vertex_lat, annotation,
-												                    API_ID_GRID_MGT_REG_H2D_GRID_VIA_GLOBAL_DATA);
-	if (report_error_enabled) {
-		char nc_file_name[NAME_STR_SIZE];
-		sprintf(nc_file_name, "%s/%s@%s.nc", comp_comm_group_mgt_mgr->get_internal_H2D_grids_dir(), grid_name, comp_comm_group_mgt_mgr->get_global_node_of_local_comp(*comp_id, true, annotation)->get_full_name());
-		char temp_grid_name[NAME_STR_SIZE];
-		sprintf(temp_grid_name, "%s_temp", grid_name);
-		original_grid_mgr->register_H2D_grid_via_file(*comp_id, temp_grid_name, nc_file_name, annotation);
-	}
+    *grid_id = original_grid_mgr->register_H2D_grid_via_global_data(*comp_id, grid_name, edge_type, coord_unit, tmp_cyclic_or_acyclic, data_type, *dim_size1, *dim_size2, *size_center_lon, *size_center_lat, 
+                                                                    *size_mask, *size_area, *size_vertex_lon, *size_vertex_lat, tmp_min_lon, tmp_max_lon, tmp_min_lat, tmp_max_lat, center_lon, center_lat, mask, area, vertex_lon, vertex_lat, annotation,
+                                                                    API_ID_GRID_MGT_REG_H2D_GRID_VIA_GLOBAL_DATA);
+    if (report_error_enabled) {
+        char nc_file_name[NAME_STR_SIZE];
+        sprintf(nc_file_name, "%s/%s@%s.nc", comp_comm_group_mgt_mgr->get_internal_H2D_grids_dir(), grid_name, comp_comm_group_mgt_mgr->get_global_node_of_local_comp(*comp_id, true, annotation)->get_full_name());
+        char temp_grid_name[NAME_STR_SIZE];
+        sprintf(temp_grid_name, "%s_temp", grid_name);
+        original_grid_mgr->register_H2D_grid_via_file(*comp_id, temp_grid_name, nc_file_name, annotation);
+    }
 
-	EXECUTION_REPORT_LOG(REPORT_LOG, -1, true, "Finish registering an H2D grid %s", grid_name);
+    EXECUTION_REPORT_LOG(REPORT_LOG, -1, true, "Finish registering an H2D grid %s", grid_name);
 }
 
 
@@ -891,27 +925,27 @@ extern "C" void register_h2d_grid_with_local_data_
 (int *comp_id, int *grid_id, const char *grid_name, const char *edge_type, const char *coord_unit, const char *cyclic_or_acyclic, const char *data_type, int *grid_size, int *num_local_cells, int *size_local_cells_global_index, int *size_center_lon, int *size_center_lat, 
  int *size_mask, int *size_area, int *size_vertex_lon, int *size_vertex_lat, int *local_cells_global_index, char *min_lon, char *max_lon, char *min_lat, char *max_lat, char *center_lon, char *center_lat, int *mask, char *area, char *vertex_lon, char *vertex_lat, const char *decomp_name, int *decomp_id, const char *annotation)
 {
-	char tmp_min_lon[8], tmp_max_lon[8], tmp_min_lat[8], tmp_max_lat[8], tmp_cyclic_or_acyclic[NAME_STR_SIZE];
-	int data_type_size = 4;
+    char tmp_min_lon[8], tmp_max_lon[8], tmp_min_lat[8], tmp_max_lat[8], tmp_cyclic_or_acyclic[NAME_STR_SIZE];
+    int data_type_size = 4;
 
 
-	EXECUTION_REPORT_LOG(REPORT_LOG, -1, true, "Start to register an H2D grid %s", grid_name);
+    EXECUTION_REPORT_LOG(REPORT_LOG, -1, true, "Start to register an H2D grid %s", grid_name);
 
-	common_checking_for_grid_registration(*comp_id, grid_name, coord_unit, API_ID_GRID_MGT_REG_H2D_GRID_VIA_LOCAL_DATA, annotation);
-	check_API_parameter_string_length(-1, API_ID_GRID_MGT_REG_H2D_GRID_VIA_LOCAL_DATA, CCPL_NAME_STR_LEN, decomp_name, "decomp_name", annotation);
+    common_checking_for_grid_registration(*comp_id, grid_name, coord_unit, API_ID_GRID_MGT_REG_H2D_GRID_VIA_LOCAL_DATA, annotation);
+    check_API_parameter_string_length(-1, API_ID_GRID_MGT_REG_H2D_GRID_VIA_LOCAL_DATA, CCPL_NAME_STR_LEN, decomp_name, "decomp_name", annotation);
 
-	if (words_are_the_same(data_type, DATA_TYPE_DOUBLE))
-		data_type_size = 8;
-	memcpy(tmp_min_lon, min_lon, data_type_size);
-	memcpy(tmp_max_lon, max_lon, data_type_size);
-	memcpy(tmp_min_lat, min_lat, data_type_size);
-	memcpy(tmp_max_lat, max_lat, data_type_size);
-	strcpy(tmp_cyclic_or_acyclic, cyclic_or_acyclic);
+    if (words_are_the_same(data_type, DATA_TYPE_DOUBLE))
+        data_type_size = 8;
+    memcpy(tmp_min_lon, min_lon, data_type_size);
+    memcpy(tmp_max_lon, max_lon, data_type_size);
+    memcpy(tmp_min_lat, min_lat, data_type_size);
+    memcpy(tmp_max_lat, max_lat, data_type_size);
+    strcpy(tmp_cyclic_or_acyclic, cyclic_or_acyclic);
 
-	*grid_id = original_grid_mgr->register_H2D_grid_via_local_data(*comp_id, grid_name, edge_type, coord_unit, tmp_cyclic_or_acyclic, data_type, *grid_size, *num_local_cells, *size_local_cells_global_index, *size_center_lon, *size_center_lat, *size_mask, *size_area, 
-	                                                               *size_vertex_lon, *size_vertex_lat, local_cells_global_index, tmp_min_lon, tmp_max_lon, tmp_min_lat, tmp_max_lat, center_lon, center_lat, mask, area, vertex_lon, vertex_lat, decomp_name, decomp_id, annotation, API_ID_GRID_MGT_REG_H2D_GRID_VIA_LOCAL_DATA);
+    *grid_id = original_grid_mgr->register_H2D_grid_via_local_data(*comp_id, grid_name, edge_type, coord_unit, tmp_cyclic_or_acyclic, data_type, *grid_size, *num_local_cells, *size_local_cells_global_index, *size_center_lon, *size_center_lat, *size_mask, *size_area, 
+                                                                   *size_vertex_lon, *size_vertex_lat, local_cells_global_index, tmp_min_lon, tmp_max_lon, tmp_min_lat, tmp_max_lat, center_lon, center_lat, mask, area, vertex_lon, vertex_lat, decomp_name, decomp_id, annotation, API_ID_GRID_MGT_REG_H2D_GRID_VIA_LOCAL_DATA);
 
-	EXECUTION_REPORT_LOG(REPORT_LOG, -1, true, "Finish registering an H2D grid %s", grid_name);
+    EXECUTION_REPORT_LOG(REPORT_LOG, -1, true, "Finish registering an H2D grid %s", grid_name);
 }
 
 
@@ -922,17 +956,17 @@ extern "C" void register_h2d_grid_with_file_
 #endif
 (int *comp_id, int *grid_id, const char *grid_name, const char *data_file_name, const char *annotation)
 {
-	char full_data_file_name[NAME_STR_SIZE];
+    char full_data_file_name[NAME_STR_SIZE];
 
 
-	EXECUTION_REPORT_LOG(REPORT_LOG, -1, true, "Start to register an H2D grid %s", grid_name);
+    EXECUTION_REPORT_LOG(REPORT_LOG, -1, true, "Start to register an H2D grid %s", grid_name);
 
-	common_checking_for_grid_registration(*comp_id, grid_name, NULL, API_ID_GRID_MGT_REG_H2D_GRID_VIA_FILE, annotation);
-	check_API_parameter_string_length(*comp_id, API_ID_GRID_MGT_REG_H2D_GRID_VIA_FILE, 1000, data_file_name, "data_file_name", annotation);
-	sprintf(full_data_file_name, "%s/grids_weights/%s", comp_comm_group_mgt_mgr->get_root_comp_config_dir(), data_file_name);
-	*grid_id = original_grid_mgr->register_H2D_grid_via_file(*comp_id, grid_name, full_data_file_name, annotation);
+    common_checking_for_grid_registration(*comp_id, grid_name, NULL, API_ID_GRID_MGT_REG_H2D_GRID_VIA_FILE, annotation);
+    check_API_parameter_string_length(*comp_id, API_ID_GRID_MGT_REG_H2D_GRID_VIA_FILE, 1000, data_file_name, "data_file_name", annotation);
+    sprintf(full_data_file_name, "%s/grids_weights/%s", comp_comm_group_mgt_mgr->get_root_comp_config_dir(), data_file_name);
+    *grid_id = original_grid_mgr->register_H2D_grid_via_file(*comp_id, grid_name, full_data_file_name, annotation);
 
-	EXECUTION_REPORT_LOG(REPORT_LOG, -1, true, "Finish registering an H2D grid %s", grid_name);
+    EXECUTION_REPORT_LOG(REPORT_LOG, -1, true, "Finish registering an H2D grid %s", grid_name);
 }
 
 
@@ -943,13 +977,13 @@ extern "C" void register_h2d_grid_from_another_component_
 #endif
 (int *comp_id, int *grid_id, const char *grid_name, const char *annotation)
 {
-	EXECUTION_REPORT_LOG(REPORT_LOG, -1, true, "Start to register an H2D grid %s", grid_name);
+    EXECUTION_REPORT_LOG(REPORT_LOG, -1, true, "Start to register an H2D grid %s", grid_name);
 
-	common_checking_for_grid_registration(*comp_id, grid_name, NULL, API_ID_GRID_MGT_REG_H2D_GRID_VIA_COMP, annotation);
-	check_and_verify_name_format_of_string_for_API(*comp_id, grid_name, API_ID_GRID_MGT_REG_H2D_GRID_VIA_COMP, "the C-Coupler grid", annotation);
-	*grid_id = original_grid_mgr->register_H2D_grid_via_comp(*comp_id, grid_name, annotation);
+    common_checking_for_grid_registration(*comp_id, grid_name, NULL, API_ID_GRID_MGT_REG_H2D_GRID_VIA_COMP, annotation);
+    check_and_verify_name_format_of_string_for_API(*comp_id, grid_name, API_ID_GRID_MGT_REG_H2D_GRID_VIA_COMP, "the C-Coupler grid", annotation);
+    *grid_id = original_grid_mgr->register_H2D_grid_via_comp(*comp_id, grid_name, annotation);
 
-	EXECUTION_REPORT_LOG(REPORT_LOG, -1, true, "Finish registering an H2D grid %s", grid_name);
+    EXECUTION_REPORT_LOG(REPORT_LOG, -1, true, "Finish registering an H2D grid %s", grid_name);
 }
 
 
@@ -960,15 +994,15 @@ extern "C" void register_cor_defined_grid_
 #endif
 (int *comp_id, const char *CCPL_grid_name, const char *CoR_grid_name, const char *annotation, int *grid_id)
 {
-	EXECUTION_REPORT_LOG(REPORT_LOG, -1, true, "Start to register a CoR grid %s", CCPL_grid_name);
+    EXECUTION_REPORT_LOG(REPORT_LOG, -1, true, "Start to register a CoR grid %s", CCPL_grid_name);
 
-	common_checking_for_grid_registration(*comp_id, CCPL_grid_name, NULL, API_ID_GRID_MGT_REG_GRID_VIA_COR, annotation);
-	check_and_verify_name_format_of_string_for_API(*comp_id, CoR_grid_name, API_ID_GRID_MGT_REG_GRID_VIA_COR, "the CoR grid", annotation);
-	check_API_parameter_string(*comp_id, API_ID_GRID_MGT_REG_GRID_VIA_COR, comp_comm_group_mgt_mgr->get_comm_group_of_local_comp(*comp_id, "C-Coupler code in register_cor_defined_grid for getting component management node"), "registering a grid", CCPL_grid_name, "CCPL_grid_name", annotation);
-	check_API_parameter_string(*comp_id, API_ID_GRID_MGT_REG_GRID_VIA_COR, comp_comm_group_mgt_mgr->get_comm_group_of_local_comp(*comp_id, "C-Coupler code in register_cor_defined_grid for getting component management node"), "registering a grid", CoR_grid_name, "CoR_grid_name", annotation);
-	*grid_id = original_grid_mgr->get_CoR_defined_grid(*comp_id, CCPL_grid_name, CoR_grid_name, annotation);
+    common_checking_for_grid_registration(*comp_id, CCPL_grid_name, NULL, API_ID_GRID_MGT_REG_GRID_VIA_COR, annotation);
+    check_and_verify_name_format_of_string_for_API(*comp_id, CoR_grid_name, API_ID_GRID_MGT_REG_GRID_VIA_COR, "the CoR grid", annotation);
+    check_API_parameter_string(*comp_id, API_ID_GRID_MGT_REG_GRID_VIA_COR, comp_comm_group_mgt_mgr->get_comm_group_of_local_comp(*comp_id, "C-Coupler code in register_cor_defined_grid for getting component management node"), "registering a grid", CCPL_grid_name, "CCPL_grid_name", annotation);
+    check_API_parameter_string(*comp_id, API_ID_GRID_MGT_REG_GRID_VIA_COR, comp_comm_group_mgt_mgr->get_comm_group_of_local_comp(*comp_id, "C-Coupler code in register_cor_defined_grid for getting component management node"), "registering a grid", CoR_grid_name, "CoR_grid_name", annotation);
+    *grid_id = original_grid_mgr->get_CoR_defined_grid(*comp_id, CCPL_grid_name, CoR_grid_name, annotation);
 
-	EXECUTION_REPORT_LOG(REPORT_LOG, -1, true, "Finish registering a CoR grid %s", CCPL_grid_name);
+    EXECUTION_REPORT_LOG(REPORT_LOG, -1, true, "Finish registering a CoR grid %s", CCPL_grid_name);
 }
 
 
@@ -979,18 +1013,18 @@ extern "C" void register_mid_point_grid_
 #endif
 (int *level_3D_grid_id, int *mid_3D_grid_id, int *mid_1D_grid_id, int *size_mask, int *mask, const char *annotation)
 {
-	char API_label[NAME_STR_SIZE];
+    char API_label[NAME_STR_SIZE];
 
 
-	EXECUTION_REPORT_LOG(REPORT_LOG, -1, true, "Start to register a middle level grid");
+    EXECUTION_REPORT_LOG(REPORT_LOG, -1, true, "Start to register a middle level grid");
 
-	get_API_hint(-1, API_ID_GRID_MGT_REG_MID_POINT_GRID, API_label);	
-	check_for_ccpl_managers_allocated(API_ID_GRID_MGT_REG_MID_POINT_GRID, annotation);
-	EXECUTION_REPORT(REPORT_ERROR, -1, original_grid_mgr->is_grid_id_legal(*level_3D_grid_id), "Error happens when calling the API \"%s\" to register the mid-point grid of a grid: the grid ID of the interface-level grid (level_3D_grid_id) is wrong. Please verify the model code with the annotation \"%s.", API_label, annotation);
-	check_for_coupling_registration_stage(original_grid_mgr->get_comp_id_of_grid(*level_3D_grid_id), API_ID_GRID_MGT_REG_MID_POINT_GRID, true, annotation);
-	original_grid_mgr->register_mid_point_grid(*level_3D_grid_id, mid_3D_grid_id, mid_1D_grid_id, *size_mask, mask, annotation, API_label);
+    get_API_hint(-1, API_ID_GRID_MGT_REG_MID_POINT_GRID, API_label);    
+    check_for_ccpl_managers_allocated(API_ID_GRID_MGT_REG_MID_POINT_GRID, annotation);
+    EXECUTION_REPORT(REPORT_ERROR, -1, original_grid_mgr->is_grid_id_legal(*level_3D_grid_id), "Error happens when calling the API \"%s\" to register the mid-point grid of a grid: the grid ID of the interface-level grid (level_3D_grid_id) is wrong. Please verify the model code with the annotation \"%s\".", API_label, annotation);
+    check_for_coupling_registration_stage(original_grid_mgr->get_comp_id_of_grid(*level_3D_grid_id), API_ID_GRID_MGT_REG_MID_POINT_GRID, true, annotation);
+    original_grid_mgr->register_mid_point_grid(*level_3D_grid_id, mid_3D_grid_id, mid_1D_grid_id, *size_mask, mask, annotation, API_label);
 
-	EXECUTION_REPORT_LOG(REPORT_LOG, -1, true, "Start to register a middle level grid");
+    EXECUTION_REPORT_LOG(REPORT_LOG, -1, true, "Start to register a middle level grid");
 }
 
 
@@ -1001,9 +1035,9 @@ extern "C" void get_grid_size_
 #endif
 (int *grid_id, int *grid_size, const char *annotation)
 {
-	check_for_ccpl_managers_allocated(API_ID_GRID_MGT_GET_GRID_SIZE, annotation);
+    check_for_ccpl_managers_allocated(API_ID_GRID_MGT_GET_GRID_SIZE, annotation);
 
-	*grid_size = original_grid_mgr->get_grid_size(*grid_id, annotation);
+    *grid_size = original_grid_mgr->get_grid_size(*grid_id, annotation);
 }
 
 
@@ -1014,9 +1048,9 @@ extern "C" void get_grid_id_
 #endif
 (int *comp_id, const char *grid_name, int *grid_id, const char *annotation)
 {
-	check_for_ccpl_managers_allocated(API_ID_GRID_MGT_GET_GRID_ID, annotation);
-	check_API_parameter_string_length(*comp_id, API_ID_GRID_MGT_GET_GRID_ID, CCPL_NAME_STR_LEN, grid_name, "grid_name", annotation);
-	*grid_id = original_grid_mgr->get_grid_id(*comp_id, grid_name, annotation);
+    check_for_ccpl_managers_allocated(API_ID_GRID_MGT_GET_GRID_ID, annotation);
+    check_API_parameter_string_length(*comp_id, API_ID_GRID_MGT_GET_GRID_ID, CCPL_NAME_STR_LEN, grid_name, "grid_name", annotation);
+    *grid_id = original_grid_mgr->get_grid_id(*comp_id, grid_name, annotation);
 }
 
 
@@ -1027,8 +1061,8 @@ extern "C" void get_h2d_grid_area_in_remapping_weights_
 #endif
 (int *interface_id, int *field_index, void *output_area_data, int *area_array_size, const char *data_type, int *have_area, const char *annotation)
 {
-	check_for_ccpl_managers_allocated(API_ID_GRID_MGT_GET_H2D_GRID_AREA_FROM_WGTS, annotation);
-	*have_area = inout_interface_mgr->get_h2d_grid_area_in_remapping_weights(*interface_id, (*field_index)-1, output_area_data, *area_array_size, data_type, annotation);
+    check_for_ccpl_managers_allocated(API_ID_GRID_MGT_GET_H2D_GRID_AREA_FROM_WGTS, annotation);
+    *have_area = inout_interface_mgr->get_h2d_grid_area_in_remapping_weights(*interface_id, (*field_index)-1, output_area_data, *area_array_size, data_type, annotation);
 }
 
 
@@ -1039,17 +1073,17 @@ extern "C" void get_h2d_grid_data_
 #endif
 (int *grid_id, int *decomp_id, const char *label, const char *data_type, int *array_size, char *grid_data, const char *annotation)
 {
-	char API_label[NAME_STR_SIZE];
+    char API_label[NAME_STR_SIZE];
 
 
-	check_for_ccpl_managers_allocated(API_ID_GRID_MGT_GET_H2D_GRID_DATA, annotation);
-	get_API_hint(-1, API_ID_GRID_MGT_GET_H2D_GRID_DATA, API_label);
-	EXECUTION_REPORT(REPORT_ERROR, -1, original_grid_mgr->is_grid_id_legal(*grid_id), "Error happens when calling the API \"%s\" to get the grid data of an H2D grid: the parameter of \"grid_id\" is wrong. Please verify the model code with the annotation \"%s.", API_label, annotation);
-	EXECUTION_REPORT(REPORT_ERROR, original_grid_mgr->get_comp_id_of_grid(*grid_id), original_grid_mgr->get_original_grid(*grid_id)->is_H2D_grid(), "Error happens when calling the API \"%s\" to get the grid data of an H2D grid: the grid \"%s\" is not an H2D grid. Please verify the model code with the annotation \"%s.", API_label, original_grid_mgr->get_original_grid(*grid_id)->get_grid_name(), annotation);
-	EXECUTION_REPORT(REPORT_ERROR, original_grid_mgr->get_comp_id_of_grid(*grid_id), *decomp_id == -1 || decomps_info_mgr->is_decomp_id_legal(*decomp_id), "Error happens when calling the API \"%s\" to get the grid data of an H2D grid: the decomp_id is wrong (must be -1 or a legal decomp_id). Please verify the model code with the annotation \"%s.", API_label, annotation);
-	if (*decomp_id != -1)
-		EXECUTION_REPORT(REPORT_ERROR, original_grid_mgr->get_comp_id_of_grid(*grid_id), original_grid_mgr->get_comp_id_of_grid(*grid_id) == decomps_info_mgr->get_decomp_info(*decomp_id)->get_comp_id(), "Error happens when calling the API \"%s\" to get the grid data of an H2D grid: the grid_id and decomp_id do not correspond to the same component model. Please verify the model code with the annotation \"%s.", API_label, annotation);
-	original_grid_mgr->get_original_grid(*grid_id)->get_grid_data(*decomp_id, label, data_type, *array_size, grid_data, annotation, API_label);
+    check_for_ccpl_managers_allocated(API_ID_GRID_MGT_GET_H2D_GRID_DATA, annotation);
+    get_API_hint(-1, API_ID_GRID_MGT_GET_H2D_GRID_DATA, API_label);
+    EXECUTION_REPORT(REPORT_ERROR, -1, original_grid_mgr->is_grid_id_legal(*grid_id), "Error happens when calling the API \"%s\" to get the grid data of an H2D grid: the parameter of \"grid_id\" is wrong. Please verify the model code with the annotation \"%s\".", API_label, annotation);
+    EXECUTION_REPORT(REPORT_ERROR, original_grid_mgr->get_comp_id_of_grid(*grid_id), original_grid_mgr->get_original_grid(*grid_id)->is_H2D_grid(), "Error happens when calling the API \"%s\" to get the grid data of an H2D grid: the grid \"%s\" is not an H2D grid. Please verify the model code with the annotation \"%s\".", API_label, original_grid_mgr->get_original_grid(*grid_id)->get_grid_name(), annotation);
+    EXECUTION_REPORT(REPORT_ERROR, original_grid_mgr->get_comp_id_of_grid(*grid_id), *decomp_id == -1 || decomps_info_mgr->is_decomp_id_legal(*decomp_id), "Error happens when calling the API \"%s\" to get the grid data of an H2D grid: the decomp_id is wrong (must be -1 or a legal decomp_id). Please verify the model code with the annotation \"%s\".", API_label, annotation);
+    if (*decomp_id != -1)
+        EXECUTION_REPORT(REPORT_ERROR, original_grid_mgr->get_comp_id_of_grid(*grid_id), original_grid_mgr->get_comp_id_of_grid(*grid_id) == decomps_info_mgr->get_decomp_info(*decomp_id)->get_comp_id(), "Error happens when calling the API \"%s\" to get the grid data of an H2D grid: the grid_id and decomp_id do not correspond to the same component model. Please verify the model code with the annotation \"%s\".", API_label, annotation);
+    original_grid_mgr->get_original_grid(*grid_id)->get_grid_data(*decomp_id, label, data_type, *array_size, grid_data, annotation, API_label);
 }
 
 
@@ -1060,26 +1094,26 @@ extern "C" void register_parallel_decomposition_
 #endif
 (int *decomp_id, int *grid_id, int *num_local_cells, int *array_size, const int *local_cells_global_indx, const char *decomp_name, const char *annotation)
 {
-	EXECUTION_REPORT_LOG(REPORT_LOG, -1, true, "Start to register a parallel decomp %s", decomp_name);
-	
-	check_for_ccpl_managers_allocated(API_ID_DECOMP_MGT_REG_DECOMP, annotation);
-	EXECUTION_REPORT(REPORT_ERROR, -1, original_grid_mgr->is_grid_id_legal(*grid_id), "Error happens when calling the API \"CCPL_register_normal_parallel_decomp\" to register a parallel decomposition \"%s\": the parameter \"grid_id\" is wrong. Please check the model code with the annotation \"%s\"", decomp_name, annotation);
-	int comp_id = original_grid_mgr->get_comp_id_of_grid(*grid_id);
-	check_API_parameter_string_length(comp_id, API_ID_DECOMP_MGT_REG_DECOMP, CCPL_NAME_STR_LEN, decomp_name, "decomp_name", annotation);
-	check_for_coupling_registration_stage(comp_id, API_ID_DECOMP_MGT_REG_DECOMP, true, annotation);
-	check_and_verify_name_format_of_string_for_API(comp_id, decomp_name, API_ID_DECOMP_MGT_REG_DECOMP, "the parallel decomposition", annotation);
+    EXECUTION_REPORT_LOG(REPORT_LOG, -1, true, "Start to register a parallel decomp %s", decomp_name);
+    
+    check_for_ccpl_managers_allocated(API_ID_DECOMP_MGT_REG_DECOMP, annotation);
+    EXECUTION_REPORT(REPORT_ERROR, -1, original_grid_mgr->is_grid_id_legal(*grid_id), "Error happens when calling the API \"CCPL_register_normal_parallel_decomp\" to register a parallel decomposition \"%s\": the parameter \"grid_id\" is wrong. Please check the model code with the annotation \"%s\"", decomp_name, annotation);
+    int comp_id = original_grid_mgr->get_comp_id_of_grid(*grid_id);
+    check_API_parameter_string_length(comp_id, API_ID_DECOMP_MGT_REG_DECOMP, CCPL_NAME_STR_LEN, decomp_name, "decomp_name", annotation);
+    check_for_coupling_registration_stage(comp_id, API_ID_DECOMP_MGT_REG_DECOMP, true, annotation);
+    check_and_verify_name_format_of_string_for_API(comp_id, decomp_name, API_ID_DECOMP_MGT_REG_DECOMP, "the parallel decomposition", annotation);
 
-	EXECUTION_REPORT(REPORT_ERROR, comp_id, original_grid_mgr->get_original_grid(*grid_id)->is_H2D_grid(), "Error happens when calling the API \"CCPL_register_normal_parallel_decomp\" to register a parallel decomposition \"%s\": the grid \"%s\" corresponding to the parameter \"grid_id\" is not a horizontal grid. Please check the model code with the annotation \"%s\"", decomp_name, original_grid_mgr->get_original_grid(*grid_id)->get_grid_name(), annotation);
-	EXECUTION_REPORT(REPORT_ERROR, comp_id, *num_local_cells >= 0, "Error happens when calling the API \"CCPL_register_normal_parallel_decomp\" to register a parallel decomposition \"%s\": the parameter \"num_local_cells\" (currently is %d) cannot be smaller than 0. Please check the model code with the annotation \"%s\"", decomp_name, *num_local_cells, annotation);
-	EXECUTION_REPORT(REPORT_ERROR, comp_id, *num_local_cells <= *array_size, "Error happens when calling the API \"CCPL_register_normal_parallel_decomp\" to register a parallel decomposition \"%s\": the array size (currently is %d) of the parameter \"local_cells_global_index\" cannot be smaller than the parameter \"num_local_cells\" (currently is %d). Please check the model code with the annotation \"%s\"", decomp_name, *num_local_cells, *array_size, annotation);
-	int grid_size = original_grid_mgr->get_original_grid(*grid_id)->get_original_CoR_grid()->get_grid_size();
-	for (int i = 0; i < *num_local_cells; i ++)
-		if (local_cells_global_indx[i] != CCPL_NULL_INT)
-			EXECUTION_REPORT(REPORT_ERROR, comp_id, local_cells_global_indx[i] > 0 && local_cells_global_indx[i] <= grid_size, "Error happens when calling the API \"CCPL_register_parallel_decomp\" to register a parallel decomposition \"%s\": some values (for example %d) in parameter \"local_cells_global_indx\" are not between 1 and the size of the grid (currently is %d). Please check the model code with the annotation \"%s\"", decomp_name, local_cells_global_indx[i], grid_size, annotation);
-		
-	*decomp_id = decomps_info_mgr->register_H2D_parallel_decomposition(decomp_name, *grid_id, *num_local_cells, local_cells_global_indx, annotation);
+    EXECUTION_REPORT(REPORT_ERROR, comp_id, original_grid_mgr->get_original_grid(*grid_id)->is_H2D_grid(), "Error happens when calling the API \"CCPL_register_normal_parallel_decomp\" to register a parallel decomposition \"%s\": the grid \"%s\" corresponding to the parameter \"grid_id\" is not a horizontal grid. Please check the model code with the annotation \"%s\"", decomp_name, original_grid_mgr->get_original_grid(*grid_id)->get_grid_name(), annotation);
+    EXECUTION_REPORT(REPORT_ERROR, comp_id, *num_local_cells >= 0, "Error happens when calling the API \"CCPL_register_normal_parallel_decomp\" to register a parallel decomposition \"%s\": the parameter \"num_local_cells\" (currently is %d) cannot be smaller than 0. Please check the model code with the annotation \"%s\"", decomp_name, *num_local_cells, annotation);
+    EXECUTION_REPORT(REPORT_ERROR, comp_id, *num_local_cells <= *array_size, "Error happens when calling the API \"CCPL_register_normal_parallel_decomp\" to register a parallel decomposition \"%s\": the array size (currently is %d) of the parameter \"local_cells_global_index\" cannot be smaller than the parameter \"num_local_cells\" (currently is %d). Please check the model code with the annotation \"%s\"", decomp_name, *num_local_cells, *array_size, annotation);
+    int grid_size = original_grid_mgr->get_original_grid(*grid_id)->get_original_CoR_grid()->get_grid_size();
+    for (int i = 0; i < *num_local_cells; i ++)
+        if (local_cells_global_indx[i] != CCPL_NULL_INT)
+            EXECUTION_REPORT(REPORT_ERROR, comp_id, local_cells_global_indx[i] > 0 && local_cells_global_indx[i] <= grid_size, "Error happens when calling the API \"CCPL_register_parallel_decomp\" to register a parallel decomposition \"%s\": some values (for example %d) in parameter \"local_cells_global_indx\" are not between 1 and the size of the grid (currently is %d). Please check the model code with the annotation \"%s\"", decomp_name, local_cells_global_indx[i], grid_size, annotation);
+        
+    *decomp_id = decomps_info_mgr->register_H2D_parallel_decomposition(decomp_name, *grid_id, *num_local_cells, local_cells_global_indx, annotation);
 
-	EXECUTION_REPORT_LOG(REPORT_LOG, -1, true, "Finish registering a parallel decomp %s", decomp_name);
+    EXECUTION_REPORT_LOG(REPORT_LOG, -1, true, "Finish registering a parallel decomp %s", decomp_name);
 }
 
 
@@ -1091,15 +1125,15 @@ extern "C" void register_external_field_instance_
 (int *field_instance_id, const char *field_name, long *data_buffer_ptr, int *field_size, int *decomp_id, int *comp_or_grid_id, 
  int *buf_mark, int *usage_tag, const char *unit, const char *data_type, const char *annotation)
 {
-	EXECUTION_REPORT_LOG(REPORT_LOG, -1, true, "Start to register a field instance %s", field_name);
+    EXECUTION_REPORT_LOG(REPORT_LOG, -1, true, "Start to register a field instance %s", field_name);
 
-	check_for_ccpl_managers_allocated(API_ID_FIELD_MGT_REG_FIELD_INST, annotation);
-	*field_instance_id = memory_manager->register_external_field_instance(field_name, (void*)(*data_buffer_ptr), *field_size, *decomp_id, *comp_or_grid_id, *buf_mark, *usage_tag, unit, data_type, annotation);
-	Field_mem_info *field_instance = memory_manager->get_field_instance(*field_instance_id);
-	if (field_instance->is_REST_field_inst())
-		comp_comm_group_mgt_mgr->search_global_node(field_instance->get_host_comp_id())->get_restart_mgr()->add_restarted_field_instances(field_instance);
-	
-	EXECUTION_REPORT_LOG(REPORT_LOG, -1, true, "Finish registering a field instance %s", field_name);
+    check_for_ccpl_managers_allocated(API_ID_FIELD_MGT_REG_FIELD_INST, annotation);
+    *field_instance_id = memory_manager->register_external_field_instance(field_name, (void*)(*data_buffer_ptr), *field_size, *decomp_id, *comp_or_grid_id, *buf_mark, *usage_tag, unit, data_type, annotation);
+    Field_mem_info *field_instance = memory_manager->get_field_instance(*field_instance_id);
+    if (field_instance->is_REST_field_inst())
+        comp_comm_group_mgt_mgr->search_global_node(field_instance->get_host_comp_id())->get_restart_mgr()->add_restarted_field_instance(field_instance, false);
+    
+    EXECUTION_REPORT_LOG(REPORT_LOG, -1, true, "Finish registering a field instance %s", field_name);
 }
 
 
@@ -1110,12 +1144,12 @@ extern "C" void register_an_io_field_from_field_instance_
 #endif
 (int *field_inst_id, const char *field_IO_name, const char *annotation)
 {
-	EXECUTION_REPORT_LOG(REPORT_LOG, -1, true, "Start to register an I/O field %s", field_IO_name);
+    EXECUTION_REPORT_LOG(REPORT_LOG, -1, true, "Start to register an I/O field %s", field_IO_name);
 
-	check_for_ccpl_managers_allocated(API_ID_FIELD_MGT_REG_IO_FIELD_from_INST, annotation);
-	IO_fields_mgr->register_IO_field(*field_inst_id, field_IO_name, annotation);
+    check_for_ccpl_managers_allocated(API_ID_FIELD_MGT_REG_IO_FIELD_from_INST, annotation);
+    IO_fields_mgr->register_IO_field(*field_inst_id, field_IO_name, annotation);
 
-	EXECUTION_REPORT_LOG(REPORT_LOG, -1, true, "Finish registering an I/O field %s", field_IO_name);
+    EXECUTION_REPORT_LOG(REPORT_LOG, -1, true, "Finish registering an I/O field %s", field_IO_name);
 }
 
 
@@ -1126,14 +1160,14 @@ extern "C" void register_io_fields_from_field_instances_
 #endif
 (int *num_field_inst, int *size_field_inst_ids, int *field_inst_ids, const char *annotation)
 {
-	EXECUTION_REPORT_LOG(REPORT_LOG, -1, true, "Start to register I/O fields");
+    EXECUTION_REPORT_LOG(REPORT_LOG, -1, true, "Start to register I/O fields");
 
-	check_for_ccpl_managers_allocated(API_ID_FIELD_MGT_REG_IO_FIELDs_from_INSTs, annotation);
-	EXECUTION_REPORT(REPORT_ERROR, -1, *num_field_inst > 0, "Error happers when calling the API \"CCPL_register_IO_fields_from_field_instances\": the parameter \"num_field_inst\" must be larger than 0. Please check the model code with the annotation \"%s\".", annotation);
-	EXECUTION_REPORT(REPORT_ERROR, -1, *size_field_inst_ids > 0, "Error happers when calling the API \"CCPL_register_IO_fields_from_field_instances\": the parameter \"field_inst_ids\" seems to be an empty array, which means it has not been allocated. Please check the model code with the annotation \"%s\".", annotation);
-	IO_fields_mgr->register_IO_fields(*num_field_inst, *size_field_inst_ids, field_inst_ids, annotation);
+    check_for_ccpl_managers_allocated(API_ID_FIELD_MGT_REG_IO_FIELDs_from_INSTs, annotation);
+    EXECUTION_REPORT(REPORT_ERROR, -1, *num_field_inst > 0, "Error happers when calling the API \"CCPL_register_IO_fields_from_field_instances\": the parameter \"num_field_inst\" must be larger than 0. Please check the model code with the annotation \"%s\".", annotation);
+    EXECUTION_REPORT(REPORT_ERROR, -1, *size_field_inst_ids > 0, "Error happers when calling the API \"CCPL_register_IO_fields_from_field_instances\": the parameter \"field_inst_ids\" seems to be an empty array, which means it has not been allocated. Please check the model code with the annotation \"%s\".", annotation);
+    IO_fields_mgr->register_IO_fields(*num_field_inst, *size_field_inst_ids, field_inst_ids, annotation);
 
-	EXECUTION_REPORT_LOG(REPORT_LOG, -1, true, "Finish registering I/O fields");
+    EXECUTION_REPORT_LOG(REPORT_LOG, -1, true, "Finish registering I/O fields");
 }
 
 
@@ -1145,12 +1179,12 @@ extern "C" void register_a_new_io_field_
 (int *comp_or_grid_id, int *decomp_id, int *field_size, long *data_buffer_ptr, const char *field_IO_name, 
  const char *long_name, const char *unit, const char *data_type, const char * annotation)
 {
-	EXECUTION_REPORT_LOG(REPORT_LOG, -1, true, "Start to register an I/O field %s", field_IO_name);
+    EXECUTION_REPORT_LOG(REPORT_LOG, -1, true, "Start to register an I/O field %s", field_IO_name);
 
-	check_for_ccpl_managers_allocated(API_ID_FIELD_MGT_REG_IO_FIELD_from_BUFFER, annotation);
-	IO_fields_mgr->register_IO_field(*comp_or_grid_id, *decomp_id, *field_size, (void*)(*data_buffer_ptr), field_IO_name, long_name, unit, data_type, annotation);
-	
-	EXECUTION_REPORT_LOG(REPORT_LOG, -1, true, "Finish registering an I/O field %s", field_IO_name);
+    check_for_ccpl_managers_allocated(API_ID_FIELD_MGT_REG_IO_FIELD_from_BUFFER, annotation);
+    IO_fields_mgr->register_IO_field(*comp_or_grid_id, *decomp_id, *field_size, (void*)(*data_buffer_ptr), field_IO_name, long_name, unit, data_type, annotation);
+    
+    EXECUTION_REPORT_LOG(REPORT_LOG, -1, true, "Finish registering an I/O field %s", field_IO_name);
 }
 
 
@@ -1160,15 +1194,15 @@ extern "C" void define_single_timer
 extern "C" void define_single_timer_
 #endif
 (int *comp_id, int *timer_id, const char *freq_unit, int *freq_count, int *local_lag_count, int *remote_lag_count, const char *annotation)
-{	
-	EXECUTION_REPORT_LOG(REPORT_LOG, -1, true, "Start to define a timer");
-	
-	check_for_coupling_registration_stage(*comp_id, API_ID_TIME_MGT_DEFINE_SINGLE_TIMER, true, annotation);
-	EXECUTION_REPORT(REPORT_ERROR, *comp_id, components_time_mgrs->get_time_mgr(*comp_id)->get_time_step_in_second() > 0, "Error happers when calling the API \"CCPL_define_single_timer\": the time step of the corresponding component model \"%s\" has not been set yet. Please specify the time step before defining a timer at the model code with the annotation \"%s\"", 
-		             comp_comm_group_mgt_mgr->get_global_node_of_local_comp(*comp_id, true, annotation)->get_comp_full_name(), annotation);
-	*timer_id = timer_mgr->define_timer(*comp_id, freq_unit, *freq_count, *local_lag_count, *remote_lag_count, annotation);
-	
-	EXECUTION_REPORT_LOG(REPORT_LOG, -1, true, "Finish defining a timer");
+{    
+    EXECUTION_REPORT_LOG(REPORT_LOG, -1, true, "Start to define a timer");
+    
+    check_for_coupling_registration_stage(*comp_id, API_ID_TIME_MGT_DEFINE_SINGLE_TIMER, true, annotation);
+    EXECUTION_REPORT(REPORT_ERROR, *comp_id, components_time_mgrs->get_time_mgr(*comp_id)->get_time_step_in_second() > 0, "Error happers when calling the API \"CCPL_define_single_timer\": the time step of the corresponding component model \"%s\" has not been set yet. Please specify the time step before defining a timer at the model code with the annotation \"%s\"", 
+                     comp_comm_group_mgt_mgr->get_global_node_of_local_comp(*comp_id, true, annotation)->get_comp_full_name(), annotation);
+    *timer_id = timer_mgr->define_timer(*comp_id, freq_unit, *freq_count, *local_lag_count, *remote_lag_count, annotation);
+    
+    EXECUTION_REPORT_LOG(REPORT_LOG, -1, true, "Finish defining a timer");
 }
 
 
@@ -1179,14 +1213,14 @@ extern "C" void define_complex_timer_
 #endif
 (int *comp_id, int *timer_id, int *children_timers_id, int *num_children_timers, int *array_size, int *or_or_and, const char *annotation)
 {
-	EXECUTION_REPORT_LOG(REPORT_LOG, -1, true, "Start to define a timer");
+    EXECUTION_REPORT_LOG(REPORT_LOG, -1, true, "Start to define a timer");
 
-	check_for_coupling_registration_stage(*comp_id, API_ID_TIME_MGT_DEFINE_COMPLEX_TIMER, true, annotation);
-	EXECUTION_REPORT(REPORT_ERROR, *comp_id, components_time_mgrs->get_time_mgr(*comp_id)->get_time_step_in_second() > 0, "The time step of the component \%s\" has not been set yet. Please specify the time step before defining a timer at the model code with the annotation \"%s\"", 
-		             comp_comm_group_mgt_mgr->get_global_node_of_local_comp(*comp_id, true, annotation)->get_comp_name(), annotation);
-	*timer_id = timer_mgr->define_timer(*comp_id, children_timers_id, *num_children_timers, *array_size, *or_or_and, annotation);
+    check_for_coupling_registration_stage(*comp_id, API_ID_TIME_MGT_DEFINE_COMPLEX_TIMER, true, annotation);
+    EXECUTION_REPORT(REPORT_ERROR, *comp_id, components_time_mgrs->get_time_mgr(*comp_id)->get_time_step_in_second() > 0, "The time step of the component \%s\" has not been set yet. Please specify the time step before defining a timer at the model code with the annotation \"%s\"", 
+                     comp_comm_group_mgt_mgr->get_global_node_of_local_comp(*comp_id, true, annotation)->get_comp_name(), annotation);
+    *timer_id = timer_mgr->define_timer(*comp_id, children_timers_id, *num_children_timers, *array_size, *or_or_and, annotation);
 
-	EXECUTION_REPORT_LOG(REPORT_LOG, -1, true, "Finish defining a timer");
+    EXECUTION_REPORT_LOG(REPORT_LOG, -1, true, "Finish defining a timer");
 }
 
 
@@ -1197,15 +1231,15 @@ extern "C" void set_component_time_step_
 #endif
 (int *comp_id, int *time_step_in_second, const char *annotation)
 {
-	check_for_coupling_registration_stage(*comp_id, API_ID_TIME_MGT_SET_NORMAL_TIME_STEP, true, annotation);
+    check_for_coupling_registration_stage(*comp_id, API_ID_TIME_MGT_SET_NORMAL_TIME_STEP, true, annotation);
 
-	EXECUTION_REPORT_LOG(REPORT_LOG, -1, true, "Start to set the time step of component model \%s\"", comp_comm_group_mgt_mgr->get_global_node_of_local_comp(*comp_id,true,"")->get_full_name());
-		
-	synchronize_comp_processes_for_API(*comp_id, API_ID_TIME_MGT_SET_NORMAL_TIME_STEP, comp_comm_group_mgt_mgr->get_comm_group_of_local_comp(*comp_id, "C-Coupler code in set_component_time_step_"), "setting the time step of a component model", annotation);
-	check_API_parameter_int(*comp_id, API_ID_TIME_MGT_SET_NORMAL_TIME_STEP, comp_comm_group_mgt_mgr->get_comm_group_of_local_comp(*comp_id,"C-Coupler code in set_component_time_step_"), NULL, *time_step_in_second, "time step (the unit is seconds)", annotation);
-	components_time_mgrs->set_component_time_step(*comp_id, *time_step_in_second, annotation);
-	
-	EXECUTION_REPORT_LOG(REPORT_LOG, -1, true, "Finsh setting the time step of component model \%s\"", comp_comm_group_mgt_mgr->get_global_node_of_local_comp(*comp_id,true,"")->get_full_name());
+    EXECUTION_REPORT_LOG(REPORT_LOG, -1, true, "Start to set the time step of component model \%s\"", comp_comm_group_mgt_mgr->get_global_node_of_local_comp(*comp_id,true,"")->get_full_name());
+        
+    synchronize_comp_processes_for_API(*comp_id, API_ID_TIME_MGT_SET_NORMAL_TIME_STEP, comp_comm_group_mgt_mgr->get_comm_group_of_local_comp(*comp_id, "C-Coupler code in set_component_time_step_"), "setting the time step of a component model", annotation);
+    check_API_parameter_int(*comp_id, API_ID_TIME_MGT_SET_NORMAL_TIME_STEP, comp_comm_group_mgt_mgr->get_comm_group_of_local_comp(*comp_id,"C-Coupler code in set_component_time_step_"), NULL, *time_step_in_second, "time step (the unit is seconds)", annotation);
+    components_time_mgrs->set_component_time_step(*comp_id, *time_step_in_second, annotation);
+    
+    EXECUTION_REPORT_LOG(REPORT_LOG, -1, true, "Finish setting the time step of component model \%s\"", comp_comm_group_mgt_mgr->get_global_node_of_local_comp(*comp_id,true,"")->get_full_name());
 }
 
 
@@ -1216,12 +1250,12 @@ extern "C" void reset_component_current_time_to_start_time_
 #endif
 (int *comp_id, const char *annotation)
 {
-	check_for_coupling_registration_stage(*comp_id, API_ID_TIME_MGT_RESET_TIME_TO_START, true, annotation);
+    check_for_coupling_registration_stage(*comp_id, API_ID_TIME_MGT_RESET_TIME_TO_START, true, annotation);
 
-	EXECUTION_REPORT_LOG(REPORT_LOG, -1, true, "Start to reset the current time of the component model \%s\" to start time", comp_comm_group_mgt_mgr->get_global_node_of_local_comp(*comp_id,true,"")->get_full_name());
-	synchronize_comp_processes_for_API(*comp_id, API_ID_TIME_MGT_SET_NORMAL_TIME_STEP, comp_comm_group_mgt_mgr->get_comm_group_of_local_comp(*comp_id, "C-Coupler code in CCPL_reset_current_time_to_start_time_"), "resetting the current time of a component model to the initial time", annotation);
-	components_time_mgrs->get_time_mgr(*comp_id)->reset_current_time_to_start_time(annotation);
-	EXECUTION_REPORT_LOG(REPORT_LOG, -1, true, "Finishing resetting the current time of the component model \%s\" to start time", comp_comm_group_mgt_mgr->get_global_node_of_local_comp(*comp_id,true,"")->get_full_name());	
+    EXECUTION_REPORT_LOG(REPORT_LOG, -1, true, "Start to reset the current time of the component model \%s\" to start time", comp_comm_group_mgt_mgr->get_global_node_of_local_comp(*comp_id,true,"")->get_full_name());
+    synchronize_comp_processes_for_API(*comp_id, API_ID_TIME_MGT_SET_NORMAL_TIME_STEP, comp_comm_group_mgt_mgr->get_comm_group_of_local_comp(*comp_id, "C-Coupler code in CCPL_reset_current_time_to_start_time_"), "resetting the current time of a component model to the initial time", annotation);
+    components_time_mgrs->get_time_mgr(*comp_id)->reset_current_time_to_start_time(annotation);
+    EXECUTION_REPORT_LOG(REPORT_LOG, -1, true, "Finish resetting the current time of the component model \%s\" to start time", comp_comm_group_mgt_mgr->get_global_node_of_local_comp(*comp_id,true,"")->get_full_name());    
 }
 
 
@@ -1232,13 +1266,13 @@ extern "C" void advance_component_time_
 #endif
 (int *comp_id, const char *annotation)
 {
-	EXECUTION_REPORT_LOG(REPORT_LOG, -1, true, "Start to advance time");
-	
-	check_for_component_registered(*comp_id, API_ID_TIME_MGT_ADVANCE_TIME, annotation, false);
-//	components_IO_output_procedures_mgr->get_component_IO_output_procedures(*comp_id)->execute();
-	components_time_mgrs->advance_component_time(*comp_id, annotation);
-	EXECUTION_REPORT(REPORT_PROGRESS, *comp_id, true, "Component model \"%s\" advance time at the model code with the annotation \"%s\"", comp_comm_group_mgt_mgr->get_global_node_of_local_comp(*comp_id,true,"")->get_full_name(), annotation);
-	EXECUTION_REPORT_LOG(REPORT_LOG, -1, true, "Finish advancing time");
+    EXECUTION_REPORT_LOG(REPORT_LOG, -1, true, "Start to advance time");
+    
+    check_for_component_registered(*comp_id, API_ID_TIME_MGT_ADVANCE_TIME, annotation, false);
+//    components_IO_output_procedures_mgr->get_component_IO_output_procedures(*comp_id)->execute();
+    components_time_mgrs->advance_component_time(*comp_id, annotation);
+    EXECUTION_REPORT(REPORT_PROGRESS, *comp_id, true, "Component model \"%s\" advance time at the model code with the annotation \"%s\"", comp_comm_group_mgt_mgr->get_global_node_of_local_comp(*comp_id,true,"")->get_full_name(), annotation);
+    EXECUTION_REPORT_LOG(REPORT_LOG, -1, true, "Finish advancing time");
 }
 
 
@@ -1247,13 +1281,13 @@ extern "C" void ccpl_write_restart
 #else
 extern "C" void ccpl_write_restart_
 #endif
-(int *comp_id, int *bypass_timer, const char *annotation)
+(int *comp_id, int *bypass_timer, int *bypass_imported_fields, const char *annotation)
 {
-	EXECUTION_REPORT_LOG(REPORT_LOG, -1, true, "Start to do restart write");
-	check_for_component_registered(*comp_id, API_ID_RESTART_MGT_WRITE_IO, annotation, false);
-	if (comp_comm_group_mgt_mgr->get_global_node_of_local_comp(*comp_id,true,annotation)->is_real_component_model())
-		comp_comm_group_mgt_mgr->get_global_node_of_local_comp(*comp_id,true,annotation)->get_restart_mgr()->do_restart_write(annotation, *bypass_timer == 1);
-	EXECUTION_REPORT_LOG(REPORT_LOG, -1, true, "Finish doing restart write");
+    EXECUTION_REPORT_LOG(REPORT_LOG, -1, true, "Start to do restart write");
+    check_for_component_registered(*comp_id, API_ID_RESTART_MGT_WRITE_IO, annotation, false);
+    if (comp_comm_group_mgt_mgr->get_global_node_of_local_comp(*comp_id,true,annotation)->is_real_component_model())
+        comp_comm_group_mgt_mgr->get_global_node_of_local_comp(*comp_id,true,annotation)->get_restart_mgr()->do_restart_write(annotation, *bypass_timer == 1, *bypass_imported_fields == 1);
+    EXECUTION_REPORT_LOG(REPORT_LOG, -1, true, "Finish doing restart write");
 }
 
 
@@ -1264,11 +1298,11 @@ extern "C" void ccpl_read_restart_
 #endif
 (int *comp_id, const char *specified_file_name, const char *annotation)
 {
-	EXECUTION_REPORT_LOG(REPORT_LOG, -1, true, "Start to do restart read");
-	check_for_component_registered(*comp_id, API_ID_RESTART_MGT_START_READ_IO, annotation, false);
-	if (comp_comm_group_mgt_mgr->get_global_node_of_local_comp(*comp_id,true,annotation)->is_real_component_model())
-		comp_comm_group_mgt_mgr->get_global_node_of_local_comp(*comp_id,true,annotation)->get_restart_mgr()->read_restart_mgt_info(specified_file_name, annotation);
-	EXECUTION_REPORT_LOG(REPORT_LOG, -1, true, "Finish doing restart read");
+    EXECUTION_REPORT_LOG(REPORT_LOG, -1, true, "Start to do restart read");
+    check_for_component_registered(*comp_id, API_ID_RESTART_MGT_START_READ_IO, annotation, false);
+    if (comp_comm_group_mgt_mgr->get_global_node_of_local_comp(*comp_id,true,annotation)->is_real_component_model())
+        comp_comm_group_mgt_mgr->get_global_node_of_local_comp(*comp_id,true,annotation)->get_restart_mgr()->read_restart_mgt_info(specified_file_name, annotation);
+    EXECUTION_REPORT_LOG(REPORT_LOG, -1, true, "Finish doing restart read");
 }
 
 
@@ -1279,10 +1313,10 @@ extern "C" void ccpl_read_all_restart_fields_
 #endif
 (int *comp_id, const char *annotation)
 {
-	EXECUTION_REPORT_LOG(REPORT_LOG, -1, true, "Start to read all restart fields from restart data file");
-	check_for_component_registered(*comp_id, API_ID_RESTART_MGT_READ_ALL, annotation, false);
-	comp_comm_group_mgt_mgr->search_global_node(*comp_id)->get_restart_mgr()->read_all_restarted_fields(annotation);
-	EXECUTION_REPORT_LOG(REPORT_LOG, -1, true, "Finish reading all restart fields from restart data file");
+    EXECUTION_REPORT_LOG(REPORT_LOG, -1, true, "Start to read all restart fields from restart data file");
+    check_for_component_registered(*comp_id, API_ID_RESTART_MGT_READ_ALL, annotation, false);
+    comp_comm_group_mgt_mgr->search_global_node(*comp_id)->get_restart_mgr()->read_all_restarted_fields(annotation);
+    EXECUTION_REPORT_LOG(REPORT_LOG, -1, true, "Finish reading all restart fields from restart data file");
 }
 
 
@@ -1293,11 +1327,11 @@ extern "C" void ccpl_read_import_interface_restart_fields_
 #endif
 (int *interface_id, const char *annotation)
 {
-	EXECUTION_REPORT_LOG(REPORT_LOG, -1, true, "Start to all fields of an import interface from restart data file");
-	Inout_interface *inout_interface = inout_interface_mgr->get_interface(*interface_id);
-	EXECUTION_REPORT(REPORT_ERROR, -1, inout_interface != NULL, "Error happens when calling the API \"CCPL_restart_read_fields_interface\": the parameter of \"interface_id\" is wrong");
-	inout_interface->read_restart_fields(API_ID_RESTART_MGT_READ_INTERFACE, annotation);
-	EXECUTION_REPORT_LOG(REPORT_LOG, -1, true, "Finish reading all fields of an import interface from restart data file");
+    EXECUTION_REPORT_LOG(REPORT_LOG, -1, true, "Start to all fields of an import interface from restart data file");
+    Inout_interface *inout_interface = inout_interface_mgr->get_interface(*interface_id);
+    EXECUTION_REPORT(REPORT_ERROR, -1, inout_interface != NULL, "Error happens when calling the API \"CCPL_restart_read_fields_interface\": the parameter of \"interface_id\" is wrong");
+    inout_interface->read_restart_fields(API_ID_RESTART_MGT_READ_INTERFACE, annotation);
+    EXECUTION_REPORT_LOG(REPORT_LOG, -1, true, "Finish reading all fields of an import interface from restart data file");
 }
 
 
@@ -1308,48 +1342,48 @@ extern "C" void get_ccpl_restart_time_
 #endif
 (int *comp_id, int *restart_date, int *restart_second, const char *annotation)
 {
-	check_for_component_registered(*comp_id, API_ID_RESTART_MGT_GET_SETTING, annotation, false);
-	Time_mgt *time_mgr = components_time_mgrs->get_time_mgr(*comp_id);
-	if (time_mgr->get_runtype_mark() == RUNTYPE_MARK_CONTINUE) {
-		*restart_date = time_mgr->get_common_restart_full_time()/100000;
-		*restart_second = time_mgr->get_common_restart_full_time()%100000;
-	}
-	else if (time_mgr->get_runtype_mark() == RUNTYPE_MARK_INITIAL) {
-		*restart_date = -1;
-		*restart_second = -1;
-	}
-	else {
-		*restart_date = time_mgr->get_rest_refdate();
-		*restart_second = time_mgr->get_rest_refsecond();
-	}
+    check_for_component_registered(*comp_id, API_ID_RESTART_MGT_GET_SETTING, annotation, false);
+    Time_mgt *time_mgr = components_time_mgrs->get_time_mgr(*comp_id);
+    if (time_mgr->get_runtype_mark() == RUNTYPE_MARK_CONTINUE) {
+        *restart_date = time_mgr->get_common_restart_full_time()/100000;
+        *restart_second = time_mgr->get_common_restart_full_time()%100000;
+    }
+    else if (time_mgr->get_runtype_mark() == RUNTYPE_MARK_INITIAL) {
+        *restart_date = -1;
+        *restart_second = -1;
+    }
+    else {
+        *restart_date = time_mgr->get_rest_refdate();
+        *restart_second = time_mgr->get_rest_refsecond();
+    }
 }
 
 
 #ifdef LINK_WITHOUT_UNDERLINE
-	extern "C" void get_ccpl_original_case_name
+    extern "C" void get_ccpl_original_case_name
 #else
-	extern "C" void get_ccpl_original_case_name_
+    extern "C" void get_ccpl_original_case_name_
 #endif
 (int *comp_id, int *size_original_case_name, char *original_case_name, const char *annotation)
 {
-	check_for_component_registered(*comp_id, API_ID_RESTART_MGT_GET_SETTING, annotation, false);
-	Time_mgt *time_mgr = components_time_mgrs->get_time_mgr(*comp_id);
-	if (time_mgr->get_runtype_mark() == RUNTYPE_MARK_CONTINUE || time_mgr->get_runtype_mark() == RUNTYPE_MARK_INITIAL)
-		copy_out_string_to_Fortran_API(*comp_id, *size_original_case_name, original_case_name, time_mgr->get_case_name(), API_ID_RESTART_MGT_GET_SETTING, "original_case_name", annotation);
-	else copy_out_string_to_Fortran_API(*comp_id, *size_original_case_name, original_case_name, time_mgr->get_rest_refcase(), API_ID_RESTART_MGT_GET_SETTING, "original_case_name", annotation);
+    check_for_component_registered(*comp_id, API_ID_RESTART_MGT_GET_SETTING, annotation, false);
+    Time_mgt *time_mgr = components_time_mgrs->get_time_mgr(*comp_id);
+    if (time_mgr->get_runtype_mark() == RUNTYPE_MARK_CONTINUE || time_mgr->get_runtype_mark() == RUNTYPE_MARK_INITIAL)
+        copy_out_string_to_Fortran_API(*comp_id, *size_original_case_name, original_case_name, time_mgr->get_case_name(), API_ID_RESTART_MGT_GET_SETTING, "original_case_name", annotation);
+    else copy_out_string_to_Fortran_API(*comp_id, *size_original_case_name, original_case_name, time_mgr->get_rest_refcase(), API_ID_RESTART_MGT_GET_SETTING, "original_case_name", annotation);
 }
 
 
 #ifdef LINK_WITHOUT_UNDERLINE
-	extern "C" void get_ccpl_run_type
+    extern "C" void get_ccpl_run_type
 #else
-	extern "C" void get_ccpl_run_type_
+    extern "C" void get_ccpl_run_type_
 #endif
 (int *comp_id, int *size_run_type, char *run_type, const char *annotation)
 {
-	check_for_component_registered(*comp_id, API_ID_RESTART_MGT_GET_SETTING, annotation, false);
-	Time_mgt *time_mgr = components_time_mgrs->get_time_mgr(*comp_id);
-	copy_out_string_to_Fortran_API(*comp_id, *size_run_type, run_type, time_mgr->get_run_type(), API_ID_RESTART_MGT_GET_SETTING, "run_type", annotation);
+    check_for_component_registered(*comp_id, API_ID_RESTART_MGT_GET_SETTING, annotation, false);
+    Time_mgt *time_mgr = components_time_mgrs->get_time_mgr(*comp_id);
+    copy_out_string_to_Fortran_API(*comp_id, *size_run_type, run_type, time_mgr->get_run_type(), API_ID_RESTART_MGT_GET_SETTING, "run_type", annotation);
 }
 
 
@@ -1360,12 +1394,12 @@ extern "C" void is_restart_timer_on_
 #endif
 (int *comp_id, int *check_result, const char *annotation)
 {
-	check_for_component_registered(*comp_id, API_ID_RESTART_MGT_IS_TIMER_ON, annotation, false);
-	EXECUTION_REPORT(REPORT_ERROR, *comp_id, comp_comm_group_mgt_mgr->get_global_node_of_local_comp(*comp_id,true,"in is_restart_timer_on_")->is_real_component_model(), "Error happens when calling the API CCPL_is_restart_timer_on: the given component model \"%s\" is not a real model. Please verify the model code related to the annotation \"%s\"",
-		             comp_comm_group_mgt_mgr->get_global_node_of_local_comp(*comp_id,true,"in is_restart_timer_on_")->get_comp_full_name(), annotation);
-	if (components_time_mgrs->get_time_mgr(*comp_id)->is_restart_timer_on())
-		*check_result = 1;
-	else *check_result = 0;
+    check_for_component_registered(*comp_id, API_ID_RESTART_MGT_IS_TIMER_ON, annotation, false);
+    EXECUTION_REPORT(REPORT_ERROR, *comp_id, comp_comm_group_mgt_mgr->get_global_node_of_local_comp(*comp_id,true,"in is_restart_timer_on_")->is_real_component_model(), "Error happens when calling the API CCPL_is_restart_timer_on: the given component model \"%s\" is not a real model. Please verify the model code related to the annotation \"%s\"",
+                     comp_comm_group_mgt_mgr->get_global_node_of_local_comp(*comp_id,true,"in is_restart_timer_on_")->get_comp_full_name(), annotation);
+    if (components_time_mgrs->get_time_mgr(*comp_id)->is_restart_timer_on())
+        *check_result = 1;
+    else *check_result = 0;
 }
 
 
@@ -1376,8 +1410,8 @@ extern "C" void check_ccpl_component_current_time_
 #endif
 (int *comp_id, int *date, int *second, const char *annotation)
 {
-	check_for_component_registered(*comp_id, API_ID_TIME_MGT_CHECK_CURRENT_TIME, annotation, false);
-	components_time_mgrs->check_component_current_time(*comp_id, *date, *second, annotation);
+    check_for_component_registered(*comp_id, API_ID_TIME_MGT_CHECK_CURRENT_TIME, annotation, false);
+    components_time_mgrs->check_component_current_time(*comp_id, *date, *second, annotation);
 }
 
 
@@ -1388,10 +1422,10 @@ extern "C" void is_ccpl_timer_on_
 #endif
 (int *timer_id, int *is_on, const char *annotation)
 {
-	check_for_ccpl_managers_allocated(API_ID_TIME_MGT_IS_TIMER_ON, annotation);
-	if (timer_mgr->is_timer_on(*timer_id, annotation))
-		*is_on = 1;
-	else *is_on = 0;
+    check_for_ccpl_managers_allocated(API_ID_TIME_MGT_IS_TIMER_ON, annotation);
+    if (timer_mgr->is_timer_on(*timer_id, annotation))
+        *is_on = 1;
+    else *is_on = 0;
 }
 
 
@@ -1402,11 +1436,11 @@ extern "C" void check_is_ccpl_model_last_step_
 #endif
 (int *comp_id, int *is_last_step, const char *annotation)
 {
-	check_for_component_registered(*comp_id, API_ID_TIME_MGT_IS_MODEL_LAST_STEP, annotation, false);
-	Time_mgt *time_mgr = components_time_mgrs->get_time_mgr(*comp_id);
-	if (time_mgr->get_current_num_time_step() == time_mgr->get_num_total_step() - 1)
-		*is_last_step = 1;
-	else *is_last_step = 0;
+    check_for_component_registered(*comp_id, API_ID_TIME_MGT_IS_MODEL_LAST_STEP, annotation, false);
+    Time_mgt *time_mgr = components_time_mgrs->get_time_mgr(*comp_id);
+    if (time_mgr->get_current_num_time_step() == time_mgr->get_num_total_step() - 1)
+        *is_last_step = 1;
+    else *is_last_step = 0;
 }
 
 
@@ -1417,10 +1451,10 @@ extern "C" void check_is_ccpl_model_run_ended_
 #endif
 (int *comp_id, int *is_ended, const char *annotation)
 {
-	check_for_component_registered(*comp_id, API_ID_TIME_MGT_IS_MODEL_RUN_ENDED, annotation, false);
-	if (components_time_mgrs->is_model_run_ended(*comp_id, annotation))
-		*is_ended = 1;
-	else *is_ended = 0;
+    check_for_component_registered(*comp_id, API_ID_TIME_MGT_IS_MODEL_RUN_ENDED, annotation, false);
+    if (components_time_mgrs->is_model_run_ended(*comp_id, annotation))
+        *is_ended = 1;
+    else *is_ended = 0;
 }
 
 
@@ -1431,16 +1465,16 @@ extern "C" void register_normal_remap_interface_
 #endif
 (const char *interface_name, int *interface_id, int *num_fields, int *field_ids_src, int *field_ids_dst, int *timer_id, int *inst_or_aver, int *array_size1, int *array_size2, const char *annotation)
 {
-	char API_label[NAME_STR_SIZE];
+    char API_label[NAME_STR_SIZE];
 
-	
-	EXECUTION_REPORT_LOG(REPORT_LOG, -1, true, "Start to register remap interface");
-	check_for_ccpl_managers_allocated(API_ID_INTERFACE_REG_NORMAL_REMAP, annotation);	
-	check_API_parameter_string_length(-1, API_ID_INTERFACE_REG_NORMAL_REMAP, CCPL_NAME_STR_LEN, interface_name, "interface_name", annotation);
-	get_API_hint(-1, API_ID_INTERFACE_REG_NORMAL_REMAP, API_label);
-	*interface_id = inout_interface_mgr->register_normal_remap_interface(interface_name, *num_fields, field_ids_src, field_ids_dst, *timer_id, *inst_or_aver, *array_size1, *array_size2, API_label, annotation);
+    
+    EXECUTION_REPORT_LOG(REPORT_LOG, -1, true, "Start to register remap interface");
+    check_for_ccpl_managers_allocated(API_ID_INTERFACE_REG_NORMAL_REMAP, annotation);    
+    check_API_parameter_string_length(-1, API_ID_INTERFACE_REG_NORMAL_REMAP, CCPL_NAME_STR_LEN, interface_name, "interface_name", annotation);
+    get_API_hint(-1, API_ID_INTERFACE_REG_NORMAL_REMAP, API_label);
+    *interface_id = inout_interface_mgr->register_normal_remap_interface(interface_name, *num_fields, field_ids_src, field_ids_dst, *timer_id, *inst_or_aver, *array_size1, *array_size2, API_label, annotation);
 
-	EXECUTION_REPORT_LOG(REPORT_LOG, -1, true, "Finish registering remap interface");
+    EXECUTION_REPORT_LOG(REPORT_LOG, -1, true, "Finish registering remap interface");
 }
 
 
@@ -1449,19 +1483,19 @@ extern "C" void register_frac_based_remap_interface
 #else
 extern "C" void register_frac_based_remap_interface_
 #endif
-(const char *interface_name, int *interface_id, int *num_fields, int *field_ids_src, int *field_ids_dst, int *timer_id, int *inst_or_aver, int *array_size1, int *array_size2, void *frac_src, void *frac_dst, int *size_frac_src, int *size_frac_dst, const char *frac_data_type, const char *annotation)
+(const char *interface_name, int *interface_id, int *num_fields, int *field_ids_src, int *field_ids_dst, int *timer_id, int *inst_or_aver, int *array_size1, int *array_size2, long *frac_src, long *frac_dst, int *size_frac_src, int *size_frac_dst, const char *frac_data_type, const char *annotation)
 {
-	char API_label[NAME_STR_SIZE];
-	
+    char API_label[NAME_STR_SIZE];
+    
 
-	EXECUTION_REPORT_LOG(REPORT_LOG, -1, true, "Start to register fraction based remap interface");
+    EXECUTION_REPORT_LOG(REPORT_LOG, -1, true, "Start to register fraction based remap interface");
 
-	check_for_ccpl_managers_allocated(API_ID_INTERFACE_REG_FRAC_REMAP, annotation);		
-	check_API_parameter_string_length(-1, API_ID_INTERFACE_REG_FRAC_REMAP, CCPL_NAME_STR_LEN, interface_name, "interface_name", annotation);
-	get_API_hint(-1, API_ID_INTERFACE_REG_FRAC_REMAP, API_label);
-	*interface_id = inout_interface_mgr->register_frac_based_remap_interface(interface_name, *num_fields, field_ids_src, field_ids_dst, *timer_id, *inst_or_aver, *array_size1, *array_size2, frac_src, frac_dst, *size_frac_src, *size_frac_dst, frac_data_type, API_label, annotation);
+    check_for_ccpl_managers_allocated(API_ID_INTERFACE_REG_FRAC_REMAP, annotation);        
+    check_API_parameter_string_length(-1, API_ID_INTERFACE_REG_FRAC_REMAP, CCPL_NAME_STR_LEN, interface_name, "interface_name", annotation);
+    get_API_hint(-1, API_ID_INTERFACE_REG_FRAC_REMAP, API_label);
+    *interface_id = inout_interface_mgr->register_frac_based_remap_interface(interface_name, *num_fields, field_ids_src, field_ids_dst, *timer_id, *inst_or_aver, *array_size1, *array_size2, (void*)(*frac_src), (void*)(*frac_dst), *size_frac_src, *size_frac_dst, frac_data_type, API_label, annotation);
 
-	EXECUTION_REPORT_LOG(REPORT_LOG, -1, true, "Finish registering fraction based remap interface");
+    EXECUTION_REPORT_LOG(REPORT_LOG, -1, true, "Finish registering fraction based remap interface");
 }
 
 
@@ -1472,20 +1506,20 @@ extern "C" void register_inout_interface_
 #endif
 (const char *interface_name, int *interface_id, int *import_or_export, int *num_fields, int *field_ids, int *timer_id, int *inst_or_aver, const char *annotation, int *array_size1)
 {
-	EXECUTION_REPORT_LOG(REPORT_LOG, -1, true, "Start to register import/export interface");
+    EXECUTION_REPORT_LOG(REPORT_LOG, -1, true, "Start to register an import/export interface");
 
-	if (*import_or_export == 0) {
-		check_for_ccpl_managers_allocated(API_ID_INTERFACE_REG_IMPORT, annotation);
-		check_API_parameter_string_length(-1, API_ID_INTERFACE_REG_IMPORT, CCPL_NAME_STR_LEN, interface_name, "interface_name", annotation);
-		*interface_id = inout_interface_mgr->register_inout_interface(interface_name, *import_or_export, *num_fields, field_ids, *array_size1, *timer_id, *inst_or_aver, annotation, INTERFACE_SOURCE_REGISTER);
-	}
-	else {
-		check_for_ccpl_managers_allocated(API_ID_INTERFACE_REG_EXPORT, annotation);
-		check_API_parameter_string_length(-1, API_ID_INTERFACE_REG_EXPORT, CCPL_NAME_STR_LEN, interface_name, "interface_name", annotation);
-		*interface_id = inout_interface_mgr->register_inout_interface(interface_name, *import_or_export, *num_fields, field_ids, *array_size1, *timer_id, 0, annotation, INTERFACE_SOURCE_REGISTER);
-	}	
+    if (*import_or_export == 0) {
+        check_for_ccpl_managers_allocated(API_ID_INTERFACE_REG_IMPORT, annotation);
+        check_API_parameter_string_length(-1, API_ID_INTERFACE_REG_IMPORT, CCPL_NAME_STR_LEN, interface_name, "interface_name", annotation);
+        *interface_id = inout_interface_mgr->register_inout_interface(interface_name, *import_or_export, *num_fields, field_ids, *array_size1, *timer_id, *inst_or_aver, annotation, INTERFACE_SOURCE_REGISTER);
+    }
+    else {
+        check_for_ccpl_managers_allocated(API_ID_INTERFACE_REG_EXPORT, annotation);
+        check_API_parameter_string_length(-1, API_ID_INTERFACE_REG_EXPORT, CCPL_NAME_STR_LEN, interface_name, "interface_name", annotation);
+        *interface_id = inout_interface_mgr->register_inout_interface(interface_name, *import_or_export, *num_fields, field_ids, *array_size1, *timer_id, 0, annotation, INTERFACE_SOURCE_REGISTER);
+    }    
 
-	EXECUTION_REPORT_LOG(REPORT_LOG, -1, true, "Finish register import/export interface");
+    EXECUTION_REPORT_LOG(REPORT_LOG, -1, true, "Finish registering an import/export interface");
 }
 
 
@@ -1496,10 +1530,10 @@ extern "C" void check_is_ccpl_import_field_connected_
 #endif
 (int *interface_id, int *field_instance_id, int *check_result, const char *annotation)
 {
-	check_for_ccpl_managers_allocated(API_ID_INTERFACE_CHECK_IMPORT_FIELD_CONNECTED, annotation);
-	Inout_interface *import_interface = inout_interface_mgr->get_interface(*interface_id);
-	EXECUTION_REPORT(REPORT_ERROR, -1, import_interface != NULL, "ERROR happens when calling the API \"CCPL_check_is_import_field_connected\": the parameter \"interface_id\" is not a legal ID of a coupling interface. Please verify the model code with the annotation \"%s\".", annotation);
-	*check_result = import_interface->check_is_import_field_connected(*field_instance_id, annotation);
+    check_for_ccpl_managers_allocated(API_ID_INTERFACE_CHECK_IMPORT_FIELD_CONNECTED, annotation);
+    Inout_interface *import_interface = inout_interface_mgr->get_interface(*interface_id);
+    EXECUTION_REPORT(REPORT_ERROR, -1, import_interface != NULL, "ERROR happens when calling the API \"CCPL_check_is_import_field_connected\": the parameter \"interface_id\" is not a legal ID of a coupling interface. Please verify the model code with the annotation \"%s\".", annotation);
+    *check_result = import_interface->check_is_import_field_connected(*field_instance_id, annotation);
 }
 
 
@@ -1510,7 +1544,23 @@ extern "C" void set_import_interface_fields_necessity_
 #endif
 (int *import_interface_id, int *necessity, int *size_necessity, const char *annotation)
 {
-	inout_interface_mgr->get_interface(*import_interface_id)->set_fields_necessity(necessity, *size_necessity, annotation);
+    inout_interface_mgr->get_interface(*import_interface_id)->set_fields_necessity(necessity, *size_necessity, annotation);
+}
+
+
+#ifdef LINK_WITHOUT_UNDERLINE
+extern "C" void get_ccpl_import_fields_sender_time
+#else
+extern "C" void get_ccpl_import_fields_sender_time_
+#endif
+(int *import_interface_id, int *size_sender_date, int *size_sender_elapsed_days, int *size_sender_second, int *sender_date, int *sender_elapsed_days, int *sender_second, const char *annotation)
+{
+	EXECUTION_REPORT_LOG(REPORT_LOG, -1, true, "Start to get the sender time of import fields");
+	check_for_ccpl_managers_allocated(API_ID_INTERFACE_GET_SENDER_TIME, annotation);
+    Inout_interface *import_interface = inout_interface_mgr->get_interface(*import_interface_id);
+    EXECUTION_REPORT(REPORT_ERROR, -1, import_interface != NULL, "ERROR happens when calling the API \"CCPL_get_import_fields_sender_time\": the parameter \"interface_id\" is not a legal ID of a coupling interface. Please verify the model code with the annotation \"%s\".", annotation);
+	import_interface->get_sender_time(*size_sender_date, *size_sender_elapsed_days, *size_sender_second, sender_date, sender_elapsed_days, sender_second, annotation);
+	EXECUTION_REPORT_LOG(REPORT_LOG, -1, true, "Finish getting the sender time of import fields");
 }
 
 
@@ -1521,12 +1571,12 @@ extern "C" void execute_inout_interface_with_id_
 #endif
 (int *interface_id, int *bypass_timer, int *field_update_status, int *size_field_update_status, int *num_dst_fields, const char *annotation)
 {
-	EXECUTION_REPORT_LOG(REPORT_LOG, -1, true, "Start to execute an interface");
+    EXECUTION_REPORT_LOG(REPORT_LOG, -1, true, "Start to execute an interface");
 
-	check_for_ccpl_managers_allocated(API_ID_INTERFACE_EXECUTE_WITH_ID, annotation);
-	inout_interface_mgr->execute_interface(*interface_id, API_ID_INTERFACE_EXECUTE_WITH_ID, *bypass_timer == 1, field_update_status, *size_field_update_status, num_dst_fields, annotation);
+    check_for_ccpl_managers_allocated(API_ID_INTERFACE_EXECUTE_WITH_ID, annotation);
+    inout_interface_mgr->execute_interface(*interface_id, API_ID_INTERFACE_EXECUTE_WITH_ID, *bypass_timer == 1, field_update_status, *size_field_update_status, num_dst_fields, annotation);
 
-	EXECUTION_REPORT_LOG(REPORT_LOG, -1, true, "Finish executing an interface");
+    EXECUTION_REPORT_LOG(REPORT_LOG, -1, true, "Finish executing an interface");
 }
 
 
@@ -1537,13 +1587,13 @@ extern "C" void execute_inout_interface_with_name_
 #endif
 (int *comp_id, const char *interface_name, int *bypass_timer, int *field_update_status, int *size_field_update_status, int *num_dst_fields, const char *annotation)
 {
-	EXECUTION_REPORT_LOG(REPORT_LOG, -1, true, "Start to execute an interface");
+    EXECUTION_REPORT_LOG(REPORT_LOG, -1, true, "Start to execute an interface");
 
-	check_for_ccpl_managers_allocated(API_ID_INTERFACE_EXECUTE_WITH_NAME, annotation);
-	check_API_parameter_string_length(-1, API_ID_INTERFACE_EXECUTE_WITH_NAME, CCPL_NAME_STR_LEN, interface_name, "interface_name", annotation);
-	inout_interface_mgr->execute_interface(*comp_id, API_ID_INTERFACE_EXECUTE_WITH_NAME, interface_name, *bypass_timer == 1, field_update_status, *size_field_update_status, num_dst_fields, annotation);
+    check_for_ccpl_managers_allocated(API_ID_INTERFACE_EXECUTE_WITH_NAME, annotation);
+    check_API_parameter_string_length(-1, API_ID_INTERFACE_EXECUTE_WITH_NAME, CCPL_NAME_STR_LEN, interface_name, "interface_name", annotation);
+    inout_interface_mgr->execute_interface(*comp_id, API_ID_INTERFACE_EXECUTE_WITH_NAME, interface_name, *bypass_timer == 1, field_update_status, *size_field_update_status, num_dst_fields, annotation);
 
-	EXECUTION_REPORT_LOG(REPORT_LOG, -1, true, "Finish executing an interface");
+    EXECUTION_REPORT_LOG(REPORT_LOG, -1, true, "Finish executing an interface");
 }
 
 
@@ -1554,9 +1604,9 @@ extern "C" void get_local_comp_full_name_
 #endif
 (int *comp_id, char *comp_full_name, int *comp_full_name_size, const char *annotation)
 {
-	check_for_component_registered(*comp_id, API_ID_INTERFACE_GET_LOCAL_COMP_FULL_NAME, annotation, false);
-	const char *full_name = comp_comm_group_mgt_mgr->get_global_node_of_local_comp(*comp_id, true, "in get_local_comp_full_name_")->get_full_name();
-	copy_out_string_to_Fortran_API(*comp_id, *comp_full_name_size, comp_full_name, full_name, API_ID_INTERFACE_GET_LOCAL_COMP_FULL_NAME, "comp_full_name", annotation);
+    check_for_component_registered(*comp_id, API_ID_COMP_MGT_GET_LOCAL_COMP_FULL_NAME, annotation, false);
+    const char *full_name = comp_comm_group_mgt_mgr->get_global_node_of_local_comp(*comp_id, true, "in get_local_comp_full_name_")->get_full_name();
+    copy_out_string_to_Fortran_API(*comp_id, *comp_full_name_size, comp_full_name, full_name, API_ID_COMP_MGT_GET_LOCAL_COMP_FULL_NAME, "comp_full_name", annotation);
 }
 
 
@@ -1567,18 +1617,18 @@ extern "C" void ccpl_report_
 #endif
 (int *report_type, int *comp_id, int *condition, const char *report_content, const char *annotation)
 {
-	int API_id;
-	bool local_condition = *condition == 1? true : false;
+    int API_id;
+    bool local_condition = *condition == 1? true : false;
 
-	
-	if (*report_type == REPORT_ERROR)
-		API_id = API_ID_REPORT_ERROR;
-	else if (*report_type == REPORT_EXTERNAL_LOG)
-		API_id = API_ID_REPORT_LOG;
-	else API_id = API_ID_REPORT_PROGRESS;
-
-	check_for_ccpl_managers_allocated(API_id, annotation);
-	check_API_parameter_string_length(*comp_id, API_id, 512, report_content, "report_string", annotation);
-	EXECUTION_REPORT(*report_type, *comp_id, local_condition, report_content);
+    
+    if (*report_type == REPORT_ERROR)
+        API_id = API_ID_REPORT_ERROR;
+    else if (*report_type == REPORT_EXTERNAL_LOG)
+        API_id = API_ID_REPORT_LOG;
+    else API_id = API_ID_REPORT_PROGRESS;
+
+    check_for_ccpl_managers_allocated(API_id, annotation);
+    check_API_parameter_string_length(*comp_id, API_id, 512, report_content, "report_string", annotation);
+    EXECUTION_REPORT(*report_type, *comp_id, local_condition, report_content);
 }
 
diff --git a/src/Driver/coupling_interface.h b/src/Driver/coupling_interface.h
old mode 100644
new mode 100755
diff --git a/src/Driver/global_data.cxx b/src/Driver/global_data.cxx
old mode 100644
new mode 100755
diff --git a/src/Driver/global_data.h b/src/Driver/global_data.h
old mode 100644
new mode 100755
diff --git a/src/Driver/object_type_prefix.h b/src/Driver/object_type_prefix.h
old mode 100644
new mode 100755
diff --git a/src/Driver/timer_mgt.cxx b/src/Driver/timer_mgt.cxx
old mode 100644
new mode 100755
index 63db37d..9fa4b91
--- a/src/Driver/timer_mgt.cxx
+++ b/src/Driver/timer_mgt.cxx
@@ -23,8 +23,8 @@ int num_days_of_month_of_leap_year[] = {31, 29, 31, 30, 31, 30, 31, 31, 30, 31,
 
 
 bool common_is_timer_on(const char *frequency_unit, int frequency_count, int local_lag_count, int current_year, 
-	                  int current_month, int current_day, int current_second, int current_num_elapsed_day,
-	                  int start_year, int start_month, int start_day, int start_second, int start_num_elapsed_day)
+                      int current_month, int current_day, int current_second, int current_num_elapsed_day,
+                      int start_year, int start_month, int start_day, int start_second, int start_num_elapsed_day)
 {
     long num_elapsed_time;
 
@@ -57,19 +57,19 @@ bool common_is_timer_on(const char *frequency_unit, int frequency_count, int loc
 
 Coupling_timer::Coupling_timer(int comp_id, int timer_id, int *children_timers_id, int num_children_timers, int or_or_and, const char *annotation)
 {
-	this->timer_id = timer_id;
-	this->comp_id = comp_id;
-	this->or_or_and = or_or_and;
-	EXECUTION_REPORT(REPORT_ERROR, comp_id, num_children_timers > 1, "Error happens when calling the API \"CCPL_define_complex_timer\": parameter num_children_timers cannot be smaller than 2. Please verify the model code corresponding to the annotation \"%s\"", annotation);
-	EXECUTION_REPORT(REPORT_ERROR, comp_id, or_or_and == 0 || or_or_and == 1, "Error happens when calling the API \"CCPL_define_complex_timer\": the value of the parameter \"OR_or_AND\" must be 0 (means or) or 1 (means and). Please verify the model code corresponding to the annotation \"%s\"", annotation);
-	for (int i = 0; i < num_children_timers; i ++) {
-		EXECUTION_REPORT(REPORT_ERROR, comp_id, timer_mgr->get_timer(children_timers_id[i]) != NULL, "Error happens when calling the API \"CCPL_define_complex_timer\": the %dth value in parameter \"children_timers_id\" is not a legal ID of a timer. Please verify the model code corresponding to the annotation \"%s\"", i, annotation);
-		children.push_back(timer_mgr->get_timer(children_timers_id[i]));
-		EXECUTION_REPORT(REPORT_ERROR, comp_id, children[i]->get_comp_id() == comp_id, "Error happens when calling the API \"CCPL_define_complex_timer\": all children timers (\"children_timers_id\") must be corresponding to the same component model with \"comp_id\". Please verify the model code corresponding to the annotation \"%s\"", annotation);
-	}
-	comp_time_mgr = components_time_mgrs->get_time_mgr(comp_id);
-	EXECUTION_REPORT(REPORT_ERROR, -1, comp_time_mgr != NULL, "Software error in Coupling_timer::Coupling_timer, with annotation \"%s\"", annotation);
-	annotation_mgr->add_annotation(timer_id, "define timer", annotation);
+    this->timer_id = timer_id;
+    this->comp_id = comp_id;
+    this->or_or_and = or_or_and;
+    EXECUTION_REPORT(REPORT_ERROR, comp_id, num_children_timers > 1, "Error happens when calling the API \"CCPL_define_complex_timer\": parameter num_children_timers cannot be smaller than 2. Please verify the model code corresponding to the annotation \"%s\"", annotation);
+    EXECUTION_REPORT(REPORT_ERROR, comp_id, or_or_and == 0 || or_or_and == 1, "Error happens when calling the API \"CCPL_define_complex_timer\": the value of the parameter \"OR_or_AND\" must be 0 (means or) or 1 (means and). Please verify the model code corresponding to the annotation \"%s\"", annotation);
+    for (int i = 0; i < num_children_timers; i ++) {
+        EXECUTION_REPORT(REPORT_ERROR, comp_id, timer_mgr->get_timer(children_timers_id[i]) != NULL, "Error happens when calling the API \"CCPL_define_complex_timer\": the %dth value in parameter \"children_timers_id\" is not a legal ID of a timer. Please verify the model code corresponding to the annotation \"%s\"", i, annotation);
+        children.push_back(timer_mgr->get_timer(children_timers_id[i]));
+        EXECUTION_REPORT(REPORT_ERROR, comp_id, children[i]->get_comp_id() == comp_id, "Error happens when calling the API \"CCPL_define_complex_timer\": all children timers (\"children_timers_id\") must be corresponding to the same component model with \"comp_id\". Please verify the model code corresponding to the annotation \"%s\"", annotation);
+    }
+    comp_time_mgr = components_time_mgrs->get_time_mgr(comp_id);
+    EXECUTION_REPORT(REPORT_ERROR, -1, comp_time_mgr != NULL, "Software error in Coupling_timer::Coupling_timer, with annotation \"%s\"", annotation);
+    annotation_mgr->add_annotation(timer_id, "define timer", annotation);
 }
 
 
@@ -77,54 +77,54 @@ Coupling_timer::Coupling_timer(int comp_id, int timer_id, const char *freq_unit,
 {
     strcpy(frequency_unit, freq_unit);
     this->frequency_count = freq_count;
-	this->local_lag_count = local_lag_count;
+    this->local_lag_count = local_lag_count;
     this->remote_lag_count = remote_lag_count;
-	this->timer_id = timer_id;
-	this->comp_id = comp_id;
-	this->or_or_and = -1;
-	comp_time_mgr = components_time_mgrs->get_time_mgr(comp_id);
-	EXECUTION_REPORT(REPORT_ERROR, -1, comp_time_mgr != NULL, "Software error in Coupling_timer::Coupling_timer, with annotation \"%s\"", annotation);
-	comp_time_mgr->check_timer_format(frequency_unit, frequency_count, local_lag_count, remote_lag_count, true, annotation);
-	annotation_mgr->add_annotation(timer_id, "define timer", annotation);
-	if (IS_TIME_UNIT_STEP(freq_unit)) {
-		EXECUTION_REPORT(REPORT_ERROR, -1, comp_time_mgr->get_time_step_in_second() > 0, "Software error in Coupling_timer::Coupling_timer: uninitialized time step");
-		strcpy(frequency_unit, FREQUENCY_UNIT_SECONDS);
-		frequency_count *= comp_time_mgr->get_time_step_in_second();
-		this->local_lag_count *= comp_time_mgr->get_time_step_in_second();
-		this->remote_lag_count *= comp_time_mgr->get_time_step_in_second();
-	}
+    this->timer_id = timer_id;
+    this->comp_id = comp_id;
+    this->or_or_and = -1;
+    comp_time_mgr = components_time_mgrs->get_time_mgr(comp_id);
+    EXECUTION_REPORT(REPORT_ERROR, -1, comp_time_mgr != NULL, "Software error in Coupling_timer::Coupling_timer, with annotation \"%s\"", annotation);
+    comp_time_mgr->check_timer_format(frequency_unit, frequency_count, local_lag_count, remote_lag_count, true, annotation);
+    annotation_mgr->add_annotation(timer_id, "define timer", annotation);
+    if (IS_TIME_UNIT_STEP(freq_unit)) {
+        EXECUTION_REPORT(REPORT_ERROR, -1, comp_time_mgr->get_time_step_in_second() > 0, "Software error in Coupling_timer::Coupling_timer: uninitialized time step");
+        strcpy(frequency_unit, FREQUENCY_UNIT_SECONDS);
+        frequency_count *= comp_time_mgr->get_time_step_in_second();
+        this->local_lag_count *= comp_time_mgr->get_time_step_in_second();
+        this->remote_lag_count *= comp_time_mgr->get_time_step_in_second();
+    }
 }
 
 
 Coupling_timer::Coupling_timer(int comp_id, int timer_id, Coupling_timer *existing_timer)
 {
-	frequency_count = existing_timer->frequency_count;
-	local_lag_count = existing_timer->local_lag_count;
-	remote_lag_count = existing_timer->remote_lag_count;
-	strcpy(frequency_unit, existing_timer->frequency_unit);
-	this->timer_id = timer_id;
-	this->comp_id = comp_id;
-	comp_time_mgr = components_time_mgrs->get_time_mgr(comp_id);
+    frequency_count = existing_timer->frequency_count;
+    local_lag_count = existing_timer->local_lag_count;
+    remote_lag_count = existing_timer->remote_lag_count;
+    strcpy(frequency_unit, existing_timer->frequency_unit);
+    this->timer_id = timer_id;
+    this->comp_id = comp_id;
+    comp_time_mgr = components_time_mgrs->get_time_mgr(comp_id);
 }
 
 
 Coupling_timer::Coupling_timer(const char *array_buffer, long &buffer_content_iter, int comp_id, bool report_check, bool &successful)
 {
-	int num_children;
-	long str_size;
-
-
-	load_string(frequency_unit, str_size, NAME_STR_SIZE, array_buffer, buffer_content_iter, NULL);
-	successful = read_data_from_array_buffer(&frequency_count, sizeof(int), array_buffer, buffer_content_iter, report_check);
-	successful = successful && read_data_from_array_buffer(&local_lag_count, sizeof(int), array_buffer, buffer_content_iter, report_check);
-	successful = successful && read_data_from_array_buffer(&remote_lag_count, sizeof(int), array_buffer, buffer_content_iter, report_check);
-	successful = successful && read_data_from_array_buffer(&num_children, sizeof(int), array_buffer, buffer_content_iter, report_check);
-	comp_time_mgr = components_time_mgrs->get_time_mgr(comp_id);
-	for (int i = 0; i < num_children; i ++) {
-		children.push_back(new Coupling_timer(array_buffer, buffer_content_iter, comp_id, report_check, successful));
-		timer_mgr->add_timer(children[i]);
-	}
-	timer_mgr->add_timer(this);
+    int num_children;
+    long str_size;
+
+
+    load_string(frequency_unit, str_size, NAME_STR_SIZE, array_buffer, buffer_content_iter, NULL);
+    successful = read_data_from_array_buffer(&frequency_count, sizeof(int), array_buffer, buffer_content_iter, report_check);
+    successful = successful && read_data_from_array_buffer(&local_lag_count, sizeof(int), array_buffer, buffer_content_iter, report_check);
+    successful = successful && read_data_from_array_buffer(&remote_lag_count, sizeof(int), array_buffer, buffer_content_iter, report_check);
+    successful = successful && read_data_from_array_buffer(&num_children, sizeof(int), array_buffer, buffer_content_iter, report_check);
+    comp_time_mgr = components_time_mgrs->get_time_mgr(comp_id);
+    for (int i = 0; i < num_children; i ++) {
+        children.push_back(new Coupling_timer(array_buffer, buffer_content_iter, comp_id, report_check, successful));
+        timer_mgr->add_timer(children[i]);
+    }
+    timer_mgr->add_timer(this);
 }
 
 
@@ -135,411 +135,412 @@ Coupling_timer::~Coupling_timer()
 
 void Coupling_timer::write_timer_into_array(char **array_buffer, long &buffer_max_size, long &buffer_content_size)
 {
-	int num_children = children.size();
-	for (int i = num_children-1; i >= 0; i --)
-		children[i]->write_timer_into_array(array_buffer, buffer_max_size, buffer_content_size);
-	write_data_into_array_buffer(&num_children, sizeof(int), array_buffer, buffer_max_size, buffer_content_size);
-	write_data_into_array_buffer(&remote_lag_count, sizeof(int), array_buffer, buffer_max_size, buffer_content_size);
-	write_data_into_array_buffer(&local_lag_count, sizeof(int), array_buffer, buffer_max_size, buffer_content_size);
-	write_data_into_array_buffer(&frequency_count, sizeof(int), array_buffer, buffer_max_size, buffer_content_size);
-	dump_string(frequency_unit, -1, array_buffer, buffer_max_size, buffer_content_size);
+    int num_children = children.size();
+    for (int i = num_children-1; i >= 0; i --)
+        children[i]->write_timer_into_array(array_buffer, buffer_max_size, buffer_content_size);
+    write_data_into_array_buffer(&num_children, sizeof(int), array_buffer, buffer_max_size, buffer_content_size);
+    write_data_into_array_buffer(&remote_lag_count, sizeof(int), array_buffer, buffer_max_size, buffer_content_size);
+    write_data_into_array_buffer(&local_lag_count, sizeof(int), array_buffer, buffer_max_size, buffer_content_size);
+    write_data_into_array_buffer(&frequency_count, sizeof(int), array_buffer, buffer_max_size, buffer_content_size);
+    dump_string(frequency_unit, -1, array_buffer, buffer_max_size, buffer_content_size);
 }
 
 
 bool Coupling_timer::is_timer_on(int current_year, int current_month, int current_day, int current_second, int current_num_elapsed_day,
-	                             int start_year, int start_month, int start_day, int start_second, int start_num_elapsed_day)
+                                 int start_year, int start_month, int start_day, int start_second, int start_num_elapsed_day)
 {
-	return common_is_timer_on(frequency_unit, frequency_count, local_lag_count, current_year,  
-		                      current_month, current_day, current_second, current_num_elapsed_day,
-	                          start_year, start_month, start_day, start_second, start_num_elapsed_day);
+    return common_is_timer_on(frequency_unit, frequency_count, local_lag_count, current_year,  
+                              current_month, current_day, current_second, current_num_elapsed_day,
+                              start_year, start_month, start_day, start_second, start_num_elapsed_day);
 }
 
 
-void Coupling_timer::get_time_of_next_timer_on(Time_mgt *time_mgr, int current_year, int current_month, int current_day, int current_second, int current_num_elapsed_days, int time_step_in_second, int &next_timer_num_elapsed_days, int &next_timer_second, bool advance)
-{	
-	if (advance)
-		time_mgr->advance_time(current_year, current_month, current_day, current_second, current_num_elapsed_days, time_step_in_second);
-	while (!is_timer_on(current_year, current_month, current_day, current_second, current_num_elapsed_days, time_mgr->get_start_year(), 
-		                time_mgr->get_start_month(), time_mgr->get_start_day(), time_mgr->get_start_second(), time_mgr->get_start_num_elapsed_day()))	
-		time_mgr->advance_time(current_year, current_month, current_day, current_second, current_num_elapsed_days, time_step_in_second);
+void Coupling_timer::get_time_of_next_timer_on(Time_mgt *time_mgr, int current_year, int current_month, int current_day, int current_second, int current_num_elapsed_days, int time_step_in_second, int &next_timer_num_elapsed_days, int &next_timer_date, int &next_timer_second, bool advance)
+{    
+    if (advance)
+        time_mgr->advance_time(current_year, current_month, current_day, current_second, current_num_elapsed_days, time_step_in_second);
+    while (!is_timer_on(current_year, current_month, current_day, current_second, current_num_elapsed_days, time_mgr->get_start_year(), 
+                        time_mgr->get_start_month(), time_mgr->get_start_day(), time_mgr->get_start_second(), time_mgr->get_start_num_elapsed_day()))    
+        time_mgr->advance_time(current_year, current_month, current_day, current_second, current_num_elapsed_days, time_step_in_second);
 
-	next_timer_num_elapsed_days = current_num_elapsed_days;
-	next_timer_second = current_second;
+    next_timer_num_elapsed_days = current_num_elapsed_days;
+	next_timer_date = current_year*10000 + current_month*100 + current_day;
+    next_timer_second = current_second;
 }
 
 
 bool Coupling_timer::is_timer_on()
 {
-	if (children.size() == 0)
-		return comp_time_mgr->is_timer_on(frequency_unit, frequency_count, local_lag_count);
-	else if (or_or_and == 0) { // or
-		for (int i = 0; i < children.size(); i ++)
-			if (children[i]->is_timer_on())
-				return true;
-		return false;
-	}
-	else {  // and
-		for (int i = 0; i < children.size(); i ++)
-			if (!children[i]->is_timer_on())
-				return false;
-		return true;	
-	}
+    if (children.size() == 0)
+        return comp_time_mgr->is_timer_on(frequency_unit, frequency_count, local_lag_count);
+    else if (or_or_and == 0) { // or
+        for (int i = 0; i < children.size(); i ++)
+            if (children[i]->is_timer_on())
+                return true;
+        return false;
+    }
+    else {  // and
+        for (int i = 0; i < children.size(); i ++)
+            if (!children[i]->is_timer_on())
+                return false;
+        return true;    
+    }
 }
 
 
 void Coupling_timer::check_timer_format()
 { 
-	comp_time_mgr->check_timer_format(frequency_unit, frequency_count, local_lag_count, remote_lag_count, false, NULL); 
+    comp_time_mgr->check_timer_format(frequency_unit, frequency_count, local_lag_count, remote_lag_count, false, NULL); 
 }
 
 
 bool Coupling_timer::is_the_same_with(Coupling_timer *another)
 {
-	if (this->frequency_count != another->frequency_count)
-		return false;
-	if (this->local_lag_count != another->local_lag_count)
-		return false;
-	if (this->remote_lag_count != another->remote_lag_count)
-		return false;
-	if (!words_are_the_same(this->frequency_unit, another->frequency_unit))
-		return false;
-	if (this->children.size() != another->children.size())
-		return false;
-	if (this->children.size() > 0) {
-		if (this->or_or_and != another->or_or_and)
-			return false;
-		for (int i = 0; i < this->children.size(); i ++)
-			if (!this->children[i]->is_the_same_with(another->children[i]))
-				return false;
-	}
-
-	return true;
+    if (this->frequency_count != another->frequency_count)
+        return false;
+    if (this->local_lag_count != another->local_lag_count)
+        return false;
+    if (this->remote_lag_count != another->remote_lag_count)
+        return false;
+    if (!words_are_the_same(this->frequency_unit, another->frequency_unit))
+        return false;
+    if (this->children.size() != another->children.size())
+        return false;
+    if (this->children.size() > 0) {
+        if (this->or_or_and != another->or_or_and)
+            return false;
+        for (int i = 0; i < this->children.size(); i ++)
+            if (!this->children[i]->is_the_same_with(another->children[i]))
+                return false;
+    }
+
+    return true;
 }
 
 
 Timer_mgt::~Timer_mgt()
 {
-	for (int i = 0; i < timers.size(); i ++) {
- 		delete timers[i];
-	}
+    for (int i = 0; i < timers.size(); i ++) {
+         delete timers[i];
+    }
 }
 
 
 void Timer_mgt::add_timer(Coupling_timer *timer)
 {
-	timers.push_back(timer);
+    timers.push_back(timer);
 }
 
 
 bool Timer_mgt::check_is_legal_timer_id(int timer_id)
 {
-	if ((timer_id & TYPE_ID_PREFIX_MASK) != TYPE_TIMER_ID_PREFIX)
-		return false;
+    if ((timer_id & TYPE_ID_PREFIX_MASK) != TYPE_TIMER_ID_PREFIX)
+        return false;
 
-	return (timer_id & TYPE_ID_SUFFIX_MASK) < timers.size();
+    return (timer_id & TYPE_ID_SUFFIX_MASK) < timers.size();
 }
 
 
 Coupling_timer *Timer_mgt::get_timer(int timer_id)
 {
-	if (!check_is_legal_timer_id(timer_id))
-		return NULL;
+    if (!check_is_legal_timer_id(timer_id))
+        return NULL;
 
-	return timers[timer_id&TYPE_ID_SUFFIX_MASK];
+    return timers[timer_id&TYPE_ID_SUFFIX_MASK];
 }
 
 
 int Timer_mgt::define_timer(int comp_id, const char *freq_unit, int freq_count, int local_lag_count, int remote_lag_count, const char *annotation)
 {
-	timers.push_back(new Coupling_timer(comp_id, TYPE_TIMER_ID_PREFIX|timers.size(), freq_unit, freq_count, local_lag_count, remote_lag_count, annotation));
- 	return timers[timers.size()-1]->get_timer_id();
+    timers.push_back(new Coupling_timer(comp_id, TYPE_TIMER_ID_PREFIX|timers.size(), freq_unit, freq_count, local_lag_count, remote_lag_count, annotation));
+     return timers[timers.size()-1]->get_timer_id();
 }
 
 
 int Timer_mgt::define_timer(int comp_id, int *timers_id, int num_timers, int array_size, int or_or_and, const char *annotation)
 {
-	EXECUTION_REPORT(REPORT_ERROR, comp_id, array_size >= num_timers, "Error happens when calling the API \"CCPL_define_complex_timer\": the array size of \"children_timers_id\" cannot be smaller than \"num_children_timers\". Please check the model code with the annotation \"%s\"", annotation);
-	timers.push_back(new Coupling_timer(comp_id, TYPE_TIMER_ID_PREFIX|timers.size(), timers_id, num_timers, or_or_and, annotation));
- 	return timers[timers.size()-1]->get_timer_id();
+    EXECUTION_REPORT(REPORT_ERROR, comp_id, array_size >= num_timers, "Error happens when calling the API \"CCPL_define_complex_timer\": the array size of \"children_timers_id\" cannot be smaller than \"num_children_timers\". Please check the model code with the annotation \"%s\"", annotation);
+    timers.push_back(new Coupling_timer(comp_id, TYPE_TIMER_ID_PREFIX|timers.size(), timers_id, num_timers, or_or_and, annotation));
+     return timers[timers.size()-1]->get_timer_id();
 }
 
 
 int Timer_mgt::define_timer(int comp_id, Coupling_timer *existing_timer)
 {
-	Coupling_timer *new_timer = new Coupling_timer(comp_id, TYPE_TIMER_ID_PREFIX|timers.size(), existing_timer);
-	timers.push_back(new_timer);
- 	return new_timer->get_timer_id();
+    Coupling_timer *new_timer = new Coupling_timer(comp_id, TYPE_TIMER_ID_PREFIX|timers.size(), existing_timer);
+    timers.push_back(new_timer);
+     return new_timer->get_timer_id();
 }
 
 
 bool Timer_mgt::is_timer_on(int timer_id, const char *annotation)
 {
-	EXECUTION_REPORT(REPORT_ERROR, -1, check_is_legal_timer_id(timer_id), "The timer id is wrong when checking whether a timer is on. Please check the model code with the annotation \"%s\"", annotation);
-	return timers[timer_id&TYPE_ID_SUFFIX_MASK]->is_timer_on();
+    EXECUTION_REPORT(REPORT_ERROR, -1, check_is_legal_timer_id(timer_id), "The timer id is wrong when checking whether a timer is on. Please check the model code with the annotation \"%s\"", annotation);
+    return timers[timer_id&TYPE_ID_SUFFIX_MASK]->is_timer_on();
 }
 
 
 bool Time_mgt::check_is_time_legal(int year, int month, int day, int second, const char *report_label)
 {
-	if (report_label != NULL) {
-		EXECUTION_REPORT(REPORT_ERROR,-1, year >= 0, "The time format is wrong: the year of simulation run can not be negative. Please check the model code with the annotation \"%s\"", report_label);
-		EXECUTION_REPORT(REPORT_ERROR,-1, second >=0 && second <= SECONDS_PER_DAY, "The time format is wrong: the second of simulation run must between 0 and SECONDS_PER_DAY. Please check the model code with the annotation \"%s\"", report_label);
-	   	EXECUTION_REPORT(REPORT_ERROR,-1, month >= 1 && month <= 12, "The time format is wrong: the month must be between 1 and 12. Please check the model code with the annotation \"%s\"", report_label);
-		if (leap_year_on && is_a_leap_year(year))
-        	EXECUTION_REPORT(REPORT_ERROR,-1, day >= 1 && day <= num_days_of_month_of_leap_year[month-1], "The time format is wrong: the day must be between 1 and %d. Please check the model code with the annotation \"%s\"", num_days_of_month_of_leap_year[month-1], report_label);
-		else EXECUTION_REPORT(REPORT_ERROR,-1, day >= 1 && day <= num_days_of_month_of_nonleap_year[month-1], "The time format is wrong: the day must be between 1 and %d. Please check the model code with the annotation \"%s\"", num_days_of_month_of_nonleap_year[month-1], report_label);
-		return true;
-	}
-	else {
-		if (!(year >= 0) || !(second >=0 && second <= SECONDS_PER_DAY) || !(month >= 1 && month <= 12))
-			return false;
-		if (leap_year_on && is_a_leap_year(year)) {
-			if (!(day >= 1 && day <= num_days_of_month_of_leap_year[month-1]))
-				return false;
-		}
-		else {
-			if (!(day >= 1 && day <= num_days_of_month_of_nonleap_year[month-1]))
-				return false;
-		}
-		return true;
-	}
+    if (report_label != NULL) {
+        EXECUTION_REPORT(REPORT_ERROR,-1, year >= 0, "The time format (%d-%d-%d-%d) is wrong: the year of simulation run can not be negative. Please check the model code with the annotation \"%s\"", year, month, day, second, report_label);
+        EXECUTION_REPORT(REPORT_ERROR,-1, second >=0 && second <= SECONDS_PER_DAY, "The time format (%d-%d-%d-%d) is wrong: the second of simulation run must between 0 and SECONDS_PER_DAY. Please check the model code with the annotation \"%s\"", year, month, day, second, report_label);
+           EXECUTION_REPORT(REPORT_ERROR,-1, month >= 1 && month <= 12, "The time format (%d-%d-%d-%d) is wrong: the month must be between 1 and 12. Please check the model code with the annotation \"%s\"", year, month, day, second, report_label);
+        if (leap_year_on && is_a_leap_year(year))
+            EXECUTION_REPORT(REPORT_ERROR,-1, day >= 1 && day <= num_days_of_month_of_leap_year[month-1], "The time format (%d-%d-%d-%d) is wrong: the day must be between 1 and %d. Please check the model code with the annotation \"%s\"", year, month, day, second, num_days_of_month_of_leap_year[month-1], report_label);
+        else EXECUTION_REPORT(REPORT_ERROR,-1, day >= 1 && day <= num_days_of_month_of_nonleap_year[month-1], "The time format (%d-%d-%d-%d) is wrong: the day must be between 1 and %d. Please check the model code with the annotation \"%s\"", year, month, day, second, num_days_of_month_of_nonleap_year[month-1], report_label);
+        return true;
+    }
+    else {
+        if (!(year >= 0) || !(second >=0 && second <= SECONDS_PER_DAY) || !(month >= 1 && month <= 12))
+            return false;
+        if (leap_year_on && is_a_leap_year(year)) {
+            if (!(day >= 1 && day <= num_days_of_month_of_leap_year[month-1]))
+                return false;
+        }
+        else {
+            if (!(day >= 1 && day <= num_days_of_month_of_nonleap_year[month-1]))
+                return false;
+        }
+        return true;
+    }
 }
 
 
 void Time_mgt::calculate_stop_time(int start_year, int start_month, int start_day, int start_second)
 {
-	long num_total_seconds;
-	
-
-	if (IS_TIME_UNIT_YEAR(stop_option)) {
-		stop_year = start_year + stop_n;
-		stop_month = start_month;
-		stop_day = start_day;
-		stop_second = start_second;
-		if (start_month == 2 && start_day == 29 && !is_a_leap_year(stop_year))
-			stop_day = 28;
-	}
-	else if (IS_TIME_UNIT_MONTH(stop_option)) {
-		stop_year = start_year + stop_n/12;
-		if (start_month + (stop_n%12) > 12) {
-			stop_year ++;
-			stop_month = (start_month + (stop_n%12)) - 12;
-		}
-		else stop_month = (start_month + (stop_n%12));
-		stop_day = start_day;
-		stop_second = start_second;
-		if (is_a_leap_year(stop_year) && num_days_of_month_of_leap_year[stop_month-1] < stop_day)
-			stop_day = num_days_of_month_of_leap_year[stop_month-1];
-		if (!is_a_leap_year(stop_year) && num_days_of_month_of_nonleap_year[stop_month-1] < stop_day)
-			stop_day = num_days_of_month_of_nonleap_year[stop_month-1]; 				
-	}
-	else {
-		int num_days = 0, num_hours = 0, num_minutes = 0, num_seconds = 0;
-		if (IS_TIME_UNIT_DAY(stop_option)) {
-			num_days = stop_n;
-			num_total_seconds = stop_n * SECONDS_PER_DAY;
-		}
-		else if (IS_TIME_UNIT_HOUR(stop_option)) {
-			num_days = stop_n/24;
-			num_hours = stop_n % 24;
-			num_total_seconds = stop_n * 3600;
-		}
-		else if (IS_TIME_UNIT_MINUTE(stop_option)) {
-			num_days = stop_n / 1440;
-			num_hours = (stop_n % 1440) / 60;
-			num_minutes = stop_n % 60;
-			num_total_seconds = stop_n * 60;
-		}
-		else {
-			num_days = stop_n / SECONDS_PER_DAY;
-			num_hours = (stop_n % SECONDS_PER_DAY) / 3600;
-			num_minutes = (stop_n % 3600) / 60;
-			num_seconds = stop_n % 60;
-			num_total_seconds = stop_n;
-		}
-		this->stop_year = -1;
-		this->stop_month = -1;
-		this->stop_day = -1;
-		this->stop_second = -1;
-		this->stop_num_elapsed_day = -1;
-		Time_mgt *cloned_time_mgr = clone_time_mgr(comp_id);
-		cloned_time_mgr->set_time_step_in_second(SECONDS_PER_DAY, "C-Coupler creates the time manager of a component", true);
-		for (int i = 0; i < num_days; i ++)
-			cloned_time_mgr->advance_model_time("in Time_mgt(...)", false);
-		cloned_time_mgr->set_time_step_in_second(3600, "C-Coupler creates the time manager of a component", true);
-		for (int i = 0; i < num_hours; i ++)
-			cloned_time_mgr->advance_model_time("in Time_mgt(...)", false);
-		cloned_time_mgr->set_time_step_in_second(60, "C-Coupler creates the time manager of a component", true);
-		for (int i = 0; i < num_minutes; i ++)
-			cloned_time_mgr->advance_model_time("in Time_mgt(...)", false);
-		cloned_time_mgr->set_time_step_in_second(1, "C-Coupler creates the time manager of a component", true);
-		for (int i = 0; i < num_seconds; i ++)
-			cloned_time_mgr->advance_model_time("in Time_mgt(...)", false);
-		this->stop_year = cloned_time_mgr->current_year;
-		this->stop_month = cloned_time_mgr->current_month;
-		this->stop_day = cloned_time_mgr->current_day;
-		this->stop_second = cloned_time_mgr->current_second;
-		delete cloned_time_mgr;
-		EXECUTION_REPORT(REPORT_ERROR, -1, num_total_seconds == (calculate_elapsed_day(stop_year,stop_month,stop_day)-current_num_elapsed_day)*((long)SECONDS_PER_DAY) + stop_second-start_second,
-						 "Software error in Time_mgt::Time_mgt: fail to caculate stop time according to stop_n");
-	}
+    long num_total_seconds;
+    
+
+    if (IS_TIME_UNIT_YEAR(stop_option)) {
+        stop_year = start_year + stop_n;
+        stop_month = start_month;
+        stop_day = start_day;
+        stop_second = start_second;
+        if (start_month == 2 && start_day == 29 && !is_a_leap_year(stop_year))
+            stop_day = 28;
+    }
+    else if (IS_TIME_UNIT_MONTH(stop_option)) {
+        stop_year = start_year + stop_n/12;
+        if (start_month + (stop_n%12) > 12) {
+            stop_year ++;
+            stop_month = (start_month + (stop_n%12)) - 12;
+        }
+        else stop_month = (start_month + (stop_n%12));
+        stop_day = start_day;
+        stop_second = start_second;
+        if (is_a_leap_year(stop_year) && num_days_of_month_of_leap_year[stop_month-1] < stop_day)
+            stop_day = num_days_of_month_of_leap_year[stop_month-1];
+        if (!is_a_leap_year(stop_year) && num_days_of_month_of_nonleap_year[stop_month-1] < stop_day)
+            stop_day = num_days_of_month_of_nonleap_year[stop_month-1];                 
+    }
+    else {
+        int num_days = 0, num_hours = 0, num_minutes = 0, num_seconds = 0;
+        if (IS_TIME_UNIT_DAY(stop_option)) {
+            num_days = stop_n;
+            num_total_seconds = stop_n * SECONDS_PER_DAY;
+        }
+        else if (IS_TIME_UNIT_HOUR(stop_option)) {
+            num_days = stop_n/24;
+            num_hours = stop_n % 24;
+            num_total_seconds = stop_n * 3600;
+        }
+        else if (IS_TIME_UNIT_MINUTE(stop_option)) {
+            num_days = stop_n / 1440;
+            num_hours = (stop_n % 1440) / 60;
+            num_minutes = stop_n % 60;
+            num_total_seconds = stop_n * 60;
+        }
+        else {
+            num_days = stop_n / SECONDS_PER_DAY;
+            num_hours = (stop_n % SECONDS_PER_DAY) / 3600;
+            num_minutes = (stop_n % 3600) / 60;
+            num_seconds = stop_n % 60;
+            num_total_seconds = stop_n;
+        }
+        this->stop_year = -1;
+        this->stop_month = -1;
+        this->stop_day = -1;
+        this->stop_second = -1;
+        this->stop_num_elapsed_day = -1;
+        Time_mgt *cloned_time_mgr = clone_time_mgr(comp_id);
+        cloned_time_mgr->set_time_step_in_second(SECONDS_PER_DAY, "C-Coupler creates the time manager of a component", true);
+        for (int i = 0; i < num_days; i ++)
+            cloned_time_mgr->advance_model_time("in Time_mgt(...)", false);
+        cloned_time_mgr->set_time_step_in_second(3600, "C-Coupler creates the time manager of a component", true);
+        for (int i = 0; i < num_hours; i ++)
+            cloned_time_mgr->advance_model_time("in Time_mgt(...)", false);
+        cloned_time_mgr->set_time_step_in_second(60, "C-Coupler creates the time manager of a component", true);
+        for (int i = 0; i < num_minutes; i ++)
+            cloned_time_mgr->advance_model_time("in Time_mgt(...)", false);
+        cloned_time_mgr->set_time_step_in_second(1, "C-Coupler creates the time manager of a component", true);
+        for (int i = 0; i < num_seconds; i ++)
+            cloned_time_mgr->advance_model_time("in Time_mgt(...)", false);
+        this->stop_year = cloned_time_mgr->current_year;
+        this->stop_month = cloned_time_mgr->current_month;
+        this->stop_day = cloned_time_mgr->current_day;
+        this->stop_second = cloned_time_mgr->current_second;
+        delete cloned_time_mgr;
+        EXECUTION_REPORT(REPORT_ERROR, -1, num_total_seconds == (calculate_elapsed_day(stop_year,stop_month,stop_day)-current_num_elapsed_day)*((long)SECONDS_PER_DAY) + stop_second-start_second,
+                         "Software error in Time_mgt::Time_mgt: fail to caculate stop time according to stop_n");
+    }
 }
 
 
 Time_mgt::Time_mgt(int comp_id, const char *XML_file_name, bool is_for_root_comp)
 {
-	int line_number;
-
-	
-	time_step_in_second = -1;
-	case_desc[0] = '\0';
-
-	EXECUTION_REPORT(REPORT_ERROR, -1, comp_comm_group_mgt_mgr->is_legal_local_comp_id(comp_id,false), "Software error in Time_mgt::Time_mgt: wrong component id");
-	this->comp_id = comp_id;
-	this->restart_timer = NULL;
-	this->advance_time_synchronized = false;
-	this->time_has_been_advanced = false;
-	{
-		int start_date, stop_date, reference_date, rest_freq_count, time_step;
-		long num_total_seconds;
-		TiXmlDocument XML_file(XML_file_name);
-		EXECUTION_REPORT(REPORT_ERROR, -1, XML_file.LoadFile(MPI_COMM_WORLD), "Fail to read XML file \"%s\" with the time information setting. The XML file may not exist or may not be a legal XML file. Please check.", XML_file_name);
-		TiXmlElement *XML_element = XML_file.FirstChildElement();
-		const char *exp_model_name = get_XML_attribute(-1, CCPL_NAME_STR_LEN, XML_element, "model_name", XML_file_name, line_number, "the name of the model for the simulation", "the overall parameters to run the model", true);
-		strcpy(this->exp_model_name, exp_model_name);	
-		const char *case_name = get_XML_attribute(-1, CCPL_NAME_STR_LEN, XML_element, "case_name", XML_file_name, line_number, "the name of the simulation", "the overall parameters to run the model", true);
-		strcpy(this->case_name, case_name);
-		const char *case_desc = XML_element->Attribute("case_description", &line_number);
-		if (case_desc != NULL) {
-			check_XML_attribute_value_string_length(-1, 1000, "case_description", case_desc, XML_file_name, line_number);
-			strcpy(this->case_desc, case_desc);
-		}
-		EXECUTION_REPORT(REPORT_WARNING, -1, case_desc != NULL, "The description of the current simulation is unset or the format of the XML file is wrong. ");
-		const char *run_type = get_XML_attribute(-1, -1, XML_element, "run_type", XML_file_name, line_number, "the type to run the model", "the overall parameters to run the model", true);
-		EXECUTION_REPORT(REPORT_ERROR, -1, words_are_the_same(run_type,RUNTYPE_INITIAL) || words_are_the_same(run_type,RUNTYPE_CONTINUE) || words_are_the_same(run_type,RUNTYPE_BRANCH) || words_are_the_same(run_type,RUNTYPE_HYBRID),
-			             "Run_type (%s) is wrong. It must be one of the four options: \"initial\", \"continue\", \"branch\" and \"hybrid\". Please check the XML file \"%s\" arround the line_number %d", run_type, XML_file_name, line_number);
-		strcpy(this->run_type, run_type);
-		if (words_are_the_same(run_type,RUNTYPE_INITIAL))
-			runtype_mark = RUNTYPE_MARK_INITIAL;
-		else if (words_are_the_same(run_type,RUNTYPE_CONTINUE))
-			runtype_mark = RUNTYPE_MARK_CONTINUE;
-		else if (words_are_the_same(run_type,RUNTYPE_BRANCH))
-			runtype_mark = RUNTYPE_MARK_BRANCH;
-		else runtype_mark = RUNTYPE_MARK_HYBRID;
-		if (words_are_the_same(run_type,RUNTYPE_BRANCH) || words_are_the_same(run_type,RUNTYPE_HYBRID)) {
-			const char *rest_refcase = get_XML_attribute(-1, CCPL_NAME_STR_LEN, XML_element, "rest_ref_case", XML_file_name, line_number, "the name of the reference case for branch run of hybrid run", "the overall parameters to run the model", true);
-			strcpy(this->rest_refcase, rest_refcase);
-			const char *refdate_string = get_XML_attribute(-1, -1, XML_element, "rest_ref_date", XML_file_name, line_number, "the date of the reference case for branch run of hybrid run", "the overall parameters to run the model", true);	
-			EXECUTION_REPORT(REPORT_ERROR, -1, is_string_decimal_number(refdate_string), "Error happens when using the XML configuration file \"%s\": the value (\"%s\") of the attribute \"%s\" is not a decimal integer. Please verify the XML file around the line %d", XML_file_name, refdate_string, "rest_ref_date", line_number);
-			EXECUTION_REPORT(REPORT_ERROR, -1, sscanf(refdate_string, "%d", &rest_refdate) == 1, "Software error in Time_mgt::Time_mgt");
-			EXECUTION_REPORT(REPORT_ERROR, -1, check_is_time_legal(rest_refdate/10000, (rest_refdate%10000)/100, rest_refdate%100, 0, NULL), "The date of the reference case for branch run of hybrid run is a wrong date. Please check the XML file \"%s\" arround the line_number %d", XML_file_name, line_number);
-			const char *refsecond_string = get_XML_attribute(-1, -1, XML_element, "rest_ref_second", XML_file_name, line_number, "The second of the reference case for branch run of hybrid run", "the overall parameters to run the model", true);
-			EXECUTION_REPORT(REPORT_ERROR, -1, is_string_decimal_number(refsecond_string), "Error happens when using the XML configuration file \"%s\": the value (\"%s\") of the attribute \"%s\" is not a decimal integer. Please verify the XML file around the line %d", XML_file_name, refsecond_string, "rest_ref_second", line_number);
-			EXECUTION_REPORT(REPORT_ERROR, -1, sscanf(refsecond_string, "%d", &rest_refsecond) == 1, "Software error in Time_mgt::Time_mgt"); 	
-			EXECUTION_REPORT(REPORT_ERROR, -1, check_is_time_legal(rest_refdate/10000, (rest_refdate%10000)/100, rest_refdate%100, rest_refsecond, NULL), "The \"rest_ref_second\" (%d) specified is a wrong second number in a day. Please check the XML file \"%s\" arround the line_number %d", rest_refsecond, XML_file_name, line_number);
-		}
-		else {
-			rest_refcase[0] = '\0';
-			rest_refdate = -1;
-			rest_refsecond = -1;
-		}
-		const char *leap_year_string = get_XML_attribute(-1, -1, XML_element, "leap_year", XML_file_name, line_number, "whether leap year is on in the simulation", "the overall parameters to run the model", true);
-		EXECUTION_REPORT(REPORT_ERROR, -1, words_are_the_same(leap_year_string, "on") || words_are_the_same(leap_year_string, "off"),
-			             "The value of leap year wrong. Its value must be \"on\" or \"off\". Please check the XML file \"%s\" arround the line_number %d", XML_file_name, line_number);
-		if (words_are_the_same(leap_year_string, "on"))
-			leap_year_on = true;
-		else leap_year_on = false;
-		const char *start_date_string = get_XML_attribute(-1, -1, XML_element, "start_date", XML_file_name, line_number, "the start date to run the simulation", "the overall parameters to run the model", true);		
-		EXECUTION_REPORT(REPORT_ERROR, -1, is_string_decimal_number(start_date_string), "Error happens when using the XML configuration file \"%s\": the value (\"%s\") of the attribute \"%s\" is not a decimal integer. Please verify the XML file around the line %d", XML_file_name, start_date_string, "start_date", line_number);
-		EXECUTION_REPORT(REPORT_ERROR, -1, sscanf(start_date_string, "%d", &start_date) == 1, "Software error in Time_mgt::Time_mgt");
-		restart_second = -1;
-		restart_num_elapsed_day = -1;
-		restart_full_time = -1;
-		common_restart_full_time = -1;
-	    start_year = start_date / 10000;
-    	start_month = (start_date%10000) / 100;
-    	start_day = start_date % 100;
-		EXECUTION_REPORT(REPORT_ERROR, -1, check_is_time_legal(start_year, start_month, start_day, 0, NULL), "The start date specified is a wrong date. Please check the XML file \"%s\" arround the line_number %d", XML_file_name, line_number);
-		const char *start_second_string = get_XML_attribute(-1, -1, XML_element, "start_second", XML_file_name, line_number, "the start second to run the simulation", "the overall parameters to run the model", true);
-		EXECUTION_REPORT(REPORT_ERROR, -1, is_string_decimal_number(start_second_string), "Error happens when using the XML configuration file \"%s\": the value (\"%s\") of the attribute \"%s\" is not a decimal integer. Please verify the XML file around the line %d", XML_file_name, start_second_string, "start_second", line_number);
-		EXECUTION_REPORT(REPORT_ERROR, -1, sscanf(start_second_string, "%d", &this->start_second) == 1, "Software error in Time_mgt::Time_mgt");		
-		EXECUTION_REPORT(REPORT_ERROR, -1, check_is_time_legal(start_year, start_month, start_day, start_second, NULL), "The start second (%d) specified is a wrong second number in a day. Please check the XML file \"%s\" arround the line_number %d", start_second, XML_file_name, line_number);
-		current_num_elapsed_day = calculate_elapsed_day(start_year,start_month,start_day);
-		current_year = start_year;
-		current_month = start_month;
-		current_day = start_day;
-		current_second = start_second;
-		current_num_elapsed_day = calculate_elapsed_day(start_year,start_month,start_day);
-		start_num_elapsed_day = current_num_elapsed_day;
-		const char *reference_date_string = XML_element->Attribute("reference_date", &line_number);
-		if (reference_date_string != NULL) {			
-			EXECUTION_REPORT(REPORT_ERROR, -1, is_string_decimal_number(reference_date_string), "Error happens when using the XML configuration file \"%s\": the value (\"%s\") of the attribute \"%s\" is not a decimal integer. Please verify the XML file around the line %d", XML_file_name, reference_date_string, "reference_date", line_number);
-			EXECUTION_REPORT(REPORT_ERROR, -1, sscanf(reference_date_string, "%d", &reference_date) == 1, "Software error in Time_mgt::Time_mgt");
-			reference_year = reference_date / 10000;
-			reference_month = (reference_date%10000) / 100;
-			reference_day = reference_date % 100;
-			EXECUTION_REPORT(REPORT_ERROR, -1, check_is_time_legal(reference_year, reference_month, reference_day, 0, NULL), "The reference date specified is a wrong date. Please check the XML file \"%s\" arround the line_number %d", XML_file_name, line_number);			
-		}
-		else {
-			reference_year = 0;
-			reference_month = 1;
-			reference_day = 1;
-		}
-		const char *rest_freq_unit = get_XML_attribute(-1, -1, XML_element, "rest_freq_unit", XML_file_name, line_number, "the unit of the frequency of writing restart data files", "the overall parameters to run the model", true);		
-		EXECUTION_REPORT(REPORT_ERROR, -1, words_are_the_same(rest_freq_unit, "none") || IS_TIME_UNIT_YEAR(rest_freq_unit) || IS_TIME_UNIT_SECOND(rest_freq_unit) || IS_TIME_UNIT_DAY(rest_freq_unit) || IS_TIME_UNIT_MONTH(rest_freq_unit),
-			             "The time unit for the frequency of writing restart files (rest_freq_unit) must be one of the following options: \"none\", %s, %s, %s, %s. Please check the XML file \"%s\" arround the line_number %d", TIME_UNIT_STRING_SECOND, TIME_UNIT_STRING_DAY, TIME_UNIT_STRING_MONTH, TIME_UNIT_STRING_YEAR, XML_file_name, line_number);
-		strcpy(this->rest_freq_unit, rest_freq_unit);
-		this->rest_freq_count = 0;
-		if (!words_are_the_same(rest_freq_unit, "none")) {
-			const char *rest_freq_count_string = get_XML_attribute(-1, -1, XML_element, "rest_freq_count", XML_file_name, line_number, "the count of the frequency of writing restart data files", "the overall parameters to run the model", true);		
-			EXECUTION_REPORT(REPORT_ERROR, -1, is_string_decimal_number(rest_freq_count_string), "Error happens when using the XML configuration file \"%s\": the value (\"%s\") of the attribute \"%s\" is not a decimal integer. Please verify the XML file around the line %d", XML_file_name, rest_freq_count_string, "rest_freq_count", line_number);			
-			EXECUTION_REPORT(REPORT_ERROR, -1, sscanf(rest_freq_count_string, "%d", &rest_freq_count) == 1, "Software error in Time_mgt::Time_mgt");
-			EXECUTION_REPORT(REPORT_ERROR, -1, rest_freq_count > 0, "The count of time unit for the frequency of writing restart files (rest_freq_count) must be a possitive value. Please check the XML file \"%s\" arround the line_number %d", XML_file_name, line_number);
-			this->rest_freq_count = rest_freq_count;
-		}
-		const char *stop_option = get_XML_attribute(-1, -1, XML_element, "stop_option", XML_file_name, line_number, "the option to specify the end of the simulation", "the overall parameters to run the model", true);
-		EXECUTION_REPORT(REPORT_ERROR, -1, words_are_the_same(stop_option, "date") || IS_TIME_UNIT_SECOND(stop_option) || IS_TIME_UNIT_MINUTE(stop_option) || IS_TIME_UNIT_HOUR(stop_option) || IS_TIME_UNIT_DAY(stop_option) || IS_TIME_UNIT_MONTH(stop_option) || IS_TIME_UNIT_YEAR(stop_option),
-			             "The stop option is wrong. It must be one of the following options: \"date\", %s, %s, %s, %s, %s, %s. Please check the XML file \"%s\" arround the line_number %d", TIME_UNIT_STRING_SECOND, TIME_UNIT_STRING_MINUTE, TIME_UNIT_STRING_HOUR, TIME_UNIT_STRING_DAY, TIME_UNIT_STRING_MONTH, TIME_UNIT_STRING_YEAR, XML_file_name, line_number);
-		strcpy(this->stop_option, stop_option);
-		if (words_are_the_same(stop_option, "date")) {
-			const char *stop_date_string = get_XML_attribute(-1, -1, XML_element, "stop_date", XML_file_name, line_number, "the date to stop the simulation", "the overall parameters to run the model", true);
-			EXECUTION_REPORT(REPORT_ERROR, -1, is_string_decimal_number(stop_date_string), "Error happens when using the XML configuration file \"%s\": the value (\"%s\") of the attribute \"%s\" is not a decimal integer. Please verify the XML file around the line %d", XML_file_name, stop_date_string, "stop_date", line_number);						
-			EXECUTION_REPORT(REPORT_ERROR, -1, sscanf(stop_date_string, "%d", &stop_date), "Software error in Time_mgt::Time_mgt");
-			stop_year = stop_date / 10000;
-			stop_month = (stop_date%10000) / 100;
-			stop_day = stop_date % 100;
-			EXECUTION_REPORT(REPORT_ERROR, -1, check_is_time_legal(stop_year, stop_month, stop_day, 0, NULL), "The stop date specified is a wrong date. Please check the XML file \"%s\" arround the line_number %d", XML_file_name, line_number);
-			const char *stop_second_string = get_XML_attribute(-1, -1, XML_element, "stop_second", XML_file_name, line_number, "the second to stop the simulation", "the overall parameters to run the model", true);
-			EXECUTION_REPORT(REPORT_ERROR, -1, is_string_decimal_number(stop_second_string), "Error happens when using the XML configuration file \"%s\": the value (\"%s\") of the attribute \"%s\" is not a decimal integer. Please verify the XML file around the line %d", XML_file_name, stop_second_string, "stop_second", line_number);									
-			EXECUTION_REPORT(REPORT_ERROR, -1, sscanf(stop_second_string, "%d", &this->stop_second), "Software error in Time_mgt::Time_mgt"); 	
-			EXECUTION_REPORT(REPORT_ERROR, -1, check_is_time_legal(stop_year, stop_month, stop_day, stop_second, NULL), "The stop second specified is a wrong second number in a day. Please check the XML file \"%s\" arround the line_number %d", XML_file_name, line_number);
-			num_total_seconds = (calculate_elapsed_day(stop_year,stop_month,stop_day)-current_num_elapsed_day)*((long)SECONDS_PER_DAY) + stop_second-start_second;
-			EXECUTION_REPORT(REPORT_ERROR, -1, num_total_seconds > 0, "The stop time of simulation is wrong. It must be after the start time. Please check the XML file \"%s\" arround the line_number %d", XML_file_name, line_number);
-		}
-		else {
-			const char *stop_n_string = get_XML_attribute(-1, -1, XML_element, "stop_n", XML_file_name, line_number, "the count for stopping the simulation", "the overall parameters to run the model", true);
-			EXECUTION_REPORT(REPORT_ERROR, -1, is_string_decimal_number(stop_n_string), "Error happens when using the XML configuration file \"%s\": the value (\"%s\") of the attribute \"%s\" is not a decimal integer. Please verify the XML file around the line %d", XML_file_name, stop_n_string, "stop_n", line_number);												
-			EXECUTION_REPORT(REPORT_ERROR, -1, sscanf(stop_n_string, "%d", &stop_n), "Software error in Time_mgt::Time_mgt"); 
-			if (stop_n == -999)
-				stop_year = stop_month = stop_day = stop_second = -1;
-			else {
-				calculate_stop_time(start_year, start_month, start_day, start_second);				
-				EXECUTION_REPORT(REPORT_ERROR, -1, check_is_time_legal(stop_year,stop_month,stop_day,stop_second,"Software error in Time_mgt::Time_mgt: wrong stop time generated by C-Coupler."));
-			}
-			EXECUTION_REPORT_LOG(REPORT_LOG, -1, true, "The stop time generated by C-Coupler according to the users' specification is %04d%02d%02d-%05d", stop_year, stop_month, stop_day, stop_second);
-		}
-	}
-
-	num_total_steps = -1;
-	initialize_to_start_time();
-
-	if (is_for_root_comp && runtype_mark == RUNTYPE_MARK_CONTINUE) {
-		if (comp_comm_group_mgt_mgr->get_current_proc_global_id() == 0)
-			common_restart_full_time = determine_continue_run_restart_time();
-		MPI_Bcast(&common_restart_full_time, 1, MPI_LONG, 0, MPI_COMM_WORLD);
-		EXECUTION_REPORT_LOG(REPORT_LOG, comp_id, true, "The restart time determined by the rpointer files is %ld", common_restart_full_time);
-		EXECUTION_REPORT(REPORT_ERROR, comp_id, common_restart_full_time != -1, "Error happens when starting the continue run: fail to find a common restart time according to the rpointer files among a component models");
-	}
+    int line_number;
+
+    
+    time_step_in_second = -1;
+    case_desc[0] = '\0';
+
+    EXECUTION_REPORT(REPORT_ERROR, -1, comp_comm_group_mgt_mgr->is_legal_local_comp_id(comp_id,false), "Software error in Time_mgt::Time_mgt: wrong component id");
+    this->comp_id = comp_id;
+    this->restart_timer = NULL;
+    this->advance_time_synchronized = false;
+    this->time_has_been_advanced = false;
+    {
+        int start_date, stop_date, reference_date, rest_freq_count, time_step;
+        long num_total_seconds;
+        TiXmlDocument XML_file(XML_file_name);
+        EXECUTION_REPORT(REPORT_ERROR, -1, XML_file.LoadFile(MPI_COMM_WORLD), "Fail to read XML file \"%s\" with the time information setting. The XML file may not exist or may not be a legal XML file. Please check.", XML_file_name);
+        TiXmlElement *XML_element = XML_file.FirstChildElement();
+        const char *exp_model_name = get_XML_attribute(-1, CCPL_NAME_STR_LEN, XML_element, "model_name", XML_file_name, line_number, "the name of the model for the simulation", "the overall parameters to run the model", true);
+        strcpy(this->exp_model_name, exp_model_name);    
+        const char *case_name = get_XML_attribute(-1, CCPL_NAME_STR_LEN, XML_element, "case_name", XML_file_name, line_number, "the name of the simulation", "the overall parameters to run the model", true);
+        strcpy(this->case_name, case_name);
+        const char *case_desc = XML_element->Attribute("case_description", &line_number);
+        if (case_desc != NULL) {
+            check_XML_attribute_value_string_length(-1, 1000, "case_description", case_desc, XML_file_name, line_number);
+            strcpy(this->case_desc, case_desc);
+        }
+        EXECUTION_REPORT(REPORT_WARNING, -1, case_desc != NULL, "The description of the current simulation is unset or the format of the XML file is wrong. ");
+        const char *run_type = get_XML_attribute(-1, -1, XML_element, "run_type", XML_file_name, line_number, "the type to run the model", "the overall parameters to run the model", true);
+        EXECUTION_REPORT(REPORT_ERROR, -1, words_are_the_same(run_type,RUNTYPE_INITIAL) || words_are_the_same(run_type,RUNTYPE_CONTINUE) || words_are_the_same(run_type,RUNTYPE_BRANCH) || words_are_the_same(run_type,RUNTYPE_HYBRID),
+                         "Run_type (%s) is wrong. It must be one of the four options: \"initial\", \"continue\", \"branch\" and \"hybrid\". Please check the XML file \"%s\" arround the line_number %d", run_type, XML_file_name, line_number);
+        strcpy(this->run_type, run_type);
+        if (words_are_the_same(run_type,RUNTYPE_INITIAL))
+            runtype_mark = RUNTYPE_MARK_INITIAL;
+        else if (words_are_the_same(run_type,RUNTYPE_CONTINUE))
+            runtype_mark = RUNTYPE_MARK_CONTINUE;
+        else if (words_are_the_same(run_type,RUNTYPE_BRANCH))
+            runtype_mark = RUNTYPE_MARK_BRANCH;
+        else runtype_mark = RUNTYPE_MARK_HYBRID;
+        if (words_are_the_same(run_type,RUNTYPE_BRANCH) || words_are_the_same(run_type,RUNTYPE_HYBRID)) {
+            const char *rest_refcase = get_XML_attribute(-1, CCPL_NAME_STR_LEN, XML_element, "rest_ref_case", XML_file_name, line_number, "the name of the reference case for branch run of hybrid run", "the overall parameters to run the model", true);
+            strcpy(this->rest_refcase, rest_refcase);
+            const char *refdate_string = get_XML_attribute(-1, -1, XML_element, "rest_ref_date", XML_file_name, line_number, "the date of the reference case for branch run of hybrid run", "the overall parameters to run the model", true);    
+            EXECUTION_REPORT(REPORT_ERROR, -1, is_string_decimal_number(refdate_string), "Error happens when using the XML configuration file \"%s\": the value (\"%s\") of the attribute \"%s\" is not a decimal integer. Please verify the XML file around the line %d", XML_file_name, refdate_string, "rest_ref_date", line_number);
+            EXECUTION_REPORT(REPORT_ERROR, -1, sscanf(refdate_string, "%d", &rest_refdate) == 1, "Software error in Time_mgt::Time_mgt");
+            EXECUTION_REPORT(REPORT_ERROR, -1, check_is_time_legal(rest_refdate/10000, (rest_refdate%10000)/100, rest_refdate%100, 0, NULL), "The date of the reference case for branch run of hybrid run is a wrong date. Please check the XML file \"%s\" arround the line_number %d", XML_file_name, line_number);
+            const char *refsecond_string = get_XML_attribute(-1, -1, XML_element, "rest_ref_second", XML_file_name, line_number, "The second of the reference case for branch run of hybrid run", "the overall parameters to run the model", true);
+            EXECUTION_REPORT(REPORT_ERROR, -1, is_string_decimal_number(refsecond_string), "Error happens when using the XML configuration file \"%s\": the value (\"%s\") of the attribute \"%s\" is not a decimal integer. Please verify the XML file around the line %d", XML_file_name, refsecond_string, "rest_ref_second", line_number);
+            EXECUTION_REPORT(REPORT_ERROR, -1, sscanf(refsecond_string, "%d", &rest_refsecond) == 1, "Software error in Time_mgt::Time_mgt");     
+            EXECUTION_REPORT(REPORT_ERROR, -1, check_is_time_legal(rest_refdate/10000, (rest_refdate%10000)/100, rest_refdate%100, rest_refsecond, NULL), "The \"rest_ref_second\" (%d) specified is a wrong second number in a day. Please check the XML file \"%s\" arround the line_number %d", rest_refsecond, XML_file_name, line_number);
+        }
+        else {
+            rest_refcase[0] = '\0';
+            rest_refdate = -1;
+            rest_refsecond = -1;
+        }
+        const char *leap_year_string = get_XML_attribute(-1, -1, XML_element, "leap_year", XML_file_name, line_number, "whether leap year is on in the simulation", "the overall parameters to run the model", true);
+        EXECUTION_REPORT(REPORT_ERROR, -1, words_are_the_same(leap_year_string, "on") || words_are_the_same(leap_year_string, "off"),
+                         "The value of leap year wrong. Its value must be \"on\" or \"off\". Please check the XML file \"%s\" arround the line_number %d", XML_file_name, line_number);
+        if (words_are_the_same(leap_year_string, "on"))
+            leap_year_on = true;
+        else leap_year_on = false;
+        const char *start_date_string = get_XML_attribute(-1, -1, XML_element, "start_date", XML_file_name, line_number, "the start date to run the simulation", "the overall parameters to run the model", true);        
+        EXECUTION_REPORT(REPORT_ERROR, -1, is_string_decimal_number(start_date_string), "Error happens when using the XML configuration file \"%s\": the value (\"%s\") of the attribute \"%s\" is not a decimal integer. Please verify the XML file around the line %d", XML_file_name, start_date_string, "start_date", line_number);
+        EXECUTION_REPORT(REPORT_ERROR, -1, sscanf(start_date_string, "%d", &start_date) == 1, "Software error in Time_mgt::Time_mgt");
+        restart_second = -1;
+        restart_num_elapsed_day = -1;
+        restart_full_time = -1;
+        common_restart_full_time = -1;
+        start_year = start_date / 10000;
+        start_month = (start_date%10000) / 100;
+        start_day = start_date % 100;
+        EXECUTION_REPORT(REPORT_ERROR, -1, check_is_time_legal(start_year, start_month, start_day, 0, NULL), "The start date specified is a wrong date. Please check the XML file \"%s\" arround the line_number %d", XML_file_name, line_number);
+        const char *start_second_string = get_XML_attribute(-1, -1, XML_element, "start_second", XML_file_name, line_number, "the start second to run the simulation", "the overall parameters to run the model", true);
+        EXECUTION_REPORT(REPORT_ERROR, -1, is_string_decimal_number(start_second_string), "Error happens when using the XML configuration file \"%s\": the value (\"%s\") of the attribute \"%s\" is not a decimal integer. Please verify the XML file around the line %d", XML_file_name, start_second_string, "start_second", line_number);
+        EXECUTION_REPORT(REPORT_ERROR, -1, sscanf(start_second_string, "%d", &this->start_second) == 1, "Software error in Time_mgt::Time_mgt");        
+        EXECUTION_REPORT(REPORT_ERROR, -1, check_is_time_legal(start_year, start_month, start_day, start_second, NULL), "The start second (%d) specified is a wrong second number in a day. Please check the XML file \"%s\" arround the line_number %d", start_second, XML_file_name, line_number);
+        current_num_elapsed_day = calculate_elapsed_day(start_year,start_month,start_day);
+        current_year = start_year;
+        current_month = start_month;
+        current_day = start_day;
+        current_second = start_second;
+        current_num_elapsed_day = calculate_elapsed_day(start_year,start_month,start_day);
+        start_num_elapsed_day = current_num_elapsed_day;
+        const char *reference_date_string = XML_element->Attribute("reference_date", &line_number);
+        if (reference_date_string != NULL) {            
+            EXECUTION_REPORT(REPORT_ERROR, -1, is_string_decimal_number(reference_date_string), "Error happens when using the XML configuration file \"%s\": the value (\"%s\") of the attribute \"%s\" is not a decimal integer. Please verify the XML file around the line %d", XML_file_name, reference_date_string, "reference_date", line_number);
+            EXECUTION_REPORT(REPORT_ERROR, -1, sscanf(reference_date_string, "%d", &reference_date) == 1, "Software error in Time_mgt::Time_mgt");
+            reference_year = reference_date / 10000;
+            reference_month = (reference_date%10000) / 100;
+            reference_day = reference_date % 100;
+            EXECUTION_REPORT(REPORT_ERROR, -1, check_is_time_legal(reference_year, reference_month, reference_day, 0, NULL), "The reference date specified is a wrong date. Please check the XML file \"%s\" arround the line_number %d", XML_file_name, line_number);            
+        }
+        else {
+            reference_year = 0;
+            reference_month = 1;
+            reference_day = 1;
+        }
+        const char *rest_freq_unit = get_XML_attribute(-1, -1, XML_element, "rest_freq_unit", XML_file_name, line_number, "the unit of the frequency of writing restart data files", "the overall parameters to run the model", true);        
+        EXECUTION_REPORT(REPORT_ERROR, -1, words_are_the_same(rest_freq_unit, "none") || IS_TIME_UNIT_YEAR(rest_freq_unit) || IS_TIME_UNIT_SECOND(rest_freq_unit) || IS_TIME_UNIT_DAY(rest_freq_unit) || IS_TIME_UNIT_MONTH(rest_freq_unit),
+                         "The time unit for the frequency of writing restart files (rest_freq_unit) must be one of the following options: \"none\", %s, %s, %s, %s. Please check the XML file \"%s\" arround the line_number %d", TIME_UNIT_STRING_SECOND, TIME_UNIT_STRING_DAY, TIME_UNIT_STRING_MONTH, TIME_UNIT_STRING_YEAR, XML_file_name, line_number);
+        strcpy(this->rest_freq_unit, rest_freq_unit);
+        this->rest_freq_count = 0;
+        if (!words_are_the_same(rest_freq_unit, "none")) {
+            const char *rest_freq_count_string = get_XML_attribute(-1, -1, XML_element, "rest_freq_count", XML_file_name, line_number, "the count of the frequency of writing restart data files", "the overall parameters to run the model", true);        
+            EXECUTION_REPORT(REPORT_ERROR, -1, is_string_decimal_number(rest_freq_count_string), "Error happens when using the XML configuration file \"%s\": the value (\"%s\") of the attribute \"%s\" is not a decimal integer. Please verify the XML file around the line %d", XML_file_name, rest_freq_count_string, "rest_freq_count", line_number);            
+            EXECUTION_REPORT(REPORT_ERROR, -1, sscanf(rest_freq_count_string, "%d", &rest_freq_count) == 1, "Software error in Time_mgt::Time_mgt");
+            EXECUTION_REPORT(REPORT_ERROR, -1, rest_freq_count > 0, "The count of time unit for the frequency of writing restart files (rest_freq_count) must be a possitive value. Please check the XML file \"%s\" arround the line_number %d", XML_file_name, line_number);
+            this->rest_freq_count = rest_freq_count;
+        }
+        const char *stop_option = get_XML_attribute(-1, -1, XML_element, "stop_option", XML_file_name, line_number, "the option to specify the end of the simulation", "the overall parameters to run the model", true);
+        EXECUTION_REPORT(REPORT_ERROR, -1, words_are_the_same(stop_option, "date") || IS_TIME_UNIT_SECOND(stop_option) || IS_TIME_UNIT_MINUTE(stop_option) || IS_TIME_UNIT_HOUR(stop_option) || IS_TIME_UNIT_DAY(stop_option) || IS_TIME_UNIT_MONTH(stop_option) || IS_TIME_UNIT_YEAR(stop_option),
+                         "The stop option is wrong. It must be one of the following options: \"date\", %s, %s, %s, %s, %s, %s. Please check the XML file \"%s\" arround the line_number %d", TIME_UNIT_STRING_SECOND, TIME_UNIT_STRING_MINUTE, TIME_UNIT_STRING_HOUR, TIME_UNIT_STRING_DAY, TIME_UNIT_STRING_MONTH, TIME_UNIT_STRING_YEAR, XML_file_name, line_number);
+        strcpy(this->stop_option, stop_option);
+        if (words_are_the_same(stop_option, "date")) {
+            const char *stop_date_string = get_XML_attribute(-1, -1, XML_element, "stop_date", XML_file_name, line_number, "the date to stop the simulation", "the overall parameters to run the model", true);
+            EXECUTION_REPORT(REPORT_ERROR, -1, is_string_decimal_number(stop_date_string), "Error happens when using the XML configuration file \"%s\": the value (\"%s\") of the attribute \"%s\" is not a decimal integer. Please verify the XML file around the line %d", XML_file_name, stop_date_string, "stop_date", line_number);                        
+            EXECUTION_REPORT(REPORT_ERROR, -1, sscanf(stop_date_string, "%d", &stop_date), "Software error in Time_mgt::Time_mgt");
+            stop_year = stop_date / 10000;
+            stop_month = (stop_date%10000) / 100;
+            stop_day = stop_date % 100;
+            EXECUTION_REPORT(REPORT_ERROR, -1, check_is_time_legal(stop_year, stop_month, stop_day, 0, NULL), "The stop date specified is a wrong date. Please check the XML file \"%s\" arround the line_number %d", XML_file_name, line_number);
+            const char *stop_second_string = get_XML_attribute(-1, -1, XML_element, "stop_second", XML_file_name, line_number, "the second to stop the simulation", "the overall parameters to run the model", true);
+            EXECUTION_REPORT(REPORT_ERROR, -1, is_string_decimal_number(stop_second_string), "Error happens when using the XML configuration file \"%s\": the value (\"%s\") of the attribute \"%s\" is not a decimal integer. Please verify the XML file around the line %d", XML_file_name, stop_second_string, "stop_second", line_number);                                    
+            EXECUTION_REPORT(REPORT_ERROR, -1, sscanf(stop_second_string, "%d", &this->stop_second), "Software error in Time_mgt::Time_mgt");     
+            EXECUTION_REPORT(REPORT_ERROR, -1, check_is_time_legal(stop_year, stop_month, stop_day, stop_second, NULL), "The stop second specified is a wrong second number in a day. Please check the XML file \"%s\" arround the line_number %d", XML_file_name, line_number);
+            num_total_seconds = (calculate_elapsed_day(stop_year,stop_month,stop_day)-current_num_elapsed_day)*((long)SECONDS_PER_DAY) + stop_second-start_second;
+            EXECUTION_REPORT(REPORT_ERROR, -1, num_total_seconds > 0, "The stop time of simulation is wrong. It must be after the start time. Please check the XML file \"%s\" arround the line_number %d", XML_file_name, line_number);
+        }
+        else {
+            const char *stop_n_string = get_XML_attribute(-1, -1, XML_element, "stop_n", XML_file_name, line_number, "the count for stopping the simulation", "the overall parameters to run the model", true);
+            EXECUTION_REPORT(REPORT_ERROR, -1, is_string_decimal_number(stop_n_string), "Error happens when using the XML configuration file \"%s\": the value (\"%s\") of the attribute \"%s\" is not a decimal integer. Please verify the XML file around the line %d", XML_file_name, stop_n_string, "stop_n", line_number);                                                
+            EXECUTION_REPORT(REPORT_ERROR, -1, sscanf(stop_n_string, "%d", &stop_n), "Software error in Time_mgt::Time_mgt"); 
+            if (stop_n == -999)
+                stop_year = stop_month = stop_day = stop_second = -1;
+            else {
+                calculate_stop_time(start_year, start_month, start_day, start_second);                
+                EXECUTION_REPORT(REPORT_ERROR, -1, check_is_time_legal(stop_year,stop_month,stop_day,stop_second,"Software error in Time_mgt::Time_mgt: wrong stop time generated by C-Coupler."));
+            }
+            EXECUTION_REPORT_LOG(REPORT_LOG, -1, true, "The stop time generated by C-Coupler according to the users' specification is %04d%02d%02d-%05d", stop_year, stop_month, stop_day, stop_second);
+        }
+    }
+
+    num_total_steps = -1;
+    initialize_to_start_time();
+
+    if (is_for_root_comp && runtype_mark == RUNTYPE_MARK_CONTINUE) {
+        if (comp_comm_group_mgt_mgr->get_current_proc_global_id() == 0)
+            common_restart_full_time = determine_continue_run_restart_time();
+        MPI_Bcast(&common_restart_full_time, 1, MPI_LONG, 0, MPI_COMM_WORLD);
+        EXECUTION_REPORT_LOG(REPORT_LOG, comp_id, true, "The restart time determined by the rpointer files is %ld", common_restart_full_time);
+        EXECUTION_REPORT(REPORT_ERROR, comp_id, common_restart_full_time != -1, "Error happens when starting the continue run: fail to find a common restart time according to the rpointer files among a component models. Please check the rpointer files.");
+    }
 }
 
 
@@ -553,25 +554,25 @@ void Time_mgt::initialize_to_start_time()
     current_month = start_month;
     current_day = start_day;
     current_second = start_second;
-	current_num_elapsed_day = calculate_elapsed_day(start_year,start_month,start_day);
-	start_num_elapsed_day = current_num_elapsed_day;
-	if (stop_year != -1)
-		stop_num_elapsed_day = calculate_elapsed_day(stop_year,stop_month,stop_day);
-	else stop_num_elapsed_day = -1;
-	current_step_id = 0;
-	restarted_step_id = -1;
-	restart_second = -1;
-	restart_num_elapsed_day = -1;
-	restart_full_time = -1;
-	common_restart_full_time = -1;
-	time_has_been_advanced = false;
+    current_num_elapsed_day = calculate_elapsed_day(start_year,start_month,start_day);
+    start_num_elapsed_day = current_num_elapsed_day;
+    if (stop_year != -1)
+        stop_num_elapsed_day = calculate_elapsed_day(stop_year,stop_month,stop_day);
+    else stop_num_elapsed_day = -1;
+    current_step_id = 0;
+    restarted_step_id = -1;
+    restart_second = -1;
+    restart_num_elapsed_day = -1;
+    restart_full_time = -1;
+    common_restart_full_time = -1;
+    time_has_been_advanced = false;
 }
 
 
 void Time_mgt::build_restart_timer()
 {
-	if (!words_are_the_same(rest_freq_unit, "none"))
-		restart_timer = timer_mgr->get_timer(timer_mgr->define_timer(comp_id, rest_freq_unit, rest_freq_count, 0, 0, "C-Coupler define restart timer"));
+    if (!words_are_the_same(rest_freq_unit, "none"))
+        restart_timer = timer_mgr->get_timer(timer_mgr->define_timer(comp_id, rest_freq_unit, rest_freq_count, 0, 0, "C-Coupler define restart timer"));
 }
 
 
@@ -582,31 +583,41 @@ Time_mgt::~Time_mgt()
 
 int Time_mgt::get_current_num_days_in_year()
 {
-	if (leap_year_on && is_a_leap_year(current_year))
-		return elapsed_days_on_start_of_month_of_leap_year[current_month-1] + current_day;
-	return elapsed_days_on_start_of_month_of_nonleap_year[current_month-1] + current_day;
+    if (leap_year_on && is_a_leap_year(current_year))
+        return elapsed_days_on_start_of_month_of_leap_year[current_month-1] + current_day;
+    return elapsed_days_on_start_of_month_of_nonleap_year[current_month-1] + current_day;
 }
 
 
 long Time_mgt::calculate_elapsed_day(int year, int month, int day)
 {
-	int num_leap_year;
+    int num_leap_year;
+
 
+    check_is_time_legal(year, month, day, 0, "(at calculate_elapsed_day)");
 
-	check_is_time_legal(year, month, day, 0, "(at calculate_elapsed_day)");
+    if (!leap_year_on)
+        return year*NUM_DAYS_PER_NONLEAP_YEAR + elapsed_days_on_start_of_month_of_nonleap_year[month-1] + day - 1;
 
-	if (!leap_year_on)
-	    return year*NUM_DAYS_PER_NONLEAP_YEAR + elapsed_days_on_start_of_month_of_nonleap_year[month-1] + day - 1;
+    num_leap_year = (year-1)/4 - (year-1)/100 + (year-1)/400;
 
-	num_leap_year = (year-1)/4 - (year-1)/100 + (year-1)/400;
+    if (year > 0)
+        num_leap_year ++;   // year 0 is a leap year
+
+    if (is_a_leap_year(year))
+        return year*NUM_DAYS_PER_NONLEAP_YEAR + num_leap_year + elapsed_days_on_start_of_month_of_leap_year[month-1] + day - 1;
+
+    return year*NUM_DAYS_PER_NONLEAP_YEAR + num_leap_year + elapsed_days_on_start_of_month_of_nonleap_year[month-1] + day - 1;
+}
 
-	if (year > 0)
-		num_leap_year ++;   // year 0 is a leap year
 
-	if (is_a_leap_year(year))
-		return year*NUM_DAYS_PER_NONLEAP_YEAR + num_leap_year + elapsed_days_on_start_of_month_of_leap_year[month-1] + day - 1;
+long Time_mgt::get_elapsed_day_from_full_time(long full_time)
+{
+	int year = full_time / 1000000000;
+	int month = full_time%((long)1000000000) / 10000000;
+	int day = full_time%((long)10000000) / 100000;
 
-	return year*NUM_DAYS_PER_NONLEAP_YEAR + num_leap_year + elapsed_days_on_start_of_month_of_nonleap_year[month-1] + day - 1;
+	return calculate_elapsed_day(year, month, day);
 }
 
 
@@ -615,25 +626,25 @@ void Time_mgt::advance_time(int &current_year, int &current_month, int &current_
     int i, num_days_in_current_month;
 
 
-	if (&current_year == &(this->current_year))
-		time_has_been_advanced = true;
+    if (&current_year == &(this->current_year))
+        time_has_been_advanced = true;
     current_second += time_step_in_second;
-	for (i = 0; i < current_second / SECONDS_PER_DAY; i ++) {
+    for (i = 0; i < current_second / SECONDS_PER_DAY; i ++) {
         current_num_elapsed_day ++;
-		if (leap_year_on && is_a_leap_year(current_year)) 
-			num_days_in_current_month = num_days_of_month_of_leap_year[current_month-1];
-		else num_days_in_current_month = num_days_of_month_of_nonleap_year[current_month-1];
-		current_day ++;
-		if (current_day > num_days_in_current_month) {
-			current_month ++;
-			current_day = 1;
-		}
-		if (current_month > 12) {
-			current_month = 1;
-			current_year ++;
-		}
+        if (leap_year_on && is_a_leap_year(current_year)) 
+            num_days_in_current_month = num_days_of_month_of_leap_year[current_month-1];
+        else num_days_in_current_month = num_days_of_month_of_nonleap_year[current_month-1];
+        current_day ++;
+        if (current_day > num_days_in_current_month) {
+            current_month ++;
+            current_day = 1;
+        }
+        if (current_month > 12) {
+            current_month = 1;
+            current_year ++;
+        }
     }
-	current_second = current_second % SECONDS_PER_DAY;	
+    current_second = current_second % SECONDS_PER_DAY;    
 }
 
 
@@ -642,49 +653,49 @@ void Time_mgt::advance_model_time(const char *annotation, bool from_external_mod
     int i, num_days_in_current_month;
  
 
-	EXECUTION_REPORT(REPORT_WARNING, comp_id, !is_time_out_of_execution(((long)current_num_elapsed_day)*100000+current_second), "Warning happens when advancing the model time at the model code with the annotation \"%s\": the current model time is out of the bounds of the integration period and the model coupling will not executed again. Please make sure that the component model and C-Coupler are consistent in time step, time advancing and integration period (e.g., start time and stop time).", annotation);
-
-	EXECUTION_REPORT(REPORT_ERROR, comp_id, time_step_in_second != -1, "Cannot advance the time of the component \"\%s\" at the model code with the annotation \"%s\", because the time step has not been specified.", 
-					 comp_comm_group_mgt_mgr->get_global_node_of_local_comp(comp_id,false, "")->get_comp_name(), annotation);
-	if (from_external_model && !advance_time_synchronized) {		
-		synchronize_comp_processes_for_API(comp_id, API_ID_TIME_MGT_ADVANCE_TIME, comp_comm_group_mgt_mgr->get_comm_group_of_local_comp(comp_id, "C-Coupler code in Time_mgt::advance_model_time"), "advance the time of a component", annotation);
-		advance_time_synchronized = true;		
-		comp_comm_group_mgt_mgr->search_global_node(comp_id)->get_performance_timing_mgr()->performance_timing_output();
-		comp_comm_group_mgt_mgr->search_global_node(comp_id)->get_performance_timing_mgr()->performance_timing_reset();		
-		if (get_runtype_mark() != RUNTYPE_MARK_INITIAL) {
-			EXECUTION_REPORT(REPORT_ERROR, comp_id, comp_comm_group_mgt_mgr->get_global_node_of_local_comp(comp_id,false,"")->get_restart_mgr()->check_restart_read_started(), "Error happens in a \"%s\" run where restart data should be read in: the API \"CCPL_start_!restart_read_IO\" has not been called before advancing the model time. Please verify.", run_type);
-			EXECUTION_REPORT(REPORT_ERROR, comp_id, comp_comm_group_mgt_mgr->get_global_node_of_local_comp(comp_id,false,"")->get_restart_mgr()->get_are_all_restarted_fields_read(), "Error happens in a \"%s\" run where restart data should be read in: the API \"CCPL_restart_read_fields_all\" has not been called before advancing the model time. Please verify.", run_type);
-		}
-	}
-
-	previous_year = current_year;
-	previous_month = current_month;
-	previous_day = current_day;
-	previous_second = current_second;
+    EXECUTION_REPORT(REPORT_WARNING, comp_id, !is_time_out_of_execution(((long)current_num_elapsed_day)*100000+current_second), "Warning happens when advancing the model time at the model code with the annotation \"%s\": the current model time is out of the bounds of the integration period and the model coupling will not executed again. Please make sure that the component model and C-Coupler are consistent in time step, time advancing and integration period (e.g., start time and stop time).", annotation);
+
+    EXECUTION_REPORT(REPORT_ERROR, comp_id, time_step_in_second != -1, "Cannot advance the time of the component \"\%s\" at the model code with the annotation \"%s\", because the time step has not been specified.", 
+                     comp_comm_group_mgt_mgr->get_global_node_of_local_comp(comp_id,false, "")->get_comp_name(), annotation);
+    if (from_external_model && !advance_time_synchronized) {        
+        synchronize_comp_processes_for_API(comp_id, API_ID_TIME_MGT_ADVANCE_TIME, comp_comm_group_mgt_mgr->get_comm_group_of_local_comp(comp_id, "C-Coupler code in Time_mgt::advance_model_time"), "advance the time of a component", annotation);
+        advance_time_synchronized = true;        
+        comp_comm_group_mgt_mgr->search_global_node(comp_id)->get_performance_timing_mgr()->performance_timing_output();
+        comp_comm_group_mgt_mgr->search_global_node(comp_id)->get_performance_timing_mgr()->performance_timing_reset();        
+        if (get_runtype_mark() != RUNTYPE_MARK_INITIAL) {
+            EXECUTION_REPORT(REPORT_ERROR, comp_id, comp_comm_group_mgt_mgr->get_global_node_of_local_comp(comp_id,false,"")->get_restart_mgr()->check_restart_read_started(), "Error happens in a \"%s\" run where restart data should be read in: the API \"CCPL_start_!restart_read_IO\" has not been called before advancing the model time. Please verify.", run_type);
+            EXECUTION_REPORT(REPORT_ERROR, comp_id, comp_comm_group_mgt_mgr->get_global_node_of_local_comp(comp_id,false,"")->get_restart_mgr()->get_are_all_restarted_fields_read(), "Error happens in a \"%s\" run where restart data should be read in: the API \"CCPL_restart_read_fields_all\" has not been called before advancing the model time. Please verify.", run_type);
+        }
+    }
+
+    previous_year = current_year;
+    previous_month = current_month;
+    previous_day = current_day;
+    previous_second = current_second;
     current_step_id ++;
-	advance_time(current_year, current_month, current_day, current_second, current_num_elapsed_day, time_step_in_second);
+    advance_time(current_year, current_month, current_day, current_second, current_num_elapsed_day, time_step_in_second);
 }
 
 
 double Time_mgt::get_double_current_calendar_time(int shift_second, const char *annotation)
 {
-	double calday;
+    double calday;
 
-	
-	EXECUTION_REPORT(REPORT_ERROR,-1, shift_second >= 0, "Error happens when calling the API \"CCPL_get_current_calendar_time\": the parameter \"shift_second\" (currently is %d) cannot be a negative value. Please verify the model code with the annotation \"%s\".", shift_second, annotation);
+    
+    EXECUTION_REPORT(REPORT_ERROR,-1, shift_second >= 0, "Error happens when calling the API \"CCPL_get_current_calendar_time\": the parameter \"shift_second\" (currently is %d) cannot be a negative value. Please verify the model code with the annotation \"%s\".", shift_second, annotation);
 
-	if (leap_year_on && is_a_leap_year(current_year)) {
-		calday = elapsed_days_on_start_of_month_of_leap_year[current_month-1] + current_day + ((double)(current_second+shift_second))/SECONDS_PER_DAY;
-		if (calday > (NUM_DAYS_PER_LEAP_YEAR+1))
-			calday = calday - (NUM_DAYS_PER_LEAP_YEAR+1);
-	}
-	else {
-		calday = elapsed_days_on_start_of_month_of_nonleap_year[current_month-1] + current_day + ((double)(current_second+shift_second))/SECONDS_PER_DAY;
-		if (calday > (NUM_DAYS_PER_NONLEAP_YEAR+1))
-			calday = calday - (NUM_DAYS_PER_NONLEAP_YEAR+1);
-	}
+    if (leap_year_on && is_a_leap_year(current_year)) {
+        calday = elapsed_days_on_start_of_month_of_leap_year[current_month-1] + current_day + ((double)(current_second+shift_second))/SECONDS_PER_DAY;
+        if (calday > (NUM_DAYS_PER_LEAP_YEAR+1))
+            calday = calday - (NUM_DAYS_PER_LEAP_YEAR+1);
+    }
+    else {
+        calday = elapsed_days_on_start_of_month_of_nonleap_year[current_month-1] + current_day + ((double)(current_second+shift_second))/SECONDS_PER_DAY;
+        if (calday > (NUM_DAYS_PER_NONLEAP_YEAR+1))
+            calday = calday - (NUM_DAYS_PER_NONLEAP_YEAR+1);
+    }
 
-	return calday;
+    return calday;
 }
 
 
@@ -699,17 +710,17 @@ bool Time_mgt::is_timer_on(const char *frequency_unit, int frequency_count, int
     long num_elapsed_time;
 
 
-   	return common_is_timer_on(frequency_unit, frequency_count, local_lag_count, current_year,  
-		                      current_month, current_day, current_second, current_num_elapsed_day,
-	                          start_year, start_month, start_day, start_second, start_num_elapsed_day);
+       return common_is_timer_on(frequency_unit, frequency_count, local_lag_count, current_year,  
+                              current_month, current_day, current_second, current_num_elapsed_day,
+                              start_year, start_month, start_day, start_second, start_num_elapsed_day);
 }
 
 
 bool Time_mgt::check_is_model_run_finished()
 {
     EXECUTION_REPORT_LOG(REPORT_LOG, comp_id, true, "check_is_model_run_finished %d %ld", current_step_id, num_total_steps);
-	if (num_total_steps == -1)
-		return false;
+    if (num_total_steps == -1)
+        return false;
     return current_step_id >= num_total_steps;
 }
 
@@ -747,436 +758,446 @@ int Time_mgt::get_current_date()
 
 void Time_mgt::check_timer_format(const char *frequency_unit, int frequency_count, int local_lag_count, int remote_lag_count, bool check_value, const char *annotation)
 {
-	if (time_step_in_second > 0) {
-	    EXECUTION_REPORT(REPORT_ERROR, comp_id, IS_TIME_UNIT_STEP(frequency_unit) || IS_TIME_UNIT_SECOND(frequency_unit) || IS_TIME_UNIT_DAY(frequency_unit) || IS_TIME_UNIT_MONTH(frequency_unit) || IS_TIME_UNIT_YEAR(frequency_unit), 
-	                 "Error happens when calling the API \"CCPL_define_single_timer\": the period unit is \"%s\", not one of %s, %s, %s, %s, %s. Please check the model code with the annotation \"%s\"", frequency_unit, TIME_UNIT_STRING_STEP, TIME_UNIT_STRING_SECOND, TIME_UNIT_STRING_DAY, TIME_UNIT_STRING_MONTH, TIME_UNIT_STRING_YEAR, annotation);
-	    EXECUTION_REPORT(REPORT_ERROR, comp_id, frequency_count > 0, "Error happers when calling the API \"CCPL_define_single_timer\": \"period_count\" must be a positive number. Please verify the model code with the annotation \"%s\"", annotation);
-	    if (IS_TIME_UNIT_SECOND(frequency_unit) && check_value) {
-	        EXECUTION_REPORT(REPORT_ERROR, comp_id, frequency_count%time_step_in_second == 0, "Error happens when defining a timer: the frequency count (%d) in timer is not a multiple of the time step (%d) of the component when the frequency unit is \"%s\". Please check the model code with the annotation \"%s\"", frequency_count, time_step_in_second, frequency_unit, annotation);
-	        EXECUTION_REPORT(REPORT_ERROR, comp_id, local_lag_count%time_step_in_second == 0, "Error happens when defining a timer: the remote lag count (%d) in a timer is not a multiple of the time step (%d) of the component when the frequency unit is \"%s\". Please check the model code with the annotation \"%s\"", local_lag_count, time_step_in_second, frequency_unit, annotation);        
-	    }	
-		if (local_lag_count != 0)
-			EXECUTION_REPORT(REPORT_ERROR, comp_id, !IS_TIME_UNIT_MONTH(frequency_unit) && !IS_TIME_UNIT_YEAR(frequency_unit), "Error happens when defining a timer: the local lag count cannot be set when the frequency unit is \"%s\". Please check the model code with the annotation \"%s\"", frequency_unit, annotation);
-		if (remote_lag_count != 0)
-			EXECUTION_REPORT(REPORT_ERROR, comp_id, !IS_TIME_UNIT_MONTH(frequency_unit) && !IS_TIME_UNIT_YEAR(frequency_unit), "Error happens when defining a timer: the remote lag count cannot be set when the frequency unit is \"%s\". Please check the model code with the annotation \"%s\"", frequency_unit, annotation);
-	}
+    if (time_step_in_second > 0) {
+        EXECUTION_REPORT(REPORT_ERROR, comp_id, IS_TIME_UNIT_STEP(frequency_unit) || IS_TIME_UNIT_SECOND(frequency_unit) || IS_TIME_UNIT_DAY(frequency_unit) || IS_TIME_UNIT_MONTH(frequency_unit) || IS_TIME_UNIT_YEAR(frequency_unit), 
+                     "Error happens when calling the API \"CCPL_define_single_timer\": the period unit is \"%s\", not one of %s, %s, %s, %s, %s. Please check the model code with the annotation \"%s\"", frequency_unit, TIME_UNIT_STRING_STEP, TIME_UNIT_STRING_SECOND, TIME_UNIT_STRING_DAY, TIME_UNIT_STRING_MONTH, TIME_UNIT_STRING_YEAR, annotation);
+        EXECUTION_REPORT(REPORT_ERROR, comp_id, frequency_count > 0, "Error happers when calling the API \"CCPL_define_single_timer\": \"period_count\" must be a positive number. Please verify the model code with the annotation \"%s\"", annotation);
+        if (IS_TIME_UNIT_SECOND(frequency_unit) && check_value) {
+            EXECUTION_REPORT(REPORT_ERROR, comp_id, frequency_count%time_step_in_second == 0, "Error happens when defining a timer: the frequency count (%d) in timer is not a multiple of the time step (%d) of the component when the frequency unit is \"%s\". Please check the model code with the annotation \"%s\"", frequency_count, time_step_in_second, frequency_unit, annotation);
+            EXECUTION_REPORT(REPORT_ERROR, comp_id, local_lag_count%time_step_in_second == 0, "Error happens when defining a timer: the remote lag count (%d) in a timer is not a multiple of the time step (%d) of the component when the frequency unit is \"%s\". Please check the model code with the annotation \"%s\"", local_lag_count, time_step_in_second, frequency_unit, annotation);        
+        }    
+        if (local_lag_count != 0)
+            EXECUTION_REPORT(REPORT_ERROR, comp_id, !IS_TIME_UNIT_MONTH(frequency_unit) && !IS_TIME_UNIT_YEAR(frequency_unit), "Error happens when defining a timer: the local lag count cannot be set when the frequency unit is \"%s\". Please check the model code with the annotation \"%s\"", frequency_unit, annotation);
+        if (remote_lag_count != 0)
+            EXECUTION_REPORT(REPORT_ERROR, comp_id, !IS_TIME_UNIT_MONTH(frequency_unit) && !IS_TIME_UNIT_YEAR(frequency_unit), "Error happens when defining a timer: the remote lag count cannot be set when the frequency unit is \"%s\". Please check the model code with the annotation \"%s\"", frequency_unit, annotation);
+    }
 }
 
 
 bool Time_mgt::check_time_consistency_between_components(long full_time)
 {
-	EXECUTION_REPORT(REPORT_ERROR,-1, false, "to be implemented: Time_mgt::check_time_consistency_between_components");
-	
+    EXECUTION_REPORT(REPORT_ERROR,-1, false, "to be implemented: Time_mgt::check_time_consistency_between_components");
+    
 }
 
 
 void Time_mgt::get_elapsed_days_from_start_date(int *num_days, int *num_seconds)
 {
-	long current_num_elapsed_days, start_num_elapsed_days;
-	
-	current_num_elapsed_days = calculate_elapsed_day(current_year, current_month, current_day);
-	start_num_elapsed_days = calculate_elapsed_day(start_year, start_month, start_day);
-	*num_days = current_num_elapsed_days - start_num_elapsed_days;
-	*num_seconds = current_second;
+    long current_num_elapsed_days, start_num_elapsed_days;
+    
+    current_num_elapsed_days = calculate_elapsed_day(current_year, current_month, current_day);
+    start_num_elapsed_days = calculate_elapsed_day(start_year, start_month, start_day);
+    *num_days = current_num_elapsed_days - start_num_elapsed_days;
+    *num_seconds = current_second;
 }
 
 
 void Time_mgt::get_elapsed_days_from_reference_date(int *num_days, int *num_seconds)
 {
-	long current_num_elapsed_days, reference_num_elapsed_days;
-	
-	current_num_elapsed_days = calculate_elapsed_day(current_year, current_month, current_day);
-	reference_num_elapsed_days = calculate_elapsed_day(reference_year, reference_month, reference_day);
-	*num_days = current_num_elapsed_days - reference_num_elapsed_days;
-	*num_seconds = current_second;
+    long current_num_elapsed_days, reference_num_elapsed_days;
+    
+    current_num_elapsed_days = calculate_elapsed_day(current_year, current_month, current_day);
+    reference_num_elapsed_days = calculate_elapsed_day(reference_year, reference_month, reference_day);
+    *num_days = current_num_elapsed_days - reference_num_elapsed_days;
+    *num_seconds = current_second;
 }
 
 
 void Time_mgt::get_current_time(int &year, int &month, int &day, int &second, int shift_second, const char *annotation)
 {
-	int num_days_in_current_month;
+    int num_days_in_current_month;
 
-	
-	EXECUTION_REPORT(REPORT_ERROR,-1, shift_second >= 0, "Error happens when calling the API \"CCPL_get_current_time\": the parameter \"shift_second\" (currently is %d) cannot be a negative value. Please verify the model code with the annotation \"%s\".", shift_second, annotation);
-	
-	year = current_year;
-	month = current_month;
-	day = current_day;
-	second = current_second + shift_second;
+    
+    EXECUTION_REPORT(REPORT_ERROR,-1, shift_second >= 0, "Error happens when calling the API \"CCPL_get_current_time\": the parameter \"shift_second\" (currently is %d) cannot be a negative value. Please verify the model code with the annotation \"%s\".", shift_second, annotation);
+    
+    year = current_year;
+    month = current_month;
+    day = current_day;
+    second = current_second + shift_second;
 
     while (second >= SECONDS_PER_DAY) {
-		second -= SECONDS_PER_DAY;
-		if (leap_year_on && is_a_leap_year(year)) 
-			num_days_in_current_month = num_days_of_month_of_leap_year[month-1];
-		else num_days_in_current_month = num_days_of_month_of_nonleap_year[month-1];
-		day ++;
-		if (day > num_days_in_current_month) {
-			month ++;
-			day = 1;
-		}
-		if (month > 12) {
-			month = 1;
-			year ++;
-		}
+        second -= SECONDS_PER_DAY;
+        if (leap_year_on && is_a_leap_year(year)) 
+            num_days_in_current_month = num_days_of_month_of_leap_year[month-1];
+        else num_days_in_current_month = num_days_of_month_of_nonleap_year[month-1];
+        day ++;
+        if (day > num_days_in_current_month) {
+            month ++;
+            day = 1;
+        }
+        if (month > 12) {
+            month = 1;
+            year ++;
+        }
     }
 }
 
 
 int Time_mgt::get_current_num_time_step()
 {
-//	if (words_are_the_same(compset_communicators_info_mgr->get_running_case_mode(), "hybrid") && current_step_id < SECONDS_PER_DAY/time_step_in_second)
-//		return current_step_id + SECONDS_PER_DAY/time_step_in_second;
+//    if (words_are_the_same(compset_communicators_info_mgr->get_running_case_mode(), "hybrid") && current_step_id < SECONDS_PER_DAY/time_step_in_second)
+//        return current_step_id + SECONDS_PER_DAY/time_step_in_second;
     return current_step_id; 
 }
 
 
 Time_mgt *Time_mgt::clone_time_mgr(int comp_id)
 {
-	Time_mgt *new_time_mgr = new Time_mgt();
-
-
-	new_time_mgr->restart_second = this->restart_second;
-	new_time_mgr->restart_num_elapsed_day = this->restart_num_elapsed_day;
-	new_time_mgr->restart_full_time = this->restart_full_time;
-	new_time_mgr->common_restart_full_time = this->common_restart_full_time;
-	new_time_mgr->restarted_step_id = this->restarted_step_id;
-	new_time_mgr->start_year = this->start_year;
-	new_time_mgr->start_month = this->start_month;
-	new_time_mgr->start_day = this->start_day;
-	new_time_mgr->start_second = this->start_second;
-	new_time_mgr->previous_year = this->previous_year;
-	new_time_mgr->previous_month = this->previous_month;
-	new_time_mgr->previous_day = this->previous_day;
-	new_time_mgr->previous_second = this->previous_second;
-	new_time_mgr->current_year = this->current_year;
-	new_time_mgr->current_month = this->current_month;
-	new_time_mgr->current_day = this->current_day;
-	new_time_mgr->current_second = this->current_second;
-	new_time_mgr->reference_year = this->reference_year;
-	new_time_mgr->reference_month = this->reference_month;
-	new_time_mgr->reference_day = this->reference_day;
-	new_time_mgr->stop_year = this->stop_year;
-	new_time_mgr->stop_month = this->stop_month;
-	new_time_mgr->stop_day = this->stop_day;
-	new_time_mgr->stop_second = this->stop_second;
-	new_time_mgr->time_step_in_second = -1;
-	new_time_mgr->current_step_id = 0;
-	new_time_mgr->num_total_steps = 0;
-	new_time_mgr->leap_year_on = this->leap_year_on;
-	new_time_mgr->comp_id = comp_id;
-	new_time_mgr->current_num_elapsed_day = this->current_num_elapsed_day;
-	new_time_mgr->start_num_elapsed_day = this->start_num_elapsed_day;
-	new_time_mgr->stop_num_elapsed_day = this->stop_num_elapsed_day;
-	new_time_mgr->advance_time_synchronized = false;
-	new_time_mgr->stop_n = this->stop_n;
-	new_time_mgr->runtype_mark = this->runtype_mark;
-	strcpy(new_time_mgr->case_name, this->case_name);
-	strcpy(new_time_mgr->exp_model_name, this->exp_model_name);
-	strcpy(new_time_mgr->case_desc, this->case_desc);
-	strcpy(new_time_mgr->run_type, this->run_type);
-	strcpy(new_time_mgr->rest_refcase, this->rest_refcase);
-	strcpy(new_time_mgr->stop_option, this->stop_option);
-	strcpy(new_time_mgr->rest_freq_unit, this->rest_freq_unit);
-	new_time_mgr->rest_freq_count = this->rest_freq_count;
-	new_time_mgr->rest_refdate = this->rest_refdate;
-	new_time_mgr->rest_refsecond = this->rest_refsecond;
-	new_time_mgr->restart_timer = NULL;
-	new_time_mgr->time_has_been_advanced = false;
-
-	return new_time_mgr;
+    Time_mgt *new_time_mgr = new Time_mgt();
+
+
+    new_time_mgr->restart_second = this->restart_second;
+    new_time_mgr->restart_num_elapsed_day = this->restart_num_elapsed_day;
+    new_time_mgr->restart_full_time = this->restart_full_time;
+    new_time_mgr->common_restart_full_time = this->common_restart_full_time;
+    new_time_mgr->restarted_step_id = this->restarted_step_id;
+    new_time_mgr->start_year = this->start_year;
+    new_time_mgr->start_month = this->start_month;
+    new_time_mgr->start_day = this->start_day;
+    new_time_mgr->start_second = this->start_second;
+    new_time_mgr->previous_year = this->previous_year;
+    new_time_mgr->previous_month = this->previous_month;
+    new_time_mgr->previous_day = this->previous_day;
+    new_time_mgr->previous_second = this->previous_second;
+    new_time_mgr->current_year = this->current_year;
+    new_time_mgr->current_month = this->current_month;
+    new_time_mgr->current_day = this->current_day;
+    new_time_mgr->current_second = this->current_second;
+    new_time_mgr->reference_year = this->reference_year;
+    new_time_mgr->reference_month = this->reference_month;
+    new_time_mgr->reference_day = this->reference_day;
+    new_time_mgr->stop_year = this->stop_year;
+    new_time_mgr->stop_month = this->stop_month;
+    new_time_mgr->stop_day = this->stop_day;
+    new_time_mgr->stop_second = this->stop_second;
+    new_time_mgr->time_step_in_second = -1;
+    new_time_mgr->current_step_id = 0;
+    new_time_mgr->num_total_steps = 0;
+    new_time_mgr->leap_year_on = this->leap_year_on;
+    new_time_mgr->comp_id = comp_id;
+    new_time_mgr->current_num_elapsed_day = this->current_num_elapsed_day;
+    new_time_mgr->start_num_elapsed_day = this->start_num_elapsed_day;
+    new_time_mgr->stop_num_elapsed_day = this->stop_num_elapsed_day;
+    new_time_mgr->advance_time_synchronized = false;
+    new_time_mgr->stop_n = this->stop_n;
+    new_time_mgr->runtype_mark = this->runtype_mark;
+    strcpy(new_time_mgr->case_name, this->case_name);
+    strcpy(new_time_mgr->exp_model_name, this->exp_model_name);
+    strcpy(new_time_mgr->case_desc, this->case_desc);
+    strcpy(new_time_mgr->run_type, this->run_type);
+    strcpy(new_time_mgr->rest_refcase, this->rest_refcase);
+    strcpy(new_time_mgr->stop_option, this->stop_option);
+    strcpy(new_time_mgr->rest_freq_unit, this->rest_freq_unit);
+    new_time_mgr->rest_freq_count = this->rest_freq_count;
+    new_time_mgr->rest_refdate = this->rest_refdate;
+    new_time_mgr->rest_refsecond = this->rest_refsecond;
+    new_time_mgr->restart_timer = NULL;
+    new_time_mgr->time_has_been_advanced = false;
+
+    return new_time_mgr;
 }
 
 
 bool Time_mgt::set_time_step_in_second(int time_step_in_second, const char *annotation, bool check_error)
 {
-	this->time_step_in_second = time_step_in_second;
-	EXECUTION_REPORT(REPORT_ERROR, comp_id, time_step_in_second > 0, "The value of the time step is wrong when setting the time step of the component \"%s\". It must be a positive value. Please check the model code with the annotation \"%s\"",
-					 comp_comm_group_mgt_mgr->get_global_node_of_local_comp(comp_id,false, "get comp name in Time_mgt::set_time_step_in_second")->get_comp_name(), annotation);
-	if (stop_year != -1) {
-		long total_seconds = (stop_num_elapsed_day-current_num_elapsed_day)*((long)SECONDS_PER_DAY) + stop_second-start_second;
-		if (!check_error && total_seconds%((long)time_step_in_second) != 0)
-			return false;
-		EXECUTION_REPORT(REPORT_ERROR, comp_id, total_seconds%((long)time_step_in_second) == 0, "The time step set at model code with the annotation \"%s\" does not match the start time and the stop time of the simulation. Please check the model code and the XML file \"env_run.xml\"", annotation);
-		num_total_steps = total_seconds / time_step_in_second;
-	}
-	else num_total_steps = -1;
-	if (restart_timer != NULL) {
-		long rest_freq;
-		if (IS_TIME_UNIT_DAY(rest_freq_unit))
-			rest_freq = SECONDS_PER_DAY * rest_freq_count;
-		else if (IS_TIME_UNIT_MONTH(rest_freq_unit) || IS_TIME_UNIT_YEAR(rest_freq_unit))
-			rest_freq = SECONDS_PER_DAY;
-		else if (IS_TIME_UNIT_SECOND(rest_freq_unit))
-			rest_freq = rest_freq_count;
-		EXECUTION_REPORT(REPORT_ERROR, comp_id, rest_freq%((long)time_step_in_second) == 0, "The time step set at model code with the annotation \"%s\" does not match the frequency of writing restart data files. Please check the model code and the XML file \"env_run.xml\"", annotation);
-	}
-
-	return true;
+    this->time_step_in_second = time_step_in_second;
+    EXECUTION_REPORT(REPORT_ERROR, comp_id, time_step_in_second > 0, "The value of the time step is wrong when setting the time step of the component \"%s\". It must be a positive value. Please check the model code with the annotation \"%s\"",
+                     comp_comm_group_mgt_mgr->get_global_node_of_local_comp(comp_id,false, "get comp name in Time_mgt::set_time_step_in_second")->get_comp_name(), annotation);
+    if (stop_year != -1) {
+        long total_seconds = (stop_num_elapsed_day-current_num_elapsed_day)*((long)SECONDS_PER_DAY) + stop_second-start_second;
+        if (!check_error && total_seconds%((long)time_step_in_second) != 0)
+            return false;
+        EXECUTION_REPORT(REPORT_ERROR, comp_id, total_seconds%((long)time_step_in_second) == 0, "The time step set at model code with the annotation \"%s\" does not match the start time and the stop time of the simulation. Please check the model code and the XML file \"env_run.xml\"", annotation);
+        num_total_steps = total_seconds / time_step_in_second;
+    }
+    else num_total_steps = -1;
+    if (restart_timer != NULL) {
+        long rest_freq;
+        if (IS_TIME_UNIT_DAY(rest_freq_unit))
+            rest_freq = SECONDS_PER_DAY * rest_freq_count;
+        else if (IS_TIME_UNIT_MONTH(rest_freq_unit) || IS_TIME_UNIT_YEAR(rest_freq_unit))
+            rest_freq = SECONDS_PER_DAY;
+        else if (IS_TIME_UNIT_SECOND(rest_freq_unit))
+            rest_freq = rest_freq_count;
+        EXECUTION_REPORT(REPORT_ERROR, comp_id, rest_freq%((long)time_step_in_second) == 0, "The time step set at model code with the annotation \"%s\" does not match the frequency of writing restart data files. Please check the model code and the XML file \"env_run.xml\"", annotation);
+    }
+
+    return true;
 }
 
 
 bool Time_mgt::is_a_leap_year(int year)
 {
-	return ((year%4) == 0 && (year%100) != 0) || (year%400) == 0;
+    return ((year%4) == 0 && (year%100) != 0) || (year%400) == 0;
 }
 
 
 void Time_mgt::check_consistency_of_current_time(int date, int second, const char *annotation)
 {
-	EXECUTION_REPORT(REPORT_ERROR, comp_id, date == get_current_date() && second == get_current_second(), "the model time is different from the time managed by C-Coupler. Please verify the model code according to the annotation \"%s\"", annotation);
+    EXECUTION_REPORT(REPORT_ERROR, comp_id, date == get_current_date() && second == get_current_second(), "the model time is different from the time managed by C-Coupler. Please verify the model code according to the annotation \"%s\"", annotation);
 }
 
 
 bool Time_mgt::is_time_out_of_execution(long another_time)
 {
-	if (stop_num_elapsed_day == -1)
-		return another_time < ((long)start_num_elapsed_day)*100000+start_second;
-	
-	return another_time < ((long)start_num_elapsed_day)*100000+start_second || another_time >= ((long)stop_num_elapsed_day)*100000+stop_second;
+    if (stop_num_elapsed_day == -1)
+        return another_time < ((long)start_num_elapsed_day)*100000+start_second;
+    
+    return another_time < ((long)start_num_elapsed_day)*100000+start_second || another_time >= ((long)stop_num_elapsed_day)*100000+stop_second;
 }
 
 
 void Time_mgt::write_time_mgt_into_array(char **array_buffer, long &buffer_max_size, long &buffer_content_size)
 {
-	int temp_int;
-
-	
-	write_data_into_array_buffer(&start_year, sizeof(int), array_buffer, buffer_max_size, buffer_content_size);
-	write_data_into_array_buffer(&start_month, sizeof(int), array_buffer, buffer_max_size, buffer_content_size);
-	write_data_into_array_buffer(&start_day, sizeof(int), array_buffer, buffer_max_size, buffer_content_size);
-	write_data_into_array_buffer(&start_second, sizeof(int), array_buffer, buffer_max_size, buffer_content_size);	
-	write_data_into_array_buffer(&previous_year, sizeof(int), array_buffer, buffer_max_size, buffer_content_size);
-	write_data_into_array_buffer(&previous_month, sizeof(int), array_buffer, buffer_max_size, buffer_content_size);
-	write_data_into_array_buffer(&previous_day, sizeof(int), array_buffer, buffer_max_size, buffer_content_size);
-	write_data_into_array_buffer(&previous_second, sizeof(int), array_buffer, buffer_max_size, buffer_content_size);
-	write_data_into_array_buffer(&current_year, sizeof(int), array_buffer, buffer_max_size, buffer_content_size);
-	write_data_into_array_buffer(&current_month, sizeof(int), array_buffer, buffer_max_size, buffer_content_size);
-	write_data_into_array_buffer(&current_day, sizeof(int), array_buffer, buffer_max_size, buffer_content_size);
-	write_data_into_array_buffer(&current_second, sizeof(int), array_buffer, buffer_max_size, buffer_content_size);
-	write_data_into_array_buffer(&time_step_in_second, sizeof(int), array_buffer, buffer_max_size, buffer_content_size);
-	temp_int = 1;
-	write_data_into_array_buffer(&temp_int, sizeof(int), array_buffer, buffer_max_size, buffer_content_size);
-	write_data_into_array_buffer(&current_step_id, sizeof(int), array_buffer, buffer_max_size, buffer_content_size);
-	write_data_into_array_buffer(&leap_year_on, sizeof(bool), array_buffer, buffer_max_size, buffer_content_size);
-	dump_string(comp_comm_group_mgt_mgr->get_global_node_of_local_comp(comp_id,false,"")->get_full_name(), -1, array_buffer, buffer_max_size, buffer_content_size);
-	dump_string(case_name, -1, array_buffer, buffer_max_size, buffer_content_size);
+    int temp_int;
+
+    
+    write_data_into_array_buffer(&start_year, sizeof(int), array_buffer, buffer_max_size, buffer_content_size);
+    write_data_into_array_buffer(&start_month, sizeof(int), array_buffer, buffer_max_size, buffer_content_size);
+    write_data_into_array_buffer(&start_day, sizeof(int), array_buffer, buffer_max_size, buffer_content_size);
+    write_data_into_array_buffer(&start_second, sizeof(int), array_buffer, buffer_max_size, buffer_content_size);    
+    write_data_into_array_buffer(&previous_year, sizeof(int), array_buffer, buffer_max_size, buffer_content_size);
+    write_data_into_array_buffer(&previous_month, sizeof(int), array_buffer, buffer_max_size, buffer_content_size);
+    write_data_into_array_buffer(&previous_day, sizeof(int), array_buffer, buffer_max_size, buffer_content_size);
+    write_data_into_array_buffer(&previous_second, sizeof(int), array_buffer, buffer_max_size, buffer_content_size);
+    write_data_into_array_buffer(&current_year, sizeof(int), array_buffer, buffer_max_size, buffer_content_size);
+    write_data_into_array_buffer(&current_month, sizeof(int), array_buffer, buffer_max_size, buffer_content_size);
+    write_data_into_array_buffer(&current_day, sizeof(int), array_buffer, buffer_max_size, buffer_content_size);
+    write_data_into_array_buffer(&current_second, sizeof(int), array_buffer, buffer_max_size, buffer_content_size);
+    write_data_into_array_buffer(&time_step_in_second, sizeof(int), array_buffer, buffer_max_size, buffer_content_size);
+    temp_int = 1;
+    write_data_into_array_buffer(&temp_int, sizeof(int), array_buffer, buffer_max_size, buffer_content_size);
+    write_data_into_array_buffer(&current_step_id, sizeof(int), array_buffer, buffer_max_size, buffer_content_size);
+    write_data_into_array_buffer(&leap_year_on, sizeof(bool), array_buffer, buffer_max_size, buffer_content_size);
+    dump_string(comp_comm_group_mgt_mgr->get_global_node_of_local_comp(comp_id,false,"")->get_full_name(), -1, array_buffer, buffer_max_size, buffer_content_size);
+    dump_string(case_name, -1, array_buffer, buffer_max_size, buffer_content_size);
 }
 
 
 void Time_mgt::import_restart_data(const char *temp_array_buffer, long &buffer_content_iter, const char *file_name, bool check_existing_data)
 {
-	int restart_start_year, restart_start_month, restart_start_day, restart_start_second, restart_previous_year, restart_previous_month, restart_previous_day, restart_previous_second;
-	int restart_current_year, restart_current_month, restart_current_day, restart_current_second, restart_time_step_in_second, restart_current_step_id;
-	int temp_int;
-	bool restart_leap_year_on;
-	char restart_comp_full_name[NAME_STR_SIZE], restart_case_name[NAME_STR_SIZE];
-	long str_size;
-
-
-	load_string(restart_case_name, str_size, NAME_STR_SIZE, temp_array_buffer, buffer_content_iter, file_name);
-	load_string(restart_comp_full_name, str_size, NAME_STR_SIZE, temp_array_buffer, buffer_content_iter, file_name);
-	EXECUTION_REPORT(REPORT_ERROR, -1, read_data_from_array_buffer(&restart_leap_year_on, sizeof(bool), temp_array_buffer, buffer_content_iter, false), "Fail to load the restart data file \"%s\": its format is wrong, or the information it includes is not complete. Please try a different restart time with complete restart data files.", file_name);
-	EXECUTION_REPORT(REPORT_ERROR, -1, read_data_from_array_buffer(&restart_current_step_id, sizeof(int), temp_array_buffer, buffer_content_iter, false), "Fail to load the restart data file \"%s\": its format is wrong, or the information it includes is not complete. Please try a different restart time with complete restart data files.", file_name);
-	EXECUTION_REPORT(REPORT_ERROR, -1, read_data_from_array_buffer(&temp_int, sizeof(int), temp_array_buffer, buffer_content_iter, false), "Fail to load the restart data file \"%s\": its format is wrong, or the information it includes is not complete. Please try a different restart time with complete restart data files.", file_name);
-	EXECUTION_REPORT(REPORT_ERROR, -1, read_data_from_array_buffer(&restart_time_step_in_second, sizeof(int), temp_array_buffer, buffer_content_iter, false), "Fail to load the restart data file \"%s\": its format is wrong, or the information it includes is not complete. Please try a different restart time with complete restart data files.", file_name);
-	EXECUTION_REPORT(REPORT_ERROR, -1, read_data_from_array_buffer(&restart_current_second, sizeof(int), temp_array_buffer, buffer_content_iter, false), "Fail to load the restart data file \"%s\": its format is wrong, or the information it includes is not complete. Please try a different restart time with complete restart data files.", file_name);
-	EXECUTION_REPORT(REPORT_ERROR, -1, read_data_from_array_buffer(&restart_current_day, sizeof(int), temp_array_buffer, buffer_content_iter, false), "Fail to load the restart data file \"%s\": its format is wrong, or the information it includes is not complete. Please try a different restart time with complete restart data files.", file_name);
-	EXECUTION_REPORT(REPORT_ERROR, -1, read_data_from_array_buffer(&restart_current_month, sizeof(int), temp_array_buffer, buffer_content_iter, false), "Fail to load the restart data file \"%s\": its format is wrong, or the information it includes is not complete. Please try a different restart time with complete restart data files.", file_name);
-	EXECUTION_REPORT(REPORT_ERROR, -1, read_data_from_array_buffer(&restart_current_year, sizeof(int), temp_array_buffer, buffer_content_iter, false), "Fail to load the restart data file \"%s\": its format is wrong, or the information it includes is not complete. Please try a different restart time with complete restart data files.", file_name);
-	EXECUTION_REPORT(REPORT_ERROR, -1, read_data_from_array_buffer(&restart_previous_second, sizeof(int), temp_array_buffer, buffer_content_iter, false), "Fail to load the restart data file \"%s\": its format is wrong, or the information it includes is not complete. Please try a different restart time with complete restart data files.", file_name);
-	EXECUTION_REPORT(REPORT_ERROR, -1, read_data_from_array_buffer(&restart_previous_day, sizeof(int), temp_array_buffer, buffer_content_iter, false), "Fail to load the restart data file \"%s\": its format is wrong, or the information it includes is not complete. Please try a different restart time with complete restart data files.", file_name);
-	EXECUTION_REPORT(REPORT_ERROR, -1, read_data_from_array_buffer(&restart_previous_month, sizeof(int), temp_array_buffer, buffer_content_iter, false), "Fail to load the restart data file \"%s\": its format is wrong, or the information it includes is not complete. Please try a different restart time with complete restart data files.", file_name);
-	EXECUTION_REPORT(REPORT_ERROR, -1, read_data_from_array_buffer(&restart_previous_year, sizeof(int), temp_array_buffer, buffer_content_iter, false), "Fail to load the restart data file \"%s\": its format is wrong, or the information it includes is not complete. Please try a different restart time with complete restart data files.", file_name);
-	EXECUTION_REPORT(REPORT_ERROR, -1, read_data_from_array_buffer(&restart_start_second, sizeof(int), temp_array_buffer, buffer_content_iter, false), "Fail to load the restart data file \"%s\": its format is wrong, or the information it includes is not complete. Please try a different restart time with complete restart data files.", file_name);
-	EXECUTION_REPORT(REPORT_ERROR, -1, read_data_from_array_buffer(&restart_start_day, sizeof(int), temp_array_buffer, buffer_content_iter, false), "Fail to load the restart data file \"%s\": its format is wrong, or the information it includes is not complete. Please try a different restart time with complete restart data files.", file_name);
-	EXECUTION_REPORT(REPORT_ERROR, -1, read_data_from_array_buffer(&restart_start_month, sizeof(int), temp_array_buffer, buffer_content_iter, false), "Fail to load the restart data file \"%s\": its format is wrong, or the information it includes is not complete. Please try a different restart time with complete restart data files.", file_name);
-	EXECUTION_REPORT(REPORT_ERROR, -1, read_data_from_array_buffer(&restart_start_year, sizeof(int), temp_array_buffer, buffer_content_iter, false), "Fail to load the restart data file \"%s\": its format is wrong, or the information it includes is not complete. Please try a different restart time with complete restart data files.", file_name);
-
-	if (check_existing_data) {
-		if (words_are_the_same(RUNTYPE_CONTINUE, run_type))
-			EXECUTION_REPORT(REPORT_ERROR, comp_id, words_are_the_same(restart_case_name, case_name), "Error happens when importing the restart data from the file \"%s\": the current case name (\"%s\") is different from the case name (\"%s\") imported from the restart data when it is a \"continue\" run. Please verify.", file_name, case_name, restart_case_name);
-		if (words_are_the_same(RUNTYPE_CONTINUE, run_type) || words_are_the_same(RUNTYPE_BRANCH, run_type)) {
-			char str1[NAME_STR_SIZE], str2[NAME_STR_SIZE];
-			sprintf(str1, "%04d%02d%02d-%05d", start_year, start_month, start_day, start_second);
-			sprintf(str2, "%04d%02d%02d-%05d", restart_start_year, restart_start_month, restart_start_day, restart_start_second);
-			EXECUTION_REPORT(REPORT_ERROR, comp_id, words_are_the_same(str1,str2), "Error happens when importing the restart data from the file \"%s\": the current start time (%s) of the simulation is different from the start time (%s) imported from the restart data when it is a \"continue\" or \"branch\" run. Please verify.", file_name, str1, str2);
-			if (leap_year_on)
-				strcpy(str1, "on");
-			else strcpy(str1, "off");
-			if (restart_leap_year_on)
-				strcpy(str2, "on");
-			else strcpy(str2, "off");
-			EXECUTION_REPORT(REPORT_ERROR, comp_id, leap_year_on == restart_leap_year_on, "Error happens when importing the restart data from the file \"%s\": the current setting of leap year (\"%s\") is different from the setting (\"%s\") imported from the restart data when it is a \"continue\" or \"branch\" run. Please verify. ", file_name, str1, str2);
-			EXECUTION_REPORT(REPORT_ERROR, comp_id, time_step_in_second != -1, "Error happens when importing the restart data from the file \"%s\": the time step of the component model has not been set before reading the restart data file for a \"continue\" or \"branch\" run. Please verify. ", file_name, time_step_in_second, restart_time_step_in_second);
-			EXECUTION_REPORT(REPORT_ERROR, comp_id, time_step_in_second == restart_time_step_in_second, "Error happens when importing the restart data from the file \"%s\": the current setting of time step (%d) is different from the setting (%d) imported from the restart data when it is a \"continue\" or \"branch\" run. Please verify. ", file_name, time_step_in_second, restart_time_step_in_second);
-		}	
-	}
-
-	current_second = restart_current_second;
-	current_day = restart_current_day;
-	current_month = restart_current_month;
-	current_year = restart_current_year;
-	previous_second = restart_previous_second;
-	previous_day = restart_previous_day;
-	previous_month = restart_previous_month;
-	previous_year = restart_previous_year;
-	if (time_step_in_second == -1) {
-		time_step_in_second = restart_time_step_in_second;
-		annotation_mgr->add_annotation(comp_id, "setting time step", "C-Coupler read from restart file");
-	}
+    int restart_start_year, restart_start_month, restart_start_day, restart_start_second, restart_previous_year, restart_previous_month, restart_previous_day, restart_previous_second;
+    int restart_current_year, restart_current_month, restart_current_day, restart_current_second, restart_time_step_in_second, restart_current_step_id;
+    int temp_int;
+    bool restart_leap_year_on;
+    char restart_comp_full_name[NAME_STR_SIZE], restart_case_name[NAME_STR_SIZE];
+    long str_size;
+
+
+    load_string(restart_case_name, str_size, NAME_STR_SIZE, temp_array_buffer, buffer_content_iter, file_name);
+    load_string(restart_comp_full_name, str_size, NAME_STR_SIZE, temp_array_buffer, buffer_content_iter, file_name);
+    EXECUTION_REPORT(REPORT_ERROR, -1, read_data_from_array_buffer(&restart_leap_year_on, sizeof(bool), temp_array_buffer, buffer_content_iter, false), "Fail to load the restart data file \"%s\": its format is wrong, or the information it includes is not complete. Please try a different restart time with complete restart data files.", file_name);
+    EXECUTION_REPORT(REPORT_ERROR, -1, read_data_from_array_buffer(&restart_current_step_id, sizeof(int), temp_array_buffer, buffer_content_iter, false), "Fail to load the restart data file \"%s\": its format is wrong, or the information it includes is not complete. Please try a different restart time with complete restart data files.", file_name);
+    EXECUTION_REPORT(REPORT_ERROR, -1, read_data_from_array_buffer(&temp_int, sizeof(int), temp_array_buffer, buffer_content_iter, false), "Fail to load the restart data file \"%s\": its format is wrong, or the information it includes is not complete. Please try a different restart time with complete restart data files.", file_name);
+    EXECUTION_REPORT(REPORT_ERROR, -1, read_data_from_array_buffer(&restart_time_step_in_second, sizeof(int), temp_array_buffer, buffer_content_iter, false), "Fail to load the restart data file \"%s\": its format is wrong, or the information it includes is not complete. Please try a different restart time with complete restart data files.", file_name);
+    EXECUTION_REPORT(REPORT_ERROR, -1, read_data_from_array_buffer(&restart_current_second, sizeof(int), temp_array_buffer, buffer_content_iter, false), "Fail to load the restart data file \"%s\": its format is wrong, or the information it includes is not complete. Please try a different restart time with complete restart data files.", file_name);
+    EXECUTION_REPORT(REPORT_ERROR, -1, read_data_from_array_buffer(&restart_current_day, sizeof(int), temp_array_buffer, buffer_content_iter, false), "Fail to load the restart data file \"%s\": its format is wrong, or the information it includes is not complete. Please try a different restart time with complete restart data files.", file_name);
+    EXECUTION_REPORT(REPORT_ERROR, -1, read_data_from_array_buffer(&restart_current_month, sizeof(int), temp_array_buffer, buffer_content_iter, false), "Fail to load the restart data file \"%s\": its format is wrong, or the information it includes is not complete. Please try a different restart time with complete restart data files.", file_name);
+    EXECUTION_REPORT(REPORT_ERROR, -1, read_data_from_array_buffer(&restart_current_year, sizeof(int), temp_array_buffer, buffer_content_iter, false), "Fail to load the restart data file \"%s\": its format is wrong, or the information it includes is not complete. Please try a different restart time with complete restart data files.", file_name);
+    EXECUTION_REPORT(REPORT_ERROR, -1, read_data_from_array_buffer(&restart_previous_second, sizeof(int), temp_array_buffer, buffer_content_iter, false), "Fail to load the restart data file \"%s\": its format is wrong, or the information it includes is not complete. Please try a different restart time with complete restart data files.", file_name);
+    EXECUTION_REPORT(REPORT_ERROR, -1, read_data_from_array_buffer(&restart_previous_day, sizeof(int), temp_array_buffer, buffer_content_iter, false), "Fail to load the restart data file \"%s\": its format is wrong, or the information it includes is not complete. Please try a different restart time with complete restart data files.", file_name);
+    EXECUTION_REPORT(REPORT_ERROR, -1, read_data_from_array_buffer(&restart_previous_month, sizeof(int), temp_array_buffer, buffer_content_iter, false), "Fail to load the restart data file \"%s\": its format is wrong, or the information it includes is not complete. Please try a different restart time with complete restart data files.", file_name);
+    EXECUTION_REPORT(REPORT_ERROR, -1, read_data_from_array_buffer(&restart_previous_year, sizeof(int), temp_array_buffer, buffer_content_iter, false), "Fail to load the restart data file \"%s\": its format is wrong, or the information it includes is not complete. Please try a different restart time with complete restart data files.", file_name);
+    EXECUTION_REPORT(REPORT_ERROR, -1, read_data_from_array_buffer(&restart_start_second, sizeof(int), temp_array_buffer, buffer_content_iter, false), "Fail to load the restart data file \"%s\": its format is wrong, or the information it includes is not complete. Please try a different restart time with complete restart data files.", file_name);
+    EXECUTION_REPORT(REPORT_ERROR, -1, read_data_from_array_buffer(&restart_start_day, sizeof(int), temp_array_buffer, buffer_content_iter, false), "Fail to load the restart data file \"%s\": its format is wrong, or the information it includes is not complete. Please try a different restart time with complete restart data files.", file_name);
+    EXECUTION_REPORT(REPORT_ERROR, -1, read_data_from_array_buffer(&restart_start_month, sizeof(int), temp_array_buffer, buffer_content_iter, false), "Fail to load the restart data file \"%s\": its format is wrong, or the information it includes is not complete. Please try a different restart time with complete restart data files.", file_name);
+    EXECUTION_REPORT(REPORT_ERROR, -1, read_data_from_array_buffer(&restart_start_year, sizeof(int), temp_array_buffer, buffer_content_iter, false), "Fail to load the restart data file \"%s\": its format is wrong, or the information it includes is not complete. Please try a different restart time with complete restart data files.", file_name);
+
+    if (check_existing_data) {
+        if (words_are_the_same(RUNTYPE_CONTINUE, run_type))
+            EXECUTION_REPORT(REPORT_ERROR, comp_id, words_are_the_same(restart_case_name, case_name), "Error happens when importing the restart data from the file \"%s\": the current case name (\"%s\") is different from the case name (\"%s\") imported from the restart data when it is a \"continue\" run. Please verify.", file_name, case_name, restart_case_name);
+        if (words_are_the_same(RUNTYPE_CONTINUE, run_type) || words_are_the_same(RUNTYPE_BRANCH, run_type)) {
+            char str1[NAME_STR_SIZE], str2[NAME_STR_SIZE];
+            sprintf(str1, "%04d%02d%02d-%05d", start_year, start_month, start_day, start_second);
+            sprintf(str2, "%04d%02d%02d-%05d", restart_start_year, restart_start_month, restart_start_day, restart_start_second);
+            EXECUTION_REPORT(REPORT_ERROR, comp_id, words_are_the_same(str1,str2), "Error happens when importing the restart data from the file \"%s\": the current start time (%s) of the simulation is different from the start time (%s) imported from the restart data when it is a \"continue\" or \"branch\" run. Please verify.", file_name, str1, str2);
+            if (leap_year_on)
+                strcpy(str1, "on");
+            else strcpy(str1, "off");
+            if (restart_leap_year_on)
+                strcpy(str2, "on");
+            else strcpy(str2, "off");
+            EXECUTION_REPORT(REPORT_ERROR, comp_id, leap_year_on == restart_leap_year_on, "Error happens when importing the restart data from the file \"%s\": the current setting of leap year (\"%s\") is different from the setting (\"%s\") imported from the restart data when it is a \"continue\" or \"branch\" run. Please verify. ", file_name, str1, str2);
+            EXECUTION_REPORT(REPORT_ERROR, comp_id, time_step_in_second != -1, "Error happens when importing the restart data from the file \"%s\": the time step of the component model has not been set before reading the restart data file for a \"continue\" or \"branch\" run. Please verify. ", file_name, time_step_in_second, restart_time_step_in_second);
+            EXECUTION_REPORT(REPORT_ERROR, comp_id, time_step_in_second == restart_time_step_in_second, "Error happens when importing the restart data from the file \"%s\": the current setting of time step (%d) is different from the setting (%d) imported from the restart data when it is a \"continue\" or \"branch\" run. Please verify. ", file_name, time_step_in_second, restart_time_step_in_second);
+        }    
+    }
+
+    current_second = restart_current_second;
+    current_day = restart_current_day;
+    current_month = restart_current_month;
+    current_year = restart_current_year;
+    previous_second = restart_previous_second;
+    previous_day = restart_previous_day;
+    previous_month = restart_previous_month;
+    previous_year = restart_previous_year;
+    if (time_step_in_second == -1) {
+        time_step_in_second = restart_time_step_in_second;
+        annotation_mgr->add_annotation(comp_id, "setting time step", "C-Coupler read from restart file");
+    }
     current_num_elapsed_day = calculate_elapsed_day(current_year,current_month,current_day);
-	current_step_id = ((current_num_elapsed_day-start_num_elapsed_day)*SECONDS_PER_DAY+current_second-start_second)/time_step_in_second;
-	if (words_are_the_same(RUNTYPE_CONTINUE, run_type) || words_are_the_same(RUNTYPE_BRANCH, run_type)) {
-		restart_second = current_second;
-		restart_num_elapsed_day = current_num_elapsed_day;
-		restart_full_time = restart_num_elapsed_day*((long)100000)+restart_second; 
-		EXECUTION_REPORT_LOG(REPORT_LOG, comp_id, true, "Set the restart time to %ld", restart_full_time);
-		restarted_step_id = current_step_id;
-	}
+    current_step_id = ((current_num_elapsed_day-start_num_elapsed_day)*SECONDS_PER_DAY+current_second-start_second)/time_step_in_second;
+    if (words_are_the_same(RUNTYPE_CONTINUE, run_type) || words_are_the_same(RUNTYPE_BRANCH, run_type)) {
+        restart_second = current_second;
+        restart_num_elapsed_day = current_num_elapsed_day;
+        restart_full_time = restart_num_elapsed_day*((long)100000)+restart_second; 
+        EXECUTION_REPORT_LOG(REPORT_LOG, comp_id, true, "Set the restart time to %ld", restart_full_time);
+        restarted_step_id = current_step_id;
+    }
 
-	if ((words_are_the_same(RUNTYPE_CONTINUE, run_type) || words_are_the_same(RUNTYPE_BRANCH, run_type)) && !words_are_the_same(stop_option, "date")) {
-		calculate_stop_time(current_year, current_month, current_day, current_second);
-		stop_num_elapsed_day = calculate_elapsed_day(stop_year,stop_month,stop_day);
-		current_num_elapsed_day = calculate_elapsed_day(start_year,start_month,start_day);
-		EXECUTION_REPORT(REPORT_ERROR, comp_id, set_time_step_in_second(time_step_in_second, "in Time_mgt::import_restart_data", false), "Error happens when importing the restart data from the file \"%s\": the time step does not match the setting of stop time", file_name);
-		current_num_elapsed_day = calculate_elapsed_day(current_year,current_month,current_day);
-	}
+    if ((words_are_the_same(RUNTYPE_CONTINUE, run_type) || words_are_the_same(RUNTYPE_BRANCH, run_type)) && !words_are_the_same(stop_option, "date")) {
+        calculate_stop_time(current_year, current_month, current_day, current_second);
+        stop_num_elapsed_day = calculate_elapsed_day(stop_year,stop_month,stop_day);
+        current_num_elapsed_day = calculate_elapsed_day(start_year,start_month,start_day);
+        EXECUTION_REPORT(REPORT_ERROR, comp_id, set_time_step_in_second(time_step_in_second, "in Time_mgt::import_restart_data", false), "Error happens when importing the restart data from the file \"%s\": the time step does not match the setting of stop time", file_name);
+        current_num_elapsed_day = calculate_elapsed_day(current_year,current_month,current_day);
+    }
 }
 
 
 void Time_mgt::reset_current_time_to_start_time(const char *annotation)
 {
-	Inout_interface *executed_interface = inout_interface_mgr->search_an_inout_interface_executed_with_timer(comp_id);
-	if (executed_interface != NULL)
-		EXECUTION_REPORT(REPORT_ERROR, comp_id, false, "Error happens when calling the API CCPL_reset_current_time_to_start_time: the current time cannot be reset because a coupling interface \"%s\" of the current component model has been executed without its timer bypassed. Please check the model code with the annotation \"%s\"", executed_interface->get_interface_name(), annotation);
-	initialize_to_start_time();
+    Inout_interface *executed_interface = inout_interface_mgr->search_an_inout_interface_executed_with_timer(comp_id);
+    if (executed_interface != NULL)
+        EXECUTION_REPORT(REPORT_ERROR, comp_id, false, "Error happens when calling the API CCPL_reset_current_time_to_start_time: the current time cannot be reset because a coupling interface \"%s\" of the current component model has been executed without its timer bypassed. Please check the model code with the annotation \"%s\"", executed_interface->get_interface_name(), annotation);
+    initialize_to_start_time();
+}
+
+
+bool Time_mgt::is_restart_timer_on() 
+{ 
+    if (restart_timer == NULL)
+        return false;
+    
+    return restart_timer->is_timer_on(); 
 }
 
 
+
 long Time_mgt::determine_continue_run_restart_time()
 {
-	DIR *cur_dir = opendir(comp_comm_group_mgt_mgr->get_restart_common_dir());
-	std::vector<std::pair<long, long> > comps_continue_run_candidate_restart_time;
-	struct dirent *ent = NULL;
-	struct stat st;
-	long restart_time_in_rpointer, restart_time_in_prev_rpointer;
-	char rpointer_file_name[NAME_STR_SIZE*2], prev_rpointer_file_name[NAME_STR_SIZE*2];
-	int i;
-
-	
-	EXECUTION_REPORT(REPORT_ERROR, -1, cur_dir != NULL, "Comp_comm_group_mgt_mgr::is_comp_type_coupled");
-	while ((ent = readdir(cur_dir)) != NULL) {
-		stat(ent->d_name, &st);
-		if (strlen(ent->d_name) > strlen("rpointer.") && strncmp(ent->d_name, "rpointer.", strlen("rpointer.")) == 0) {
-			sprintf(rpointer_file_name, "%s/%s", comp_comm_group_mgt_mgr->get_restart_common_dir(), ent->d_name);
-			restart_time_in_rpointer = get_restart_time_in_rpointer_file(rpointer_file_name);
-			restart_time_in_prev_rpointer = -1;
-			sprintf(prev_rpointer_file_name, "%s/prev.%s", comp_comm_group_mgt_mgr->get_restart_common_dir(), ent->d_name);
-			if (does_file_exist(prev_rpointer_file_name))
-				restart_time_in_prev_rpointer = get_restart_time_in_rpointer_file(prev_rpointer_file_name);
-			comps_continue_run_candidate_restart_time.push_back(std::make_pair(restart_time_in_rpointer, restart_time_in_prev_rpointer));
-		}
-	}
-
-	if (comps_continue_run_candidate_restart_time.size() == 0)
-		return -1;
-
-	for (i = 1; i < comps_continue_run_candidate_restart_time.size(); i ++)
-		if (comps_continue_run_candidate_restart_time[i].first != comps_continue_run_candidate_restart_time[0].first && comps_continue_run_candidate_restart_time[i].second != comps_continue_run_candidate_restart_time[0].first)
-			break;
-	if (i == comps_continue_run_candidate_restart_time.size())
-		return comps_continue_run_candidate_restart_time[0].first;
-
-	for (i = 1; i < comps_continue_run_candidate_restart_time.size(); i ++)
-		if (comps_continue_run_candidate_restart_time[i].first != comps_continue_run_candidate_restart_time[0].second && comps_continue_run_candidate_restart_time[i].second != comps_continue_run_candidate_restart_time[0].second)
-			break;
-	if (i == comps_continue_run_candidate_restart_time.size())
-		return comps_continue_run_candidate_restart_time[0].second;
-
-	return -1;
+    DIR *cur_dir = opendir(comp_comm_group_mgt_mgr->get_restart_common_dir());
+    std::vector<std::pair<long, long> > comps_continue_run_candidate_restart_time;
+    struct dirent *ent = NULL;
+    struct stat st;
+    long restart_time_in_rpointer, restart_time_in_prev_rpointer;
+    char rpointer_file_name[NAME_STR_SIZE*2], prev_rpointer_file_name[NAME_STR_SIZE*2];
+    int i;
+
+    
+    EXECUTION_REPORT(REPORT_ERROR, -1, cur_dir != NULL, "Comp_comm_group_mgt_mgr::is_comp_type_coupled");
+    while ((ent = readdir(cur_dir)) != NULL) {
+        stat(ent->d_name, &st);
+        if (strlen(ent->d_name) > strlen("rpointer.") && strncmp(ent->d_name, "rpointer.", strlen("rpointer.")) == 0) {
+            sprintf(rpointer_file_name, "%s/%s", comp_comm_group_mgt_mgr->get_restart_common_dir(), ent->d_name);
+            restart_time_in_rpointer = get_restart_time_in_rpointer_file(rpointer_file_name);
+            restart_time_in_prev_rpointer = -1;
+            sprintf(prev_rpointer_file_name, "%s/prev.%s", comp_comm_group_mgt_mgr->get_restart_common_dir(), ent->d_name);
+            if (does_file_exist(prev_rpointer_file_name))
+                restart_time_in_prev_rpointer = get_restart_time_in_rpointer_file(prev_rpointer_file_name);
+            comps_continue_run_candidate_restart_time.push_back(std::make_pair(restart_time_in_rpointer, restart_time_in_prev_rpointer));
+        }
+    }
+
+    if (comps_continue_run_candidate_restart_time.size() == 0)
+        return -1;
+
+    for (i = 1; i < comps_continue_run_candidate_restart_time.size(); i ++)
+        if (comps_continue_run_candidate_restart_time[i].first != comps_continue_run_candidate_restart_time[0].first && comps_continue_run_candidate_restart_time[i].second != comps_continue_run_candidate_restart_time[0].first)
+            break;
+    if (i == comps_continue_run_candidate_restart_time.size())
+        return comps_continue_run_candidate_restart_time[0].first;
+
+    for (i = 1; i < comps_continue_run_candidate_restart_time.size(); i ++)
+        if (comps_continue_run_candidate_restart_time[i].first != comps_continue_run_candidate_restart_time[0].second && comps_continue_run_candidate_restart_time[i].second != comps_continue_run_candidate_restart_time[0].second)
+            break;
+    if (i == comps_continue_run_candidate_restart_time.size())
+        return comps_continue_run_candidate_restart_time[0].second;
+
+    return -1;
 }
 
 
 Components_time_mgt::~Components_time_mgt()
 {
-	for (int i = 0; i < components_time_mgrs.size(); i ++)
-		delete components_time_mgrs[i];
+    for (int i = 0; i < components_time_mgrs.size(); i ++)
+        delete components_time_mgrs[i];
 }
 
 
 Time_mgt *Components_time_mgt::get_time_mgr(int comp_id)
 {
-	if (!comp_comm_group_mgt_mgr->is_legal_local_comp_id(comp_id,false))
-		return NULL;
+    if (!comp_comm_group_mgt_mgr->is_legal_local_comp_id(comp_id,false))
+        return NULL;
 
-	if (comp_comm_group_mgt_mgr->get_global_node_of_local_comp(comp_id,false, "C-Coupler native code get time manager")->get_current_proc_local_id() == -1)
-		return NULL;
+    if (comp_comm_group_mgt_mgr->get_global_node_of_local_comp(comp_id,false, "C-Coupler native code get time manager")->get_current_proc_local_id() == -1)
+        return NULL;
 
-	for (int i = 0; i < components_time_mgrs.size(); i++)
-		if (components_time_mgrs[i]->get_comp_id() == comp_id)
-			return components_time_mgrs[i];
+    for (int i = 0; i < components_time_mgrs.size(); i++)
+        if (components_time_mgrs[i]->get_comp_id() == comp_id)
+            return components_time_mgrs[i];
 
-	return NULL;
+    return NULL;
 }
 
 
 void Components_time_mgt::define_root_comp_time_mgr(int comp_id, const char *xml_file_name)
 {
-	components_time_mgrs.push_back(new Time_mgt(comp_id, xml_file_name, true));
-	components_time_mgrs[components_time_mgrs.size()-1]->build_restart_timer();
+    components_time_mgrs.push_back(new Time_mgt(comp_id, xml_file_name, true));
+    components_time_mgrs[components_time_mgrs.size()-1]->build_restart_timer();
 }
 
 
 
 void Components_time_mgt::set_component_time_step(int comp_id, int time_step, const char *annotation)
 {
-	Time_mgt *time_mgr = get_time_mgr(comp_id);
-	if (time_mgr->get_time_step_in_second() != -1 && time_mgr->get_time_step_in_second() != time_step)
-		EXECUTION_REPORT(REPORT_ERROR, comp_id, false, "Error happens when clalling API \"CCPL_set_normal_time_step\": the time step of the component model \"%s\" has already been set before (the corresponding model code annotation is \"%s\"). It cannot be set again at the model code with the annotation \"%s\"",
-						 comp_comm_group_mgt_mgr->get_global_node_of_local_comp(comp_id,false, annotation)->get_comp_name(), annotation_mgr->get_annotation(comp_id, "setting time step"), annotation);
-	annotation_mgr->add_annotation(comp_id, "setting time step", annotation);
-	if (comp_comm_group_mgt_mgr->get_current_proc_id_in_comp(comp_id, "get the local id of the current component in Components_time_mgt::set_component_time_step") == 0)
-		EXECUTION_REPORT(REPORT_ERROR, comp_id, time_step > 0, "The value of time step is wrong. It must be a positive value. Please check the model code with the annotation \"%s\"", annotation);
-	get_time_mgr(comp_id)->set_time_step_in_second(time_step, annotation, true);
+    Time_mgt *time_mgr = get_time_mgr(comp_id);
+    if (time_mgr->get_time_step_in_second() != -1 && time_mgr->get_time_step_in_second() != time_step)
+        EXECUTION_REPORT(REPORT_ERROR, comp_id, false, "Error happens when clalling API \"CCPL_set_normal_time_step\": the time step of the component model \"%s\" has already been set before (the corresponding model code annotation is \"%s\"). It cannot be set again at the model code with the annotation \"%s\"",
+                         comp_comm_group_mgt_mgr->get_global_node_of_local_comp(comp_id,false, annotation)->get_comp_name(), annotation_mgr->get_annotation(comp_id, "setting time step"), annotation);
+    annotation_mgr->add_annotation(comp_id, "setting time step", annotation);
+    if (comp_comm_group_mgt_mgr->get_current_proc_id_in_comp(comp_id, "get the local id of the current component in Components_time_mgt::set_component_time_step") == 0)
+        EXECUTION_REPORT(REPORT_ERROR, comp_id, time_step > 0, "The value of time step is wrong. It must be a positive value. Please check the model code with the annotation \"%s\"", annotation);
+    get_time_mgr(comp_id)->set_time_step_in_second(time_step, annotation, true);
 }
 
 
 void Components_time_mgt::clone_parent_comp_time_mgr(int comp_id, int parent_comp_id, const char *annotation)
 {
-	Time_mgt *parent_time_mgr = get_time_mgr(parent_comp_id);
-	Time_mgt *new_time_mgr;
+    Time_mgt *parent_time_mgr = get_time_mgr(parent_comp_id);
+    Time_mgt *new_time_mgr;
 
 
-	EXECUTION_REPORT(REPORT_ERROR, -1, comp_comm_group_mgt_mgr->is_legal_local_comp_id(comp_id,false), "Software error in Components_time_mgt::clone_parent_comp_time_mgr: wrong comp_id");
-	EXECUTION_REPORT(REPORT_ERROR, comp_id, parent_time_mgr != NULL, "Software error in Components_time_mgt::clone_parent_comp_time_mgr: parent time manager is NULL");
-	new_time_mgr = parent_time_mgr->clone_time_mgr(comp_id);
-	components_time_mgrs.push_back(new_time_mgr);
-	new_time_mgr->build_restart_timer();
+    EXECUTION_REPORT(REPORT_ERROR, -1, comp_comm_group_mgt_mgr->is_legal_local_comp_id(comp_id,false), "Software error in Components_time_mgt::clone_parent_comp_time_mgr: wrong comp_id");
+    EXECUTION_REPORT(REPORT_ERROR, comp_id, parent_time_mgr != NULL, "Software error in Components_time_mgt::clone_parent_comp_time_mgr: parent time manager is NULL");
+    new_time_mgr = parent_time_mgr->clone_time_mgr(comp_id);
+    components_time_mgrs.push_back(new_time_mgr);
+    new_time_mgr->build_restart_timer();
 }
 
 
 void Components_time_mgt::advance_component_time(int comp_id, const char *annotation)
 {
-	Time_mgt *time_mgr = get_time_mgr(comp_id);
-	time_mgr->advance_model_time(annotation, true);
-	comp_comm_group_mgt_mgr->set_current_proc_current_time(comp_id, time_mgr->get_current_num_elapsed_day(), time_mgr->get_current_second());
+    Time_mgt *time_mgr = get_time_mgr(comp_id);
+    time_mgr->advance_model_time(annotation, true);
+    comp_comm_group_mgt_mgr->set_current_proc_current_time(comp_id, time_mgr->get_current_num_elapsed_day(), time_mgr->get_current_second());
     EXECUTION_REPORT_LOG(REPORT_LOG, comp_id, true, "The current time is %08d-%05d, and the current number of the time step is %d", time_mgr->get_current_date(), time_mgr->get_current_second(), time_mgr->get_current_step_id());
-	comp_comm_group_mgt_mgr->search_global_node(comp_id)->get_restart_mgr()->write_restart_mgt_into_file();
+    comp_comm_group_mgt_mgr->search_global_node(comp_id)->get_restart_mgr()->write_restart_mgt_into_file();
 }
 
 
 void Components_time_mgt::check_component_current_time(int comp_id, int date, int second, const char *annotation)
 {
-	Time_mgt *comp_time_mgr = get_time_mgr(comp_id);
-	EXECUTION_REPORT(REPORT_ERROR, -1, comp_time_mgr != NULL, "The parameter of component id for checking the current time is wrong. Please check the model code with the annotation of \"%s\"", annotation);
-	comp_time_mgr->check_consistency_of_current_time(date, second, annotation);
+    Time_mgt *comp_time_mgr = get_time_mgr(comp_id);
+    EXECUTION_REPORT(REPORT_ERROR, -1, comp_time_mgr != NULL, "The parameter of component id for checking the current time is wrong. Please check the model code with the annotation of \"%s\"", annotation);
+    comp_time_mgr->check_consistency_of_current_time(date, second, annotation);
 }
 
 
 bool Components_time_mgt::is_model_run_ended(int comp_id, const char *annotation)
 {
-	Time_mgt *comp_time_mgr = get_time_mgr(comp_id);
-	EXECUTION_REPORT(REPORT_ERROR, -1, comp_time_mgr != NULL, "The parameter of component id for checking the current time is wrong. Please check the model code with the annotation of \"%s\"", annotation);
-	return comp_time_mgr->check_is_model_run_finished();
+    Time_mgt *comp_time_mgr = get_time_mgr(comp_id);
+    EXECUTION_REPORT(REPORT_ERROR, -1, comp_time_mgr != NULL, "The parameter of component id for checking the current time is wrong. Please check the model code with the annotation of \"%s\"", annotation);
+    return comp_time_mgr->check_is_model_run_finished();
 }
 
diff --git a/src/Driver/timer_mgt.h b/src/Driver/timer_mgt.h
old mode 100644
new mode 100755
index bb4247a..4808b69
--- a/src/Driver/timer_mgt.h
+++ b/src/Driver/timer_mgt.h
@@ -45,10 +45,10 @@
 #define RUNTYPE_BRANCH                  "branch"
 #define RUNTYPE_HYBRID                  "hybrid"
 
-#define SECONDS_PER_DAY                 86400
-#define NUM_MONTH_PER_YEAR              12
-#define NUM_DAYS_PER_NONLEAP_YEAR       365
-#define NUM_DAYS_PER_LEAP_YEAR          366
+#define SECONDS_PER_DAY                 ((long)86400)
+#define NUM_MONTH_PER_YEAR              ((long)12)
+#define NUM_DAYS_PER_NONLEAP_YEAR       ((long)365)
+#define NUM_DAYS_PER_LEAP_YEAR          ((long)366)
 
 
 #define IS_TIME_UNIT_STEP(unit)         (words_are_the_same(unit,FREQUENCY_UNIT_STEP) || words_are_the_same(unit,FREQUENCY_UNIT_STEPS) || words_are_the_same(unit,FREQUENCY_UNIT_NSTEP) || words_are_the_same(unit,FREQUENCY_UNIT_NSTEPS))
@@ -87,51 +87,51 @@ class Coupling_timer
         friend class Time_mgt;
         char frequency_unit[NAME_STR_SIZE];
         int frequency_count;
-		int local_lag_count;
+        int local_lag_count;
         int remote_lag_count;
-		int timer_id;
-		int comp_id;
-		std::vector<Coupling_timer*> children;
-		Time_mgt *comp_time_mgr;
-		int or_or_and;
+        int timer_id;
+        int comp_id;
+        std::vector<Coupling_timer*> children;
+        Time_mgt *comp_time_mgr;
+        int or_or_and;
         
     public:
-		Coupling_timer(int, int, int*, int, int, const char *);
-		Coupling_timer(int, int, const char*, int, int, int, const char*);
-		Coupling_timer(int, int, Coupling_timer*);
-		Coupling_timer(const char*, long &, int, bool, bool &);
+        Coupling_timer(int, int, int*, int, int, const char *);
+        Coupling_timer(int, int, const char*, int, int, int, const char*);
+        Coupling_timer(int, int, Coupling_timer*);
+        Coupling_timer(const char*, long &, int, bool, bool &);
         ~Coupling_timer();
         bool is_timer_on();
-		bool is_timer_on(int, int, int, int, int, int, int, int, int, int);
-		int get_timer_id() { return timer_id; }
-		int get_comp_id() { return comp_id; }
-		int get_frequency_count() { return frequency_count; }
-		int get_local_lag_count() { return local_lag_count; } 
-		int get_remote_lag_count() { return remote_lag_count; }
-		const char *get_frequency_unit() { return frequency_unit; }
-		void write_timer_into_array(char **, long &, long &);
-		void get_time_of_next_timer_on(Time_mgt *, int, int, int, int, int, int, int &, int &, bool);
-		void reset_remote_lag_count() { remote_lag_count = 0; }
-		void check_timer_format();
-		bool is_the_same_with(Coupling_timer *);
+        bool is_timer_on(int, int, int, int, int, int, int, int, int, int);
+        int get_timer_id() { return timer_id; }
+        int get_comp_id() { return comp_id; }
+        int get_frequency_count() { return frequency_count; }
+        int get_local_lag_count() { return local_lag_count; } 
+        int get_remote_lag_count() { return remote_lag_count; }
+        const char *get_frequency_unit() { return frequency_unit; }
+        void write_timer_into_array(char **, long &, long &);
+        void get_time_of_next_timer_on(Time_mgt *, int, int, int, int, int, int, int &, int &, int &, bool);
+        void reset_remote_lag_count() { remote_lag_count = 0; }
+        void check_timer_format();
+        bool is_the_same_with(Coupling_timer *);
 };
 
 
 class Timer_mgt
 {
-	private:
-		std::vector<Coupling_timer*> timers;
+    private:
+        std::vector<Coupling_timer*> timers;
 
-	public:
-		Timer_mgt() {};
-		~Timer_mgt();
-		bool check_is_legal_timer_id(int);
-		Coupling_timer *get_timer(int);
-		int define_timer(int, const char*, int, int, int, const char*);
-		int define_timer(int, int*, int, int, int, const char*);
-		int define_timer(int, Coupling_timer*);
-		bool is_timer_on(int, const char*);
-		void add_timer(Coupling_timer *);
+    public:
+        Timer_mgt() {};
+        ~Timer_mgt();
+        bool check_is_legal_timer_id(int);
+        Coupling_timer *get_timer(int);
+        int define_timer(int, const char*, int, int, int, const char*);
+        int define_timer(int, int*, int, int, int, const char*);
+        int define_timer(int, Coupling_timer*);
+        bool is_timer_on(int, const char*);
+        void add_timer(Coupling_timer *);
 };
 
 
@@ -151,48 +151,48 @@ class Time_mgt
         int current_month;
         int current_day; 
         int current_second;
-		int reference_year;
-		int reference_month;
-		int reference_day;
+        int reference_year;
+        int reference_month;
+        int reference_day;
         int stop_year;
         int stop_month;
         int stop_day;
         int stop_second;
         int time_step_in_second; 
         int current_num_elapsed_day;
-		int start_num_elapsed_day;
-		int restart_num_elapsed_day;		
-		long common_restart_full_time;
-		long restart_full_time;
-		int stop_num_elapsed_day;
+        int start_num_elapsed_day;
+        int restart_num_elapsed_day;        
+        long common_restart_full_time;
+        long restart_full_time;
+        int stop_num_elapsed_day;
         int current_step_id;
-		int restarted_step_id;
+        int restarted_step_id;
         long num_total_steps;
         bool leap_year_on;
         Coupling_timer *restart_timer;
-		int comp_id;
-		char case_name[NAME_STR_SIZE];
-		char exp_model_name[NAME_STR_SIZE];
-		char case_desc[NAME_STR_SIZE];
-		char run_type[NAME_STR_SIZE];
-		int runtype_mark;
-		char stop_option[NAME_STR_SIZE];
-		char rest_freq_unit[NAME_STR_SIZE];
-		int rest_freq_count;
-		char rest_refcase[NAME_STR_SIZE];
-		int rest_refdate;
-		int rest_refsecond;
-		bool advance_time_synchronized;
-		bool time_has_been_advanced;
-		int stop_n;
+        int comp_id;
+        char case_name[NAME_STR_SIZE];
+        char exp_model_name[NAME_STR_SIZE];
+        char case_desc[NAME_STR_SIZE];
+        char run_type[NAME_STR_SIZE];
+        int runtype_mark;
+        char stop_option[NAME_STR_SIZE];
+        char rest_freq_unit[NAME_STR_SIZE];
+        int rest_freq_count;
+        char rest_refcase[NAME_STR_SIZE];
+        int rest_refdate;
+        int rest_refsecond;
+        bool advance_time_synchronized;
+        bool time_has_been_advanced;
+        int stop_n;
 
     public:
-		Time_mgt() {}
-		Time_mgt(int, const char *, bool);
+        Time_mgt() {}
+        Time_mgt(int, const char *, bool);
         ~Time_mgt();
-		void initialize_to_start_time();
+        void initialize_to_start_time();
         void advance_model_time(const char*, bool);
-		void advance_time(int &, int &, int &, int &, int &, int);
+        void advance_time(int &, int &, int &, int &, int &, int);
         int get_current_year() { return current_year; }
         int get_current_month() { return current_month; }
         int get_current_day() { return current_day; }
@@ -200,16 +200,16 @@ class Time_mgt
         int get_current_minute() { return (current_second % 3600) / 60; }
         int get_current_second() { return current_second; }
         int get_time_step_in_second() { return time_step_in_second; }
-		int get_stop_year() { return stop_year; }
-		int get_stop_month() { return stop_month; }
-		int get_stop_day() { return stop_day; }
-		int get_stop_second() { return stop_second; }
-		int get_start_year() { return start_year; }
-		int get_start_month() { return start_month; }
-		int get_start_day() { return start_day; }
-		int get_start_second() { return start_second; }
-		int get_start_num_elapsed_day() { return start_num_elapsed_day; }
-		int get_stop_num_elapsed_day() { return stop_num_elapsed_day; }
+        int get_stop_year() { return stop_year; }
+        int get_stop_month() { return stop_month; }
+        int get_stop_day() { return stop_day; }
+        int get_stop_second() { return stop_second; }
+        int get_start_year() { return start_year; }
+        int get_start_month() { return start_month; }
+        int get_start_day() { return start_day; }
+        int get_start_second() { return start_second; }
+        int get_start_num_elapsed_day() { return start_num_elapsed_day; }
+        int get_stop_num_elapsed_day() { return stop_num_elapsed_day; }
         bool is_timer_on(const char *, int, int);
         bool check_is_model_run_finished();
         bool check_is_coupled_run_restart_time();
@@ -221,58 +221,59 @@ class Time_mgt
         int get_current_date();
         int get_current_num_time_step();
         long get_num_total_step() { return num_total_steps; }
-		int get_current_num_days_in_year();
+        int get_current_num_days_in_year();
         void check_timer_format(const char*, int, int, int, bool, const char*);
-		bool check_time_consistency_between_components(long);
+        bool check_time_consistency_between_components(long);
         long calculate_elapsed_day(int, int, int);
-		void get_elapsed_days_from_start_date(int*, int*);
-		void get_elapsed_days_from_reference_date(int*, int*);
-		void get_current_time(int&, int&, int&, int&, int, const char*);
-		bool check_is_time_legal(int, int, int, int, const char*);
-		bool get_is_leap_year_on() { return leap_year_on; }
-		int get_comp_id() { return comp_id; }
-		Time_mgt *clone_time_mgr(int);
-		bool set_time_step_in_second(int, const char*, bool);
-		bool is_a_leap_year(int);
-		void build_restart_timer();
-		int get_current_step_id() { return current_step_id; }
-		void check_consistency_of_current_time(int, int, const char*);
-		int get_current_num_elapsed_day() { return current_num_elapsed_day; }
-		bool is_time_out_of_execution(long);
-		void write_time_mgt_into_array(char **, long &, long &);
-		void import_restart_data(const char*, long&, const char *, bool);
-		bool is_restart_timer_on() { return restart_timer->is_timer_on(); }
-		const char *get_case_name() { return case_name; }
-		const char *get_run_type() { return run_type; }
-		const char *get_rest_refcase() { return rest_refcase; }
-		int get_rest_refdate() { return rest_refdate; }
-		int get_rest_refsecond() { return rest_refsecond; }
-		bool is_first_restart_step() { return current_step_id == restarted_step_id; }
-		void calculate_stop_time(int, int, int, int);
-		bool get_time_has_been_advanced() { return time_has_been_advanced; }
-		void reset_current_time_to_start_time(const char*);
-		long get_restart_full_time() { return restart_full_time; }
-		long get_common_restart_full_time() { return common_restart_full_time; }
-		int get_runtype_mark() { return runtype_mark; }
-		long determine_continue_run_restart_time();
+		long get_elapsed_day_from_full_time(long);
+        void get_elapsed_days_from_start_date(int*, int*);
+        void get_elapsed_days_from_reference_date(int*, int*);
+        void get_current_time(int&, int&, int&, int&, int, const char*);
+        bool check_is_time_legal(int, int, int, int, const char*);
+        bool get_is_leap_year_on() { return leap_year_on; }
+        int get_comp_id() { return comp_id; }
+        Time_mgt *clone_time_mgr(int);
+        bool set_time_step_in_second(int, const char*, bool);
+        bool is_a_leap_year(int);
+        void build_restart_timer();
+        int get_current_step_id() { return current_step_id; }
+        void check_consistency_of_current_time(int, int, const char*);
+        int get_current_num_elapsed_day() { return current_num_elapsed_day; }
+        bool is_time_out_of_execution(long);
+        void write_time_mgt_into_array(char **, long &, long &);
+        void import_restart_data(const char*, long&, const char *, bool);
+        bool is_restart_timer_on();
+        const char *get_case_name() { return case_name; }
+        const char *get_run_type() { return run_type; }
+        const char *get_rest_refcase() { return rest_refcase; }
+        int get_rest_refdate() { return rest_refdate; }
+        int get_rest_refsecond() { return rest_refsecond; }
+        bool is_first_restart_step() { return current_step_id == restarted_step_id; }
+        void calculate_stop_time(int, int, int, int);
+        bool get_time_has_been_advanced() { return time_has_been_advanced; }
+        void reset_current_time_to_start_time(const char*);
+        long get_restart_full_time() { return restart_full_time; }
+        long get_common_restart_full_time() { return common_restart_full_time; }
+        int get_runtype_mark() { return runtype_mark; }
+        long determine_continue_run_restart_time();
 };
 
 
 class Components_time_mgt
 {
-	private:
-		std::vector<Time_mgt*> components_time_mgrs;
+    private:
+        std::vector<Time_mgt*> components_time_mgrs;
 
-	public:
-		Components_time_mgt() {}
-		~Components_time_mgt();
-		Time_mgt *get_time_mgr(int);
-		void define_root_comp_time_mgr(int, const char*);
-		void clone_parent_comp_time_mgr(int, int, const char*);
-		void set_component_time_step(int, int, const char*);
-		void advance_component_time(int, const char*);
-		bool is_model_run_ended(int, const char*);
-		void check_component_current_time(int, int, int, const char*);
+    public:
+        Components_time_mgt() {}
+        ~Components_time_mgt();
+        Time_mgt *get_time_mgr(int);
+        void define_root_comp_time_mgr(int, const char*);
+        void clone_parent_comp_time_mgr(int, int, const char*);
+        void set_component_time_step(int, int, const char*);
+        void advance_component_time(int, const char*);
+        bool is_model_run_ended(int, const char*);
+        void check_component_current_time(int, int, int, const char*);
 };
 
 
diff --git a/src/Parallel_MGT/compset_communicators_info_mgt.cxx b/src/Parallel_MGT/compset_communicators_info_mgt.cxx
old mode 100644
new mode 100755
index 86c0e8d..ab0a4be
--- a/src/Parallel_MGT/compset_communicators_info_mgt.cxx
+++ b/src/Parallel_MGT/compset_communicators_info_mgt.cxx
@@ -25,29 +25,29 @@
 
 void output_CCPL_log(const char *log_string, const char *log_file_name, char **log_buffer, int &log_buffer_content_size, bool flush_log_file)
 {
-	if (*log_buffer == NULL) {
-		*log_buffer = new char [LOG_BUFFER_MAX_SIZE];
-		*log_buffer[0] = '\0';
-		log_buffer_content_size = 0;
-	}
+    if (*log_buffer == NULL) {
+        *log_buffer = new char [LOG_BUFFER_MAX_SIZE];
+        *log_buffer[0] = '\0';
+        log_buffer_content_size = 0;
+    }
 
-	strcat(*log_buffer, log_string);
-	log_buffer_content_size += strlen(log_string);
-
-	if (log_buffer_content_size >= LOG_BUFFER_MAX_CONTENT_SIZE)
-		flush_log_file = true;
-
-	if (flush_log_file) {
-		FILE *log_file = stdout;
-		if (log_file_name != NULL)
-			log_file = fopen(log_file_name, "a+");
-		fprintf(log_file, *log_buffer);
-		fflush(log_file);
-		if (log_file_name != NULL)
-			fclose(log_file);
-		*log_buffer[0] = '\0';
-		log_buffer_content_size = 0;
-	}
+    strcat(*log_buffer, log_string);
+    log_buffer_content_size += strlen(log_string);
+
+    if (log_buffer_content_size >= LOG_BUFFER_MAX_CONTENT_SIZE)
+        flush_log_file = true;
+
+    if (flush_log_file) {
+        FILE *log_file = stdout;
+        if (log_file_name != NULL)
+            log_file = fopen(log_file_name, "a+");
+        fprintf(log_file, *log_buffer);
+        fflush(log_file);
+        if (log_file_name != NULL)
+            fclose(log_file);
+        *log_buffer[0] = '\0';
+        log_buffer_content_size = 0;
+    }
 }
 
 
@@ -61,15 +61,18 @@ void recursively_remove_directory()
         return;
  
     while ((ent = readdir(cur_dir)) != NULL) {
-        stat(ent->d_name, &st);
+        if (stat(ent->d_name, &st) != 0)
+			continue;
      
         if (words_are_the_same(ent->d_name, ".") || words_are_the_same(ent->d_name, ".."))
             continue;
  
         if (S_ISDIR(st.st_mode)) {
+		    char old_path[NAME_STR_SIZE];
+		    getcwd(old_path, NAME_STR_SIZE);
             chdir(ent->d_name);
             recursively_remove_directory();
-            chdir("..");
+            chdir(old_path);
         }
         remove(ent->d_name);
     }
@@ -85,8 +88,8 @@ void remove_directory(const char *path)
     getcwd(old_path, NAME_STR_SIZE);
      
     if (chdir(path) == -1)
-    	EXECUTION_REPORT(REPORT_ERROR, -1, false, "Fail to open \"%s\" which should be a directory");
-	
+        EXECUTION_REPORT(REPORT_ERROR, -1, false, "Fail to open \"%s\" which should be a directory");
+    
     recursively_remove_directory();
     chdir(old_path);
 }
@@ -94,402 +97,402 @@ void remove_directory(const char *path)
 
 void create_directory(const char *path, MPI_Comm comm, bool is_root_proc, bool new_dir)
 {
-	char buffer[NAME_STR_SIZE];
-	
-
-	if (is_root_proc) {
-		DIR *dir=opendir(path);
-		if (dir != NULL && new_dir)
-			remove_directory(path);
-		if (dir == NULL) {
-			umask(0);
-			mkdir(path, S_IRWXU|S_IRWXG|S_IROTH|S_IXOTH);
-			int retcode = errno;
-			dir=opendir(path);
-			EXECUTION_REPORT(REPORT_ERROR, -1, dir != NULL, "Directory \"%s\" cannot be created: %s. Please verify.", path, strerror(retcode));
-		}
-	}	
+    char buffer[NAME_STR_SIZE];
+    
+
+    if (is_root_proc) {
+        DIR *dir=opendir(path);
+        if (dir != NULL && new_dir)
+            remove_directory(path);
+        if (dir == NULL) {
+            umask(0);
+            mkdir(path, S_IRWXU|S_IRWXG|S_IROTH|S_IXOTH);
+            int retcode = errno;
+            dir=opendir(path);
+            EXECUTION_REPORT(REPORT_ERROR, -1, dir != NULL, "Directory \"%s\" cannot be created: %s. Please verify.", path, strerror(retcode));
+        }
+    }    
 }
 
 
 Comp_comm_group_mgt_node::~Comp_comm_group_mgt_node()
 {
-	if (performance_timing_mgr != NULL)
-		delete performance_timing_mgr;
-	
-	if (log_buffer != NULL) {
-		output_log("", true);
-		delete [] log_buffer;
-	}
+    if (performance_timing_mgr != NULL)
+        delete performance_timing_mgr;
+    
+    if (log_buffer != NULL) {
+        output_log("", true);
+        delete [] log_buffer;
+    }
 
-	if (temp_array_buffer != NULL)
-		delete [] temp_array_buffer;
+    if (temp_array_buffer != NULL)
+        delete [] temp_array_buffer;
 
-	if (restart_mgr != NULL)
-		delete restart_mgr;
+    if (restart_mgr != NULL)
+        delete restart_mgr;
 
-	if (proc_latest_model_time != NULL)
-		delete [] proc_latest_model_time;
+    if (proc_latest_model_time != NULL)
+        delete [] proc_latest_model_time;
 }
 
 
 Comp_comm_group_mgt_node::Comp_comm_group_mgt_node(const char *comp_name, const char *comp_type, int comp_id, Comp_comm_group_mgt_node *parent, MPI_Comm &comm, bool enabled_in_parent_coupling_gen, const char *annotation)
 {
-	std::vector<char*> unique_comp_name;
-	int i, j, num_procs, current_proc_local_id_in_parent, *process_comp_id, *processes_global_id;
-	MPI_Comm parent_comm;
-	char dir[NAME_STR_SIZE];
-	Comp_comm_group_mgt_node *ancestor = parent;
-
-	
-	strcpy(this->comp_name, comp_name);
-	strcpy(this->comp_type, comp_type);
-	if (parent != NULL && words_are_the_same(parent->get_comp_type(), COMP_TYPE_PSEUDO_COUPLED) && parent->children.size() > 0)
-		EXECUTION_REPORT(REPORT_ERROR, parent->get_comp_id(), false, "Error happens when registering the component model \"%s\": its parent \"%s\" is an inactive component model and already has one child \"%s\". Please note that an inactive component model can have at most one child. Please check the model code with the annotation \"%s\"", comp_name, parent->comp_name, parent->children[0]->comp_name, annotation);
-
-	while(ancestor != NULL && words_are_the_same(ancestor->get_comp_type(), COMP_TYPE_PSEUDO_COUPLED)) 
-		ancestor = ancestor->get_parent();
-	if (ancestor == NULL || words_are_the_same(ancestor->get_comp_name(), COMP_TYPE_ROOT))
-		strcpy(this->full_name, this->comp_name);
-	else sprintf(this->full_name, "%s@%s", ancestor->get_full_name(), this->comp_name);
-	strcpy(this->annotation_start, annotation);
-	this->annotation_end[0] = '\0';
-	this->comp_id = comp_id;
-	this->parent = parent;
-	this->buffer_content_size = 0;
-	this->buffer_max_size = 1024;
-	this->temp_array_buffer = new char [buffer_max_size];
-	this->definition_finalized = false;	
-	this->proc_latest_model_time = NULL;
-	this->enabled_in_parent_coupling_generation = enabled_in_parent_coupling_gen;
-	this->log_buffer = NULL;
-	this->performance_timing_mgr = new Performance_timing_mgt(comp_id);
-	restart_mgr = new Restart_mgt(this);
-	comp_ccpl_log_file_name[0] = '\0';
-	comp_model_log_file_name[0] = '\0';
-	comp_model_log_file_device = -1;
-	min_remote_lag_seconds = 0;
-	max_remote_lag_seconds = 0;
-
-	if (comm != MPI_COMM_NULL) {
-		comm_group = comm;
-		if (parent == NULL)
-			synchronize_comp_processes_for_API(-1, API_ID_COMP_MGT_REG_COMP, comm, "checking the given communicator for registering root component", annotation);
-		else {
-			char tmp_string[NAME_STR_SIZE];
-			sprintf(tmp_string, "for checking the given communicator for registering a child component \"%s\"", comp_name);
-			synchronize_comp_processes_for_API(parent->get_comp_id(), API_ID_COMP_MGT_REG_COMP, comm, tmp_string, annotation);			
-			check_API_parameter_string(parent->get_comp_id(), API_ID_COMP_MGT_REG_COMP, comm, "registering a component model", parent->get_comp_name(), "\"parent_id\" (the parent component model)", annotation);
-		}	
-	}
-	else {
-		EXECUTION_REPORT(REPORT_ERROR,-1, parent != NULL, "Software error in Comp_comm_group_mgt_node::Comp_comm_group_mgt_node for checking parent");
-		synchronize_comp_processes_for_API(parent->get_comp_id(), API_ID_COMP_MGT_REG_COMP, parent->get_comm_group(), "checking the communicator of the current component for registering its children component", annotation);
-		check_API_parameter_string(parent->get_comp_id(), API_ID_COMP_MGT_REG_COMP, parent->get_comm_group(), "registering a component model", parent->get_comp_name(), "\"parent_id\" (the parent component model)", annotation);
-		parent_comm = parent->get_comm_group();
-		if ((parent->comp_id&TYPE_ID_SUFFIX_MASK) != 0)
-			EXECUTION_REPORT_LOG(REPORT_LOG, parent->comp_id, true, 
-			                 "Before the MPI_barrier for synchronizing all processes of the parent component \"%s\" for registerring its children components including \"%s\" (the corresponding model code annotation is \"%s\")", 
-			                 parent->get_comp_name(), comp_name, annotation);
-		else if (parent->get_current_proc_local_id() == 0) 
-			EXECUTION_REPORT_LOG(REPORT_LOG, -1, true, 
-			                 "Before the MPI_barrier for synchronizing all processes of the whole coupled model for registerring root components including \"%s\" (the corresponding model code annotation is \"%s\")", 
-			                 comp_name, annotation);	
-		EXECUTION_REPORT(REPORT_ERROR,-1, MPI_Barrier(parent_comm) == MPI_SUCCESS);
-		if ((parent->comp_id&TYPE_ID_SUFFIX_MASK) != 0)
-			EXECUTION_REPORT_LOG(REPORT_LOG, parent->comp_id, true, 
-			                 "After the MPI_barrier for synchronizing all processes of the parent component \"%s\" for registerring its children components including \"%s\" (the corresponding model code annotation is \"%s\")", 
-			                 parent->get_comp_name(), comp_name, annotation);
-		else if (parent->get_current_proc_local_id() == 0) 
-			EXECUTION_REPORT_LOG(REPORT_LOG, -1, true, 
-			                 "After the MPI_barrier for synchronizing all processes of the whole coupled model for registerring root components including \"%s\" (the corresponding model code annotation is \"%s\")", 
-			                 comp_name, annotation);	
-		EXECUTION_REPORT(REPORT_ERROR,-1, MPI_Comm_size(parent_comm, &num_procs) == MPI_SUCCESS);
-		EXECUTION_REPORT(REPORT_ERROR,-1, MPI_Comm_rank(parent_comm, &current_proc_local_id_in_parent) == MPI_SUCCESS);
-		char *all_comp_name;
-		if (current_proc_local_id_in_parent == 0) 
-			all_comp_name = new char [NAME_STR_SIZE*num_procs];
-		process_comp_id = new int [num_procs];
-		EXECUTION_REPORT(REPORT_ERROR,-1, MPI_Gather((char*)comp_name, NAME_STR_SIZE, MPI_CHAR, all_comp_name, NAME_STR_SIZE, MPI_CHAR, 0, parent_comm) == MPI_SUCCESS);
-		if (current_proc_local_id_in_parent == 0) {
-			unique_comp_name.push_back(all_comp_name);
-			process_comp_id[0] = 0;
-			for (i = 1; i < num_procs; i ++) {
-				for (j = 0; j < unique_comp_name.size(); j ++)
-					if (words_are_the_same(unique_comp_name[j], all_comp_name+i*NAME_STR_SIZE)) {
-						break;
-					}
-				if (j == unique_comp_name.size())
-					unique_comp_name.push_back(all_comp_name+i*NAME_STR_SIZE);
-				process_comp_id[i] = j;
-			}
-		}
-		EXECUTION_REPORT(REPORT_ERROR,-1, MPI_Bcast(process_comp_id, num_procs, MPI_INT, 0, parent_comm)  == MPI_SUCCESS);
-		EXECUTION_REPORT(REPORT_ERROR,-1, MPI_Comm_split(parent_comm, process_comp_id[current_proc_local_id_in_parent], 0, &comm_group) == MPI_SUCCESS);
-		if (current_proc_local_id_in_parent == 0)
-			delete [] all_comp_name;
-		delete [] process_comp_id;
-		comm = comm_group;
-	}
+    std::vector<char*> unique_comp_name;
+    int i, j, num_procs, current_proc_local_id_in_parent, *process_comp_id, *processes_global_id;
+    MPI_Comm parent_comm;
+    char dir[NAME_STR_SIZE];
+    Comp_comm_group_mgt_node *ancestor = parent;
+
+    
+    strcpy(this->comp_name, comp_name);
+    strcpy(this->comp_type, comp_type);
+    if (parent != NULL && words_are_the_same(parent->get_comp_type(), COMP_TYPE_PSEUDO_COUPLED) && parent->children.size() > 0)
+        EXECUTION_REPORT(REPORT_ERROR, parent->get_comp_id(), false, "Error happens when registering the component model \"%s\": its parent \"%s\" is an inactive component model and already has one child \"%s\". Please note that an inactive component model can have at most one child. Please check the model code with the annotation \"%s\"", comp_name, parent->comp_name, parent->children[0]->comp_name, annotation);
+
+    while(ancestor != NULL && words_are_the_same(ancestor->get_comp_type(), COMP_TYPE_PSEUDO_COUPLED)) 
+        ancestor = ancestor->get_parent();
+    if (ancestor == NULL || words_are_the_same(ancestor->get_comp_name(), COMP_TYPE_ROOT))
+        strcpy(this->full_name, this->comp_name);
+    else sprintf(this->full_name, "%s@%s", ancestor->get_full_name(), this->comp_name);
+    strcpy(this->annotation_start, annotation);
+    this->annotation_end[0] = '\0';
+    this->comp_id = comp_id;
+    this->parent = parent;
+    this->buffer_content_size = 0;
+    this->buffer_max_size = 1024;
+    this->temp_array_buffer = new char [buffer_max_size];
+    this->definition_finalized = false;    
+    this->proc_latest_model_time = NULL;
+    this->enabled_in_parent_coupling_generation = enabled_in_parent_coupling_gen;
+    this->log_buffer = NULL;
+    this->performance_timing_mgr = new Performance_timing_mgt(comp_id);
+    restart_mgr = new Restart_mgt(this);
+    comp_ccpl_log_file_name[0] = '\0';
+    comp_model_log_file_name[0] = '\0';
+    comp_model_log_file_device = -1;
+    min_remote_lag_seconds = 0;
+    max_remote_lag_seconds = 0;
+
+    if (comm != MPI_COMM_NULL) {
+        comm_group = comm;
+        if (parent == NULL)
+            synchronize_comp_processes_for_API(-1, API_ID_COMP_MGT_REG_COMP, comm, "checking the given communicator for registering root component", annotation);
+        else {
+            char tmp_string[NAME_STR_SIZE];
+            sprintf(tmp_string, "for checking the given communicator for registering a child component \"%s\"", comp_name);
+            synchronize_comp_processes_for_API(parent->get_comp_id(), API_ID_COMP_MGT_REG_COMP, comm, tmp_string, annotation);            
+            check_API_parameter_string(parent->get_comp_id(), API_ID_COMP_MGT_REG_COMP, comm, "registering a component model", parent->get_comp_name(), "\"parent_id\" (the parent component model)", annotation);
+        }    
+    }
+    else {
+        EXECUTION_REPORT(REPORT_ERROR,-1, parent != NULL, "Software error in Comp_comm_group_mgt_node::Comp_comm_group_mgt_node for checking parent");
+        synchronize_comp_processes_for_API(parent->get_comp_id(), API_ID_COMP_MGT_REG_COMP, parent->get_comm_group(), "checking the communicator of the current component for registering its children component", annotation);
+        check_API_parameter_string(parent->get_comp_id(), API_ID_COMP_MGT_REG_COMP, parent->get_comm_group(), "registering a component model", parent->get_comp_name(), "\"parent_id\" (the parent component model)", annotation);
+        parent_comm = parent->get_comm_group();
+        if ((parent->comp_id&TYPE_ID_SUFFIX_MASK) != 0)
+            EXECUTION_REPORT_LOG(REPORT_LOG, parent->comp_id, true, 
+                             "Before the MPI_barrier for synchronizing all processes of the parent component \"%s\" for registering its children components including \"%s\" (the corresponding model code annotation is \"%s\")", 
+                             parent->get_comp_name(), comp_name, annotation);
+        else if (parent->get_current_proc_local_id() == 0) 
+            EXECUTION_REPORT_LOG(REPORT_LOG, -1, true, 
+                             "Before the MPI_barrier for synchronizing all processes of the whole coupled model for registering root components including \"%s\" (the corresponding model code annotation is \"%s\")", 
+                             comp_name, annotation);    
+        EXECUTION_REPORT(REPORT_ERROR,-1, MPI_Barrier(parent_comm) == MPI_SUCCESS);
+        if ((parent->comp_id&TYPE_ID_SUFFIX_MASK) != 0)
+            EXECUTION_REPORT_LOG(REPORT_LOG, parent->comp_id, true, 
+                             "After the MPI_barrier for synchronizing all processes of the parent component \"%s\" for registering its children components including \"%s\" (the corresponding model code annotation is \"%s\")", 
+                             parent->get_comp_name(), comp_name, annotation);
+        else if (parent->get_current_proc_local_id() == 0) 
+            EXECUTION_REPORT_LOG(REPORT_LOG, -1, true, 
+                             "After the MPI_barrier for synchronizing all processes of the whole coupled model for registering root components including \"%s\" (the corresponding model code annotation is \"%s\")", 
+                             comp_name, annotation);    
+        EXECUTION_REPORT(REPORT_ERROR,-1, MPI_Comm_size(parent_comm, &num_procs) == MPI_SUCCESS);
+        EXECUTION_REPORT(REPORT_ERROR,-1, MPI_Comm_rank(parent_comm, &current_proc_local_id_in_parent) == MPI_SUCCESS);
+        char *all_comp_name;
+        if (current_proc_local_id_in_parent == 0) 
+            all_comp_name = new char [NAME_STR_SIZE*num_procs];
+        process_comp_id = new int [num_procs];
+        EXECUTION_REPORT(REPORT_ERROR,-1, MPI_Gather((char*)comp_name, NAME_STR_SIZE, MPI_CHAR, all_comp_name, NAME_STR_SIZE, MPI_CHAR, 0, parent_comm) == MPI_SUCCESS);
+        if (current_proc_local_id_in_parent == 0) {
+            unique_comp_name.push_back(all_comp_name);
+            process_comp_id[0] = 0;
+            for (i = 1; i < num_procs; i ++) {
+                for (j = 0; j < unique_comp_name.size(); j ++)
+                    if (words_are_the_same(unique_comp_name[j], all_comp_name+i*NAME_STR_SIZE)) {
+                        break;
+                    }
+                if (j == unique_comp_name.size())
+                    unique_comp_name.push_back(all_comp_name+i*NAME_STR_SIZE);
+                process_comp_id[i] = j;
+            }
+        }
+        EXECUTION_REPORT(REPORT_ERROR,-1, MPI_Bcast(process_comp_id, num_procs, MPI_INT, 0, parent_comm)  == MPI_SUCCESS);
+        EXECUTION_REPORT(REPORT_ERROR,-1, MPI_Comm_split(parent_comm, process_comp_id[current_proc_local_id_in_parent], 0, &comm_group) == MPI_SUCCESS);
+        if (current_proc_local_id_in_parent == 0)
+            delete [] all_comp_name;
+        delete [] process_comp_id;
+        comm = comm_group;
+    }
 
-	EXECUTION_REPORT(REPORT_ERROR, -1, words_are_the_same(comp_type, COMP_TYPE_CPL) || words_are_the_same(comp_type, COMP_TYPE_ATM) || words_are_the_same(comp_type, COMP_TYPE_ATM_CHEM) || words_are_the_same(comp_type, COMP_TYPE_OCN) ||
-		             words_are_the_same(comp_type, COMP_TYPE_LND) || words_are_the_same(comp_type, COMP_TYPE_SEA_ICE) || words_are_the_same(comp_type, COMP_TYPE_WAVE) || words_are_the_same(comp_type, COMP_TYPE_ROOT) || 
-		             words_are_the_same(comp_type, COMP_TYPE_PSEUDO_COUPLED) || words_are_the_same(comp_type, COMP_TYPE_ACTIVE_COUPLED) || words_are_the_same(comp_type, COMP_TYPE_GLC) || words_are_the_same(comp_type, COMP_TYPE_RUNOFF), 
-		             "Error happens when registering the component model \"%s\" at the model code with the annotation is \"%s\": the model type \"%s\" is wrong. Please verify.", comp_name, annotation, comp_type);	
-	if (parent != NULL && words_are_the_same(comp_type, COMP_TYPE_PSEUDO_COUPLED))
-		EXECUTION_REPORT(REPORT_ERROR, -1, words_are_the_same(parent->comp_type, COMP_TYPE_PSEUDO_COUPLED) || words_are_the_same(parent->comp_type, COMP_TYPE_ROOT), 
-		                 "Error happens when calling the API \"CCPL_register_component\" to register a component model \"%s\" of type \"pesudo_coupled_system\": the type of its parent component model \"%s\" is \"%s\" but not \"pesudo_coupled_system\". Please check the model code related to the annotation \"%s\". Please verify", 
-		                 comp_name, parent->comp_name, parent->comp_type, annotation);
+    EXECUTION_REPORT(REPORT_ERROR, -1, words_are_the_same(comp_type, COMP_TYPE_CPL) || words_are_the_same(comp_type, COMP_TYPE_ATM) || words_are_the_same(comp_type, COMP_TYPE_ATM_CHEM) || words_are_the_same(comp_type, COMP_TYPE_OCN) ||
+                     words_are_the_same(comp_type, COMP_TYPE_LND) || words_are_the_same(comp_type, COMP_TYPE_SEA_ICE) || words_are_the_same(comp_type, COMP_TYPE_WAVE) || words_are_the_same(comp_type, COMP_TYPE_ROOT) || 
+                     words_are_the_same(comp_type, COMP_TYPE_PSEUDO_COUPLED) || words_are_the_same(comp_type, COMP_TYPE_ACTIVE_COUPLED) || words_are_the_same(comp_type, COMP_TYPE_GLC) || words_are_the_same(comp_type, COMP_TYPE_RUNOFF), 
+                     "Error happens when registering the component model \"%s\" at the model code with the annotation is \"%s\": the model type \"%s\" is wrong. Please verify.", comp_name, annotation, comp_type);    
+    if (parent != NULL && words_are_the_same(comp_type, COMP_TYPE_PSEUDO_COUPLED))
+        EXECUTION_REPORT(REPORT_ERROR, -1, words_are_the_same(parent->comp_type, COMP_TYPE_PSEUDO_COUPLED) || words_are_the_same(parent->comp_type, COMP_TYPE_ROOT), 
+                         "Error happens when calling the API \"CCPL_register_component\" to register a component model \"%s\" of type \"pesudo_coupled_system\": the type of its parent component model \"%s\" is \"%s\" but not \"pesudo_coupled_system\". Please check the model code related to the annotation \"%s\". Please verify", 
+                         comp_name, parent->comp_name, parent->comp_type, annotation);
 /*
-	if (parent != NULL && words_are_the_same(parent->comp_type, COMP_TYPE_PSEUDO_COUPLED) && parent->children.size() > 0)
-		EXECUTION_REPORT(REPORT_ERROR, -1, false, 
-		                 "Error happens when calling the API \"CCPL_register_component\" to register a component model \"%s\" at the model code with the annotation \"%s\": its parent \"%s\" is a coupled system (type is \"pesudo_coupled_system\") that can only have one child in a process while it already has a child \"%s\" (registerd at the model code with the annotation \"%s\"). Please verify.", 
-		                 comp_name, annotation, parent->comp_name, parent->children[0]->comp_name, parent->children[0]->get_annotation_start());
+    if (parent != NULL && words_are_the_same(parent->comp_type, COMP_TYPE_PSEUDO_COUPLED) && parent->children.size() > 0)
+        EXECUTION_REPORT(REPORT_ERROR, -1, false, 
+                         "Error happens when calling the API \"CCPL_register_component\" to register a component model \"%s\" at the model code with the annotation \"%s\": its parent \"%s\" is a coupled system (type is \"pesudo_coupled_system\") that can only have one child in a process while it already has a child \"%s\" (registerd at the model code with the annotation \"%s\"). Please verify.", 
+                         comp_name, annotation, parent->comp_name, parent->children[0]->comp_name, parent->children[0]->get_annotation_start());
 */
-	EXECUTION_REPORT(REPORT_ERROR,-1, MPI_Comm_rank(comm_group, &current_proc_local_id) == MPI_SUCCESS);
-	EXECUTION_REPORT(REPORT_ERROR,-1, MPI_Comm_rank(MPI_COMM_WORLD, &current_proc_global_id) == MPI_SUCCESS);
-	EXECUTION_REPORT(REPORT_ERROR,-1, MPI_Comm_size(comm_group, &num_procs) == MPI_SUCCESS);
-	processes_global_id = new int [num_procs];
-	EXECUTION_REPORT(REPORT_ERROR,-1, MPI_Allgather(&current_proc_global_id, 1, MPI_INT, processes_global_id, 1, MPI_INT, comm_group) == MPI_SUCCESS);
-	for (i = 0; i < num_procs; i ++)
-		local_processes_global_ids.push_back(processes_global_id[i]);
-	delete [] processes_global_id;
-
-	if (parent != NULL) {
-		for (i = 0; i < local_processes_global_ids.size(); i ++) {
-			for (j = 0; j < parent->local_processes_global_ids.size(); j ++)
-				if (local_processes_global_ids[i] == parent->local_processes_global_ids[j])
-					break;
-			if (current_proc_local_id == 0)
-				EXECUTION_REPORT(REPORT_ERROR,-1, j < parent->local_processes_global_ids.size(), 
-				                 "The processes of component \"%s\" must be a subset of the processes of its parent component \"%s\". Please check the model code related to the annotations \"%s\" and \"%s\"", 
-				                 comp_name, parent->get_comp_name(), annotation_start, parent->annotation_start);
-		}
-		parent->children.push_back(this);
-	}
-	
-	if (ancestor != NULL) {
-		if (is_real_component_model()) {
-			sprintf(working_dir, "%s/CCPL_dir/run/data/%s", comp_comm_group_mgt_mgr->get_root_working_dir(), comp_type);
-			create_directory(working_dir, comm_group, get_current_proc_local_id() == 0, false);
-			sprintf(working_dir, "%s/CCPL_dir/run/data/%s/%s", comp_comm_group_mgt_mgr->get_root_working_dir(), comp_type, full_name);
-			create_directory(working_dir, comm_group, get_current_proc_local_id() == 0, false);
-		}
-		sprintf(dir, "%s/CCPL_dir/run/CCPL_logs/by_components/%s", comp_comm_group_mgt_mgr->get_root_working_dir(), comp_type);
-		create_directory(dir, comm_group, get_current_proc_local_id() == 0, false);
-		sprintf(dir, "%s/CCPL_dir/run/model_logs/%s", comp_comm_group_mgt_mgr->get_root_working_dir(), comp_type);
-		create_directory(dir, comm_group, get_current_proc_local_id() == 0, false);
-		sprintf(dir, "%s/CCPL_dir/run/CCPL_logs/by_components/%s/%s", comp_comm_group_mgt_mgr->get_root_working_dir(), comp_type,full_name);
-		create_directory(dir, comm_group, get_current_proc_local_id() == 0, false);		
-		sprintf(dir, "%s/CCPL_dir/run/model_logs/%s/%s", comp_comm_group_mgt_mgr->get_root_working_dir(), comp_type,full_name);
-		create_directory(dir, comm_group, get_current_proc_local_id() == 0, false);
-		MPI_Barrier(get_comm_group());
-		sprintf(comp_ccpl_log_file_name, "%s/CCPL_dir/run/CCPL_logs/by_components/%s/%s/%s.CCPL.log.%d", comp_comm_group_mgt_mgr->get_root_working_dir(), comp_type, full_name, get_comp_name(), get_current_proc_local_id());
-		sprintf(comp_model_log_file_name, "%s/CCPL_dir/run/model_logs/%s/%s/%s.log.%d", comp_comm_group_mgt_mgr->get_root_working_dir(), comp_type, full_name, get_comp_name(), get_current_proc_local_id());
-	}
+    EXECUTION_REPORT(REPORT_ERROR,-1, MPI_Comm_rank(comm_group, &current_proc_local_id) == MPI_SUCCESS);
+    EXECUTION_REPORT(REPORT_ERROR,-1, MPI_Comm_rank(MPI_COMM_WORLD, &current_proc_global_id) == MPI_SUCCESS);
+    EXECUTION_REPORT(REPORT_ERROR,-1, MPI_Comm_size(comm_group, &num_procs) == MPI_SUCCESS);
+    processes_global_id = new int [num_procs];
+    EXECUTION_REPORT(REPORT_ERROR,-1, MPI_Allgather(&current_proc_global_id, 1, MPI_INT, processes_global_id, 1, MPI_INT, comm_group) == MPI_SUCCESS);
+    for (i = 0; i < num_procs; i ++)
+        local_processes_global_ids.push_back(processes_global_id[i]);
+    delete [] processes_global_id;
+
+    if (parent != NULL) {
+        for (i = 0; i < local_processes_global_ids.size(); i ++) {
+            for (j = 0; j < parent->local_processes_global_ids.size(); j ++)
+                if (local_processes_global_ids[i] == parent->local_processes_global_ids[j])
+                    break;
+            if (current_proc_local_id == 0)
+                EXECUTION_REPORT(REPORT_ERROR,-1, j < parent->local_processes_global_ids.size(), 
+                                 "The processes of component \"%s\" must be a subset of the processes of its parent component \"%s\". Please check the model code related to the annotations \"%s\" and \"%s\"", 
+                                 comp_name, parent->get_comp_name(), annotation_start, parent->annotation_start);
+        }
+        parent->children.push_back(this);
+    }
+    
+    if (ancestor != NULL) {
+        if (is_real_component_model()) {
+            sprintf(working_dir, "%s/CCPL_dir/run/data/%s", comp_comm_group_mgt_mgr->get_root_working_dir(), comp_type);
+            create_directory(working_dir, comm_group, get_current_proc_local_id() == 0, false);
+            sprintf(working_dir, "%s/CCPL_dir/run/data/%s/%s", comp_comm_group_mgt_mgr->get_root_working_dir(), comp_type, full_name);
+            create_directory(working_dir, comm_group, get_current_proc_local_id() == 0, false);
+        }
+        sprintf(dir, "%s/CCPL_dir/run/CCPL_logs/by_components/%s", comp_comm_group_mgt_mgr->get_root_working_dir(), comp_type);
+        create_directory(dir, comm_group, get_current_proc_local_id() == 0, false);
+        sprintf(dir, "%s/CCPL_dir/run/model_logs/%s", comp_comm_group_mgt_mgr->get_root_working_dir(), comp_type);
+        create_directory(dir, comm_group, get_current_proc_local_id() == 0, false);
+        sprintf(dir, "%s/CCPL_dir/run/CCPL_logs/by_components/%s/%s", comp_comm_group_mgt_mgr->get_root_working_dir(), comp_type,full_name);
+        create_directory(dir, comm_group, get_current_proc_local_id() == 0, false);        
+        sprintf(dir, "%s/CCPL_dir/run/model_logs/%s/%s", comp_comm_group_mgt_mgr->get_root_working_dir(), comp_type,full_name);
+        create_directory(dir, comm_group, get_current_proc_local_id() == 0, false);
+        MPI_Barrier(get_comm_group());
+        sprintf(comp_ccpl_log_file_name, "%s/CCPL_dir/run/CCPL_logs/by_components/%s/%s/%s.CCPL.log.%d", comp_comm_group_mgt_mgr->get_root_working_dir(), comp_type, full_name, get_comp_name(), get_current_proc_local_id());
+        sprintf(comp_model_log_file_name, "%s/CCPL_dir/run/model_logs/%s/%s/%s.log.%d", comp_comm_group_mgt_mgr->get_root_working_dir(), comp_type, full_name, get_comp_name(), get_current_proc_local_id());
+    }
 
-	if (parent != NULL)
-		check_API_parameter_string(parent->get_comp_id(), API_ID_COMP_MGT_REG_COMP, comm_group, "registering a component model", comp_type, "\"comp_type\"", annotation);
-	else check_API_parameter_string(-1, API_ID_COMP_MGT_REG_COMP, comm_group, "registering a component model", comp_type, "\"comp_type\"", annotation);
-
-	if (current_proc_local_id == 0) {
-		char XML_file_name[NAME_STR_SIZE];
-		sprintf(XML_file_name, "%s/%s.basic_info.xml", comp_comm_group_mgt_mgr->get_components_processes_dir(), full_name);
-		EXECUTION_REPORT(REPORT_ERROR, -1, !does_file_exist(XML_file_name), 
-			             "Error happens when registering a component model \"%s\": another componet model with the same name has already been registered. Please check the model code related to the annotations \"%s\"", 
-			             full_name, annotation);
-		TiXmlDocument *XML_file = new TiXmlDocument;
-		TiXmlDeclaration *XML_declaration = new TiXmlDeclaration(("1.0"),(""),(""));
-		EXECUTION_REPORT(REPORT_ERROR, -1, XML_file != NULL, "Software error: cannot create an xml file");
-		XML_file->LinkEndChild(XML_declaration);
-		TiXmlElement *root_element = new TiXmlElement("Component");
-		XML_file->LinkEndChild(root_element);
-		write_node_into_XML(root_element);
-		EXECUTION_REPORT(REPORT_ERROR, -1, XML_file->SaveFile(XML_file_name), "Software error in Comp_comm_group_mgt_node::Comp_comm_group_mgt_node: fail to write the XML file %s", XML_file_name);
-		delete XML_file;
-	}
+    if (parent != NULL)
+        check_API_parameter_string(parent->get_comp_id(), API_ID_COMP_MGT_REG_COMP, comm_group, "registering a component model", comp_type, "\"comp_type\"", annotation);
+    else check_API_parameter_string(-1, API_ID_COMP_MGT_REG_COMP, comm_group, "registering a component model", comp_type, "\"comp_type\"", annotation);
+
+    if (current_proc_local_id == 0) {
+        char XML_file_name[NAME_STR_SIZE];
+        sprintf(XML_file_name, "%s/%s.basic_info.xml", comp_comm_group_mgt_mgr->get_components_processes_dir(), full_name);
+        EXECUTION_REPORT(REPORT_ERROR, -1, !does_file_exist(XML_file_name), 
+                         "Error happens when registering a component model \"%s\": another componet model with the same name has already been registered. Please check the model code related to the annotations \"%s\"", 
+                         full_name, annotation);
+        TiXmlDocument *XML_file = new TiXmlDocument;
+        TiXmlDeclaration *XML_declaration = new TiXmlDeclaration(("1.0"),(""),(""));
+        EXECUTION_REPORT(REPORT_ERROR, -1, XML_file != NULL, "Software error: cannot create an xml file");
+        XML_file->LinkEndChild(XML_declaration);
+        TiXmlElement *root_element = new TiXmlElement("Component");
+        XML_file->LinkEndChild(root_element);
+        write_node_into_XML(root_element);
+        EXECUTION_REPORT(REPORT_ERROR, -1, XML_file->SaveFile(XML_file_name), "Software error in Comp_comm_group_mgt_node::Comp_comm_group_mgt_node: fail to write the XML file %s", XML_file_name);
+        delete XML_file;
+    }
 
-	EXECUTION_REPORT_LOG(REPORT_LOG, -1, true, "Finish registering the component model \%s\"", full_name);
+    EXECUTION_REPORT_LOG(REPORT_LOG, -1, true, "Finish registering the component model \%s\"", full_name);
 }
 
 
 Comp_comm_group_mgt_node::Comp_comm_group_mgt_node(TiXmlElement *XML_element, const char *specified_full_name, const char *XML_file_name)
 {
-	int line_number;
-
-
-	comp_id = -1;
-	temp_array_buffer = NULL;
-	proc_latest_model_time = NULL;
-	comp_model_log_file_device = -1;
-	performance_timing_mgr = NULL;
-	log_buffer = NULL;
-	EXECUTION_REPORT(REPORT_ERROR, -1, words_are_the_same(XML_element->Value(), "Online_Model"), "Software error in Comp_comm_group_mgt_node::Comp_comm_group_mgt_node: wrong element name");
-	const char *XML_comp_name = get_XML_attribute(comp_id, CCPL_NAME_STR_LEN, XML_element, "comp_name", XML_file_name, line_number, "the name of the component model", "internal configuration file of component information", true);
-	const char *XML_full_name = get_XML_attribute(comp_id, 512, XML_element, "full_name", XML_file_name, line_number, "the full name of the component model", "internal configuration file of component information", true);
-	const char *XML_comp_type = get_XML_attribute(comp_id, 512, XML_element, "comp_type", XML_file_name, line_number, "the type of the component model", "internal configuration file of component information", true);
-	const char *XML_enabled_in_parent_coupling_generation = get_XML_attribute(comp_id, CCPL_NAME_STR_LEN, XML_element, "enabled_in_parent_coupling_generation", XML_file_name, line_number, "enabled_in_parent_coupling_generation", "internal configuration file of component information", true);
-	EXECUTION_REPORT(REPORT_ERROR, -1, words_are_the_same(XML_enabled_in_parent_coupling_generation,"true") || words_are_the_same(XML_enabled_in_parent_coupling_generation,"false"), "software error in Comp_comm_group_mgt_node::Comp_comm_group_mgt_node: XML");
-	if (words_are_the_same(XML_enabled_in_parent_coupling_generation,"true"))
-		enabled_in_parent_coupling_generation = true;
-	else enabled_in_parent_coupling_generation = false;
-	const char *XML_processes = get_XML_attribute(comp_id, -1, XML_element, "processes", XML_file_name, line_number, "global IDs of the processes of the component model", "internal configuration file of component information", true);
-	strcpy(this->comp_name, XML_comp_name);
-	EXECUTION_REPORT(REPORT_ERROR, -1, words_are_the_same(specified_full_name, XML_full_name), "Software error in Comp_comm_group_mgt_node::Comp_comm_group_mgt_node: the full name specified is different from the full name in XML file %s: %s vs %s", XML_file_name, specified_full_name, XML_full_name);
-	strcpy(this->full_name, XML_full_name);
-	strcpy(this->comp_type, XML_comp_type);
-	int segment_start, segment_end;
-	for (int i = 1; i < strlen(XML_processes)+1; i ++) {
-		if (XML_processes[i-1] == ' ') {
-			segment_start = XML_processes[i]-'0';
-			segment_end = -1;
-			EXECUTION_REPORT(REPORT_ERROR, -1, segment_start >= 0 && segment_start <= 9, "Software error in Comp_comm_group_mgt_node::Comp_comm_group_mgt_node: wrong format");
-		}
-		else if (XML_processes[i-1] == '~') {
-			segment_end = XML_processes[i]-'0';
-			EXECUTION_REPORT(REPORT_ERROR, -1, segment_end >= 0 && segment_end <= 9, "Software error in Comp_comm_group_mgt_node::Comp_comm_group_mgt_node: wrong format");
-		}
-		else if (XML_processes[i] == ' ' || XML_processes[i] == '\0') {
-			if (segment_end == -1)
-				local_processes_global_ids.push_back(segment_start);
-			else {
-				for (int j = segment_start; j <= segment_end; j ++)
-					local_processes_global_ids.push_back(j);
-			}
-		}
-		else if (XML_processes[i] != '~') {
-			int digit = XML_processes[i] - '0';			
-			EXECUTION_REPORT(REPORT_ERROR, -1, digit >= 0 && digit <= 9, "Software error in Comp_comm_group_mgt_node::Comp_comm_group_mgt_node: wrong format");
-			if (segment_end == -1)
-				segment_start = segment_start * 10 + digit;
-			else segment_end = segment_end * 10 + digit;
-		}
-	}
+    int line_number;
+
+
+    comp_id = -1;
+    temp_array_buffer = NULL;
+    proc_latest_model_time = NULL;
+    comp_model_log_file_device = -1;
+    performance_timing_mgr = NULL;
+    log_buffer = NULL;
+    EXECUTION_REPORT(REPORT_ERROR, -1, words_are_the_same(XML_element->Value(), "Online_Model"), "Software error in Comp_comm_group_mgt_node::Comp_comm_group_mgt_node: wrong element name");
+    const char *XML_comp_name = get_XML_attribute(comp_id, CCPL_NAME_STR_LEN, XML_element, "comp_name", XML_file_name, line_number, "the name of the component model", "internal configuration file of component information", true);
+    const char *XML_full_name = get_XML_attribute(comp_id, 512, XML_element, "full_name", XML_file_name, line_number, "the full name of the component model", "internal configuration file of component information", true);
+    const char *XML_comp_type = get_XML_attribute(comp_id, 512, XML_element, "comp_type", XML_file_name, line_number, "the type of the component model", "internal configuration file of component information", true);
+    const char *XML_enabled_in_parent_coupling_generation = get_XML_attribute(comp_id, CCPL_NAME_STR_LEN, XML_element, "enabled_in_parent_coupling_generation", XML_file_name, line_number, "enabled_in_parent_coupling_generation", "internal configuration file of component information", true);
+    EXECUTION_REPORT(REPORT_ERROR, -1, words_are_the_same(XML_enabled_in_parent_coupling_generation,"true") || words_are_the_same(XML_enabled_in_parent_coupling_generation,"false"), "software error in Comp_comm_group_mgt_node::Comp_comm_group_mgt_node: XML");
+    if (words_are_the_same(XML_enabled_in_parent_coupling_generation,"true"))
+        enabled_in_parent_coupling_generation = true;
+    else enabled_in_parent_coupling_generation = false;
+    const char *XML_processes = get_XML_attribute(comp_id, -1, XML_element, "processes", XML_file_name, line_number, "global IDs of the processes of the component model", "internal configuration file of component information", true);
+    strcpy(this->comp_name, XML_comp_name);
+    EXECUTION_REPORT(REPORT_ERROR, -1, words_are_the_same(specified_full_name, XML_full_name), "Software error in Comp_comm_group_mgt_node::Comp_comm_group_mgt_node: the full name specified is different from the full name in XML file %s: %s vs %s", XML_file_name, specified_full_name, XML_full_name);
+    strcpy(this->full_name, XML_full_name);
+    strcpy(this->comp_type, XML_comp_type);
+    int segment_start, segment_end;
+    for (int i = 1; i < strlen(XML_processes)+1; i ++) {
+        if (XML_processes[i-1] == ' ') {
+            segment_start = XML_processes[i]-'0';
+            segment_end = -1;
+            EXECUTION_REPORT(REPORT_ERROR, -1, segment_start >= 0 && segment_start <= 9, "Software error in Comp_comm_group_mgt_node::Comp_comm_group_mgt_node: wrong format");
+        }
+        else if (XML_processes[i-1] == '~') {
+            segment_end = XML_processes[i]-'0';
+            EXECUTION_REPORT(REPORT_ERROR, -1, segment_end >= 0 && segment_end <= 9, "Software error in Comp_comm_group_mgt_node::Comp_comm_group_mgt_node: wrong format");
+        }
+        else if (XML_processes[i] == ' ' || XML_processes[i] == '\0') {
+            if (segment_end == -1)
+                local_processes_global_ids.push_back(segment_start);
+            else {
+                for (int j = segment_start; j <= segment_end; j ++)
+                    local_processes_global_ids.push_back(j);
+            }
+        }
+        else if (XML_processes[i] != '~') {
+            int digit = XML_processes[i] - '0';            
+            EXECUTION_REPORT(REPORT_ERROR, -1, digit >= 0 && digit <= 9, "Software error in Comp_comm_group_mgt_node::Comp_comm_group_mgt_node: wrong format");
+            if (segment_end == -1)
+                segment_start = segment_start * 10 + digit;
+            else segment_end = segment_end * 10 + digit;
+        }
+    }
 
-	current_proc_local_id = -1;
-	parent = NULL;
-	restart_mgr = NULL;
+    current_proc_local_id = -1;
+    parent = NULL;
+    restart_mgr = NULL;
 }
 
 
 void Comp_comm_group_mgt_node::transform_node_into_array()
 {
-	int num_procs, proc_id, num_children;
+    int num_procs, proc_id, num_children;
 
 
-	num_procs = local_processes_global_ids.size();
-	for (int i = 0; i < num_procs; i ++) {
-		proc_id = local_processes_global_ids[i];
-		write_data_into_array_buffer(&proc_id, sizeof(int), &temp_array_buffer, buffer_max_size, buffer_content_size);
-	}
-	write_data_into_array_buffer(&num_procs, sizeof(int), &temp_array_buffer, buffer_max_size, buffer_content_size);
-	write_data_into_array_buffer(&enabled_in_parent_coupling_generation, sizeof(bool), &temp_array_buffer, buffer_max_size, buffer_content_size);
-	write_data_into_array_buffer(&comm_group, sizeof(MPI_Comm), &temp_array_buffer, buffer_max_size, buffer_content_size);
-	write_data_into_array_buffer(comp_type, NAME_STR_SIZE, &temp_array_buffer, buffer_max_size, buffer_content_size);
-	write_data_into_array_buffer(comp_name, NAME_STR_SIZE, &temp_array_buffer, buffer_max_size, buffer_content_size);
-	write_data_into_array_buffer(full_name, NAME_STR_SIZE, &temp_array_buffer, buffer_max_size, buffer_content_size);
-	write_data_into_array_buffer(comp_model_log_file_name, NAME_STR_SIZE, &temp_array_buffer, buffer_max_size, buffer_content_size);
-	write_data_into_array_buffer(comp_ccpl_log_file_name, NAME_STR_SIZE, &temp_array_buffer, buffer_max_size, buffer_content_size);
-	write_data_into_array_buffer(working_dir, NAME_STR_SIZE, &temp_array_buffer, buffer_max_size, buffer_content_size);
-	write_data_into_array_buffer(annotation_start, NAME_STR_SIZE, &temp_array_buffer, buffer_max_size, buffer_content_size);
-	write_data_into_array_buffer(annotation_end, NAME_STR_SIZE, &temp_array_buffer, buffer_max_size, buffer_content_size);
+    num_procs = local_processes_global_ids.size();
+    for (int i = 0; i < num_procs; i ++) {
+        proc_id = local_processes_global_ids[i];
+        write_data_into_array_buffer(&proc_id, sizeof(int), &temp_array_buffer, buffer_max_size, buffer_content_size);
+    }
+    write_data_into_array_buffer(&num_procs, sizeof(int), &temp_array_buffer, buffer_max_size, buffer_content_size);
+    write_data_into_array_buffer(&enabled_in_parent_coupling_generation, sizeof(bool), &temp_array_buffer, buffer_max_size, buffer_content_size);
+    write_data_into_array_buffer(&comm_group, sizeof(MPI_Comm), &temp_array_buffer, buffer_max_size, buffer_content_size);
+    write_data_into_array_buffer(comp_type, NAME_STR_SIZE, &temp_array_buffer, buffer_max_size, buffer_content_size);
+    write_data_into_array_buffer(comp_name, NAME_STR_SIZE, &temp_array_buffer, buffer_max_size, buffer_content_size);
+    write_data_into_array_buffer(full_name, NAME_STR_SIZE, &temp_array_buffer, buffer_max_size, buffer_content_size);
+    write_data_into_array_buffer(comp_model_log_file_name, NAME_STR_SIZE, &temp_array_buffer, buffer_max_size, buffer_content_size);
+    write_data_into_array_buffer(comp_ccpl_log_file_name, NAME_STR_SIZE, &temp_array_buffer, buffer_max_size, buffer_content_size);
+    write_data_into_array_buffer(working_dir, NAME_STR_SIZE, &temp_array_buffer, buffer_max_size, buffer_content_size);
+    write_data_into_array_buffer(annotation_start, NAME_STR_SIZE, &temp_array_buffer, buffer_max_size, buffer_content_size);
+    write_data_into_array_buffer(annotation_end, NAME_STR_SIZE, &temp_array_buffer, buffer_max_size, buffer_content_size);
 }
 
 
 void Comp_comm_group_mgt_node::write_node_into_XML(TiXmlElement *parent_element)
 {
-	int i, num_segments;
-	int *segments_start, *segments_end;
-	TiXmlElement * current_element;
-	char *string;
-
-	
-	current_element = new TiXmlElement("Online_Model");
-	parent_element->LinkEndChild(current_element);
-	current_element->SetAttribute("comp_name", comp_name);
-	current_element->SetAttribute("full_name", full_name);
-	current_element->SetAttribute("comp_type", comp_type);
-	if (parent != NULL)
-		current_element->SetAttribute("parent_full_name", parent->get_comp_full_name()); 
-	else current_element->SetAttribute("parent_full_name", "NULL"); 
-	
-	if (enabled_in_parent_coupling_generation)
-		current_element->SetAttribute("enabled_in_parent_coupling_generation", "true");
-	else current_element->SetAttribute("enabled_in_parent_coupling_generation", "false");
-
-	segments_start = new int [local_processes_global_ids.size()];
-	segments_end = new int [local_processes_global_ids.size()];
-	segments_start[0] = local_processes_global_ids[0];
-	for (i = 1, num_segments = 1; i < local_processes_global_ids.size(); i ++) {
-		if (local_processes_global_ids[i] != local_processes_global_ids[i-1]+1) {
-			segments_end[num_segments-1] = local_processes_global_ids[i-1];
-			segments_start[num_segments] = local_processes_global_ids[i];
-			num_segments ++;
-		}
-	}
-	segments_end[num_segments-1] = local_processes_global_ids[local_processes_global_ids.size()-1];
-	string = new char [num_segments*(8*2+1)];
-	string[0] = '\0';
-	for (i = 0; i < num_segments; i ++) {
-		if (segments_start[i] != segments_end[i])
-			sprintf(string+strlen(string), " %d~%d", segments_start[i], segments_end[i]);
-		else sprintf(string+strlen(string), " %d", segments_start[i]);
-	}
+    int i, num_segments;
+    int *segments_start, *segments_end;
+    TiXmlElement * current_element;
+    char *string;
+
+    
+    current_element = new TiXmlElement("Online_Model");
+    parent_element->LinkEndChild(current_element);
+    current_element->SetAttribute("comp_name", comp_name);
+    current_element->SetAttribute("full_name", full_name);
+    current_element->SetAttribute("comp_type", comp_type);
+    if (parent != NULL)
+        current_element->SetAttribute("parent_full_name", parent->get_comp_full_name()); 
+    else current_element->SetAttribute("parent_full_name", "NULL"); 
+    
+    if (enabled_in_parent_coupling_generation)
+        current_element->SetAttribute("enabled_in_parent_coupling_generation", "true");
+    else current_element->SetAttribute("enabled_in_parent_coupling_generation", "false");
+
+    segments_start = new int [local_processes_global_ids.size()];
+    segments_end = new int [local_processes_global_ids.size()];
+    segments_start[0] = local_processes_global_ids[0];
+    for (i = 1, num_segments = 1; i < local_processes_global_ids.size(); i ++) {
+        if (local_processes_global_ids[i] != local_processes_global_ids[i-1]+1) {
+            segments_end[num_segments-1] = local_processes_global_ids[i-1];
+            segments_start[num_segments] = local_processes_global_ids[i];
+            num_segments ++;
+        }
+    }
+    segments_end[num_segments-1] = local_processes_global_ids[local_processes_global_ids.size()-1];
+    string = new char [num_segments*(8*2+1)];
+    string[0] = '\0';
+    for (i = 0; i < num_segments; i ++) {
+        if (segments_start[i] != segments_end[i])
+            sprintf(string+strlen(string), " %d~%d", segments_start[i], segments_end[i]);
+        else sprintf(string+strlen(string), " %d", segments_start[i]);
+    }
 
-	current_element->SetAttribute("processes", string);
-	
-	delete [] segments_start;
-	delete [] segments_end;
-	delete [] string;
+    current_element->SetAttribute("processes", string);
+    
+    delete [] segments_start;
+    delete [] segments_end;
+    delete [] string;
 }
 
 
 void Comp_comm_group_mgt_node::update_child(const Comp_comm_group_mgt_node *child_old, Comp_comm_group_mgt_node *child_new)
 {
-	int i;
-
-
-	EXECUTION_REPORT(REPORT_ERROR, -1, words_are_the_same(child_old->full_name, child_new->full_name), "software error in Comp_comm_group_mgt_node::update_child: children names are not the same");
-	for (i = 0; i < children.size(); i ++) {
-		EXECUTION_REPORT(REPORT_ERROR, -1, children[i]->parent == this, "software error in Comp_comm_group_mgt_node::update_child: wrong parent1");
-		EXECUTION_REPORT(REPORT_ERROR, -1, children[i]->parent != children[i], "software error in Comp_comm_group_mgt_node::update_child: wrong parent2");
-		if (children[i] == child_old) {
-			EXECUTION_REPORT_LOG(REPORT_LOG, child_old->comp_id, true, "Link the parent of component \"%s\" to \"%s\"", child_old->full_name, child_old->parent->get_full_name());
-			child_new->parent = this;
-			children[i] = child_new;
-			break;
-		}
-	}
+    int i;
+
+
+    EXECUTION_REPORT(REPORT_ERROR, -1, words_are_the_same(child_old->full_name, child_new->full_name), "software error in Comp_comm_group_mgt_node::update_child: children names are not the same");
+    for (i = 0; i < children.size(); i ++) {
+        EXECUTION_REPORT(REPORT_ERROR, -1, children[i]->parent == this, "software error in Comp_comm_group_mgt_node::update_child: wrong parent1");
+        EXECUTION_REPORT(REPORT_ERROR, -1, children[i]->parent != children[i], "software error in Comp_comm_group_mgt_node::update_child: wrong parent2");
+        if (children[i] == child_old) {
+            EXECUTION_REPORT_LOG(REPORT_LOG, child_old->comp_id, true, "Link the parent of component \"%s\" to \"%s\"", child_old->full_name, child_old->parent->get_full_name());
+            child_new->parent = this;
+            children[i] = child_new;
+            break;
+        }
+    }
 
-	EXECUTION_REPORT(REPORT_ERROR, -1, i < children.size(), "software error in Comp_comm_group_mgt_node::update_child");
+    EXECUTION_REPORT(REPORT_ERROR, -1, i < children.size(), "software error in Comp_comm_group_mgt_node::update_child");
 }
 
 
 void Comp_comm_group_mgt_node::transfer_data_buffer(Comp_comm_group_mgt_node *new_node)
 {
-	if (new_node->temp_array_buffer != NULL)
-		delete [] new_node->temp_array_buffer;
-
-	new_node->temp_array_buffer = this->temp_array_buffer;
-	new_node->buffer_content_iter = this->buffer_content_iter;
-	new_node->buffer_content_size = this->buffer_content_size;
-	new_node->buffer_max_size = this->buffer_max_size;
-	this->temp_array_buffer = NULL;
+    if (new_node->temp_array_buffer != NULL)
+        delete [] new_node->temp_array_buffer;
+
+    new_node->temp_array_buffer = this->temp_array_buffer;
+    new_node->buffer_content_iter = this->buffer_content_iter;
+    new_node->buffer_content_size = this->buffer_content_size;
+    new_node->buffer_max_size = this->buffer_max_size;
+    this->temp_array_buffer = NULL;
 }
 
 
 void Comp_comm_group_mgt_node::confirm_coupling_configuration_active(int API_id, bool require_real_model, const char *annotation)
 {
-	char API_label[NAME_STR_SIZE]; 
-
-	get_API_hint(comp_id, API_id, API_label);
-	EXECUTION_REPORT(REPORT_ERROR, comp_id, !definition_finalized, 
-		             "ERROR happens when calling the API \"%s\" at the model code with the annotation \"%s\": the coupling configuration stage of the corresponding component model \"%s\" has been ended at the model code with the annotation \"%s\"", 
-		             API_label, annotation, comp_name, get_annotation_end());
-	if (require_real_model)
-		EXECUTION_REPORT(REPORT_ERROR, comp_id, is_real_component_model(), 
-			             "ERROR happens when calling the API \"%s\" at the model code with the annotation \"%s\": the corresponding component model \"%s\" cannot handle coupling configuration because it is a pesudo coupled system (its type is \"pesudo_coupled_system\"). Please verify.", 
-			             API_label, annotation, comp_name);
+    char API_label[NAME_STR_SIZE]; 
+
+    get_API_hint(comp_id, API_id, API_label);
+    EXECUTION_REPORT(REPORT_ERROR, comp_id, !definition_finalized, 
+                     "ERROR happens when calling the API \"%s\" at the model code with the annotation \"%s\": the coupling configuration stage of the corresponding component model \"%s\" has been ended at the model code with the annotation \"%s\"", 
+                     API_label, annotation, comp_name, get_annotation_end());
+    if (require_real_model)
+        EXECUTION_REPORT(REPORT_ERROR, comp_id, is_real_component_model(), 
+                         "ERROR happens when calling the API \"%s\" at the model code with the annotation \"%s\": the corresponding component model \"%s\" cannot handle coupling configuration because it is a pesudo coupled system (its type is \"pesudo_coupled_system\"). Please verify.", 
+                         API_label, annotation, comp_name);
 }
 
 
@@ -498,611 +501,616 @@ int Comp_comm_group_mgt_node::get_local_proc_global_id(int local_indx)
     if (local_indx < local_processes_global_ids.size())
         return local_processes_global_ids[local_indx];
 
-	EXECUTION_REPORT(REPORT_ERROR, -1, false, "Software error in Comp_comm_group_mgt_node::get_local_proc_global_id");
-	
+    EXECUTION_REPORT(REPORT_ERROR, -1, false, "Software error in Comp_comm_group_mgt_node::get_local_proc_global_id");
+    
     return -1;
 }
 
 
 bool Comp_comm_group_mgt_node::is_real_component_model()
 { 
-	return !words_are_the_same(comp_type, COMP_TYPE_PSEUDO_COUPLED) && !words_are_the_same(comp_type, COMP_TYPE_ROOT); 
+    return !words_are_the_same(comp_type, COMP_TYPE_PSEUDO_COUPLED) && !words_are_the_same(comp_type, COMP_TYPE_ROOT); 
 }
 
 
 bool Comp_comm_group_mgt_node::have_local_process(int local_proc_global_id)
 {
-	for (int i = 0; i < local_processes_global_ids.size(); i ++)
-		if (local_proc_global_id == local_processes_global_ids[i])
-			return true;
-		
-	return false;
+    for (int i = 0; i < local_processes_global_ids.size(); i ++)
+        if (local_proc_global_id == local_processes_global_ids[i])
+            return true;
+        
+    return false;
 }
 
 
 void Comp_comm_group_mgt_node::allocate_proc_latest_model_time()
 {
-	if (proc_latest_model_time != NULL)
-		return;
-	
-	EXECUTION_REPORT(REPORT_ERROR, -1, get_num_procs() > 0, "Software error in Comp_comm_group_mgt_node::allocate_proc_latest_model_time");
-	proc_latest_model_time = new long [get_num_procs()];
-	for (int i = 0; i < get_num_procs(); i ++)
-		proc_latest_model_time[i] = -1;
+    if (proc_latest_model_time != NULL)
+        return;
+    
+    EXECUTION_REPORT(REPORT_ERROR, -1, get_num_procs() > 0, "Software error in Comp_comm_group_mgt_node::allocate_proc_latest_model_time");
+    proc_latest_model_time = new long [get_num_procs()];
+    for (int i = 0; i < get_num_procs(); i ++)
+        proc_latest_model_time[i] = -1;
 }
 
 
 void Comp_comm_group_mgt_node::set_current_proc_current_time(int days, int second)
 {
-	allocate_proc_latest_model_time();
-	proc_latest_model_time[current_proc_local_id] = ((long)days)*((long)100000) + (long)second;
-	EXECUTION_REPORT_LOG(REPORT_LOG, comp_id, true, "set_proc_latest_model_time %ld: %d %d", proc_latest_model_time[current_proc_local_id], days, second);
+    allocate_proc_latest_model_time();
+    proc_latest_model_time[current_proc_local_id] = ((long)days)*((long)100000) + (long)second;
+    EXECUTION_REPORT_LOG(REPORT_LOG, comp_id, true, "set_proc_latest_model_time %ld: %d %d", proc_latest_model_time[current_proc_local_id], days, second);
 }
 
 
 void Comp_comm_group_mgt_node::set_proc_latest_model_time(int proc_id, long model_time)
 {
-	allocate_proc_latest_model_time();
-	EXECUTION_REPORT(REPORT_ERROR, -1, proc_id >= 0 && proc_id < get_num_procs(), "Software error in set_proc_latest_model_time: wrong proc id: %d vs %d", proc_id, get_num_procs());
+    allocate_proc_latest_model_time();
+    EXECUTION_REPORT(REPORT_ERROR, -1, proc_id >= 0 && proc_id < get_num_procs(), "Software error in set_proc_latest_model_time: wrong proc id: %d vs %d", proc_id, get_num_procs());
 
-	if (model_time > proc_latest_model_time[proc_id])
-		proc_latest_model_time[proc_id] = model_time;
+    if (model_time > proc_latest_model_time[proc_id])
+        proc_latest_model_time[proc_id] = model_time;
 }
 
 
 long Comp_comm_group_mgt_node::get_proc_latest_model_time(int proc_id)
 {
-	EXECUTION_REPORT(REPORT_ERROR, -1, proc_id >= 0 && proc_id < get_num_procs(), "Software error in get_proc_latest_model_time: wrong proc id");
-	return proc_latest_model_time[proc_id];
+    EXECUTION_REPORT(REPORT_ERROR, -1, proc_id >= 0 && proc_id < get_num_procs(), "Software error in get_proc_latest_model_time: wrong proc id");
+    return proc_latest_model_time[proc_id];
 }
 
 
 void Comp_comm_group_mgt_node::get_all_descendant_real_comp_fullnames(int top_comp_id, std::vector<const char*> &all_descendant_real_comp_fullnames, char **temp_array_buffer, long &buffer_max_size, long &buffer_content_size)
 {
-	char *local_temp_array_buffer = NULL, *gather_temp_array_buffer = NULL;
-	long local_buffer_max_size, local_buffer_content_size = 0, gather_buffer_content_size = 0;
-	
-
-	for (int i = 0; i < children.size(); i ++)
-		if (children[i]->enabled_in_parent_coupling_generation)
-			children[i]->get_all_descendant_real_comp_fullnames(top_comp_id, all_descendant_real_comp_fullnames, &local_temp_array_buffer, local_buffer_max_size, local_buffer_content_size);
-
-	if (is_real_component_model() && current_proc_local_id == 0)
-		dump_string(full_name, -1, &local_temp_array_buffer, local_buffer_max_size, local_buffer_content_size);
-
-	if (current_proc_local_id != -1) {
-		int *all_array_size = new int [get_num_procs()];
-		gather_array_in_one_comp(get_num_procs(), current_proc_local_id, local_temp_array_buffer, local_buffer_content_size, sizeof(char), all_array_size, (void**)(&gather_temp_array_buffer), gather_buffer_content_size, comm_group);
-		if (current_proc_local_id == 0)
-			write_data_into_array_buffer(gather_temp_array_buffer, gather_buffer_content_size, temp_array_buffer, buffer_max_size, buffer_content_size);
-		delete [] all_array_size;
-	}
+    char *local_temp_array_buffer = NULL, *gather_temp_array_buffer = NULL;
+    long local_buffer_max_size, local_buffer_content_size = 0, gather_buffer_content_size = 0;
+    
+
+    for (int i = 0; i < children.size(); i ++)
+        if (children[i]->enabled_in_parent_coupling_generation)
+            children[i]->get_all_descendant_real_comp_fullnames(top_comp_id, all_descendant_real_comp_fullnames, &local_temp_array_buffer, local_buffer_max_size, local_buffer_content_size);
+
+    if (is_real_component_model() && current_proc_local_id == 0)
+        dump_string(full_name, -1, &local_temp_array_buffer, local_buffer_max_size, local_buffer_content_size);
+
+    if (current_proc_local_id != -1) {
+        int *all_array_size = new int [get_num_procs()];
+        gather_array_in_one_comp(get_num_procs(), current_proc_local_id, local_temp_array_buffer, local_buffer_content_size, sizeof(char), all_array_size, (void**)(&gather_temp_array_buffer), gather_buffer_content_size, comm_group);
+        if (current_proc_local_id == 0)
+            write_data_into_array_buffer(gather_temp_array_buffer, gather_buffer_content_size, temp_array_buffer, buffer_max_size, buffer_content_size);
+        delete [] all_array_size;
+    }
 
-	if (local_temp_array_buffer != NULL)
-		delete [] local_temp_array_buffer;
-	if (gather_temp_array_buffer != NULL)
-		delete [] gather_temp_array_buffer;
-
-	if (comp_id == top_comp_id) {
-		bcast_array_in_one_comp(current_proc_local_id, temp_array_buffer, buffer_content_size, comm_group);
-		char temp_full_name[NAME_STR_SIZE];
-		long str_size;
-		while (buffer_content_size > 0) {
-			load_string(temp_full_name, str_size, NAME_STR_SIZE, *temp_array_buffer, buffer_content_size, "C-Coupler internal");
-			all_descendant_real_comp_fullnames.push_back(strdup(temp_full_name));
-		}
-		EXECUTION_REPORT(REPORT_ERROR, -1, buffer_content_size == 0, "Software error in Comp_comm_group_mgt_node::get_all_descendant_real_comp_fullnames");
-		if (*temp_array_buffer != NULL) {
-			delete [] *temp_array_buffer;
-			*temp_array_buffer = NULL;
-		}
-		if (current_proc_local_id == 0)
-			for (int i = 0; i < all_descendant_real_comp_fullnames.size(); i ++)
-				printf("%x comp %d for internal generation %s\n", top_comp_id, i, all_descendant_real_comp_fullnames[i]);
-	}
+    if (local_temp_array_buffer != NULL)
+        delete [] local_temp_array_buffer;
+    if (gather_temp_array_buffer != NULL)
+        delete [] gather_temp_array_buffer;
+
+    if (comp_id == top_comp_id) {
+        bcast_array_in_one_comp(current_proc_local_id, temp_array_buffer, buffer_content_size, comm_group);
+        char temp_full_name[NAME_STR_SIZE];
+        long str_size;
+        while (buffer_content_size > 0) {
+            load_string(temp_full_name, str_size, NAME_STR_SIZE, *temp_array_buffer, buffer_content_size, "C-Coupler internal");
+            all_descendant_real_comp_fullnames.push_back(strdup(temp_full_name));
+        }
+        EXECUTION_REPORT(REPORT_ERROR, -1, buffer_content_size == 0, "Software error in Comp_comm_group_mgt_node::get_all_descendant_real_comp_fullnames");
+        if (*temp_array_buffer != NULL) {
+            delete [] *temp_array_buffer;
+            *temp_array_buffer = NULL;
+        }
+        if (current_proc_local_id == 0)
+            for (int i = 0; i < all_descendant_real_comp_fullnames.size(); i ++)
+                EXECUTION_REPORT_LOG(REPORT_LOG, -1, true, "%x comp %d for internal generation %s\n", top_comp_id, i, all_descendant_real_comp_fullnames[i]);
+    }
 }
 
 
 int Comp_comm_group_mgt_node::open_comp_model_log_file(int *log_file_device_id)
 {
-	int log_file_opened;
+    int log_file_opened;
 
-	
-	if (comp_model_log_file_device != -1)
-		log_file_opened = 1;
-	else log_file_opened = 0;
+    
+    if (comp_model_log_file_device != -1)
+        log_file_opened = 1;
+    else log_file_opened = 0;
 
-	comp_model_log_file_device = 100+(comp_id&TYPE_ID_SUFFIX_MASK);
-	*log_file_device_id = comp_model_log_file_device;
-	
-	return log_file_opened;
+    comp_model_log_file_device = 100+(comp_id&TYPE_ID_SUFFIX_MASK);
+    *log_file_device_id = comp_model_log_file_device;
+    
+    return log_file_opened;
 }
 
 
 int Comp_comm_group_mgt_node::get_min_remote_lag_seconds()
 {
-	EXECUTION_REPORT_ERROR_OPTIONALLY(REPORT_ERROR, -1, current_proc_local_id != -1, "Software error in Comp_comm_group_mgt_node::get_min_remote_lag_seconds");	
-	return min_remote_lag_seconds;
+    EXECUTION_REPORT_ERROR_OPTIONALLY(REPORT_ERROR, -1, current_proc_local_id != -1, "Software error in Comp_comm_group_mgt_node::get_min_remote_lag_seconds");    
+    return min_remote_lag_seconds;
 }
 
 
 int Comp_comm_group_mgt_node::get_max_remote_lag_seconds()
 {
-	EXECUTION_REPORT_ERROR_OPTIONALLY(REPORT_ERROR, -1, current_proc_local_id != -1, "Software error in Comp_comm_group_mgt_node::get_max_remote_lag_seconds");	
-	return max_remote_lag_seconds;
+    EXECUTION_REPORT_ERROR_OPTIONALLY(REPORT_ERROR, -1, current_proc_local_id != -1, "Software error in Comp_comm_group_mgt_node::get_max_remote_lag_seconds");    
+    return max_remote_lag_seconds;
 }
 
 
 void Comp_comm_group_mgt_node::update_min_max_remote_lag_seconds(int remote_lag_seconds)
 {
-	EXECUTION_REPORT_ERROR_OPTIONALLY(REPORT_ERROR, -1, current_proc_local_id != -1, "Software error in Comp_comm_group_mgt_node::update_min_max_remote_lag_seconds");
-	if (remote_lag_seconds < this->min_remote_lag_seconds)
-		this->min_remote_lag_seconds = remote_lag_seconds;
-	if (remote_lag_seconds < this->max_remote_lag_seconds)
-		this->max_remote_lag_seconds = remote_lag_seconds;
+    EXECUTION_REPORT_ERROR_OPTIONALLY(REPORT_ERROR, -1, current_proc_local_id != -1, "Software error in Comp_comm_group_mgt_node::update_min_max_remote_lag_seconds");
+    if (remote_lag_seconds < this->min_remote_lag_seconds)
+        this->min_remote_lag_seconds = remote_lag_seconds;
+    if (remote_lag_seconds < this->max_remote_lag_seconds)
+        this->max_remote_lag_seconds = remote_lag_seconds;
 }
 
 
 void Comp_comm_group_mgt_node::output_log(const char *log_string, bool flush_log_file)
 {
-	output_CCPL_log(log_string, comp_ccpl_log_file_name, &log_buffer, log_buffer_content_size, flush_log_file);
+    output_CCPL_log(log_string, comp_ccpl_log_file_name, &log_buffer, log_buffer_content_size, flush_log_file);
 }
 
 
 void Comp_comm_group_mgt_node::reset_local_node_id(int new_id) 
 { 
-	comp_id = new_id; 
-	EXECUTION_REPORT(REPORT_ERROR, -1, restart_mgr == NULL, "Software error in Comp_comm_group_mgt_node::reset_local_node_id");
+    comp_id = new_id; 
+    EXECUTION_REPORT(REPORT_ERROR, -1, restart_mgr == NULL, "Software error in Comp_comm_group_mgt_node::reset_local_node_id");
 }
 
 
 
 Comp_comm_group_mgt_mgr::Comp_comm_group_mgt_mgr(const char *executable_name)
 {
-	int i, j, num_procs, proc_id;
-	char temp_string[NAME_STR_SIZE];
-	std::vector<char*> unique_executable_name;
-
-
-	unique_comp_id_indx = 0;
-	global_node_array.clear();
-	global_node_root = NULL;
-	definition_finalized = false;
-	CCPL_platform_log_dir[0] = '\0';
-	log_buffer = NULL; 
-	EXECUTION_REPORT(REPORT_ERROR, -1, getcwd(root_working_dir,NAME_STR_SIZE) != NULL, 
-		             "Cannot get the current working directory for running the model");
-
-	for (i = strlen(executable_name)-1; i >= 0; i --)
-		if (executable_name[i] == '/')
-			break;
-	i ++;
-	EXECUTION_REPORT(REPORT_ERROR,-1, i < strlen(executable_name), "Software error1 in Comp_comm_group_mgt_mgr::Comp_comm_group_mgt_mgr");
-	strcpy(this->executable_name, executable_name+i);	
-	EXECUTION_REPORT(REPORT_ERROR, -1, !words_are_the_same(this->executable_name, "all"), "Error happens when using the executable \"%s\" to run the coupled system: the name of any executable cannot be all");
-
-	EXECUTION_REPORT(REPORT_ERROR,-1, MPI_Comm_rank(MPI_COMM_WORLD, &current_proc_global_id) == MPI_SUCCESS);
-	EXECUTION_REPORT(REPORT_ERROR,-1, MPI_Comm_size(MPI_COMM_WORLD, &num_total_global_procs) == MPI_SUCCESS);	
-
-	sprintf(temp_string, "%s/CCPL_dir/run", root_working_dir);
-	create_directory(temp_string, MPI_COMM_WORLD, current_proc_global_id == 0, false);
-	sprintf(temp_string, "%s/CCPL_dir/run/CCPL_logs", root_working_dir);
-	create_directory(temp_string, MPI_COMM_WORLD, current_proc_global_id == 0, true);
-	sprintf(temp_string, "%s/CCPL_dir/run/model_logs", root_working_dir);
-	create_directory(temp_string, MPI_COMM_WORLD, current_proc_global_id == 0, true);
-	sprintf(temp_string, "%s/CCPL_dir/run/CCPL_logs/by_components", root_working_dir);
-	create_directory(temp_string, MPI_COMM_WORLD, current_proc_global_id == 0, false);
-	sprintf(temp_string, "%s/CCPL_dir/run/data", root_working_dir);
-	create_directory(temp_string, MPI_COMM_WORLD, current_proc_global_id == 0, false);
-	sprintf(temp_string, "%s/CCPL_dir/run/data/all", root_working_dir);
-	create_directory(temp_string, MPI_COMM_WORLD, current_proc_global_id == 0, false);
-	sprintf(internal_H2D_grids_dir, "%s/CCPL_dir/run/data/all/internal_H2D_grids", root_working_dir);
-	create_directory(internal_H2D_grids_dir, MPI_COMM_WORLD, current_proc_global_id == 0, true);
-	sprintf(components_processes_dir, "%s/CCPL_dir/run/data/all/components_processes", root_working_dir);
-	create_directory(components_processes_dir, MPI_COMM_WORLD, current_proc_global_id == 0, true);
-	sprintf(components_exports_dir, "%s/CCPL_dir/run/data/all/components_exports", root_working_dir);
-	create_directory(components_exports_dir, MPI_COMM_WORLD, current_proc_global_id == 0, true);
-	sprintf(active_coupling_connections_dir, "%s/CCPL_dir/run/data/all/active_coupling_connections", root_working_dir);
-	create_directory(active_coupling_connections_dir, MPI_COMM_WORLD, current_proc_global_id == 0, true);	
-	sprintf(comps_ending_config_status_dir, "%s/CCPL_dir/run/data/all/comps_ending_config_status", root_working_dir);
-	create_directory(comps_ending_config_status_dir, MPI_COMM_WORLD, current_proc_global_id == 0, true);
-	sprintf(restart_common_dir, "%s/CCPL_dir/run/data/all/restart", root_working_dir);
-	create_directory(restart_common_dir, MPI_COMM_WORLD, current_proc_global_id == 0, false);
-	sprintf(runtime_config_root_dir, "%s/CCPL_dir/config", root_working_dir);
-	root_comp_config_dir[0] = '\0';
-	sprintf(temp_string, "%s/CCPL_dir/run/CCPL_logs/by_executables", root_working_dir);
-	create_directory(temp_string, MPI_COMM_WORLD, current_proc_global_id == 0, false);	
-	sprintf(exe_log_file_name, "%s/CCPL_dir/run/CCPL_logs/by_executables/%s/%s.CCPL.log.%d", root_working_dir, this->executable_name, this->executable_name, current_proc_global_id);
-	MPI_Barrier(MPI_COMM_WORLD);
-	EXECUTION_REPORT(REPORT_ERROR,-1, MPI_Comm_size(MPI_COMM_WORLD, &num_procs) == MPI_SUCCESS);
-	EXECUTION_REPORT(REPORT_ERROR,-1, MPI_Comm_rank(MPI_COMM_WORLD, &proc_id) == MPI_SUCCESS);
-	char *all_executable_name, dir[NAME_STR_SIZE];
-	if (proc_id == 0)
-		all_executable_name = new char [NAME_STR_SIZE*num_procs];
-	EXECUTION_REPORT(REPORT_ERROR,-1, MPI_Gather((char*)this->executable_name, NAME_STR_SIZE, MPI_CHAR, all_executable_name, NAME_STR_SIZE, MPI_CHAR, 0, MPI_COMM_WORLD) == MPI_SUCCESS);
-	if (proc_id == 0) {
-		unique_executable_name.push_back(all_executable_name);
-		for (i = 1; i < num_procs; i ++) {
-			for (j = 0; j < unique_executable_name.size(); j ++)
-				if (words_are_the_same(unique_executable_name[j], all_executable_name+i*NAME_STR_SIZE)) {
-					break;
-				}
-			if (j == unique_executable_name.size())
-				unique_executable_name.push_back(all_executable_name+i*NAME_STR_SIZE);
-		}
-		for (int j = 0; j < unique_executable_name.size(); j ++) {
-			sprintf(dir, "%s/CCPL_dir/run/CCPL_logs/by_executables/%s", root_working_dir, unique_executable_name[j]);
-			create_directory(dir, MPI_COMM_WORLD, true, false);
-		}
-		delete [] all_executable_name;	
+    int i, j, num_procs, proc_id;
+    char temp_string[NAME_STR_SIZE];
+    std::vector<char*> unique_executable_name;
+
+
+    unique_comp_id_indx = 0;
+    global_node_array.clear();
+    global_node_root = NULL;
+    definition_finalized = false;
+    CCPL_platform_log_dir[0] = '\0';
+    log_buffer = NULL; 
+    EXECUTION_REPORT(REPORT_ERROR, -1, getcwd(root_working_dir,NAME_STR_SIZE) != NULL, 
+                     "Cannot get the current working directory for running the model");
+
+    for (i = strlen(executable_name)-1; i >= 0; i --)
+        if (executable_name[i] == '/')
+            break;
+    i ++;
+    EXECUTION_REPORT(REPORT_ERROR,-1, i < strlen(executable_name), "Software error1 in Comp_comm_group_mgt_mgr::Comp_comm_group_mgt_mgr");
+    strcpy(this->executable_name, executable_name+i);    
+    EXECUTION_REPORT(REPORT_ERROR, -1, !words_are_the_same(this->executable_name, "all"), "Error happens when using the executable \"%s\" to run the coupled system: the name of any executable cannot be all");
+
+    EXECUTION_REPORT(REPORT_ERROR,-1, MPI_Comm_rank(MPI_COMM_WORLD, &current_proc_global_id) == MPI_SUCCESS);
+    EXECUTION_REPORT(REPORT_ERROR,-1, MPI_Comm_size(MPI_COMM_WORLD, &num_total_global_procs) == MPI_SUCCESS);    
+	if (current_proc_global_id == 0) {
+		sprintf(temp_string, "%s/CCPL_dir/config", root_working_dir);
+		EXECUTION_REPORT(REPORT_ERROR, -1, does_file_exist(temp_string), "Fail to initialize C-Coupler: the directory (\"%s\") for configuration files of C-Coupler does not exit.", temp_string);
 	}
+    sprintf(temp_string, "%s/CCPL_dir/run", root_working_dir);
+    create_directory(temp_string, MPI_COMM_WORLD, current_proc_global_id == 0, false);
+    sprintf(temp_string, "%s/CCPL_dir/run/CCPL_logs", root_working_dir);
+    create_directory(temp_string, MPI_COMM_WORLD, current_proc_global_id == 0, true);
+    sprintf(temp_string, "%s/CCPL_dir/run/model_logs", root_working_dir);
+    create_directory(temp_string, MPI_COMM_WORLD, current_proc_global_id == 0, true);
+    sprintf(temp_string, "%s/CCPL_dir/run/CCPL_logs/by_components", root_working_dir);
+    create_directory(temp_string, MPI_COMM_WORLD, current_proc_global_id == 0, false);
+    sprintf(temp_string, "%s/CCPL_dir/run/data", root_working_dir);
+    create_directory(temp_string, MPI_COMM_WORLD, current_proc_global_id == 0, false);
+    sprintf(temp_string, "%s/CCPL_dir/run/data/all", root_working_dir);
+    create_directory(temp_string, MPI_COMM_WORLD, current_proc_global_id == 0, false);
+    sprintf(internal_H2D_grids_dir, "%s/CCPL_dir/run/data/all/internal_H2D_grids", root_working_dir);
+    create_directory(internal_H2D_grids_dir, MPI_COMM_WORLD, current_proc_global_id == 0, true);
+    sprintf(internal_remapping_weights_dir, "%s/CCPL_dir/run/data/all/internal_remapping_weights", root_working_dir);
+    create_directory(internal_remapping_weights_dir, MPI_COMM_WORLD, current_proc_global_id == 0, false);
+    sprintf(components_processes_dir, "%s/CCPL_dir/run/data/all/components_processes", root_working_dir);
+    create_directory(components_processes_dir, MPI_COMM_WORLD, current_proc_global_id == 0, true);
+    sprintf(components_exports_dir, "%s/CCPL_dir/run/data/all/components_exports", root_working_dir);
+    create_directory(components_exports_dir, MPI_COMM_WORLD, current_proc_global_id == 0, true);
+    sprintf(active_coupling_connections_dir, "%s/CCPL_dir/run/data/all/active_coupling_connections", root_working_dir);
+    create_directory(active_coupling_connections_dir, MPI_COMM_WORLD, current_proc_global_id == 0, true);    
+    sprintf(comps_ending_config_status_dir, "%s/CCPL_dir/run/data/all/comps_ending_config_status", root_working_dir);
+    create_directory(comps_ending_config_status_dir, MPI_COMM_WORLD, current_proc_global_id == 0, true);
+    sprintf(restart_common_dir, "%s/CCPL_dir/run/data/all/restart", root_working_dir);
+    create_directory(restart_common_dir, MPI_COMM_WORLD, current_proc_global_id == 0, false);
+    sprintf(runtime_config_root_dir, "%s/CCPL_dir/config", root_working_dir);
+    root_comp_config_dir[0] = '\0';
+    sprintf(temp_string, "%s/CCPL_dir/run/CCPL_logs/by_executables", root_working_dir);
+    create_directory(temp_string, MPI_COMM_WORLD, current_proc_global_id == 0, false);    
+    sprintf(exe_log_file_name, "%s/CCPL_dir/run/CCPL_logs/by_executables/%s/%s.CCPL.log.%d", root_working_dir, this->executable_name, this->executable_name, current_proc_global_id);
+    MPI_Barrier(MPI_COMM_WORLD);
+    EXECUTION_REPORT(REPORT_ERROR,-1, MPI_Comm_size(MPI_COMM_WORLD, &num_procs) == MPI_SUCCESS);
+    EXECUTION_REPORT(REPORT_ERROR,-1, MPI_Comm_rank(MPI_COMM_WORLD, &proc_id) == MPI_SUCCESS);
+    char *all_executable_name, dir[NAME_STR_SIZE];
+    if (proc_id == 0)
+        all_executable_name = new char [NAME_STR_SIZE*num_procs];
+    EXECUTION_REPORT(REPORT_ERROR,-1, MPI_Gather((char*)this->executable_name, NAME_STR_SIZE, MPI_CHAR, all_executable_name, NAME_STR_SIZE, MPI_CHAR, 0, MPI_COMM_WORLD) == MPI_SUCCESS);
+    if (proc_id == 0) {
+        unique_executable_name.push_back(all_executable_name);
+        for (i = 1; i < num_procs; i ++) {
+            for (j = 0; j < unique_executable_name.size(); j ++)
+                if (words_are_the_same(unique_executable_name[j], all_executable_name+i*NAME_STR_SIZE)) {
+                    break;
+                }
+            if (j == unique_executable_name.size())
+                unique_executable_name.push_back(all_executable_name+i*NAME_STR_SIZE);
+        }
+        for (int j = 0; j < unique_executable_name.size(); j ++) {
+            sprintf(dir, "%s/CCPL_dir/run/CCPL_logs/by_executables/%s", root_working_dir, unique_executable_name[j]);
+            create_directory(dir, MPI_COMM_WORLD, true, false);
+        }
+        delete [] all_executable_name;    
+    }
 
-	MPI_Barrier(MPI_COMM_WORLD);
+    MPI_Barrier(MPI_COMM_WORLD);
 }
 
 
 Comp_comm_group_mgt_mgr::~Comp_comm_group_mgt_mgr()
 {
-	if (log_buffer != NULL) {
-		output_log("", true);
-		delete [] log_buffer;
-	}
+    if (log_buffer != NULL) {
+        output_log("", true);
+        delete [] log_buffer;
+    }
 
-	for (int i = 0; i < global_node_array.size(); i ++)
-		delete global_node_array[i];
+    for (int i = 0; i < global_node_array.size(); i ++)
+        delete global_node_array[i];
 
-	for (int i = 0; i < root_comps_full_names.size(); i ++)
-		delete root_comps_full_names[i];
+    for (int i = 0; i < root_comps_full_names.size(); i ++)
+        delete root_comps_full_names[i];
 }
 
 
 void Comp_comm_group_mgt_mgr::transform_global_node_tree_into_array(Comp_comm_group_mgt_node *current_global_node, Comp_comm_group_mgt_node **all_global_nodes, int &global_node_id)
 {
-	all_global_nodes[global_node_id++] = current_global_node;
-	for (int i = 0; i < current_global_node->get_num_children(); i ++)
-		transform_global_node_tree_into_array(current_global_node->get_child(i), all_global_nodes, global_node_id);
+    all_global_nodes[global_node_id++] = current_global_node;
+    for (int i = 0; i < current_global_node->get_num_children(); i ++)
+        transform_global_node_tree_into_array(current_global_node->get_child(i), all_global_nodes, global_node_id);
 }
 
 
 bool Comp_comm_group_mgt_mgr::is_legal_local_comp_id(int local_comp_id, bool is_external_call)
 {
-	int i;
-
-	
-	if ((local_comp_id&TYPE_ID_PREFIX_MASK) != TYPE_COMP_LOCAL_ID_PREFIX)
-		return false;
-	
-	for (i = 0; i < global_node_array.size(); i ++)
-		if (local_comp_id == global_node_array[i]->get_comp_id())
-			break;
-
-	if (i == global_node_array.size())
-		return false;
-
-	if (is_external_call)
-	 	return !does_comp_name_include_reserved_prefix(global_node_array[i]->get_comp_name());
-	else return true;
+    int i;
+
+    
+    if ((local_comp_id&TYPE_ID_PREFIX_MASK) != TYPE_COMP_LOCAL_ID_PREFIX)
+        return false;
+    
+    for (i = 0; i < global_node_array.size(); i ++)
+        if (local_comp_id == global_node_array[i]->get_comp_id())
+            break;
+
+    if (i == global_node_array.size())
+        return false;
+
+    if (is_external_call)
+         return !does_comp_name_include_reserved_prefix(global_node_array[i]->get_comp_name());
+    else return true;
 }
 
 
 int Comp_comm_group_mgt_mgr::register_component(const char *comp_name, const char *comp_type, MPI_Comm &comm, int parent_local_id, bool enabled_in_parent_coupling_gen, int change_dir, const char *annotation)
 {
-	int i;
-	Comp_comm_group_mgt_node *root_local_node, *new_comp;
-	MPI_Comm global_comm = MPI_COMM_WORLD;
-	char hint[NAME_STR_SIZE];
-	
-	
-	if (definition_finalized)
-		EXECUTION_REPORT(REPORT_ERROR, -1, !definition_finalized, 
-		                 "Cannot register component \"%s\" at the model code with the annotation \"%s\" because the stage of registering coupling configurations of the whole coupled model has been ended at the model code with the annotation \"%s\"", 
-		                 comp_name, annotation, global_node_array[0]->get_annotation_end());
-	
-	for (i = 0; i < global_node_array.size(); i ++)
-		if (words_are_the_same(global_node_array[i]->get_comp_name(), comp_name))
-			break;
-		
-	if (i < global_node_array.size())
-		EXECUTION_REPORT(REPORT_ERROR, -1, i == global_node_array.size(), "Error happens when registering a component model named \"%s\" at the model code with the annotation \"%s\": a component model with the same name has already been registered before, at the model code with the annotation \"%s\". Please note that, any two component models on the same MPI process cannot have the same name", comp_name, annotation, global_node_array[i]->get_annotation_start());
-
-	if (parent_local_id == -1) {
-		root_local_node = new Comp_comm_group_mgt_node(COMP_TYPE_ROOT, COMP_TYPE_ROOT, (unique_comp_id_indx++)|TYPE_COMP_LOCAL_ID_PREFIX, NULL, global_comm, enabled_in_parent_coupling_gen, annotation);
-		global_node_array.push_back(root_local_node);
-		global_node_root = root_local_node;
-		new_comp = new Comp_comm_group_mgt_node(comp_name, comp_type, (unique_comp_id_indx++)|TYPE_COMP_LOCAL_ID_PREFIX, root_local_node, comm, enabled_in_parent_coupling_gen, annotation);
-		global_node_array.push_back(new_comp);
-	}
-	else {
-		Comp_comm_group_mgt_node *parent_comp_node = search_global_node(parent_local_id);
-		EXECUTION_REPORT(REPORT_ERROR, -1, !parent_comp_node->is_definition_finalized(), 
-			             "Cannot register component \"%s\" at the model code with the annotation \"%s\" because the registration corresponding to the parent \"%s\" has been ended at the model code with the annotation \"%s\"", 
-			             comp_name, annotation, parent_comp_node->get_comp_name(), parent_comp_node->get_annotation_end()); // add debug information
-		new_comp = new Comp_comm_group_mgt_node(comp_name, comp_type, (unique_comp_id_indx++)|TYPE_COMP_LOCAL_ID_PREFIX, parent_comp_node, comm, enabled_in_parent_coupling_gen, annotation);
-		global_node_array.push_back(new_comp);
-	}
-	sprintf(hint, "regietering a component model \"%s\"", comp_name);
-	check_API_parameter_bool(new_comp->get_comp_id(), API_ID_COMP_MGT_REG_COMP, new_comp->get_comm_group(), hint, enabled_in_parent_coupling_gen, "enabled_in_parent_coupling_gen", annotation);
-
-	if (parent_local_id == -1) {
-		char *temp_array_buffer = NULL, *gather_array_buffer = NULL;
-		long local_buffer_max_size, local_buffer_content_size = 0, gather_buffer_content_size = 0, str_size;
-		bool temp_enabled_in_parent_coupling_gen;
-		char root_comp_full_name[NAME_STR_SIZE];
-		if (new_comp->get_current_proc_local_id() == 0) {
-			dump_string(new_comp->get_comp_full_name(), -1, &temp_array_buffer, local_buffer_max_size, local_buffer_content_size);
-			write_data_into_array_buffer(&enabled_in_parent_coupling_gen, sizeof(bool), &temp_array_buffer, local_buffer_max_size, local_buffer_content_size);
-		}
-		gather_array_in_one_comp(num_total_global_procs, current_proc_global_id, temp_array_buffer, local_buffer_content_size, sizeof(char), NULL, (void**)(&gather_array_buffer), gather_buffer_content_size, MPI_COMM_WORLD);
-		bcast_array_in_one_comp(current_proc_global_id, &gather_array_buffer, gather_buffer_content_size, MPI_COMM_WORLD);
-		while(gather_buffer_content_size > 0) {
-			read_data_from_array_buffer(&temp_enabled_in_parent_coupling_gen, sizeof(bool), gather_array_buffer, gather_buffer_content_size, true);
-			load_string(root_comp_full_name, str_size, NAME_STR_SIZE, gather_array_buffer, gather_buffer_content_size, NULL);
-			root_comps_enabled_in_parent_coupling_generation.push_back(temp_enabled_in_parent_coupling_gen);
-			root_comps_full_names.push_back(strdup(root_comp_full_name));
-		}
-		EXECUTION_REPORT(REPORT_ERROR, -1, gather_buffer_content_size == 0, "Software error in Comp_comm_group_mgt_mgr::register_component");
-		if (temp_array_buffer != NULL)
-			delete [] temp_array_buffer;
-		if (gather_array_buffer != NULL)
-			delete [] gather_array_buffer;
-
-		sprintf(root_comp_config_dir, "%s/%s", runtime_config_root_dir, new_comp->get_comp_name());
-		CCPL_platform_log_dir[0] = '\0';
-		check_API_parameter_int(new_comp->get_comp_id(), API_ID_COMP_MGT_REG_COMP, new_comp->get_comm_group(), "registering a component model", change_dir, "change_dir", annotation);
-		if (change_dir == 1) {
-			char new_dir[NAME_STR_SIZE];
-			sprintf(new_dir, "%s/run/%s/%s/data", root_working_dir, new_comp->get_comp_type(), new_comp->get_comp_name());
-			sprintf(CCPL_platform_log_dir, "%s/run/%s/%s/run_logs", root_working_dir, new_comp->get_comp_type(), new_comp->get_comp_name());
-			DIR *dir=opendir(new_dir);
-			EXECUTION_REPORT(REPORT_ERROR, new_comp->get_comp_id(), dir != NULL, "Fail to change working directory for the first active component model \"%s\": the directory \"%s\" does not exist.", new_comp->get_comp_name(), new_dir);
-			chdir(new_dir);
-			EXECUTION_REPORT_LOG(REPORT_LOG, new_comp->get_comp_id(), true, "change working directory to \"%s\"", new_dir);
-		}
-		original_grid_mgr->initialize_CoR_grids();
-	}
+    int i;
+    Comp_comm_group_mgt_node *root_local_node, *new_comp;
+    MPI_Comm global_comm = MPI_COMM_WORLD;
+    char hint[NAME_STR_SIZE];
+    
+    
+    if (definition_finalized)
+        EXECUTION_REPORT(REPORT_ERROR, -1, !definition_finalized, 
+                         "Cannot register component \"%s\" at the model code with the annotation \"%s\" because the stage of registering coupling configurations of the whole coupled model has been ended at the model code with the annotation \"%s\"", 
+                         comp_name, annotation, global_node_array[0]->get_annotation_end());
+    
+    for (i = 0; i < global_node_array.size(); i ++)
+        if (words_are_the_same(global_node_array[i]->get_comp_name(), comp_name))
+            break;
+        
+    if (i < global_node_array.size())
+        EXECUTION_REPORT(REPORT_ERROR, -1, i == global_node_array.size(), "Error happens when registering a component model named \"%s\" at the model code with the annotation \"%s\": a component model with the same name has already been registered before, at the model code with the annotation \"%s\". Please note that, any two component models on the same MPI process cannot have the same name", comp_name, annotation, global_node_array[i]->get_annotation_start());
+
+    if (parent_local_id == -1) {
+        root_local_node = new Comp_comm_group_mgt_node(COMP_TYPE_ROOT, COMP_TYPE_ROOT, (unique_comp_id_indx++)|TYPE_COMP_LOCAL_ID_PREFIX, NULL, global_comm, enabled_in_parent_coupling_gen, annotation);
+        global_node_array.push_back(root_local_node);
+        global_node_root = root_local_node;
+        new_comp = new Comp_comm_group_mgt_node(comp_name, comp_type, (unique_comp_id_indx++)|TYPE_COMP_LOCAL_ID_PREFIX, root_local_node, comm, enabled_in_parent_coupling_gen, annotation);
+        global_node_array.push_back(new_comp);
+    }
+    else {
+        Comp_comm_group_mgt_node *parent_comp_node = search_global_node(parent_local_id);
+        EXECUTION_REPORT(REPORT_ERROR, -1, !parent_comp_node->is_definition_finalized(), 
+                         "Cannot register component \"%s\" at the model code with the annotation \"%s\" because the registration corresponding to the parent \"%s\" has been ended at the model code with the annotation \"%s\"", 
+                         comp_name, annotation, parent_comp_node->get_comp_name(), parent_comp_node->get_annotation_end()); // add debug information
+        new_comp = new Comp_comm_group_mgt_node(comp_name, comp_type, (unique_comp_id_indx++)|TYPE_COMP_LOCAL_ID_PREFIX, parent_comp_node, comm, enabled_in_parent_coupling_gen, annotation);
+        global_node_array.push_back(new_comp);
+    }
+    sprintf(hint, "regietering a component model \"%s\"", comp_name);
+    check_API_parameter_bool(new_comp->get_comp_id(), API_ID_COMP_MGT_REG_COMP, new_comp->get_comm_group(), hint, enabled_in_parent_coupling_gen, "enabled_in_parent_coupling_gen", annotation);
+
+    if (parent_local_id == -1) {
+        char *temp_array_buffer = NULL, *gather_array_buffer = NULL;
+        long local_buffer_max_size, local_buffer_content_size = 0, gather_buffer_content_size = 0, str_size;
+        bool temp_enabled_in_parent_coupling_gen;
+        char root_comp_full_name[NAME_STR_SIZE];
+        if (new_comp->get_current_proc_local_id() == 0) {
+            dump_string(new_comp->get_comp_full_name(), -1, &temp_array_buffer, local_buffer_max_size, local_buffer_content_size);
+            write_data_into_array_buffer(&enabled_in_parent_coupling_gen, sizeof(bool), &temp_array_buffer, local_buffer_max_size, local_buffer_content_size);
+        }
+        gather_array_in_one_comp(num_total_global_procs, current_proc_global_id, temp_array_buffer, local_buffer_content_size, sizeof(char), NULL, (void**)(&gather_array_buffer), gather_buffer_content_size, MPI_COMM_WORLD);
+        bcast_array_in_one_comp(current_proc_global_id, &gather_array_buffer, gather_buffer_content_size, MPI_COMM_WORLD);
+        while(gather_buffer_content_size > 0) {
+            read_data_from_array_buffer(&temp_enabled_in_parent_coupling_gen, sizeof(bool), gather_array_buffer, gather_buffer_content_size, true);
+            load_string(root_comp_full_name, str_size, NAME_STR_SIZE, gather_array_buffer, gather_buffer_content_size, NULL);
+            root_comps_enabled_in_parent_coupling_generation.push_back(temp_enabled_in_parent_coupling_gen);
+            root_comps_full_names.push_back(strdup(root_comp_full_name));
+        }
+        EXECUTION_REPORT(REPORT_ERROR, -1, gather_buffer_content_size == 0, "Software error in Comp_comm_group_mgt_mgr::register_component");
+        if (temp_array_buffer != NULL)
+            delete [] temp_array_buffer;
+        if (gather_array_buffer != NULL)
+            delete [] gather_array_buffer;
+
+        sprintf(root_comp_config_dir, "%s/%s", runtime_config_root_dir, new_comp->get_comp_name());
+        CCPL_platform_log_dir[0] = '\0';
+        check_API_parameter_int(new_comp->get_comp_id(), API_ID_COMP_MGT_REG_COMP, new_comp->get_comm_group(), "registering a component model", change_dir, "change_dir", annotation);
+        if (change_dir == 1) {
+            char new_dir[NAME_STR_SIZE];
+            sprintf(new_dir, "%s/run/%s/%s/data", root_working_dir, new_comp->get_comp_type(), new_comp->get_comp_name());
+            sprintf(CCPL_platform_log_dir, "%s/run/%s/%s/run_logs", root_working_dir, new_comp->get_comp_type(), new_comp->get_comp_name());
+            DIR *dir=opendir(new_dir);
+            EXECUTION_REPORT(REPORT_ERROR, new_comp->get_comp_id(), dir != NULL, "Fail to change working directory for the first active component model \"%s\": the directory \"%s\" does not exist.", new_comp->get_comp_name(), new_dir);
+            chdir(new_dir);
+            EXECUTION_REPORT_LOG(REPORT_LOG, new_comp->get_comp_id(), true, "change working directory to \"%s\"", new_dir);
+        }
+        original_grid_mgr->initialize_CoR_grids();
+    }
 
-	EXECUTION_REPORT(REPORT_PROGRESS, new_comp->get_comp_id(), true, "The component model \"%s\" is successfully registered at the model code with the annotation \"%s\".", new_comp->get_full_name(), annotation);
+    EXECUTION_REPORT(REPORT_PROGRESS, new_comp->get_comp_id(), true, "The component model \"%s\" is successfully registered at the model code with the annotation \"%s\".", new_comp->get_full_name(), annotation);
 
-	EXECUTION_REPORT(REPORT_ERROR, new_comp->get_comp_id(), !does_comp_name_include_reserved_prefix(comp_name), "Error happens when registering a component model \"%s\": its name should not include the prefix \"%s\", \"%s\", \"%s\" and \"%s\". Please verify the model code with the annotation \"%s\"", comp_name, COMP_TYPE_ROOT, DATAINST_NAME_PREFIX, DATAMODEL_NAME_PREFIX, ALGMODEL_NAME_PREFIX, annotation);
+    EXECUTION_REPORT(REPORT_ERROR, new_comp->get_comp_id(), !does_comp_name_include_reserved_prefix(comp_name), "Error happens when registering a component model \"%s\": its name should not include the prefix \"%s\", \"%s\", \"%s\" and \"%s\". Please verify the model code with the annotation \"%s\"", comp_name, COMP_TYPE_ROOT, DATAINST_NAME_PREFIX, DATAMODEL_NAME_PREFIX, ALGMODEL_NAME_PREFIX, annotation);
 
-	return new_comp->get_local_node_id();
+    return new_comp->get_local_node_id();
 }
 
 
 Comp_comm_group_mgt_node *Comp_comm_group_mgt_mgr::get_global_node_of_local_comp(int local_comp_id, bool is_external_call, const char *annotation)
-{	
-	EXECUTION_REPORT_ERROR_OPTIONALLY(REPORT_ERROR, -1, is_legal_local_comp_id(local_comp_id, is_external_call), "The id of component is wrong when getting the management node of a component. Please check the model code with the annotation \"%s\"", annotation); 
+{    
+    EXECUTION_REPORT_ERROR_OPTIONALLY(REPORT_ERROR, -1, is_legal_local_comp_id(local_comp_id, is_external_call), "The id of component is wrong when getting the management node of a component. Please check the model code with the annotation \"%s\"", annotation); 
 
-	return search_global_node(local_comp_id);
+    return search_global_node(local_comp_id);
 }
 
 
 MPI_Comm Comp_comm_group_mgt_mgr::get_comm_group_of_local_comp(int local_comp_id, const char *annotation)
 {
-	return get_global_node_of_local_comp(local_comp_id,false,annotation)->get_comm_group();
+    return get_global_node_of_local_comp(local_comp_id,false,annotation)->get_comm_group();
 }
 
 
 void Comp_comm_group_mgt_mgr::get_output_data_file_header(int comp_id, char *data_file_header)
 {
-	EXECUTION_REPORT(REPORT_ERROR, -1, is_legal_local_comp_id(comp_id, true), "software error in Comp_comm_group_mgt_mgr::get_data_file_header");
-	sprintf(data_file_header, "%s/%s", search_global_node(comp_id)->get_working_dir(), search_global_node(comp_id)->get_comp_name());
+    EXECUTION_REPORT(REPORT_ERROR, -1, is_legal_local_comp_id(comp_id, true), "software error in Comp_comm_group_mgt_mgr::get_data_file_header");
+    sprintf(data_file_header, "%s/%s", search_global_node(comp_id)->get_working_dir(), search_global_node(comp_id)->get_comp_name());
 }
 
 
 const char *Comp_comm_group_mgt_mgr::get_comp_ccpl_log_file_name(int comp_id)
 {
-	EXECUTION_REPORT(REPORT_ERROR, -1, is_legal_local_comp_id(comp_id, true), "software error in Comp_comm_group_mgt_mgr::get_comp_ccpl_log_file_name");
-	return search_global_node(comp_id)->get_comp_ccpl_log_file_name();
+    EXECUTION_REPORT(REPORT_ERROR, -1, is_legal_local_comp_id(comp_id, true), "software error in Comp_comm_group_mgt_mgr::get_comp_ccpl_log_file_name");
+    return search_global_node(comp_id)->get_comp_ccpl_log_file_name();
 }
 
 
 const char *Comp_comm_group_mgt_mgr::get_comp_model_log_file(int comp_id, int &device_id)
 {
-	EXECUTION_REPORT(REPORT_ERROR, -1, is_legal_local_comp_id(comp_id, true), "software error in Comp_comm_group_mgt_mgr::get_comp_model_log_file");
-	return search_global_node(comp_id)->get_comp_model_log_file(device_id);
+    EXECUTION_REPORT(REPORT_ERROR, -1, is_legal_local_comp_id(comp_id, true), "software error in Comp_comm_group_mgt_mgr::get_comp_model_log_file");
+    return search_global_node(comp_id)->get_comp_model_log_file(device_id);
 }
 
 
 Comp_comm_group_mgt_node *Comp_comm_group_mgt_mgr::search_comp_with_comp_name(const char *comp_name)
 {
-	for (int i = 0; i < global_node_array.size(); i ++)
-		if (words_are_the_same(global_node_array[i]->get_comp_name(), comp_name) && global_node_array[i]->get_current_proc_local_id() != -1)
-			return global_node_array[i];
-		
-	return NULL;	
+    for (int i = 0; i < global_node_array.size(); i ++)
+        if (words_are_the_same(global_node_array[i]->get_comp_name(), comp_name) && global_node_array[i]->get_current_proc_local_id() != -1)
+            return global_node_array[i];
+        
+    return NULL;    
 }
 
 
 void Comp_comm_group_mgt_mgr::check_validation()
 {
-	for (int i = 0; i < global_node_array.size(); i ++) {		
-		EXECUTION_REPORT(REPORT_ERROR, -1, (global_node_array[i]->get_comp_id()&TYPE_ID_SUFFIX_MASK) == i, "Software error in Comp_comm_group_mgt_mgr::check_validation: wrong comp id does not match array index");
-		EXECUTION_REPORT(REPORT_ERROR, -1, search_global_node(global_node_array[i]->get_comp_id()) == global_node_array[i], "Software error in Comp_comm_group_mgt_mgr::check_validation: wrong comp id");
-		if (global_node_array[i]->get_parent() != NULL) {
-			EXECUTION_REPORT(REPORT_ERROR, -1, (global_node_array[i]->get_comp_id()&TYPE_ID_SUFFIX_MASK) > (global_node_array[i]->get_parent()->get_comp_id()&TYPE_ID_SUFFIX_MASK), "Software error in Comp_comm_group_mgt_mgr::check_validation: wrong parent1: %s vs %s", global_node_array[i]->get_full_name(), global_node_array[i]->get_parent()->get_full_name());
-			char full_name[NAME_STR_SIZE];
-			if ( global_node_array[i]->get_parent()->is_real_component_model()) {
-				sprintf(full_name, "%s@%s", global_node_array[i]->get_parent()->get_full_name(), global_node_array[i]->get_comp_name());
-				EXECUTION_REPORT(REPORT_ERROR, -1, words_are_the_same(full_name, global_node_array[i]->get_full_name()), "Software error in Comp_comm_group_mgt_mgr::check_validation: wrong parent2: %s vs %s", global_node_array[i]->get_full_name(), global_node_array[i]->get_parent()->get_full_name());
-			}
-			EXECUTION_REPORT(REPORT_ERROR, -1, search_global_node(global_node_array[i]->get_parent()->get_full_name()) == global_node_array[i]->get_parent(), "Software error in Comp_comm_group_mgt_mgr::check_validation: wrong parent3: %s vs %s", global_node_array[i]->get_full_name(), global_node_array[i]->get_parent()->get_full_name());
-		}	
-	}	
+    for (int i = 0; i < global_node_array.size(); i ++) {        
+        EXECUTION_REPORT(REPORT_ERROR, -1, (global_node_array[i]->get_comp_id()&TYPE_ID_SUFFIX_MASK) == i, "Software error in Comp_comm_group_mgt_mgr::check_validation: wrong comp id does not match array index");
+        EXECUTION_REPORT(REPORT_ERROR, -1, search_global_node(global_node_array[i]->get_comp_id()) == global_node_array[i], "Software error in Comp_comm_group_mgt_mgr::check_validation: wrong comp id");
+        if (global_node_array[i]->get_parent() != NULL) {
+            EXECUTION_REPORT(REPORT_ERROR, -1, (global_node_array[i]->get_comp_id()&TYPE_ID_SUFFIX_MASK) > (global_node_array[i]->get_parent()->get_comp_id()&TYPE_ID_SUFFIX_MASK), "Software error in Comp_comm_group_mgt_mgr::check_validation: wrong parent1: %s vs %s", global_node_array[i]->get_full_name(), global_node_array[i]->get_parent()->get_full_name());
+            char full_name[NAME_STR_SIZE];
+            if ( global_node_array[i]->get_parent()->is_real_component_model()) {
+                sprintf(full_name, "%s@%s", global_node_array[i]->get_parent()->get_full_name(), global_node_array[i]->get_comp_name());
+                EXECUTION_REPORT(REPORT_ERROR, -1, words_are_the_same(full_name, global_node_array[i]->get_full_name()), "Software error in Comp_comm_group_mgt_mgr::check_validation: wrong parent2: %s vs %s", global_node_array[i]->get_full_name(), global_node_array[i]->get_parent()->get_full_name());
+            }
+            EXECUTION_REPORT(REPORT_ERROR, -1, search_global_node(global_node_array[i]->get_parent()->get_full_name()) == global_node_array[i]->get_parent(), "Software error in Comp_comm_group_mgt_mgr::check_validation: wrong parent3: %s vs %s", global_node_array[i]->get_full_name(), global_node_array[i]->get_parent()->get_full_name());
+        }    
+    }    
 }
 
 
 Comp_comm_group_mgt_node *Comp_comm_group_mgt_mgr::search_global_node(const char *full_name)
-{	
-	for (int i = 0; i < global_node_array.size(); i ++)
-		if (words_are_the_same(global_node_array[i]->get_full_name(), full_name)) {
-			return global_node_array[i];
-		}
-		
-	return NULL;	
+{    
+    for (int i = 0; i < global_node_array.size(); i ++)
+        if (words_are_the_same(global_node_array[i]->get_full_name(), full_name)) {
+            return global_node_array[i];
+        }
+        
+    return NULL;    
 }
 
 
 Comp_comm_group_mgt_node *Comp_comm_group_mgt_mgr::search_global_node(int global_node_id)
 {
-	for (int i = 0; i < global_node_array.size(); i ++)
-		if (global_node_array[i]->get_local_node_id() == global_node_id)
-			return global_node_array[i];
-		
-	return NULL;
+    for (int i = 0; i < global_node_array.size(); i ++)
+        if (global_node_array[i]->get_local_node_id() == global_node_id)
+            return global_node_array[i];
+        
+    return NULL;
 }
 
 
 int Comp_comm_group_mgt_mgr::get_current_proc_id_in_comp(int comp_id, const char *annotation)
 {
-	EXECUTION_REPORT(REPORT_ERROR, -1, is_legal_local_comp_id(comp_id, true), 
-		             "The component id specified for getting the id of the current process is wrong. Please check the model code with the annotation %s.", 
-		             annotation); 
-	return search_global_node(comp_id)->get_current_proc_local_id();
+    EXECUTION_REPORT(REPORT_ERROR, -1, is_legal_local_comp_id(comp_id, true), 
+                     "The component id specified for getting the id of the current process is wrong. Please check the model code with the annotation %s.", 
+                     annotation); 
+    return search_global_node(comp_id)->get_current_proc_local_id();
 }
 
 
 int Comp_comm_group_mgt_mgr::get_num_proc_in_comp(int comp_id, const char *annotation)
 {
-	EXECUTION_REPORT(REPORT_ERROR, -1, is_legal_local_comp_id(comp_id, true), 
-		             "The component id specified for getting the the number of processes is wrong. Please check the model code with the annotation %s.", 
-		             annotation); 
-	EXECUTION_REPORT(REPORT_ERROR, -1, search_global_node(comp_id)->get_current_proc_local_id() != -1, 
-		             "The component id specified for getting the the number of processes is wrong. Please check the model code with the annotation %s.", 
-		             annotation);
-	return search_global_node(comp_id)->get_num_procs();
+    EXECUTION_REPORT(REPORT_ERROR, -1, is_legal_local_comp_id(comp_id, true), 
+                     "The component id specified for getting the the number of processes is wrong. Please check the model code with the annotation %s.", 
+                     annotation); 
+    EXECUTION_REPORT(REPORT_ERROR, -1, search_global_node(comp_id)->get_current_proc_local_id() != -1, 
+                     "The component id specified for getting the the number of processes is wrong. Please check the model code with the annotation %s.", 
+                     annotation);
+    return search_global_node(comp_id)->get_num_procs();
 }
 
 
 void Comp_comm_group_mgt_mgr::confirm_coupling_configuration_active(int comp_id, int API_id, bool require_real_model, const char *annotation)
 {
-	EXECUTION_REPORT(REPORT_ERROR, -1, comp_comm_group_mgt_mgr->is_legal_local_comp_id(comp_id, true), "software error in Comp_comm_group_mgt_mgr::confirm_coupling_configuration_active");
-	get_global_node_of_local_comp(comp_id,true,"in Comp_comm_group_mgt_mgr::confirm_coupling_configuration_active")->confirm_coupling_configuration_active(API_id, require_real_model, annotation);
+    EXECUTION_REPORT(REPORT_ERROR, -1, comp_comm_group_mgt_mgr->is_legal_local_comp_id(comp_id, true), "software error in Comp_comm_group_mgt_mgr::confirm_coupling_configuration_active");
+    get_global_node_of_local_comp(comp_id,true,"in Comp_comm_group_mgt_mgr::confirm_coupling_configuration_active")->confirm_coupling_configuration_active(API_id, require_real_model, annotation);
 }
 
 
 const int *Comp_comm_group_mgt_mgr::get_all_components_ids()
 {
-	int *all_components_ids = new int [global_node_array.size()];
+    int *all_components_ids = new int [global_node_array.size()];
 
 
-	for (int i = 1; i < global_node_array.size(); i ++) {
-		all_components_ids[i] = global_node_array[i]->get_comp_id();
-	}
-	all_components_ids[0] = global_node_array.size();
+    for (int i = 1; i < global_node_array.size(); i ++) {
+        all_components_ids[i] = global_node_array[i]->get_comp_id();
+    }
+    all_components_ids[0] = global_node_array.size();
 
-	return all_components_ids;
+    return all_components_ids;
 }
 
 
 bool Comp_comm_group_mgt_mgr::has_comp_ended_configuration(const char *comp_full_name)
 {
-	char status_file_name[NAME_STR_SIZE];
-	sprintf(status_file_name, "%s/%s.end", comps_ending_config_status_dir, comp_full_name);
-	FILE *status_file = fopen(status_file_name, "r");
-	if (status_file == NULL)
-		return false;
-
-	fclose(status_file);
-	return true;
+    char status_file_name[NAME_STR_SIZE];
+    sprintf(status_file_name, "%s/%s.end", comps_ending_config_status_dir, comp_full_name);
+    FILE *status_file = fopen(status_file_name, "r");
+    if (status_file == NULL)
+        return false;
+
+    fclose(status_file);
+    return true;
 }
 
 
 void Comp_comm_group_mgt_mgr::push_comp_node(Comp_comm_group_mgt_node *comp_node) 
 {
-	comp_node->reset_local_node_id((unique_comp_id_indx++)|TYPE_COMP_LOCAL_ID_PREFIX);
-	global_node_array.push_back(comp_node); 
+    comp_node->reset_local_node_id((unique_comp_id_indx++)|TYPE_COMP_LOCAL_ID_PREFIX);
+    global_node_array.push_back(comp_node); 
 }
 
 
 Comp_comm_group_mgt_node *Comp_comm_group_mgt_mgr::pop_comp_node()
 {
-	Comp_comm_group_mgt_node *top_comp_node = global_node_array[global_node_array.size()-1];
-	global_node_array.erase(global_node_array.begin()+global_node_array.size()-1);
-	return top_comp_node;
+    Comp_comm_group_mgt_node *top_comp_node = global_node_array[global_node_array.size()-1];
+    global_node_array.erase(global_node_array.begin()+global_node_array.size()-1);
+    return top_comp_node;
 }
 
 
 void Comp_comm_group_mgt_mgr::set_current_proc_current_time(int comp_id, int days, int second)
 {
-	get_global_node_of_local_comp(comp_id,true,"Comp_comm_group_mgt_mgr::set_current_proc_time")->set_current_proc_current_time(days, second);
+    get_global_node_of_local_comp(comp_id,true,"Comp_comm_group_mgt_mgr::set_current_proc_time")->set_current_proc_current_time(days, second);
 }
 
 
 Comp_comm_group_mgt_node *Comp_comm_group_mgt_mgr::load_comp_info_from_XML(int host_comp_id, const char *comp_full_name, MPI_Comm comm)
 {
-	char XML_file_name[NAME_STR_SIZE];
-	TiXmlDocument *XML_file;
-	int i;
-
-
-	sprintf(XML_file_name, "%s/%s.basic_info.xml", comp_comm_group_mgt_mgr->get_components_processes_dir(), comp_full_name);
-	XML_file = open_XML_file_to_read(host_comp_id, XML_file_name, comm, true);
-	TiXmlElement *XML_element = XML_file->FirstChildElement();
-	TiXmlElement *Online_Model = XML_element->FirstChildElement();
-	Comp_comm_group_mgt_node *pesudo_comp_node = new Comp_comm_group_mgt_node(Online_Model, comp_full_name, XML_file_name);
-	delete XML_file;
-		
-	return pesudo_comp_node;
+    char XML_file_name[NAME_STR_SIZE];
+    TiXmlDocument *XML_file;
+    int i;
+
+
+    sprintf(XML_file_name, "%s/%s.basic_info.xml", comp_comm_group_mgt_mgr->get_components_processes_dir(), comp_full_name);
+    XML_file = open_XML_file_to_read(host_comp_id, XML_file_name, comm, true);
+    TiXmlElement *XML_element = XML_file->FirstChildElement();
+    TiXmlElement *Online_Model = XML_element->FirstChildElement();
+    Comp_comm_group_mgt_node *pesudo_comp_node = new Comp_comm_group_mgt_node(Online_Model, comp_full_name, XML_file_name);
+    delete XML_file;
+        
+    return pesudo_comp_node;
 }
 
 
 void Comp_comm_group_mgt_mgr::get_root_comps_for_overall_coupling_generation(std::vector<const char *> &all_comp_fullnames_for_coupling_generation)
 {
-	for (int i = 0; i < root_comps_full_names.size(); i ++) 
-		if (root_comps_enabled_in_parent_coupling_generation[i])
-			all_comp_fullnames_for_coupling_generation.push_back(strdup(root_comps_full_names[i]));
+    for (int i = 0; i < root_comps_full_names.size(); i ++) 
+        if (root_comps_enabled_in_parent_coupling_generation[i])
+            all_comp_fullnames_for_coupling_generation.push_back(strdup(root_comps_full_names[i]));
 }
 
 
 bool Comp_comm_group_mgt_mgr::is_comp_type_coupled(int host_comp_id, const char *comp_type, const char *annotation)
 {
-	char comp_full_name[NAME_STR_SIZE];
+    char comp_full_name[NAME_STR_SIZE];
 
 
-	EXECUTION_REPORT(REPORT_ERROR, -1, words_are_the_same(comp_type,COMP_TYPE_CPL) || words_are_the_same(comp_type,COMP_TYPE_ATM) || words_are_the_same(comp_type,COMP_TYPE_GLC) || words_are_the_same(comp_type,COMP_TYPE_ATM_CHEM) || words_are_the_same(comp_type,COMP_TYPE_OCN) || words_are_the_same(comp_type,COMP_TYPE_LND) || words_are_the_same(comp_type,COMP_TYPE_SEA_ICE) || words_are_the_same(comp_type,COMP_TYPE_WAVE) || words_are_the_same(comp_type,COMP_TYPE_RUNOFF), 
-		             "ERROR happens when calling the API \"CCPL_is_comp_type_coupled\": the component type \"%s\" is unknown. Please verify the model code with the annotation \"%s\"", comp_type, annotation);
+    EXECUTION_REPORT(REPORT_ERROR, -1, words_are_the_same(comp_type,COMP_TYPE_CPL) || words_are_the_same(comp_type,COMP_TYPE_ATM) || words_are_the_same(comp_type,COMP_TYPE_GLC) || words_are_the_same(comp_type,COMP_TYPE_ATM_CHEM) || words_are_the_same(comp_type,COMP_TYPE_OCN) || words_are_the_same(comp_type,COMP_TYPE_LND) || words_are_the_same(comp_type,COMP_TYPE_SEA_ICE) || words_are_the_same(comp_type,COMP_TYPE_WAVE) || words_are_the_same(comp_type,COMP_TYPE_RUNOFF), 
+                     "ERROR happens when calling the API \"CCPL_is_comp_type_coupled\": the component type \"%s\" is unknown. Please verify the model code with the annotation \"%s\"", comp_type, annotation);
 
-	DIR *cur_dir = opendir(comp_comm_group_mgt_mgr->get_components_processes_dir());
-	struct dirent *ent = NULL;
-	struct stat st;
-	EXECUTION_REPORT(REPORT_ERROR, -1, cur_dir != NULL, "Comp_comm_group_mgt_mgr::is_comp_type_coupled");
-	while ((ent = readdir(cur_dir)) != NULL) {
-		stat(ent->d_name, &st);
-		if (!(strlen(ent->d_name) > strlen(".basic_info.xml") && words_are_the_same(ent->d_name+strlen(ent->d_name)-strlen(".basic_info.xml"), ".basic_info.xml")))
-			continue;
-		strncpy(comp_full_name, ent->d_name, strlen(ent->d_name)-strlen(".basic_info.xml"));
-		comp_full_name[strlen(ent->d_name)-strlen(".basic_info.xml")] = '\0';
-		Comp_comm_group_mgt_node *temp_comp_node = load_comp_info_from_XML(host_comp_id, comp_full_name, get_comm_group_of_local_comp(host_comp_id, "is_comp_type_coupled"));
-		if (words_are_the_same(temp_comp_node->get_comp_type(), comp_type)) {
-			delete temp_comp_node;
-			return true;
-		}
-		delete temp_comp_node;
-	}
-	
-	return false;
+    DIR *cur_dir = opendir(comp_comm_group_mgt_mgr->get_components_processes_dir());
+    struct dirent *ent = NULL;
+    struct stat st;
+    EXECUTION_REPORT(REPORT_ERROR, -1, cur_dir != NULL, "Comp_comm_group_mgt_mgr::is_comp_type_coupled");
+    while ((ent = readdir(cur_dir)) != NULL) {
+        stat(ent->d_name, &st);
+        if (!(strlen(ent->d_name) > strlen(".basic_info.xml") && words_are_the_same(ent->d_name+strlen(ent->d_name)-strlen(".basic_info.xml"), ".basic_info.xml")))
+            continue;
+        strncpy(comp_full_name, ent->d_name, strlen(ent->d_name)-strlen(".basic_info.xml"));
+        comp_full_name[strlen(ent->d_name)-strlen(".basic_info.xml")] = '\0';
+        Comp_comm_group_mgt_node *temp_comp_node = load_comp_info_from_XML(host_comp_id, comp_full_name, get_comm_group_of_local_comp(host_comp_id, "is_comp_type_coupled"));
+        if (words_are_the_same(temp_comp_node->get_comp_type(), comp_type)) {
+            delete temp_comp_node;
+            return true;
+        }
+        delete temp_comp_node;
+    }
+    
+    return false;
 }
 
 
 void Comp_comm_group_mgt_mgr::output_log(const char *log_string, bool flush_log_file)
 {
-	output_CCPL_log(log_string, exe_log_file_name, &log_buffer, log_buffer_content_size, flush_log_file);
+    output_CCPL_log(log_string, exe_log_file_name, &log_buffer, log_buffer_content_size, flush_log_file);
 }
 
 
 void Comp_comm_group_mgt_mgr::output_performance_timing()
 {
-	for (int i = 0; i < global_node_array.size(); i ++)
-		if (global_node_array[i]->is_real_component_model() && global_node_array[i]->get_performance_timing_mgr() != NULL)
-			global_node_array[i]->get_performance_timing_mgr()->performance_timing_output();
+    for (int i = 0; i < global_node_array.size(); i ++)
+        if (global_node_array[i]->is_real_component_model() && global_node_array[i]->get_performance_timing_mgr() != NULL)
+            global_node_array[i]->get_performance_timing_mgr()->performance_timing_output();
 }
 
 
 bool Comp_comm_group_mgt_mgr::does_comp_name_include_reserved_prefix(const char *comp_name)
 {
-	return strncmp(comp_name, COMP_TYPE_ROOT, strlen(COMP_TYPE_ROOT)) == 0 || 
-		   strncmp(comp_name, DATAINST_NAME_PREFIX, strlen(DATAINST_NAME_PREFIX)) == 0 || 
-		   strncmp(comp_name, DATAMODEL_NAME_PREFIX, strlen(DATAMODEL_NAME_PREFIX)) == 0 || 
-		   strncmp(comp_name, ALGMODEL_NAME_PREFIX, strlen(ALGMODEL_NAME_PREFIX)) == 0;
+    return strncmp(comp_name, COMP_TYPE_ROOT, strlen(COMP_TYPE_ROOT)) == 0 || 
+           strncmp(comp_name, DATAINST_NAME_PREFIX, strlen(DATAINST_NAME_PREFIX)) == 0 || 
+           strncmp(comp_name, DATAMODEL_NAME_PREFIX, strlen(DATAMODEL_NAME_PREFIX)) == 0 || 
+           strncmp(comp_name, ALGMODEL_NAME_PREFIX, strlen(ALGMODEL_NAME_PREFIX)) == 0;
 }
diff --git a/src/Parallel_MGT/compset_communicators_info_mgt.h b/src/Parallel_MGT/compset_communicators_info_mgt.h
old mode 100644
new mode 100755
index 233b34f..26dffa1
--- a/src/Parallel_MGT/compset_communicators_info_mgt.h
+++ b/src/Parallel_MGT/compset_communicators_info_mgt.h
@@ -39,159 +39,161 @@
 
 class Comp_comm_group_mgt_node
 {
-	private:
-		int comp_id;
-	    char comp_name[NAME_STR_SIZE];                // The name of component	
-	    char full_name[NAME_STR_SIZE];
-		char comp_type[NAME_STR_SIZE];
-		char annotation_start[NAME_STR_SIZE];
-		char annotation_end[NAME_STR_SIZE];
-		char comp_ccpl_log_file_name[NAME_STR_SIZE];
-		char comp_model_log_file_name[NAME_STR_SIZE];
-		int comp_model_log_file_device;
-		char working_dir[NAME_STR_SIZE];
-		Comp_comm_group_mgt_node *parent;
-		std::vector<Comp_comm_group_mgt_node*> children;
-		MPI_Comm comm_group;
-		std::vector<int> local_processes_global_ids;
-		long *proc_latest_model_time;
-		int current_proc_local_id;
-		int current_proc_global_id;
-		char *temp_array_buffer;
-		long buffer_content_size;
-		long buffer_content_iter;
-		long buffer_max_size;
-		bool definition_finalized;
-		bool enabled_in_parent_coupling_generation;
-		Restart_mgt *restart_mgr;
-		int min_remote_lag_seconds;
-		int max_remote_lag_seconds;
-		char *log_buffer;
-		int log_buffer_content_size;
-		Performance_timing_mgt *performance_timing_mgr;
+    private:
+        int comp_id;
+        char comp_name[NAME_STR_SIZE];                // The name of component    
+        char full_name[NAME_STR_SIZE];
+        char comp_type[NAME_STR_SIZE];
+        char annotation_start[NAME_STR_SIZE];
+        char annotation_end[NAME_STR_SIZE];
+        char comp_ccpl_log_file_name[NAME_STR_SIZE];
+        char comp_model_log_file_name[NAME_STR_SIZE];
+        int comp_model_log_file_device;
+        char working_dir[NAME_STR_SIZE];
+        Comp_comm_group_mgt_node *parent;
+        std::vector<Comp_comm_group_mgt_node*> children;
+        MPI_Comm comm_group;
+        std::vector<int> local_processes_global_ids;
+        long *proc_latest_model_time;
+        int current_proc_local_id;
+        int current_proc_global_id;
+        char *temp_array_buffer;
+        long buffer_content_size;
+        long buffer_content_iter;
+        long buffer_max_size;
+        bool definition_finalized;
+        bool enabled_in_parent_coupling_generation;
+        Restart_mgt *restart_mgr;
+        int min_remote_lag_seconds;
+        int max_remote_lag_seconds;
+        char *log_buffer;
+        int log_buffer_content_size;
+        Performance_timing_mgt *performance_timing_mgr;
 
-	public:
-		Comp_comm_group_mgt_node(const char*, const char*, int, Comp_comm_group_mgt_node*, MPI_Comm&, bool, const char*);
-		Comp_comm_group_mgt_node(TiXmlElement *, const char *, const char *);
-		~Comp_comm_group_mgt_node();
-		MPI_Comm get_comm_group() const { return comm_group; }
-		int get_comp_id() const { return comp_id; }
-		int get_current_proc_local_id() const { return current_proc_local_id; }
-		void transform_node_into_array();
-		int get_buffer_content_size() { return buffer_content_size; }
-		int get_buffer_content_iter() { return buffer_content_iter; }
-		const char *get_comp_name() const { return comp_name; }
-		const char *get_comp_type() const { return comp_type; }
-		const char *get_comp_full_name() const { return full_name; }
-		int get_num_children() { return children.size(); }
-		int get_local_node_id() { return comp_id; }
-		Comp_comm_group_mgt_node *get_child(int indx) { return children[indx]; }
-		void reset_local_node_id(int);
-		void reset_current_proc_local_id(int new_current_proc_local_id) { current_proc_local_id = new_current_proc_local_id; }
-		bool is_definition_finalized() { return definition_finalized; }
-		const char *get_annotation_start() { return annotation_start; }
-		const char *get_annotation_end() { return annotation_end; }
-		Comp_comm_group_mgt_node *get_parent() const { return parent; }
-		void write_node_into_XML(TiXmlElement *);
-		const char *get_working_dir() const { return working_dir; }
-		void update_child(const Comp_comm_group_mgt_node*, Comp_comm_group_mgt_node*);
-		void transfer_data_buffer(Comp_comm_group_mgt_node*);
-		int get_num_procs() const { return local_processes_global_ids.size(); }
-		int get_root_proc_global_id() const { return local_processes_global_ids[0]; }
-		int get_local_proc_global_id(int);
-		void confirm_coupling_configuration_active(int, bool, const char*);
-		const char *get_full_name() { return full_name; }
-		int open_comp_model_log_file(int*);
-		const char *get_comp_ccpl_log_file_name() { return comp_ccpl_log_file_name; } 
-		const char *get_comp_model_log_file(int &device_id) { device_id = comp_model_log_file_device; return comp_model_log_file_name; }
-		bool is_real_component_model();
-		Restart_mgt *get_restart_mgr() { return restart_mgr; }
-		bool have_local_process(int);
-		void allocate_proc_latest_model_time();
-		void set_current_proc_current_time(int, int);
-		void set_proc_latest_model_time(int, long);
-		long get_proc_latest_model_time(int);
-		void get_all_descendant_real_comp_fullnames(int, std::vector<const char*>&, char **, long &, long &);
-		int get_min_remote_lag_seconds();
-		int get_max_remote_lag_seconds();
-		void update_min_max_remote_lag_seconds(int);
-		void output_log(const char *, bool);
-		Performance_timing_mgt *get_performance_timing_mgr() { return performance_timing_mgr; }		
+    public:
+        Comp_comm_group_mgt_node(const char*, const char*, int, Comp_comm_group_mgt_node*, MPI_Comm&, bool, const char*);
+        Comp_comm_group_mgt_node(TiXmlElement *, const char *, const char *);
+        ~Comp_comm_group_mgt_node();
+        MPI_Comm get_comm_group() const { return comm_group; }
+        int get_comp_id() const { return comp_id; }
+        int get_current_proc_local_id() const { return current_proc_local_id; }
+        void transform_node_into_array();
+        int get_buffer_content_size() { return buffer_content_size; }
+        int get_buffer_content_iter() { return buffer_content_iter; }
+        const char *get_comp_name() const { return comp_name; }
+        const char *get_comp_type() const { return comp_type; }
+        const char *get_comp_full_name() const { return full_name; }
+        int get_num_children() { return children.size(); }
+        int get_local_node_id() { return comp_id; }
+        Comp_comm_group_mgt_node *get_child(int indx) { return children[indx]; }
+        void reset_local_node_id(int);
+        void reset_current_proc_local_id(int new_current_proc_local_id) { current_proc_local_id = new_current_proc_local_id; }
+        bool is_definition_finalized() { return definition_finalized; }
+        const char *get_annotation_start() { return annotation_start; }
+        const char *get_annotation_end() { return annotation_end; }
+        Comp_comm_group_mgt_node *get_parent() const { return parent; }
+        void write_node_into_XML(TiXmlElement *);
+        const char *get_working_dir() const { return working_dir; }
+        void update_child(const Comp_comm_group_mgt_node*, Comp_comm_group_mgt_node*);
+        void transfer_data_buffer(Comp_comm_group_mgt_node*);
+        int get_num_procs() const { return local_processes_global_ids.size(); }
+        int get_root_proc_global_id() const { return local_processes_global_ids[0]; }
+        int get_local_proc_global_id(int);
+        void confirm_coupling_configuration_active(int, bool, const char*);
+        const char *get_full_name() { return full_name; }
+        int open_comp_model_log_file(int*);
+        const char *get_comp_ccpl_log_file_name() { return comp_ccpl_log_file_name; } 
+        const char *get_comp_model_log_file(int &device_id) { device_id = comp_model_log_file_device; return comp_model_log_file_name; }
+        bool is_real_component_model();
+        Restart_mgt *get_restart_mgr() { return restart_mgr; }
+        bool have_local_process(int);
+        void allocate_proc_latest_model_time();
+        void set_current_proc_current_time(int, int);
+        void set_proc_latest_model_time(int, long);
+        long get_proc_latest_model_time(int);
+        void get_all_descendant_real_comp_fullnames(int, std::vector<const char*>&, char **, long &, long &);
+        int get_min_remote_lag_seconds();
+        int get_max_remote_lag_seconds();
+        void update_min_max_remote_lag_seconds(int);
+        void output_log(const char *, bool);
+        Performance_timing_mgt *get_performance_timing_mgr() { return performance_timing_mgr; }        
 };
 
 
 class Comp_comm_group_mgt_mgr
 {
-	private:
-		std::vector<Comp_comm_group_mgt_node*> global_node_array;
-		Comp_comm_group_mgt_node *global_node_root;
-		std::vector<const char*> root_comps_full_names;
-		std::vector<bool> root_comps_enabled_in_parent_coupling_generation;
-		bool definition_finalized;
-		int current_proc_global_id;
-		int num_total_global_procs;
-		char executable_name[NAME_STR_SIZE];
-		char root_working_dir[NAME_STR_SIZE];
-		char internal_H2D_grids_dir[NAME_STR_SIZE];
-		char components_processes_dir[NAME_STR_SIZE];
-		char components_exports_dir[NAME_STR_SIZE];
-		char active_coupling_connections_dir[NAME_STR_SIZE];
-		char comps_ending_config_status_dir[NAME_STR_SIZE];
-		char restart_common_dir[NAME_STR_SIZE];
-		char runtime_config_root_dir[NAME_STR_SIZE];
-		char root_comp_config_dir[NAME_STR_SIZE];
-		char CCPL_platform_log_dir[NAME_STR_SIZE];
-		char exe_log_file_name[NAME_STR_SIZE];
-		int unique_comp_id_indx;
-		char *log_buffer;
-		int log_buffer_content_size;
+    private:
+        std::vector<Comp_comm_group_mgt_node*> global_node_array;
+        Comp_comm_group_mgt_node *global_node_root;
+        std::vector<const char*> root_comps_full_names;
+        std::vector<bool> root_comps_enabled_in_parent_coupling_generation;
+        bool definition_finalized;
+        int current_proc_global_id;
+        int num_total_global_procs;
+        char executable_name[NAME_STR_SIZE];
+        char root_working_dir[NAME_STR_SIZE];
+        char internal_H2D_grids_dir[NAME_STR_SIZE];
+		char internal_remapping_weights_dir[NAME_STR_SIZE];
+        char components_processes_dir[NAME_STR_SIZE];
+        char components_exports_dir[NAME_STR_SIZE];
+        char active_coupling_connections_dir[NAME_STR_SIZE];
+        char comps_ending_config_status_dir[NAME_STR_SIZE];
+        char restart_common_dir[NAME_STR_SIZE];
+        char runtime_config_root_dir[NAME_STR_SIZE];
+        char root_comp_config_dir[NAME_STR_SIZE];
+        char CCPL_platform_log_dir[NAME_STR_SIZE];
+        char exe_log_file_name[NAME_STR_SIZE];
+        int unique_comp_id_indx;
+        char *log_buffer;
+        int log_buffer_content_size;
 
-	public:
-		Comp_comm_group_mgt_mgr(const char*);
-		~Comp_comm_group_mgt_mgr();
-		int register_component(const char*, const char*, MPI_Comm&, int, bool, int, const char*);
-		bool is_legal_local_comp_id(int, bool);
-		void transform_global_node_tree_into_array(Comp_comm_group_mgt_node*, Comp_comm_group_mgt_node**, int&);
-		Comp_comm_group_mgt_node *get_global_node_of_local_comp(int, bool, const char*);
-		MPI_Comm get_comm_group_of_local_comp(int, const char*);
-		const char *get_executable_name() { return executable_name; }
-		const char *get_annotation_start() { return global_node_array[0]->get_annotation_start(); }
-		Comp_comm_group_mgt_node *get_root_component_model() { return global_node_array[1]; }
-		const char *get_comp_ccpl_log_file_name(int);
-		const char *get_comp_model_log_file(int, int &);
-		void get_output_data_file_header(int, char*);
-		Comp_comm_group_mgt_node *search_global_node(int);
-		Comp_comm_group_mgt_node *search_global_node(const char*);
-		Comp_comm_group_mgt_node *search_comp_with_comp_name(const char*);
-		int get_current_proc_id_in_comp(int, const char *);
-		int get_num_proc_in_comp(int, const char *);
-		int get_current_proc_global_id() { return current_proc_global_id; }
-		int get_num_total_global_procs() { return num_total_global_procs; }
-		const char *get_root_working_dir() { return root_working_dir; }
-		const char *get_internal_H2D_grids_dir() { return internal_H2D_grids_dir; }
-		const char *get_components_processes_dir() { return components_processes_dir; }
-		const char *get_components_exports_dir() { return components_exports_dir; }
-		const char *get_active_coupling_connections_dir() { return active_coupling_connections_dir; }
-		const char *get_comps_ending_config_status_dir() { return comps_ending_config_status_dir; }
-		const char *get_restart_common_dir() { return restart_common_dir; }
-		const char *get_config_root_dir() { return runtime_config_root_dir; }	
-		const char *get_root_comp_config_dir() const { return root_comp_config_dir; }
-		void get_root_comps_for_overall_coupling_generation(std::vector<const char *> &);
-		void confirm_coupling_configuration_active(int, int, bool, const char*);
-		const int *get_all_components_ids();
-		Comp_comm_group_mgt_node *get_global_node_root() { return global_node_root; }
-		bool has_comp_ended_configuration(const char*);
-		void push_comp_node(Comp_comm_group_mgt_node *);
-		Comp_comm_group_mgt_node *pop_comp_node();
-		void check_validation();
-		void set_current_proc_current_time(int, int, int);
-		Comp_comm_group_mgt_node *load_comp_info_from_XML(int, const char *, MPI_Comm);
-		const char *get_CCPL_platform_log_dir() { return CCPL_platform_log_dir; }
-		bool is_comp_type_coupled(int, const char *, const char *);
-		void output_log(const char *, bool);
-		const char *get_exe_log_file_name() { return exe_log_file_name; }		
-		void output_performance_timing();
-		bool does_comp_name_include_reserved_prefix(const char *);
+    public:
+        Comp_comm_group_mgt_mgr(const char*);
+        ~Comp_comm_group_mgt_mgr();
+        int register_component(const char*, const char*, MPI_Comm&, int, bool, int, const char*);
+        bool is_legal_local_comp_id(int, bool);
+        void transform_global_node_tree_into_array(Comp_comm_group_mgt_node*, Comp_comm_group_mgt_node**, int&);
+        Comp_comm_group_mgt_node *get_global_node_of_local_comp(int, bool, const char*);
+        MPI_Comm get_comm_group_of_local_comp(int, const char*);
+        const char *get_executable_name() { return executable_name; }
+        const char *get_annotation_start() { return global_node_array[0]->get_annotation_start(); }
+        Comp_comm_group_mgt_node *get_root_component_model() { return global_node_array[1]; }
+        const char *get_comp_ccpl_log_file_name(int);
+        const char *get_comp_model_log_file(int, int &);
+        void get_output_data_file_header(int, char*);
+        Comp_comm_group_mgt_node *search_global_node(int);
+        Comp_comm_group_mgt_node *search_global_node(const char*);
+        Comp_comm_group_mgt_node *search_comp_with_comp_name(const char*);
+        int get_current_proc_id_in_comp(int, const char *);
+        int get_num_proc_in_comp(int, const char *);
+        int get_current_proc_global_id() { return current_proc_global_id; }
+        int get_num_total_global_procs() { return num_total_global_procs; }
+        const char *get_root_working_dir() { return root_working_dir; }
+        const char *get_internal_H2D_grids_dir() { return internal_H2D_grids_dir; }
+		const char *get_internal_remapping_weights_dir() { return internal_remapping_weights_dir; }
+        const char *get_components_processes_dir() { return components_processes_dir; }
+        const char *get_components_exports_dir() { return components_exports_dir; }
+        const char *get_active_coupling_connections_dir() { return active_coupling_connections_dir; }
+        const char *get_comps_ending_config_status_dir() { return comps_ending_config_status_dir; }
+        const char *get_restart_common_dir() { return restart_common_dir; }
+        const char *get_config_root_dir() { return runtime_config_root_dir; }    
+        const char *get_root_comp_config_dir() const { return root_comp_config_dir; }
+        void get_root_comps_for_overall_coupling_generation(std::vector<const char *> &);
+        void confirm_coupling_configuration_active(int, int, bool, const char*);
+        const int *get_all_components_ids();
+        Comp_comm_group_mgt_node *get_global_node_root() { return global_node_root; }
+        bool has_comp_ended_configuration(const char*);
+        void push_comp_node(Comp_comm_group_mgt_node *);
+        Comp_comm_group_mgt_node *pop_comp_node();
+        void check_validation();
+        void set_current_proc_current_time(int, int, int);
+        Comp_comm_group_mgt_node *load_comp_info_from_XML(int, const char *, MPI_Comm);
+        const char *get_CCPL_platform_log_dir() { return CCPL_platform_log_dir; }
+        bool is_comp_type_coupled(int, const char *, const char *);
+        void output_log(const char *, bool);
+        const char *get_exe_log_file_name() { return exe_log_file_name; }        
+        void output_performance_timing();
+        bool does_comp_name_include_reserved_prefix(const char *);
 };
 
 
diff --git a/src/Parallel_MGT/decomp_grid_mgt.cxx b/src/Parallel_MGT/decomp_grid_mgt.cxx
old mode 100644
new mode 100755
index a6ce301..f2a34c0
--- a/src/Parallel_MGT/decomp_grid_mgt.cxx
+++ b/src/Parallel_MGT/decomp_grid_mgt.cxx
@@ -18,75 +18,77 @@ Decomp_grid_info::Decomp_grid_info(int decomp_id, Remap_grid_class *original_gri
     Remap_grid_class *decomp_info_grid, *decomp_2D_grid;
     Remap_grid_class *leaf_grids[256], *sub_grids[256];
     int num_leaf_grids, num_sub_grids, i, j, decomp_leaf_grid_indexes[2];
-	char decomp_grid_name[NAME_STR_SIZE];
-	int comp_id;
+    char decomp_grid_name[NAME_STR_SIZE];
+    int comp_id;
 
 
-	EXECUTION_REPORT(REPORT_ERROR, -1, decomps_info_mgr->is_decomp_id_legal(decomp_id), "Software error in Decomp_grid_info::Decomp_grid_info(int decomp_id)");
-	decomp = decomps_info_mgr->get_decomp_info(decomp_id);
-	decomp_info_grid = original_grid_mgr->get_original_CoR_grid(decomp->get_grid_id());
-	comp_id = decomp->get_comp_id();
-	this->decomp_id = decomp_id;
-	strcpy(this->decomp_name, decomp->get_decomp_name());
-	this->original_grid = original_grid;
+    EXECUTION_REPORT(REPORT_ERROR, -1, decomps_info_mgr->is_decomp_id_legal(decomp_id), "Software error in Decomp_grid_info::Decomp_grid_info(int decomp_id)");
+    decomp = decomps_info_mgr->get_decomp_info(decomp_id);
+    decomp_info_grid = original_grid_mgr->get_original_CoR_grid(decomp->get_grid_id());
+    comp_id = decomp->get_comp_id();
+    this->decomp_id = decomp_id;
+    strcpy(this->decomp_name, decomp->get_decomp_name());
+    this->original_grid = original_grid;
     EXECUTION_REPORT_LOG(REPORT_LOG, decomp->get_host_comp_id(), true, 
-		             "Generate decomposition grid for the grid \"%s\" on the parallel decomposition \"%s\"", 
-		             original_grid->get_grid_name(), decomp_name);
+                     "Generate decomposition grid for the grid \"%s\" on the parallel decomposition \"%s\"", 
+                     original_grid->get_grid_name(), decomp_name);
 
-	if (decomp->get_num_local_cells() == 0) {
-		this->decomp_grid = NULL;
-		return;
-	}
+    if (decomp->get_num_local_cells() == 0) {
+        this->decomp_grid = NULL;
+        return;
+    }
 
     if (this->original_grid->get_is_sphere_grid()) {
         EXECUTION_REPORT(REPORT_ERROR, -1, decomp_info_grid == original_grid, "Software error in Decomp_grid_info::Decomp_grid_info: inconsistent H2D grid: %s  %s  %s", original_grid->get_grid_name(), decomp->get_grid_name(), decomp_name);
-		EXECUTION_REPORT_LOG(REPORT_LOG, decomp->get_host_comp_id(), true, 
-			             "generate decomposition sphere grid (%s %s) with size %d", 
-			             decomp_name, original_grid->get_grid_name(), decomp->get_num_local_cells());
+        EXECUTION_REPORT_LOG(REPORT_LOG, decomp->get_host_comp_id(), true, 
+                         "generate decomposition sphere grid (%s %s) with size %d", 
+                         decomp_name, original_grid->get_grid_name(), decomp->get_num_local_cells());
         this->decomp_grid = this->original_grid->generate_decomp_grid(decomp->get_local_cell_global_indx(), decomp->get_num_local_cells(), decomp_name);
     }
     else {
-		if (original_grid->has_grid_coord_label(COORD_LABEL_LON) || original_grid->has_grid_coord_label(COORD_LABEL_LAT))
-	        EXECUTION_REPORT(REPORT_ERROR, -1, decomp_info_grid->is_subset_of_grid(original_grid), "Software error in Decomp_grid_info::Decomp_grid_info: inconsistent H2D and MD grid",
-			                 original_grid->get_grid_name(), decomp_info_grid->get_grid_name(), decomp_name);
+        if (original_grid->has_grid_coord_label(COORD_LABEL_LON) || original_grid->has_grid_coord_label(COORD_LABEL_LAT))
+            EXECUTION_REPORT(REPORT_ERROR, -1, decomp_info_grid->is_subset_of_grid(original_grid), "Software error in Decomp_grid_info::Decomp_grid_info: inconsistent H2D and MD grid",
+                             original_grid->get_grid_name(), decomp_info_grid->get_grid_name(), decomp_name);
         original_grid->get_leaf_grids(&num_leaf_grids, leaf_grids, original_grid);
-		for (i = 0, j = 0; i < num_leaf_grids; i ++)
-			if (leaf_grids[i]->is_subset_of_grid(decomp_info_grid))
-				decomp_leaf_grid_indexes[j++] = i;
-		EXECUTION_REPORT(REPORT_ERROR,-1, j == 2, "Software error in Decomp_grid_info::Decomp_grid_info: wrong j"); 
-		EXECUTION_REPORT(REPORT_ERROR,-1, decomp_leaf_grid_indexes[1]-decomp_leaf_grid_indexes[0] == 1, "C-Coupler error in Decomp_grid_info::Decomp_grid_info\n");
+        for (i = 0, j = 0; i < num_leaf_grids; i ++)
+            if (leaf_grids[i]->is_subset_of_grid(decomp_info_grid))
+                decomp_leaf_grid_indexes[j++] = i;
+        EXECUTION_REPORT(REPORT_ERROR,-1, j == 2, "Software error in Decomp_grid_info::Decomp_grid_info: wrong j"); 
+        EXECUTION_REPORT(REPORT_ERROR,-1, decomp_leaf_grid_indexes[1]-decomp_leaf_grid_indexes[0] == 1, "C-Coupler error in Decomp_grid_info::Decomp_grid_info\n");
         for (i = 0, num_sub_grids = 0; i < num_leaf_grids; i ++) {
-			if (leaf_grids[i] == NULL)
-				continue;
-			if (leaf_grids[i]->is_subset_of_grid(decomp_info_grid)) {
-				for (j = i+1; j < num_leaf_grids; j ++)
-					if (leaf_grids[j]->is_subset_of_grid(decomp_info_grid))
-						leaf_grids[j] = NULL;
-				decomp_2D_grid = decomp_grids_mgr->search_decomp_grid_info(decomp_id, decomp_info_grid, false)->get_decomp_grid();
-				sub_grids[num_sub_grids++] = decomp_2D_grid;
-			}
-			else {
-				sub_grids[num_sub_grids++] = leaf_grids[i]->duplicate_grid(leaf_grids[i]); 
-				remap_grid_manager->add_temp_grid(sub_grids[num_sub_grids-1]);
-			}
+            if (leaf_grids[i] == NULL)
+                continue;
+            if (leaf_grids[i]->is_subset_of_grid(decomp_info_grid)) {
+                for (j = i+1; j < num_leaf_grids; j ++)
+                    if (leaf_grids[j]->is_subset_of_grid(decomp_info_grid))
+                        leaf_grids[j] = NULL;
+                decomp_2D_grid = decomp_grids_mgr->search_decomp_grid_info(decomp_id, decomp_info_grid, false)->get_decomp_grid();
+                sub_grids[num_sub_grids++] = decomp_2D_grid;
+            }
+            else {
+                sub_grids[num_sub_grids++] = leaf_grids[i]->duplicate_grid(leaf_grids[i]); 
+                remap_grid_manager->add_temp_grid(sub_grids[num_sub_grids-1]);
+            }
         }
-		sprintf(decomp_grid_name, "DECOMP_GRID_%s_%d", original_grid->get_grid_name(), comp_id);
-		EXECUTION_REPORT_LOG(REPORT_LOG, decomp->get_host_comp_id(), true, "Generate decomp grid \"%s\" based on H2D grid \"%s\" %lx", decomp_grid_name, decomp_2D_grid->get_grid_name(), decomp_2D_grid);
+        sprintf(decomp_grid_name, "%s_at_DECOMP_%s", original_grid->get_grid_name(), decomp->get_decomp_name());
+        EXECUTION_REPORT_LOG(REPORT_LOG, decomp->get_host_comp_id(), true, "Generate decomp grid \"%s\" based on H2D grid \"%s\" %lx", decomp_grid_name, decomp_2D_grid->get_grid_name(), decomp_2D_grid);
         this->decomp_grid = new Remap_grid_class(decomp_grid_name, num_sub_grids, sub_grids, 0);
-		this->decomp_grid->set_decomp_name(decomp_name);
-		this->decomp_grid->set_original_grid(original_grid);
-		if (original_grid->has_grid_coord_label(COORD_LABEL_LEV))
-			this->decomp_grid->generate_3D_grid_decomp_sigma_values(original_grid, decomp_2D_grid, decomp->get_local_cell_global_indx(), decomp->get_num_local_cells());
+        this->decomp_grid->set_decomp_name(decomp_name);
+        this->decomp_grid->set_original_grid(original_grid);
+        if (original_grid->has_grid_coord_label(COORD_LABEL_LEV))
+            this->decomp_grid->generate_3D_grid_decomp_sigma_values(original_grid, decomp_2D_grid, decomp->get_local_cell_global_indx(), decomp->get_num_local_cells());
+		if (original_grid->does_use_V3D_level_coord())
+			this->decomp_grid->set_using_V3D_level_coord();
     }
 }
 
 
 Decomp_grid_info::~Decomp_grid_info()
 {
-	if (decomp_grid != NULL && decomp_grid != original_grid) {
-		EXECUTION_REPORT_LOG(REPORT_LOG, -1, true, "remove decomp grid %s\n", decomp_grid->get_grid_name());
-	    delete decomp_grid;
-	}
+    if (decomp_grid != NULL && decomp_grid != original_grid) {
+        EXECUTION_REPORT_LOG(REPORT_LOG, -1, true, "remove decomp grid %s\n", decomp_grid->get_grid_name());
+        delete decomp_grid;
+    }
 }
 
 
@@ -96,17 +98,37 @@ Decomp_grid_info *Decomp_grid_mgt::search_decomp_grid_info(int decomp_id, Remap_
         if (decomp_grids_info[i]->get_decomp_id() == decomp_id && decomp_grids_info[i]->get_original_grid() == original_grid)
             return decomp_grids_info[i];
 
-	if (diag)
-		EXECUTION_REPORT(REPORT_ERROR, -1, true, "C-Coupler error in Decomp_grid_mgt::search_decomp_grid_info");
-		
+    if (diag)
+        EXECUTION_REPORT(REPORT_ERROR, -1, true, "C-Coupler error in Decomp_grid_mgt::search_decomp_grid_info");
+        
     decomp_grids_info.push_back(new Decomp_grid_info(decomp_id, original_grid));
     return decomp_grids_info[decomp_grids_info.size()-1];
 }
 
 
+void Decomp_grid_mgt::set_decomp_grids_using_3D_level_coord(Remap_grid_class *original_V3D_grid)
+{
+	for (int i = 0; i < decomp_grids_info.size(); i ++)
+		if (decomp_grids_info[i]->get_original_grid() == original_V3D_grid)
+			decomp_grids_info[i]->get_decomp_grid()->set_using_V3D_level_coord();
+}
+
+
 Decomp_grid_mgt::~Decomp_grid_mgt()
 {
     for (int i = 0; i < decomp_grids_info.size(); i ++)
         delete decomp_grids_info[i];
 }
 
+
+Remap_grid_class *Decomp_grid_mgt::search_decomp_grid_original_grid(int decomp_id, Remap_grid_class *decomp_grid)
+{
+	for (int i = 0; i < decomp_grids_info.size(); i ++)
+        if (decomp_grids_info[i]->get_decomp_id() == decomp_id && decomp_grids_info[i]->get_decomp_grid() == decomp_grid)
+            return decomp_grids_info[i]->get_original_grid();	
+		
+	EXECUTION_REPORT(REPORT_ERROR, -1, false, "Software error in Decomp_grid_mgt::search_decomp_grid_original_grid");
+	return NULL;
+}
+
+
diff --git a/src/Parallel_MGT/decomp_grid_mgt.h b/src/Parallel_MGT/decomp_grid_mgt.h
old mode 100644
new mode 100755
index cad6b07..3ab337d
--- a/src/Parallel_MGT/decomp_grid_mgt.h
+++ b/src/Parallel_MGT/decomp_grid_mgt.h
@@ -20,18 +20,18 @@
 class Decomp_grid_info
 {
     private:
-        char decomp_name[NAME_STR_SIZE];
-		int decomp_id;
+        char decomp_name[NAME_STR_SIZE*2];
+        int decomp_id;
         Remap_grid_class *decomp_grid;
         Remap_grid_class *original_grid;
 
     public:
-		Decomp_grid_info(int, Remap_grid_class*);
+        Decomp_grid_info(int, Remap_grid_class*);
         ~Decomp_grid_info();
         Remap_grid_class *get_decomp_grid() { return decomp_grid; }
-		Remap_grid_class *get_original_grid() { return original_grid; }
-		const char *get_decomp_name() { return decomp_name; }
-		int get_decomp_id() { return decomp_id; }
+        Remap_grid_class *get_original_grid() { return original_grid; }
+        const char *get_decomp_name() { return decomp_name; }
+        int get_decomp_id() { return decomp_id; }
 };
 
 
@@ -42,8 +42,10 @@ class Decomp_grid_mgt
 
     public:
         Decomp_grid_mgt() {}
-		Decomp_grid_info *search_decomp_grid_info(int, Remap_grid_class*, bool);
+        Decomp_grid_info *search_decomp_grid_info(int, Remap_grid_class*, bool);
         ~Decomp_grid_mgt();
+		void set_decomp_grids_using_3D_level_coord(Remap_grid_class *);
+		Remap_grid_class *search_decomp_grid_original_grid(int, Remap_grid_class*);
 };
 
 #endif
diff --git a/src/Parallel_MGT/decomp_info_mgt.cxx b/src/Parallel_MGT/decomp_info_mgt.cxx
old mode 100644
new mode 100755
index 8d25efd..d052858
--- a/src/Parallel_MGT/decomp_info_mgt.cxx
+++ b/src/Parallel_MGT/decomp_info_mgt.cxx
@@ -18,47 +18,47 @@
 
 Decomp_info::Decomp_info(const char *decomp_name, int decomp_id, int host_comp_id, int grid_id, int num_local_cells, const int *cell_indexes_in_decomp, const char *annotation, bool registered)
 {
-	Remap_grid_class *CoR_grid;
-	int i;
-	
-
-	EXECUTION_REPORT(REPORT_ERROR, -1, original_grid_mgr->is_grid_id_legal(grid_id), "Software error in Decomp_info::Decomp_info: wrong grid_id");
-	
-	this->decomp_id = decomp_id;
-	this->grid_id = grid_id;
-	this->comp_id = original_grid_mgr->get_comp_id_of_grid(grid_id);
-	if (host_comp_id == -1)
-		host_comp_id = this->comp_id;
-	this->host_comp_id = host_comp_id;
+    Remap_grid_class *CoR_grid;
+    int i;
+    
+
+    EXECUTION_REPORT(REPORT_ERROR, -1, original_grid_mgr->is_grid_id_legal(grid_id), "Software error in Decomp_info::Decomp_info: wrong grid_id");
+    
+    this->decomp_id = decomp_id;
+    this->grid_id = grid_id;
+    this->comp_id = original_grid_mgr->get_comp_id_of_grid(grid_id);
+    if (host_comp_id == -1)
+        host_comp_id = this->comp_id;
+    this->host_comp_id = host_comp_id;
     this->num_global_cells = original_grid_mgr->get_original_CoR_grid(grid_id)->get_grid_size();
-	this->num_local_cells = num_local_cells;
-	this->local_cell_global_indx = NULL;
-	strcpy(this->decomp_name, decomp_name);
-	strcpy(this->grid_name, original_grid_mgr->search_grid_info(grid_id)->get_grid_name());
-	annotation_mgr->add_annotation(decomp_id, "register decomposition", annotation);
-	is_registered = registered;
-	synchronize_comp_processes_for_API(host_comp_id, API_ID_DECOMP_MGT_REG_DECOMP, comp_comm_group_mgt_mgr->get_comm_group_of_local_comp(host_comp_id,"C-Coupler code in Decomp_info::Decomp_info for getting comm group"), "for register a parallel decomposition of a grid", annotation);
-	check_API_parameter_string(host_comp_id, API_ID_DECOMP_MGT_REG_DECOMP, comp_comm_group_mgt_mgr->get_comm_group_of_local_comp(host_comp_id,"C-Coupler code in Decomp_info::Decomp_info for getting comm group"), "for register a parallel decomposition of a grid", decomp_name, "decomp_name", annotation);
-	check_API_parameter_string(host_comp_id, API_ID_DECOMP_MGT_REG_DECOMP, comp_comm_group_mgt_mgr->get_comm_group_of_local_comp(host_comp_id,"C-Coupler code in Decomp_info::Decomp_info for getting comm group"), "for register a parallel decomposition of a grid", original_grid_mgr->get_name_of_grid(grid_id), "grid_id (the corresponding grid name)", annotation);	
-
-	CoR_grid = original_grid_mgr->search_grid_info(grid_id)->get_original_CoR_grid();
-	EXECUTION_REPORT(REPORT_ERROR, -1, CoR_grid->get_is_sphere_grid(), "Software error in Decomp_info::Decomp_info: not on sphere grid");
-	EXECUTION_REPORT(REPORT_ERROR, -1, num_local_cells >= 0, "Software error in Decomp_info::Decomp_info: wrong num_local_cells");
+    this->num_local_cells = num_local_cells;
+    this->local_cell_global_indx = NULL;
+    strcpy(this->decomp_name, decomp_name);
+    strcpy(this->grid_name, original_grid_mgr->search_grid_info(grid_id)->get_grid_name());
+    annotation_mgr->add_annotation(decomp_id, "register decomposition", annotation);
+    is_registered = registered;
+    synchronize_comp_processes_for_API(host_comp_id, API_ID_DECOMP_MGT_REG_DECOMP, comp_comm_group_mgt_mgr->get_comm_group_of_local_comp(host_comp_id,"C-Coupler code in Decomp_info::Decomp_info for getting comm group"), "for register a parallel decomposition of a grid", annotation);
+    check_API_parameter_string(host_comp_id, API_ID_DECOMP_MGT_REG_DECOMP, comp_comm_group_mgt_mgr->get_comm_group_of_local_comp(host_comp_id,"C-Coupler code in Decomp_info::Decomp_info for getting comm group"), "for register a parallel decomposition of a grid", decomp_name, "decomp_name", annotation);
+    check_API_parameter_string(host_comp_id, API_ID_DECOMP_MGT_REG_DECOMP, comp_comm_group_mgt_mgr->get_comm_group_of_local_comp(host_comp_id,"C-Coupler code in Decomp_info::Decomp_info for getting comm group"), "for register a parallel decomposition of a grid", original_grid_mgr->get_name_of_grid(grid_id), "grid_id (the corresponding grid name)", annotation);    
+
+    CoR_grid = original_grid_mgr->search_grid_info(grid_id)->get_original_CoR_grid();
+    EXECUTION_REPORT(REPORT_ERROR, -1, CoR_grid->get_is_sphere_grid(), "Software error in Decomp_info::Decomp_info: not on sphere grid");
+    EXECUTION_REPORT(REPORT_ERROR, -1, num_local_cells >= 0, "Software error in Decomp_info::Decomp_info: wrong num_local_cells");
 
     if (num_local_cells == 0)
         local_cell_global_indx = NULL;
     else {
         EXECUTION_REPORT_LOG(REPORT_LOG, host_comp_id, true, 
-			             "parallel decomposition \"%s\" on the grid \"%s\" has %d local grid cells", 
-			             decomp_name, original_grid_mgr->search_grid_info(grid_id)->get_grid_name(), num_local_cells);
+                         "parallel decomposition \"%s\" on the grid \"%s\" has %d local grid cells", 
+                         decomp_name, original_grid_mgr->search_grid_info(grid_id)->get_grid_name(), num_local_cells);
         local_cell_global_indx = new int [num_local_cells];
         for (i = 0; i < num_local_cells; i ++) {
-			if (cell_indexes_in_decomp[i] == CCPL_NULL_INT)
-				local_cell_global_indx[i] = CCPL_NULL_INT;
-			else {
-	            EXECUTION_REPORT(REPORT_ERROR, -1, cell_indexes_in_decomp[i] > 0 && cell_indexes_in_decomp[i] <= CoR_grid->get_grid_size(), "Software error in Decomp_info::Decomp_info: wrong cell index");
-	            local_cell_global_indx[i] = cell_indexes_in_decomp[i] - 1;  // -1 because fortran array index starts from 1 but c/c++ starts from 0
-			}
+            if (cell_indexes_in_decomp[i] == CCPL_NULL_INT)
+                local_cell_global_indx[i] = CCPL_NULL_INT;
+            else {
+                EXECUTION_REPORT(REPORT_ERROR, -1, cell_indexes_in_decomp[i] > 0 && cell_indexes_in_decomp[i] <= CoR_grid->get_grid_size(), "Software error in Decomp_info::Decomp_info: wrong cell index");
+                local_cell_global_indx[i] = cell_indexes_in_decomp[i] - 1;  // -1 because fortran array index starts from 1 but c/c++ starts from 0
+            }
         }
     }
 }
@@ -74,8 +74,8 @@ Decomp_info::~Decomp_info()
 void Decomp_info::check_local_cell_global_indx()
 {
     for (int i = 0; i < num_local_cells; i ++)
-		if (local_cell_global_indx[i] != CCPL_NULL_INT)
-	        EXECUTION_REPORT(REPORT_ERROR,-1, local_cell_global_indx[i] >= 0 && local_cell_global_indx[i] < num_global_cells, "C-Coupler error in check_local_cell_global_indx\n");
+        if (local_cell_global_indx[i] != CCPL_NULL_INT)
+            EXECUTION_REPORT(REPORT_ERROR,-1, local_cell_global_indx[i] >= 0 && local_cell_global_indx[i] < num_global_cells, "C-Coupler error in check_local_cell_global_indx\n");
 }
 
 
@@ -88,31 +88,31 @@ Decomp_info_mgt::~Decomp_info_mgt()
 
 int Decomp_info_mgt::generate_fully_decomp(int original_decomp_id)
 {
-	char fully_decomp_name[NAME_STR_SIZE];
-	Decomp_info *fully_decomp;
-	int *local_cells_global_indexes, num_global_cells;
-
-
-	if (fully_decomps_map.find(original_decomp_id) != fully_decomps_map.end())
-		return fully_decomps_map[original_decomp_id];
-
-	sprintf(fully_decomp_name, "fully_decomp_for_%s", get_decomp_info(original_decomp_id)->get_decomp_name());
-	fully_decomp = search_decomp_info(fully_decomp_name, get_decomp_info(original_decomp_id)->get_comp_id());
-	if (fully_decomp != NULL)
-		return fully_decomp->get_decomp_id();
-
-	if (comp_comm_group_mgt_mgr->get_current_proc_id_in_comp(get_decomp_info(original_decomp_id)->get_host_comp_id(), "in Decomp_info_mgt::generate_fully_decomp") == 0) {
-		num_global_cells = get_decomp_info(original_decomp_id)->get_num_global_cells();
-		local_cells_global_indexes = new int [num_global_cells];
-		for (int i = 0; i < num_global_cells; i ++)
-			local_cells_global_indexes[i] = i + 1;
-		fully_decomp = new Decomp_info(fully_decomp_name, (TYPE_DECOMP_ID_PREFIX|decomps_info.size()), get_decomp_info(original_decomp_id)->get_host_comp_id(), get_decomp_info(original_decomp_id)->get_grid_id(), num_global_cells, local_cells_global_indexes, "fully decomp", false);
-		delete [] local_cells_global_indexes;	
-	}
-	else fully_decomp = new Decomp_info(fully_decomp_name, (TYPE_DECOMP_ID_PREFIX|decomps_info.size()), get_decomp_info(original_decomp_id)->get_host_comp_id(), get_decomp_info(original_decomp_id)->get_grid_id(), 0, NULL, "fully decomp", false);
+    char fully_decomp_name[NAME_STR_SIZE];
+    Decomp_info *fully_decomp;
+    int *local_cells_global_indexes, num_global_cells;
+
+
+    if (fully_decomps_map.find(original_decomp_id) != fully_decomps_map.end())
+        return fully_decomps_map[original_decomp_id];
+
+    sprintf(fully_decomp_name, "fully_decomp_for_%s", get_decomp_info(original_decomp_id)->get_decomp_name());
+    fully_decomp = search_decomp_info(fully_decomp_name, get_decomp_info(original_decomp_id)->get_comp_id());
+    if (fully_decomp != NULL)
+        return fully_decomp->get_decomp_id();
+
+    if (comp_comm_group_mgt_mgr->get_current_proc_id_in_comp(get_decomp_info(original_decomp_id)->get_host_comp_id(), "in Decomp_info_mgt::generate_fully_decomp") == 0) {
+        num_global_cells = get_decomp_info(original_decomp_id)->get_num_global_cells();
+        local_cells_global_indexes = new int [num_global_cells];
+        for (int i = 0; i < num_global_cells; i ++)
+            local_cells_global_indexes[i] = i + 1;
+        fully_decomp = new Decomp_info(fully_decomp_name, (TYPE_DECOMP_ID_PREFIX|decomps_info.size()), get_decomp_info(original_decomp_id)->get_host_comp_id(), get_decomp_info(original_decomp_id)->get_grid_id(), num_global_cells, local_cells_global_indexes, "fully decomp", false);
+        delete [] local_cells_global_indexes;    
+    }
+    else fully_decomp = new Decomp_info(fully_decomp_name, (TYPE_DECOMP_ID_PREFIX|decomps_info.size()), get_decomp_info(original_decomp_id)->get_host_comp_id(), get_decomp_info(original_decomp_id)->get_grid_id(), 0, NULL, "fully decomp", false);
     decomps_info.push_back(fully_decomp);
 
-	fully_decomps_map[original_decomp_id] = fully_decomp->get_decomp_id();
+    fully_decomps_map[original_decomp_id] = fully_decomp->get_decomp_id();
 
     return fully_decomp->get_decomp_id();
 }
@@ -124,22 +124,21 @@ Decomp_info *Decomp_info_mgt::generate_remap_weights_src_decomp(Decomp_info *dst
     long *decomp_map_src, *decomp_map_dst;
     int *local_cell_global_indexes;
     char decomp_name_remap[NAME_STR_SIZE];
-	int i, j, num_local_cells = 0, src_H2D_original_grid_id;
+    int i, j, num_local_cells = 0, src_H2D_original_grid_id;
 
 
     sprintf(decomp_name_remap, "src_decomp_for_%s_%s_%s", remap_weights->get_object_name(), dst_decomp_info->get_decomp_name(), comp_comm_group_mgt_mgr->get_global_node_of_local_comp(dst_decomp_info->get_comp_id(),true,"in Decomp_info_mgt::generate_remap_weights_src_decomp")->get_comp_full_name());
-	dst_decomp_info->check_local_cell_global_indx();
+    dst_decomp_info->check_local_cell_global_indx();
     decomp_map_src = new long [src_original_grid->get_H2D_sub_CoR_grid()->get_grid_size()];
-	decomp_map_dst = new long [dst_original_grid->get_H2D_sub_CoR_grid()->get_grid_size()];
-	for (i = 0; i < dst_decomp_info->get_num_global_cells(); i ++)
-		decomp_map_dst[i] = 0;
-	for (j = 0; j < dst_decomp_info->get_num_local_cells(); j ++)
-		if (dst_decomp_info->get_local_cell_global_indx()[j] >= 0)
-			if (dst_decomp_info->get_local_cell_global_indx()[j] != CCPL_NULL_INT)
-				decomp_map_dst[dst_decomp_info->get_local_cell_global_indx()[j]] = 1;
-	EXECUTION_REPORT_LOG(REPORT_LOG, dst_decomp_info->get_comp_id(), true, "before calculate_src_decomp for grid %s", src_original_grid->get_H2D_sub_CoR_grid()->get_grid_name());
-	remap_weights->calculate_src_decomp(src_original_grid->get_H2D_sub_CoR_grid(), dst_original_grid->get_H2D_sub_CoR_grid(), decomp_map_src, decomp_map_dst);
-	EXECUTION_REPORT_LOG(REPORT_LOG, dst_decomp_info->get_comp_id(), true, "after calculate_src_decomp for grid %s", src_original_grid->get_H2D_sub_CoR_grid()->get_grid_name());
+    decomp_map_dst = new long [dst_original_grid->get_H2D_sub_CoR_grid()->get_grid_size()];
+    for (i = 0; i < dst_decomp_info->get_num_global_cells(); i ++)
+        decomp_map_dst[i] = 0;
+    for (j = 0; j < dst_decomp_info->get_num_local_cells(); j ++)
+        if (dst_decomp_info->get_local_cell_global_indx()[j] != CCPL_NULL_INT)
+            decomp_map_dst[dst_decomp_info->get_local_cell_global_indx()[j]] = 1;
+    EXECUTION_REPORT_LOG(REPORT_LOG, dst_decomp_info->get_comp_id(), true, "before calculate_src_decomp for grid %s", src_original_grid->get_H2D_sub_CoR_grid()->get_grid_name());
+    remap_weights->calculate_src_decomp(src_original_grid->get_H2D_sub_CoR_grid(), dst_original_grid->get_H2D_sub_CoR_grid(), decomp_map_src, decomp_map_dst);
+    EXECUTION_REPORT_LOG(REPORT_LOG, dst_decomp_info->get_comp_id(), true, "after calculate_src_decomp for grid %s", src_original_grid->get_H2D_sub_CoR_grid()->get_grid_name());
 
     for (long i = 0; i < src_original_grid->get_H2D_sub_CoR_grid()->get_grid_size(); i ++)
         if (decomp_map_src[i] != 0)
@@ -150,15 +149,15 @@ Decomp_info *Decomp_info_mgt::generate_remap_weights_src_decomp(Decomp_info *dst
         if (decomp_map_src[i] != 0)
             local_cell_global_indexes[num_local_cells++] = i+1;
 
-	Original_grid_info *existing_src_H2D_original_grid = original_grid_mgr->search_grid_info(src_original_grid->get_H2D_sub_CoR_grid()->get_grid_name(), src_original_grid->get_comp_id());
-	if (existing_src_H2D_original_grid != NULL)
-		src_H2D_original_grid_id = existing_src_H2D_original_grid->get_grid_id();
-	else src_H2D_original_grid_id = original_grid_mgr->add_original_grid(src_original_grid->get_comp_id(), src_original_grid->get_H2D_sub_CoR_grid()->get_grid_name(), src_original_grid->get_H2D_sub_CoR_grid());
-	decomp_for_remap = search_decomp_info(decomp_name_remap, src_original_grid->get_comp_id());
-	if (decomp_for_remap == NULL) {
-		decomp_for_remap = new Decomp_info(decomp_name_remap, (TYPE_DECOMP_ID_PREFIX|decomps_info.size()), dst_original_grid->get_comp_id(), src_H2D_original_grid_id, num_local_cells, local_cell_global_indexes, "in Decomp_info_mgt::generate_remap_weights_src_decomp", false);
-    	decomps_info.push_back(decomp_for_remap);
-	}
+    Original_grid_info *existing_src_H2D_original_grid = original_grid_mgr->search_grid_info(src_original_grid->get_H2D_sub_CoR_grid()->get_grid_name(), src_original_grid->get_comp_id());
+    if (existing_src_H2D_original_grid != NULL)
+        src_H2D_original_grid_id = existing_src_H2D_original_grid->get_grid_id();
+    else src_H2D_original_grid_id = original_grid_mgr->add_original_grid(src_original_grid->get_comp_id(), src_original_grid->get_H2D_sub_CoR_grid()->get_grid_name(), src_original_grid->get_H2D_sub_CoR_grid());
+    decomp_for_remap = search_decomp_info(decomp_name_remap, src_original_grid->get_comp_id());
+    if (decomp_for_remap == NULL) {
+        decomp_for_remap = new Decomp_info(decomp_name_remap, (TYPE_DECOMP_ID_PREFIX|decomps_info.size()), dst_original_grid->get_comp_id(), src_H2D_original_grid_id, num_local_cells, local_cell_global_indexes, "in Decomp_info_mgt::generate_remap_weights_src_decomp", false);
+        decomps_info.push_back(decomp_for_remap);
+    }
 
     delete [] decomp_map_src;
     delete [] local_cell_global_indexes;
@@ -170,62 +169,62 @@ Decomp_info *Decomp_info_mgt::generate_remap_weights_src_decomp(Decomp_info *dst
 
 Decomp_info *Decomp_info_mgt::search_decomp_info(const char *decomp_name, int comp_id)
 {
-	for (int i = 0; i < decomps_info.size(); i ++)
-		if (words_are_the_same(decomps_info[i]->get_decomp_name(), decomp_name) && decomps_info[i]->get_comp_id() == comp_id) {
-			return decomps_info[i];
-		}
+    for (int i = 0; i < decomps_info.size(); i ++)
+        if (words_are_the_same(decomps_info[i]->get_decomp_name(), decomp_name) && decomps_info[i]->get_comp_id() == comp_id) {
+            return decomps_info[i];
+        }
 
-	return NULL;
+    return NULL;
 }
 
 
 int Decomp_info_mgt::register_H2D_parallel_decomposition(const char *decomp_name, int grid_id, int num_local_cells, const int *cell_indexes_in_decomp, const char *annotation)
 {
-	Decomp_info *new_decomp = new Decomp_info(decomp_name, (TYPE_DECOMP_ID_PREFIX|decomps_info.size()), -1, grid_id, num_local_cells, cell_indexes_in_decomp, annotation, true);
+    Decomp_info *new_decomp = new Decomp_info(decomp_name, (TYPE_DECOMP_ID_PREFIX|decomps_info.size()), -1, grid_id, num_local_cells, cell_indexes_in_decomp, annotation, true);
 
-	if (search_decomp_info(decomp_name, original_grid_mgr->get_comp_id_of_grid(grid_id)) != NULL)
-		EXECUTION_REPORT(REPORT_ERROR, new_decomp->get_comp_id(), false, 
-		                 "Error happens when calling the API \"CCPL_register_normal_parallel_decomp\" to register a parallel decomposition \"%s\" at the model code with the annotation \"%s\": a parallel decomposition with the same name has already been registered before at the model code with the annotations \"%s\". Please verify.",
-					     decomp_name, annotation, annotation_mgr->get_annotation(search_decomp_info(decomp_name, original_grid_mgr->get_comp_id_of_grid(grid_id))->get_decomp_id(), "register decomposition"), annotation);
+    if (search_decomp_info(decomp_name, original_grid_mgr->get_comp_id_of_grid(grid_id)) != NULL)
+        EXECUTION_REPORT(REPORT_ERROR, new_decomp->get_comp_id(), false, 
+                         "Error happens when calling the API \"CCPL_register_normal_parallel_decomp\" to register a parallel decomposition \"%s\" at the model code with the annotation \"%s\": a parallel decomposition with the same name has already been registered before at the model code with the annotations \"%s\". Please verify.",
+                         decomp_name, annotation, annotation_mgr->get_annotation(search_decomp_info(decomp_name, original_grid_mgr->get_comp_id_of_grid(grid_id))->get_decomp_id(), "register decomposition"), annotation);
 
-	decomps_info.push_back(new_decomp);
+    decomps_info.push_back(new_decomp);
 
-	return new_decomp->get_decomp_id();
+    return new_decomp->get_decomp_id();
 } 
-	
-	
+    
+    
 bool Decomp_info_mgt::is_decomp_id_legal(int decomp_id) const
 {
-	int true_decomp_id = decomp_id & TYPE_ID_SUFFIX_MASK;
+    int true_decomp_id = decomp_id & TYPE_ID_SUFFIX_MASK;
 
-	
-	if ((decomp_id & TYPE_ID_PREFIX_MASK) != TYPE_DECOMP_ID_PREFIX)
-		return false;
+    
+    if ((decomp_id & TYPE_ID_PREFIX_MASK) != TYPE_DECOMP_ID_PREFIX)
+        return false;
 
-	if (true_decomp_id < 0 || true_decomp_id >= decomps_info.size())
-		return false;
+    if (true_decomp_id < 0 || true_decomp_id >= decomps_info.size())
+        return false;
 
-	return true;
+    return true;
 }
 
 
 int Decomp_info_mgt::get_comp_id_of_decomp(int decomp_id) const
 {
-	EXECUTION_REPORT(REPORT_ERROR, -1, is_decomp_id_legal(decomp_id), "Software error when calling Decomp_info_mgt::get_comp_id_of_decomp");
-	return decomps_info[decomp_id&TYPE_ID_SUFFIX_MASK]->get_comp_id();
+    EXECUTION_REPORT(REPORT_ERROR, -1, is_decomp_id_legal(decomp_id), "Software error when calling Decomp_info_mgt::get_comp_id_of_decomp");
+    return decomps_info[decomp_id&TYPE_ID_SUFFIX_MASK]->get_comp_id();
 }
 
 
 Remap_grid_class *Decomp_info_mgt::get_CoR_grid_of_decomp(int decomp_id) const
-{	
-	EXECUTION_REPORT(REPORT_ERROR, -1, is_decomp_id_legal(decomp_id), "Software error when calling Decomp_info_mgt::get_comp_id_of_decomp");
-	return original_grid_mgr->get_original_CoR_grid(decomps_info[decomp_id&TYPE_ID_SUFFIX_MASK]->get_grid_id());
+{    
+    EXECUTION_REPORT(REPORT_ERROR, -1, is_decomp_id_legal(decomp_id), "Software error when calling Decomp_info_mgt::get_comp_id_of_decomp");
+    return original_grid_mgr->get_original_CoR_grid(decomps_info[decomp_id&TYPE_ID_SUFFIX_MASK]->get_grid_id());
 }
 
 
 Decomp_info *Decomp_info_mgt::get_decomp_info(int decomp_id)
 {
-	EXECUTION_REPORT(REPORT_ERROR, -1, is_decomp_id_legal(decomp_id), "Software error when calling Decomp_info_mgt::get_decomp_info");
-	return decomps_info[decomp_id&TYPE_ID_SUFFIX_MASK];
+    EXECUTION_REPORT(REPORT_ERROR, -1, is_decomp_id_legal(decomp_id), "Software error when calling Decomp_info_mgt::get_decomp_info");
+    return decomps_info[decomp_id&TYPE_ID_SUFFIX_MASK];
 }
 
diff --git a/src/Parallel_MGT/decomp_info_mgt.h b/src/Parallel_MGT/decomp_info_mgt.h
old mode 100644
new mode 100755
index e678070..2244adc
--- a/src/Parallel_MGT/decomp_info_mgt.h
+++ b/src/Parallel_MGT/decomp_info_mgt.h
@@ -21,32 +21,32 @@
 class Decomp_info
 {
     private:
-		char decomp_name[NAME_STR_SIZE];
+        char decomp_name[NAME_STR_SIZE];
         char grid_name[NAME_STR_SIZE];
         int num_global_cells;
         int num_local_cells;
         int *local_cell_global_indx;
-		bool is_registered;
-		int comp_id;
-		int host_comp_id;
-		int grid_id;
-		int decomp_id;
+        bool is_registered;
+        int comp_id;
+        int host_comp_id;
+        int grid_id;
+        int decomp_id;
 
     public:
-		Decomp_info(const char *, int, int, int, int, const int *, const char *, bool);
+        Decomp_info(const char *, int, int, int, int, const int *, const char *, bool);
         ~Decomp_info();
         int get_num_local_cells() { return num_local_cells; }
         const int *get_local_cell_global_indx() { return local_cell_global_indx; }
         const char *get_grid_name() { return grid_name; }
         const char *get_decomp_name() { return decomp_name; }
-		int get_grid_id() { return grid_id; }
-		int get_comp_id() { return comp_id; }
-		int get_host_comp_id() { return host_comp_id; }
-		int get_decomp_id() { return decomp_id; }
+        int get_grid_id() { return grid_id; }
+        int get_comp_id() { return comp_id; }
+        int get_host_comp_id() { return host_comp_id; }
+        int get_decomp_id() { return decomp_id; }
         int get_num_global_cells() { return num_global_cells; }
         bool get_is_fully_grid_decomp() { return num_local_cells == num_global_cells; }
-		bool is_registered_decomp() { return is_registered; }
-		void check_local_cell_global_indx();
+        bool is_registered_decomp() { return is_registered; }
+        void check_local_cell_global_indx();
 };
 
 
@@ -54,19 +54,19 @@ class Decomp_info_mgt
 {
     private:
         std::vector<Decomp_info *> decomps_info;
-		std::map<int, int> fully_decomps_map;
+        std::map<int, int> fully_decomps_map;
         
     public:
         Decomp_info_mgt() {}
         ~Decomp_info_mgt();
         int generate_fully_decomp(int);
-		Decomp_info *generate_remap_weights_src_decomp(Decomp_info*, Original_grid_info*, Original_grid_info*, Remap_weight_of_strategy_class*);
-		Decomp_info *search_decomp_info(const char*, int);
-		int register_H2D_parallel_decomposition(const char *, int, int, const int *, const char *);
-		bool is_decomp_id_legal(int) const;
-		int get_comp_id_of_decomp(int) const;
-		Remap_grid_class *get_CoR_grid_of_decomp(int) const;
-		Decomp_info *get_decomp_info(int);
+        Decomp_info *generate_remap_weights_src_decomp(Decomp_info*, Original_grid_info*, Original_grid_info*, Remap_weight_of_strategy_class*);
+        Decomp_info *search_decomp_info(const char*, int);
+        int register_H2D_parallel_decomposition(const char *, int, int, const int *, const char *);
+        bool is_decomp_id_legal(int) const;
+        int get_comp_id_of_decomp(int) const;
+        Remap_grid_class *get_CoR_grid_of_decomp(int) const;
+        Decomp_info *get_decomp_info(int);
 };
 
 
diff --git a/src/Parallel_MGT/fields_gather_scatter_mgt.cxx b/src/Parallel_MGT/fields_gather_scatter_mgt.cxx
old mode 100644
new mode 100755
index 870d09f..269a924
--- a/src/Parallel_MGT/fields_gather_scatter_mgt.cxx
+++ b/src/Parallel_MGT/fields_gather_scatter_mgt.cxx
@@ -21,18 +21,18 @@ template <class T> void Gather_scatter_rearrange_info::rearrange_gather_data(T *
 
 
     for (m = 0; m < num_local_procs; m ++) {
-		num_data_in_each_level = counts[m] / num_levels;
-		num_local_cells = num_data_in_each_level / num_points_in_each_cell;
-		rearrange_indexes_start = displs[m] / num_levels / num_points_in_each_cell;
-		for (k = 0; k < num_levels; k ++) 
-			for (i = 0; i < num_local_cells; i ++) {
-				if (rearrange_indexes[rearrange_indexes_start+i] == CCPL_NULL_INT)
-					continue;
-				tmp_buf_src = buf_src + displs[m] + k*num_data_in_each_level + i*num_points_in_each_cell;
-				tmp_buf_dst = buf_dst + rearrange_indexes[rearrange_indexes_start+i]*num_points_in_each_cell + k*num_cells_in_fully_decomp*num_points_in_each_cell;
-				for (j = 0; j < num_points_in_each_cell; j ++)
-					tmp_buf_dst[j] = tmp_buf_src[j];
-			}
+        num_data_in_each_level = counts[m] / num_levels;
+        num_local_cells = num_data_in_each_level / num_points_in_each_cell;
+        rearrange_indexes_start = displs[m] / num_levels / num_points_in_each_cell;
+        for (k = 0; k < num_levels; k ++) 
+            for (i = 0; i < num_local_cells; i ++) {
+                if (rearrange_indexes[rearrange_indexes_start+i] == CCPL_NULL_INT)
+                    continue;
+                tmp_buf_src = buf_src + displs[m] + k*num_data_in_each_level + i*num_points_in_each_cell;
+                tmp_buf_dst = buf_dst + rearrange_indexes[rearrange_indexes_start+i]*num_points_in_each_cell + k*num_cells_in_fully_decomp*num_points_in_each_cell;
+                for (j = 0; j < num_points_in_each_cell; j ++)
+                    tmp_buf_dst[j] = tmp_buf_src[j];
+            }
     }
 }
 
@@ -44,18 +44,18 @@ template <class T> void Gather_scatter_rearrange_info::rearrange_scatter_data(T
 
 
     for (m = 0; m < num_local_procs; m ++) {
-		num_data_in_each_level = counts[m] / num_levels;
-		num_local_cells = num_data_in_each_level / num_points_in_each_cell;
-		rearrange_indexes_start = displs[m] / num_levels / num_points_in_each_cell;
-		for (k = 0; k < num_levels; k ++)
-			for (i = 0; i < num_local_cells; i ++) {
-				if (rearrange_indexes[rearrange_indexes_start+i] == CCPL_NULL_INT)
-					continue;
-				tmp_buf_src = buf_src + rearrange_indexes[rearrange_indexes_start+i]*num_points_in_each_cell + k*num_cells_in_fully_decomp*num_points_in_each_cell; 
+        num_data_in_each_level = counts[m] / num_levels;
+        num_local_cells = num_data_in_each_level / num_points_in_each_cell;
+        rearrange_indexes_start = displs[m] / num_levels / num_points_in_each_cell;
+        for (k = 0; k < num_levels; k ++)
+            for (i = 0; i < num_local_cells; i ++) {
+                if (rearrange_indexes[rearrange_indexes_start+i] == CCPL_NULL_INT)
+                    continue;
+                tmp_buf_src = buf_src + rearrange_indexes[rearrange_indexes_start+i]*num_points_in_each_cell + k*num_cells_in_fully_decomp*num_points_in_each_cell; 
                 tmp_buf_dst = buf_dst + displs[m] + k*num_data_in_each_level + i*num_points_in_each_cell;
-				for (j = 0; j < num_points_in_each_cell; j ++)
-					tmp_buf_dst[j] = tmp_buf_src[j];
-			}
+                for (j = 0; j < num_points_in_each_cell; j ++)
+                    tmp_buf_dst[j] = tmp_buf_src[j];
+            }
     }  
 }
 
@@ -63,7 +63,7 @@ template <class T> void Gather_scatter_rearrange_info::rearrange_scatter_data(T
 Gather_scatter_rearrange_info::Gather_scatter_rearrange_info(Field_mem_info *local_field)
 {
     int num_local_cells, i;
-	int *local_cell_global_indx;
+    int *local_cell_global_indx;
 
 
     counts = NULL;
@@ -71,56 +71,56 @@ Gather_scatter_rearrange_info::Gather_scatter_rearrange_info(Field_mem_info *loc
     mpibuf = NULL;
     rearrange_indexes = NULL;
     global_field_mem = NULL;
-	host_comp_id = local_field->get_host_comp_id();
-	original_decomp_id = local_field->get_decomp_id();
-	grid_id = local_field->get_grid_id();
+    host_comp_id = local_field->get_host_comp_id();
+    original_decomp_id = local_field->get_decomp_id();
+    grid_id = local_field->get_grid_id();
     sprintf(data_type, local_field->get_field_data()->get_grid_data_field()->data_type_in_application);
     num_local_procs = comp_comm_group_mgt_mgr->get_num_proc_in_comp(host_comp_id, "in Gather_scatter_rearrange_info");
-	current_proc_local_id = comp_comm_group_mgt_mgr->get_current_proc_id_in_comp(host_comp_id, "in Gather_scatter_rearrange_info");
-	local_comm = comp_comm_group_mgt_mgr->get_comm_group_of_local_comp(host_comp_id, "in Gather_scatter_rearrange_info");
+    current_proc_local_id = comp_comm_group_mgt_mgr->get_current_proc_id_in_comp(host_comp_id, "in Gather_scatter_rearrange_info");
+    local_comm = comp_comm_group_mgt_mgr->get_comm_group_of_local_comp(host_comp_id, "in Gather_scatter_rearrange_info");
 
     if (original_decomp_id == -1) {
         has_global_field = false;
         return;
     }
 
-	new_decomp_id = decomps_info_mgr->generate_fully_decomp(original_decomp_id);
+    new_decomp_id = decomps_info_mgr->generate_fully_decomp(original_decomp_id);
 
     has_global_field = true;
     num_local_cells = decomps_info_mgr->get_decomp_info(original_decomp_id)->get_num_local_cells();
-	if (num_local_cells > 0) {
-		num_levels = local_field->get_field_data()->get_coord_value_grid()->get_grid_size() / num_local_cells;
-	    num_points_in_each_cell = local_field->get_field_data()->get_grid_data_field()->required_data_size / num_local_cells / num_levels;
-	    EXECUTION_REPORT(REPORT_ERROR,-1, num_points_in_each_cell > 0, "C-Coupler software error in Gather_scatter_rearrange_info\n");
-		EXECUTION_REPORT(REPORT_ERROR,-1, local_field->get_field_data()->get_coord_value_grid()->get_grid_size()%num_local_cells == 0, "c_coupler error in Gather_scatter_rearrange_info::Gather_scatter_rearrange_info\n");		
-	}
-	else {
-		num_levels = -1;
-		num_points_in_each_cell = -1;
-	}
+    if (num_local_cells > 0) {
+        num_levels = local_field->get_field_data()->get_coord_value_grid()->get_grid_size() / num_local_cells;
+        num_points_in_each_cell = local_field->get_field_data()->get_grid_data_field()->required_data_size / num_local_cells / num_levels;
+        EXECUTION_REPORT(REPORT_ERROR,-1, num_points_in_each_cell > 0, "C-Coupler software error in Gather_scatter_rearrange_info\n");
+        EXECUTION_REPORT(REPORT_ERROR,-1, local_field->get_field_data()->get_coord_value_grid()->get_grid_size()%num_local_cells == 0, "c_coupler error in Gather_scatter_rearrange_info::Gather_scatter_rearrange_info\n");        
+    }
+    else {
+        num_levels = -1;
+        num_points_in_each_cell = -1;
+    }
 
     if (current_proc_local_id == 0) {
         counts = new int [num_local_procs];
         displs = new int [num_local_procs];
     }
 
-	MPI_Gather(&num_levels, 1, MPI_INT, counts, 1, MPI_INT, 0, local_comm);
-	MPI_Gather(&num_points_in_each_cell, 1, MPI_INT, displs, 1, MPI_INT, 0, local_comm);
+    MPI_Gather(&num_levels, 1, MPI_INT, counts, 1, MPI_INT, 0, local_comm);
+    MPI_Gather(&num_points_in_each_cell, 1, MPI_INT, displs, 1, MPI_INT, 0, local_comm);
 
     if (current_proc_local_id == 0) {
-		for (i = 0; i < num_local_procs; i ++) {
-			if (counts[i] != -1)
-				num_levels = counts[i];
-			if (displs[i] != -1)
-				num_points_in_each_cell = displs[i];
-		}
-		EXECUTION_REPORT(REPORT_ERROR, -1, num_levels != -1 && num_points_in_each_cell != -1, "C-Coupler software error2 in Gather_scatter_rearrange_info: empty parallel decomposition");
-		for (i = 0; i < num_local_procs; i ++)
-			EXECUTION_REPORT(REPORT_ERROR,-1, (counts[i] == -1 || num_levels == counts[i]) && (displs[i] == -1 || num_points_in_each_cell == displs[i]), "C-Coupler software error2 in Gather_scatter_rearrange_info\n");
+        for (i = 0; i < num_local_procs; i ++) {
+            if (counts[i] != -1)
+                num_levels = counts[i];
+            if (displs[i] != -1)
+                num_points_in_each_cell = displs[i];
+        }
+        EXECUTION_REPORT(REPORT_ERROR, -1, num_levels != -1 && num_points_in_each_cell != -1, "C-Coupler software error2 in Gather_scatter_rearrange_info: empty parallel decomposition");
+        for (i = 0; i < num_local_procs; i ++)
+            EXECUTION_REPORT(REPORT_ERROR,-1, (counts[i] == -1 || num_levels == counts[i]) && (displs[i] == -1 || num_points_in_each_cell == displs[i]), "C-Coupler software error2 in Gather_scatter_rearrange_info\n");
     }
-	MPI_Bcast(&num_levels, 1, MPI_INT, 0, local_comm);	
-	MPI_Bcast(&num_points_in_each_cell, 1, MPI_INT, 0, local_comm);
-	
+    MPI_Bcast(&num_levels, 1, MPI_INT, 0, local_comm);    
+    MPI_Bcast(&num_points_in_each_cell, 1, MPI_INT, 0, local_comm);
+    
     MPI_Gather(&num_local_cells, 1, MPI_INT, counts, 1, MPI_INT, 0, local_comm);
     if (current_proc_local_id == 0) {
         for (i = 0, num_total_cells = 0; i < num_local_procs; i ++) {
@@ -137,8 +137,8 @@ Gather_scatter_rearrange_info::Gather_scatter_rearrange_info(Field_mem_info *loc
             counts[i] *= num_points_in_each_cell*num_levels;
         }
         mpibuf = new char [num_total_cells*num_points_in_each_cell*num_levels*get_data_type_size(data_type)];
-		EXECUTION_REPORT_LOG(REPORT_LOG,-1, true, "allocate global field for gather/scatter");
-		global_field_mem = memory_manager->alloc_mem("IO_gather_field", new_decomp_id, grid_id, BUF_MARK_GATHER, data_type, "no unit", "allocate gather field", false);
+        EXECUTION_REPORT_LOG(REPORT_LOG,-1, true, "allocate global field for gather/scatter");
+        global_field_mem = memory_manager->alloc_mem("IO_gather_field", new_decomp_id, grid_id, BUF_MARK_GATHER, data_type, "no unit", "allocate gather field", false);
     }
 }
 
@@ -218,14 +218,14 @@ Field_mem_info *Gather_scatter_rearrange_info::get_global_field(Field_mem_info *
 
 void Gather_scatter_rearrange_info::scatter_field(Field_mem_info *local_field_mem, bool &has_field_in_file)
 {
-	int has_field_in_file_int = has_field_in_file? 1 : 0;
+    int has_field_in_file_int = has_field_in_file? 1 : 0;
 
 
-	MPI_Bcast(&has_field_in_file_int, 1, MPI_INT, 0, local_comm);
-	has_field_in_file = (has_field_in_file_int == 1);
-	if (!has_field_in_file)
-		return;
-	
+    MPI_Bcast(&has_field_in_file_int, 1, MPI_INT, 0, local_comm);
+    has_field_in_file = (has_field_in_file_int == 1);
+    if (!has_field_in_file)
+        return;
+    
     if (!has_global_field) {
         MPI_Bcast(local_field_mem->get_data_buf(), local_field_mem->get_field_data()->get_grid_data_field()->required_data_size*get_data_type_size(data_type),
                   MPI_CHAR, 0, local_comm);
@@ -311,19 +311,19 @@ void Fields_gather_scatter_mgt::gather_write_field(IO_netcdf *nc_file, Field_mem
 
 bool Fields_gather_scatter_mgt::read_scatter_field(IO_netcdf *nc_file, Field_mem_info *local_field, const char *field_IO_name, int time_pos, bool check_existence)
 {
-	bool has_data_in_file;
-	
+    bool has_data_in_file;
+    
 
     Gather_scatter_rearrange_info *rearrage_info = apply_gather_scatter_rearrange_info(local_field);
     if (comp_comm_group_mgt_mgr->get_current_proc_id_in_comp(local_field->get_host_comp_id(), "in read_scatter_field") == 0) {
-		if (field_IO_name != NULL)
-			strcpy(rearrage_info->get_global_field(local_field)->get_field_data()->get_grid_data_field()->field_name_in_IO_file, field_IO_name);
-		has_data_in_file = nc_file->read_data(rearrage_info->get_global_field(local_field)->get_field_data()->get_grid_data_field(), time_pos, check_existence);
-		if (field_IO_name != NULL)
-			strcpy(rearrage_info->get_global_field(local_field)->get_field_data()->get_grid_data_field()->field_name_in_IO_file, local_field->get_field_name());		
+        if (field_IO_name != NULL)
+            strcpy(rearrage_info->get_global_field(local_field)->get_field_data()->get_grid_data_field()->field_name_in_IO_file, field_IO_name);
+        has_data_in_file = nc_file->read_data(rearrage_info->get_global_field(local_field)->get_field_data()->get_grid_data_field(), time_pos, check_existence);
+        if (field_IO_name != NULL)
+            strcpy(rearrage_info->get_global_field(local_field)->get_field_data()->get_grid_data_field()->field_name_in_IO_file, local_field->get_field_name());        
     }
     rearrage_info->scatter_field(local_field, has_data_in_file);
-	return has_data_in_file;
+    return has_data_in_file;
 }
 
 
diff --git a/src/Parallel_MGT/fields_gather_scatter_mgt.h b/src/Parallel_MGT/fields_gather_scatter_mgt.h
old mode 100644
new mode 100755
index ae7676f..200e066
--- a/src/Parallel_MGT/fields_gather_scatter_mgt.h
+++ b/src/Parallel_MGT/fields_gather_scatter_mgt.h
@@ -24,7 +24,7 @@ class Gather_scatter_rearrange_info
         char data_type[NAME_STR_SIZE];
         bool has_global_field;
         int num_local_procs;
-		int num_levels;
+        int num_levels;
         int num_points_in_each_cell;
         int num_total_cells;
         int *counts;
@@ -32,13 +32,13 @@ class Gather_scatter_rearrange_info
         void *mpibuf;
         int *rearrange_indexes;
 
-		int host_comp_id;
-		int original_decomp_id;
-		int new_decomp_id;
-		int grid_id;
+        int host_comp_id;
+        int original_decomp_id;
+        int new_decomp_id;
+        int grid_id;
         Field_mem_info *global_field_mem;
-		int current_proc_local_id;
-		MPI_Comm local_comm;
+        int current_proc_local_id;
+        MPI_Comm local_comm;
 
     public:
         Gather_scatter_rearrange_info(Field_mem_info*);
@@ -49,7 +49,7 @@ class Gather_scatter_rearrange_info
         void scatter_field(Field_mem_info*, bool &);
         Field_mem_info *get_global_field(Field_mem_info*);
         template <class T> void rearrange_gather_data(T*, T*, int);
-		template <class T> void rearrange_scatter_data(T*, T*, int);
+        template <class T> void rearrange_scatter_data(T*, T*, int);
 };
 
 
@@ -61,7 +61,7 @@ class Fields_gather_scatter_mgt
 
     public:
         Field_mem_info *gather_field(Field_mem_info*);
-		Fields_gather_scatter_mgt() {}
+        Fields_gather_scatter_mgt() {}
         ~Fields_gather_scatter_mgt();
         void gather_write_field(IO_netcdf*, Field_mem_info*, bool, int, int, bool);
         bool read_scatter_field(IO_netcdf*, Field_mem_info*, const char *, int, bool);
diff --git a/src/Parallel_MGT/performance_timing_mgt.cxx b/src/Parallel_MGT/performance_timing_mgt.cxx
old mode 100644
new mode 100755
index 9a494fa..14a6a7f
--- a/src/Parallel_MGT/performance_timing_mgt.cxx
+++ b/src/Parallel_MGT/performance_timing_mgt.cxx
@@ -15,150 +15,150 @@
 
 Performance_timing_unit::Performance_timing_unit(int comp_id, int unit_type, int unit_behavior, int unit_int_keyword, const char *unit_char_keyword)
 {
-	check_timing_unit(unit_type, unit_behavior, unit_int_keyword, unit_char_keyword);
-	this->previous_time = -1.0;
-	this->total_time = 0.0;
-	this->unit_type = unit_type;
-	this->unit_behavior = unit_behavior;
-	this->unit_int_keyword = unit_int_keyword;
-	this->comp_id = comp_id;
-	EXECUTION_REPORT(REPORT_ERROR, -1, unit_char_keyword != NULL, "the keyword (last paremeter of the interface) of a performance timing unit for computation task can not be NULL");
-	if (unit_type == TIMING_TYPE_COMPUTATION || unit_type == TIMING_TYPE_COMMUNICATION)
-		strcpy(this->unit_char_keyword, unit_char_keyword);
-	else this->unit_char_keyword[0] = '\0';
+    check_timing_unit(unit_type, unit_behavior, unit_int_keyword, unit_char_keyword);
+    this->previous_time = -1.0;
+    this->total_time = 0.0;
+    this->unit_type = unit_type;
+    this->unit_behavior = unit_behavior;
+    this->unit_int_keyword = unit_int_keyword;
+    this->comp_id = comp_id;
+    EXECUTION_REPORT(REPORT_ERROR, -1, unit_char_keyword != NULL, "the keyword (last paremeter of the interface) of a performance timing unit for computation task can not be NULL");
+    if (unit_type == TIMING_TYPE_COMPUTATION || unit_type == TIMING_TYPE_COMMUNICATION)
+        strcpy(this->unit_char_keyword, unit_char_keyword);
+    else this->unit_char_keyword[0] = '\0';
 }
 
 
 void Performance_timing_unit::check_timing_unit(int unit_type, int unit_behavior, int unit_int_keyword, const char *unit_char_keyword)
 {
-	EXECUTION_REPORT(REPORT_ERROR, -1, unit_type == TIMING_TYPE_COMMUNICATION || unit_type == TIMING_TYPE_IO || unit_type == TIMING_TYPE_COMPUTATION,
-		             "C-Coupler error in checking unit_type in match_timing_unit");
-	if (unit_type == TIMING_TYPE_COMMUNICATION)
-		EXECUTION_REPORT(REPORT_ERROR, -1, unit_behavior == TIMING_COMMUNICATION_RECV_WAIT || unit_behavior == TIMING_COMMUNICATION_SEND_WAIT || unit_behavior == TIMING_COMMUNICATION_SENDRECV ||
-						 unit_behavior == TIMING_COMMUNICATION_RECV_QUERRY || unit_behavior == TIMING_COMMUNICATION_SEND_QUERRY || unit_behavior == TIMING_COMMUNICATION_SEND || unit_behavior == TIMING_COMMUNICATION_RECV,
-		                 "C-Coupler error in checking unit_behavior in match_timing_unit");
-	if (unit_type == TIMING_TYPE_IO)
-		EXECUTION_REPORT(REPORT_ERROR, -1, unit_behavior == TIMING_IO_INPUT || unit_behavior == TIMING_IO_OUTPUT || unit_behavior == TIMING_IO_RESTART,
-		                 "C-Coupler error in checking unit_behavior in match_timing_unit");
+    EXECUTION_REPORT(REPORT_ERROR, -1, unit_type == TIMING_TYPE_COMMUNICATION || unit_type == TIMING_TYPE_IO || unit_type == TIMING_TYPE_COMPUTATION,
+                     "C-Coupler error in checking unit_type in match_timing_unit");
+    if (unit_type == TIMING_TYPE_COMMUNICATION)
+        EXECUTION_REPORT(REPORT_ERROR, -1, unit_behavior == TIMING_COMMUNICATION_RECV_WAIT || unit_behavior == TIMING_COMMUNICATION_SEND_WAIT || unit_behavior == TIMING_COMMUNICATION_SENDRECV ||
+                         unit_behavior == TIMING_COMMUNICATION_RECV_QUERRY || unit_behavior == TIMING_COMMUNICATION_SEND_QUERRY || unit_behavior == TIMING_COMMUNICATION_SEND || unit_behavior == TIMING_COMMUNICATION_RECV,
+                         "C-Coupler error in checking unit_behavior in match_timing_unit");
+    if (unit_type == TIMING_TYPE_IO)
+        EXECUTION_REPORT(REPORT_ERROR, -1, unit_behavior == TIMING_IO_INPUT || unit_behavior == TIMING_IO_OUTPUT || unit_behavior == TIMING_IO_RESTART,
+                         "C-Coupler error in checking unit_behavior in match_timing_unit");
 }
 
 
 bool Performance_timing_unit::match_timing_unit(int unit_type, int unit_behavior, int unit_int_keyword, const char *unit_char_keyword)
 {
-	check_timing_unit(unit_type, unit_behavior, unit_int_keyword, unit_char_keyword);
-
-	if (unit_type == TIMING_TYPE_COMMUNICATION)
-		return unit_type == this->unit_type && unit_behavior == this->unit_behavior && words_are_the_same(unit_char_keyword,this->unit_char_keyword);
-	if (unit_type == TIMING_TYPE_IO)
-		return unit_type == this->unit_type && unit_behavior == this->unit_behavior;
-	if (unit_type == TIMING_TYPE_COMPUTATION) {
-		EXECUTION_REPORT(REPORT_ERROR, -1, unit_char_keyword != NULL, "C-Coupler software error in match_timing_unit of Performance_timing_unit: unit_char_keyword is NULL");
-		return unit_type == this->unit_type && words_are_the_same(unit_char_keyword,this->unit_char_keyword);
-	}
-
-	return false;
+    check_timing_unit(unit_type, unit_behavior, unit_int_keyword, unit_char_keyword);
+
+    if (unit_type == TIMING_TYPE_COMMUNICATION)
+        return unit_type == this->unit_type && unit_behavior == this->unit_behavior && words_are_the_same(unit_char_keyword,this->unit_char_keyword);
+    if (unit_type == TIMING_TYPE_IO)
+        return unit_type == this->unit_type && unit_behavior == this->unit_behavior;
+    if (unit_type == TIMING_TYPE_COMPUTATION) {
+        EXECUTION_REPORT(REPORT_ERROR, -1, unit_char_keyword != NULL, "C-Coupler software error in match_timing_unit of Performance_timing_unit: unit_char_keyword is NULL");
+        return unit_type == this->unit_type && words_are_the_same(unit_char_keyword,this->unit_char_keyword);
+    }
+
+    return false;
 }
 
 
 void Performance_timing_unit::timing_start()
 {
-	EXECUTION_REPORT(REPORT_ERROR, -1, previous_time == -1.0, "C-Coupler or model error in starting performance timing: timing unit has not been stoped");
-	wtime(&previous_time);
+    EXECUTION_REPORT(REPORT_ERROR, -1, previous_time == -1.0, "C-Coupler or model error in starting performance timing: timing unit has not been stoped");
+    wtime(&previous_time);
 }
 
 
 void Performance_timing_unit::timing_stop()
 {
-	double current_time;
+    double current_time;
 
 
-	EXECUTION_REPORT(REPORT_ERROR, -1, previous_time != -1.0, "C-Coupler or model error in stopping performance timing: timing unit has not been started");
-	wtime(&current_time);
-	if (current_time >= previous_time)
-		total_time += current_time - previous_time;
-	previous_time = -1.0;
+    EXECUTION_REPORT(REPORT_ERROR, -1, previous_time != -1.0, "C-Coupler or model error in stopping performance timing: timing unit has not been started");
+    wtime(&current_time);
+    if (current_time >= previous_time)
+        total_time += current_time - previous_time;
+    previous_time = -1.0;
 }
 
 
 void Performance_timing_unit::timing_output()
 {
-	if (unit_type == TIMING_TYPE_IO) {
-		if (unit_behavior == TIMING_IO_INPUT) 
-			EXECUTION_REPORT(REPORT_CONSTANTLY, comp_id, true, "TIMING RESULT: the component model \"%s\" spends %lf seconds for reading input data file at the current process\n", comp_comm_group_mgt_mgr->get_global_node_of_local_comp(comp_id,false,"")->get_full_name(), total_time);
-		else if (unit_behavior == TIMING_IO_OUTPUT) 
-			EXECUTION_REPORT(REPORT_CONSTANTLY, comp_id, true, "TIMING RESULT: the component model \"%s\" spends %lf seconds for writing output data file at the current process\n", comp_comm_group_mgt_mgr->get_global_node_of_local_comp(comp_id,false,"")->get_full_name(), total_time);
-		else if (unit_behavior == TIMING_IO_RESTART)
-			EXECUTION_REPORT(REPORT_CONSTANTLY, comp_id, true, "TIMING RESULT: the component model \"%s\" spends %lf seconds for writing restart file at the current process\n", comp_comm_group_mgt_mgr->get_global_node_of_local_comp(comp_id,false,"")->get_full_name(), total_time);
-	}
-	else if (unit_type == TIMING_TYPE_COMMUNICATION) {
-		if (unit_behavior == TIMING_COMMUNICATION_RECV_WAIT)
-			EXECUTION_REPORT(REPORT_CONSTANTLY, comp_id, true, "TIMING RESULT: the component model \"%s\" spends %lf seconds for waiting for receiving data from the component model \"%s\" at the current process\n", comp_comm_group_mgt_mgr->get_global_node_of_local_comp(comp_id,false,"")->get_full_name(), total_time, unit_char_keyword);
-		else if (unit_behavior == TIMING_COMMUNICATION_RECV)
-			EXECUTION_REPORT(REPORT_CONSTANTLY, comp_id, true, "TIMING RESULT: the component model \"%s\" spends %lf seconds for receiving data (without the time of querrying buffer status) from the component model \"%s\" at the current process", comp_comm_group_mgt_mgr->get_global_node_of_local_comp(comp_id,false,"")->get_full_name(), total_time, unit_char_keyword);
-		else if (unit_behavior == TIMING_COMMUNICATION_SEND_WAIT)
-			EXECUTION_REPORT(REPORT_CONSTANTLY, comp_id, true, "TIMING RESULT: the component model \"%s\" spends %lf seconds for waiting for sending data at the export interface \"%s\" at the current process\n", comp_comm_group_mgt_mgr->get_global_node_of_local_comp(comp_id,false,"")->get_full_name(), total_time, unit_char_keyword);
-		else if (unit_behavior == TIMING_COMMUNICATION_SEND)
-			EXECUTION_REPORT(REPORT_CONSTANTLY, comp_id, true, "TIMING RESULT: the component model \"%s\" spends %lf seconds for sending data to the component model \"%s\" (without the time of querrying buffer status) at the current process", comp_comm_group_mgt_mgr->get_global_node_of_local_comp(comp_id,false,"")->get_full_name(), total_time, unit_char_keyword);
-		else if (unit_behavior == TIMING_COMMUNICATION_SEND_QUERRY)
-			EXECUTION_REPORT(REPORT_CONSTANTLY, comp_id, true, "TIMING RESULT: the component model \"%s\" spends %lf seconds for querrying the status of the remote data buffer of the component model \"%s\" for data send at the current process", comp_comm_group_mgt_mgr->get_global_node_of_local_comp(comp_id,false,"")->get_full_name(), total_time, unit_char_keyword);
-		else if (unit_behavior == TIMING_COMMUNICATION_RECV_QUERRY)
-			EXECUTION_REPORT(REPORT_CONSTANTLY, comp_id, true, "TIMING RESULT: the component model \"%s\" spends %lf seconds for querrying the status of the local data buffer for data receive from the component model \"%s\" at the current process", comp_comm_group_mgt_mgr->get_global_node_of_local_comp(comp_id,false,"")->get_full_name(), total_time, unit_char_keyword);
-//		if (unit_behavior == TIMING_COMMUNICATION_SENDRECV)
-//			printf("%s spends %lf seconds for data communication for data remapping in each process on average\n", compset_communicators_info_mgr->get_current_comp_name(), all_process_sum_time/num_procs);
-	}
-	else if (unit_type == TIMING_TYPE_COMPUTATION)
-		EXECUTION_REPORT(REPORT_CONSTANTLY, comp_id, true, "the component model \"%s\" spends %lf seconds for numerical algorithm %s at the current process\n", comp_comm_group_mgt_mgr->get_global_node_of_local_comp(comp_id,false,"")->get_full_name(), total_time, unit_char_keyword);
+    if (unit_type == TIMING_TYPE_IO) {
+        if (unit_behavior == TIMING_IO_INPUT) 
+            EXECUTION_REPORT(REPORT_CONSTANTLY, comp_id, true, "TIMING RESULT: the component model \"%s\" spends %lf seconds for reading input data file at the current process\n", comp_comm_group_mgt_mgr->get_global_node_of_local_comp(comp_id,false,"")->get_full_name(), total_time);
+        else if (unit_behavior == TIMING_IO_OUTPUT) 
+            EXECUTION_REPORT(REPORT_CONSTANTLY, comp_id, true, "TIMING RESULT: the component model \"%s\" spends %lf seconds for writing output data file at the current process\n", comp_comm_group_mgt_mgr->get_global_node_of_local_comp(comp_id,false,"")->get_full_name(), total_time);
+        else if (unit_behavior == TIMING_IO_RESTART)
+            EXECUTION_REPORT(REPORT_CONSTANTLY, comp_id, true, "TIMING RESULT: the component model \"%s\" spends %lf seconds for writing restart file at the current process\n", comp_comm_group_mgt_mgr->get_global_node_of_local_comp(comp_id,false,"")->get_full_name(), total_time);
+    }
+    else if (unit_type == TIMING_TYPE_COMMUNICATION) {
+        if (unit_behavior == TIMING_COMMUNICATION_RECV_WAIT)
+            EXECUTION_REPORT(REPORT_CONSTANTLY, comp_id, true, "TIMING RESULT: the component model \"%s\" spends %lf seconds for waiting for receiving data from the component model \"%s\" at the current process\n", comp_comm_group_mgt_mgr->get_global_node_of_local_comp(comp_id,false,"")->get_full_name(), total_time, unit_char_keyword);
+        else if (unit_behavior == TIMING_COMMUNICATION_RECV)
+            EXECUTION_REPORT(REPORT_CONSTANTLY, comp_id, true, "TIMING RESULT: the component model \"%s\" spends %lf seconds for receiving data (without the time of querrying buffer status) from the component model \"%s\" at the current process", comp_comm_group_mgt_mgr->get_global_node_of_local_comp(comp_id,false,"")->get_full_name(), total_time, unit_char_keyword);
+        else if (unit_behavior == TIMING_COMMUNICATION_SEND_WAIT)
+            EXECUTION_REPORT(REPORT_CONSTANTLY, comp_id, true, "TIMING RESULT: the component model \"%s\" spends %lf seconds for waiting for sending data at the export interface \"%s\" at the current process\n", comp_comm_group_mgt_mgr->get_global_node_of_local_comp(comp_id,false,"")->get_full_name(), total_time, unit_char_keyword);
+        else if (unit_behavior == TIMING_COMMUNICATION_SEND)
+            EXECUTION_REPORT(REPORT_CONSTANTLY, comp_id, true, "TIMING RESULT: the component model \"%s\" spends %lf seconds for sending data to the component model \"%s\" (without the time of querrying buffer status) at the current process", comp_comm_group_mgt_mgr->get_global_node_of_local_comp(comp_id,false,"")->get_full_name(), total_time, unit_char_keyword);
+        else if (unit_behavior == TIMING_COMMUNICATION_SEND_QUERRY)
+            EXECUTION_REPORT(REPORT_CONSTANTLY, comp_id, true, "TIMING RESULT: the component model \"%s\" spends %lf seconds for querrying the status of the remote data buffer of the component model \"%s\" for data send at the current process", comp_comm_group_mgt_mgr->get_global_node_of_local_comp(comp_id,false,"")->get_full_name(), total_time, unit_char_keyword);
+        else if (unit_behavior == TIMING_COMMUNICATION_RECV_QUERRY)
+            EXECUTION_REPORT(REPORT_CONSTANTLY, comp_id, true, "TIMING RESULT: the component model \"%s\" spends %lf seconds for querrying the status of the local data buffer for data receive from the component model \"%s\" at the current process", comp_comm_group_mgt_mgr->get_global_node_of_local_comp(comp_id,false,"")->get_full_name(), total_time, unit_char_keyword);
+//        if (unit_behavior == TIMING_COMMUNICATION_SENDRECV)
+//            printf("%s spends %lf seconds for data communication for data remapping in each process on average\n", compset_communicators_info_mgr->get_current_comp_name(), all_process_sum_time/num_procs);
+    }
+    else if (unit_type == TIMING_TYPE_COMPUTATION)
+        EXECUTION_REPORT(REPORT_CONSTANTLY, comp_id, true, "the component model \"%s\" spends %lf seconds for numerical algorithm \"%s\" at the current process\n", comp_comm_group_mgt_mgr->get_global_node_of_local_comp(comp_id,false,"")->get_full_name(), total_time, unit_char_keyword);
 }
 
 
 int Performance_timing_mgt::search_timing_unit(int unit_type, int unit_behavior, int unit_int_keyword, const char *unit_char_keyword)
 {
-	int i;
-	
-	for (i = 0; i < performance_timing_units.size(); i ++)
-		if (performance_timing_units[i]->match_timing_unit(unit_type, unit_behavior, unit_int_keyword, unit_char_keyword))
-			return i;
-
-	performance_timing_units.push_back(new Performance_timing_unit(comp_id, unit_type, unit_behavior, unit_int_keyword, unit_char_keyword));
-	return performance_timing_units.size() - 1;
+    int i;
+    
+    for (i = 0; i < performance_timing_units.size(); i ++)
+        if (performance_timing_units[i]->match_timing_unit(unit_type, unit_behavior, unit_int_keyword, unit_char_keyword))
+            return i;
+
+    performance_timing_units.push_back(new Performance_timing_unit(comp_id, unit_type, unit_behavior, unit_int_keyword, unit_char_keyword));
+    return performance_timing_units.size() - 1;
 }
 
 
 void Performance_timing_mgt::performance_timing_start(int unit_type, int unit_behavior, int unit_int_keyword, const char *unit_char_keyword)
 {
-	performance_timing_units[search_timing_unit(unit_type,unit_behavior,unit_int_keyword,unit_char_keyword)]->timing_start();
+    performance_timing_units[search_timing_unit(unit_type,unit_behavior,unit_int_keyword,unit_char_keyword)]->timing_start();
 }
 
 
 void Performance_timing_mgt::performance_timing_stop(int unit_type, int unit_behavior, int unit_int_keyword, const char *unit_char_keyword)
 {
-	performance_timing_units[search_timing_unit(unit_type,unit_behavior,unit_int_keyword,unit_char_keyword)]->timing_stop();
+    performance_timing_units[search_timing_unit(unit_type,unit_behavior,unit_int_keyword,unit_char_keyword)]->timing_stop();
 }
 
 
 void Performance_timing_mgt::performance_timing_add(int unit_type, int unit_behavior, int unit_int_keyword, const char *unit_char_keyword, double time_inc)
 {
-	performance_timing_units[search_timing_unit(unit_type,unit_behavior,unit_int_keyword,unit_char_keyword)]->timing_add(time_inc);
+    performance_timing_units[search_timing_unit(unit_type,unit_behavior,unit_int_keyword,unit_char_keyword)]->timing_add(time_inc);
 }
 
 
 void Performance_timing_mgt::performance_timing_output()
 {
-	for (int i = 0; i < performance_timing_units.size(); i ++)
-		performance_timing_units[i]->timing_output();
+    for (int i = 0; i < performance_timing_units.size(); i ++)
+        performance_timing_units[i]->timing_output();
 }
 
 
 void Performance_timing_mgt::performance_timing_reset()
 {
-	for (int i = 0; i < performance_timing_units.size(); i ++)
-		performance_timing_units[i]->timing_reset();
+    for (int i = 0; i < performance_timing_units.size(); i ++)
+        performance_timing_units[i]->timing_reset();
 }
 
 
 Performance_timing_mgt::~Performance_timing_mgt()
 {
-	for (int i = 0; i < performance_timing_units.size(); i ++)
-		delete performance_timing_units[i];
+    for (int i = 0; i < performance_timing_units.size(); i ++)
+        delete performance_timing_units[i];
 }
 
diff --git a/src/Parallel_MGT/performance_timing_mgt.h b/src/Parallel_MGT/performance_timing_mgt.h
old mode 100644
new mode 100755
index 851b75f..cddabd8
--- a/src/Parallel_MGT/performance_timing_mgt.h
+++ b/src/Parallel_MGT/performance_timing_mgt.h
@@ -31,47 +31,54 @@
 #define TIMING_IO_OUTPUT                 22
 #define TIMING_IO_RESTART                23
 
+#define TIMING_COMPUTATION_ALL           31
+#define TIMING_COMPUTATION_H2D_REMAP     32
+#define TIMING_COMPUTATION_V1D_REMAP     33
+#define TIMING_COMPUTATION_V1D_WEIGHT    34
+#define TIMING_COMPUTATION_V1D_COORD     35
+
+
 
 class Performance_timing_unit
 {
-	private:
-		int unit_type;
-		int unit_behavior;
-		int unit_int_keyword;
-		char unit_char_keyword[256];
-		double previous_time;
-		double total_time;
-		int comp_id;
-
-		void check_timing_unit(int, int, int, const char*);
-
-	public:
-		Performance_timing_unit(int, int, int, int, const char*);
-		~Performance_timing_unit(){}
-		void timing_start();
-		void timing_stop();
-		void timing_output();
-		bool match_timing_unit(int, int, int, const char*);
-		void timing_add(double time_inc) { total_time += time_inc; }
-		void timing_reset() { total_time = 0.0; }
+    private:
+        int unit_type;
+        int unit_behavior;
+        int unit_int_keyword;
+        char unit_char_keyword[256];
+        double previous_time;
+        double total_time;
+        int comp_id;
+
+        void check_timing_unit(int, int, int, const char*);
+
+    public:
+        Performance_timing_unit(int, int, int, int, const char*);
+        ~Performance_timing_unit(){}
+        void timing_start();
+        void timing_stop();
+        void timing_output();
+        bool match_timing_unit(int, int, int, const char*);
+        void timing_add(double time_inc) { total_time += time_inc; }
+        void timing_reset() { total_time = 0.0; }
 };
 
 
 class Performance_timing_mgt
 {
-	private:
-		std::vector<Performance_timing_unit*> performance_timing_units;
-		int search_timing_unit(int, int, int, const char*);
-		int comp_id;
-
-	public: 
-		Performance_timing_mgt(int comp_id) { this->comp_id = comp_id; }
-		~Performance_timing_mgt();
-		void performance_timing_start(int, int, int, const char*);
-		void performance_timing_stop(int, int, int, const char*);
-		void performance_timing_add(int, int, int, const char*, double);
-		void performance_timing_output();
-		void performance_timing_reset();
+    private:
+        std::vector<Performance_timing_unit*> performance_timing_units;
+        int search_timing_unit(int, int, int, const char*);
+        int comp_id;
+
+    public: 
+        Performance_timing_mgt(int comp_id) { this->comp_id = comp_id; }
+        ~Performance_timing_mgt();
+        void performance_timing_start(int, int, int, const char*);
+        void performance_timing_stop(int, int, int, const char*);
+        void performance_timing_add(int, int, int, const char*, double);
+        void performance_timing_output();
+        void performance_timing_reset();
 };
 
 #endif
diff --git a/src/Parallel_MGT/routing_info_mgt.cxx b/src/Parallel_MGT/routing_info_mgt.cxx
index 5ba5d93..80518c1 100644
--- a/src/Parallel_MGT/routing_info_mgt.cxx
+++ b/src/Parallel_MGT/routing_info_mgt.cxx
@@ -15,7 +15,15 @@
 #include "cor_global_data.h"
 #include "CCPL_api_mgt.h"
 #include <stdio.h>
+#include <math.h>
+#include <algorithm>
 #include <string.h>
+#include <time.h>
+
+
+#define ROUTER_SEND 1
+#define ROUTER_RECV 2
+
 
 Routing_info *Routing_info_mgt::search_or_add_router(const int src_comp_id, const int dst_comp_id, const char *src_decomp_name, const char *dst_decomp_name)
 {
@@ -49,22 +57,29 @@ Routing_info *Routing_info_mgt::search_router(const int src_comp_id, const int d
     return NULL;
 }
 
+void record_time(double duration, char* prefix)
+{
+    FILE* file = fopen("record_time", "a+");
+    fprintf(file, "%s time = %lf\n", prefix, duration);
+    fclose(file);
+}
+
 
 Routing_info::Routing_info(const int src_comp_id, const int dst_comp_id, const char *src_decomp_name, const char *dst_decomp_name)
 {
-	src_decomp_info = decomps_info_mgr->search_decomp_info(src_decomp_name, src_comp_id);
-	dst_decomp_info = decomps_info_mgr->search_decomp_info(dst_decomp_name, dst_comp_id);
+    src_decomp_info = decomps_info_mgr->search_decomp_info(src_decomp_name, src_comp_id);
+    dst_decomp_info = decomps_info_mgr->search_decomp_info(dst_decomp_name, dst_comp_id);
     this->src_comp_id = src_comp_id;
     this->dst_comp_id = dst_comp_id;
     src_comp_node = comp_comm_group_mgt_mgr->search_global_node(src_comp_id);
     dst_comp_node = comp_comm_group_mgt_mgr->search_global_node(dst_comp_id);
-	strcpy(this->src_comp_full_name, src_comp_node->get_comp_full_name());
-	strcpy(this->index_dst_comp_full_name, dst_comp_node->get_comp_full_name());
-	if (dst_decomp_info != NULL)
-		dst_comp_node = comp_comm_group_mgt_mgr->search_global_node(dst_decomp_info->get_host_comp_id());
-	strcpy(this->true_dst_comp_full_name, dst_comp_node->get_comp_full_name());
-	src_comp_node_id = src_comp_node->get_comp_id();
-	dst_comp_node_id = dst_comp_node->get_comp_id();
+    strcpy(this->src_comp_full_name, src_comp_node->get_comp_full_name());
+    strcpy(this->index_dst_comp_full_name, dst_comp_node->get_comp_full_name());
+    if (dst_decomp_info != NULL)
+        dst_comp_node = comp_comm_group_mgt_mgr->search_global_node(dst_decomp_info->get_host_comp_id());
+    strcpy(this->true_dst_comp_full_name, dst_comp_node->get_comp_full_name());
+    src_comp_node_id = src_comp_node->get_comp_id();
+    dst_comp_node_id = dst_comp_node->get_comp_id();
     strcpy(this->src_decomp_name, src_decomp_name);
     strcpy(this->dst_decomp_name, dst_decomp_name);
     src_decomp_size = 0;
@@ -72,27 +87,567 @@ Routing_info::Routing_info(const int src_comp_id, const int dst_comp_id, const c
     current_proc_id_src_comp = src_comp_node->get_current_proc_local_id();
     current_proc_id_dst_comp = dst_comp_node->get_current_proc_local_id();
 
+    src_local_routing_mapping_table_entries = NULL;
+    dst_local_routing_mapping_table_entries = NULL;
+    src_remote_routing_mapping_table_entries = NULL;
+    dst_remote_routing_mapping_table_entries = NULL;
+    num_src_local_routing_mapping_table_entries = 0;
+    num_dst_local_routing_mapping_table_entries = 0;
+    num_src_remote_routing_mapping_table_entries = 0;
+    num_dst_remote_routing_mapping_table_entries = 0;
+
+    if (current_proc_id_src_comp != -1)
+        EXECUTION_REPORT_LOG(REPORT_LOG, src_comp_id, true, "Start to generate router from (%s %s) to (%s %s)", src_comp_full_name, src_decomp_name, index_dst_comp_full_name, dst_decomp_name);
+    if (current_proc_id_dst_comp != -1)
+        EXECUTION_REPORT_LOG(REPORT_LOG, dst_comp_id, true, "Start to generate router from (%s %s) to (%s %s)", src_comp_full_name, src_decomp_name, index_dst_comp_full_name, dst_decomp_name);
+
     if (words_are_the_same(src_decomp_name, "NULL")) {
-        EXECUTION_REPORT(REPORT_ERROR,-1, words_are_the_same(dst_decomp_name, "NULL"), "for router of scalar variables, the local and remote decompositions must be \"NULL\"\n");
+        EXECUTION_REPORT_ERROR_OPTIONALLY(REPORT_ERROR, -1, words_are_the_same(dst_decomp_name, "NULL"), "for router of scalar variables, the local and remote decompositions must be \"NULL\"\n");
         num_dimensions = 0;
         if (current_proc_id_src_comp != -1) 
-			src_decomp_size = 1;
+            src_decomp_size = 1;
         if (current_proc_id_dst_comp != -1) 
-			dst_decomp_size = 1;
+            dst_decomp_size = 1;
     }
     else {
+        if (current_proc_id_src_comp != -1)
+            src_comp_node->get_performance_timing_mgr()->performance_timing_start(TIMING_TYPE_COMPUTATION, -1, -1, "generating routing information new");
+        else dst_comp_node->get_performance_timing_mgr()->performance_timing_start(TIMING_TYPE_COMPUTATION, -1, -1, "generating routing information new");
+        
+        double current_time = -1.0, previous_time = -1.0;
+        MPI_Barrier(MPI_COMM_WORLD);
+        wtime(&previous_time);
+        calculate_routing_mapping_tables();
+        build_router_based_on_routing_mapping_tables();
+        wtime(&current_time);
+        double duration = current_time - previous_time;
+        double max_duration = -1;
+
+        if (current_proc_id_src_comp != -1)
+            MPI_Reduce(&duration, &max_duration, 1, MPI_DOUBLE, MPI_MAX, 0, src_comp_node->get_comm_group());
+        if (current_proc_id_src_comp == 0)
+            record_time(max_duration, "src new router");
+        if (current_proc_id_dst_comp != -1)
+            MPI_Reduce(&duration, &max_duration, 1, MPI_DOUBLE, MPI_MAX, 0, dst_comp_node->get_comm_group());
+        if (current_proc_id_dst_comp == 0)
+            record_time(max_duration, "dst new router");
+        current_time = -1.0;
+        previous_time = -1.0;
+
+        if (current_proc_id_src_comp != -1)
+            src_comp_node->get_performance_timing_mgr()->performance_timing_stop(TIMING_TYPE_COMPUTATION, -1, -1, "generating routing information new");
+        else dst_comp_node->get_performance_timing_mgr()->performance_timing_stop(TIMING_TYPE_COMPUTATION, -1, -1, "generating routing information new");        
         num_dimensions = 2;
+        if (current_proc_id_src_comp != -1)
+            src_comp_node->get_performance_timing_mgr()->performance_timing_start(TIMING_TYPE_COMPUTATION, -1, -1, "generating routing information old");
+        else dst_comp_node->get_performance_timing_mgr()->performance_timing_start(TIMING_TYPE_COMPUTATION, -1, -1, "generating routing information old");
+        
+        MPI_Barrier(MPI_COMM_WORLD);
+        wtime(&previous_time);
         build_2D_router();
+        wtime(&current_time);
+        duration = current_time - previous_time;
+        max_duration = -1;
+        if (current_proc_id_src_comp != -1)
+            MPI_Reduce(&duration, &max_duration, 1, MPI_DOUBLE, MPI_MAX, 0, src_comp_node->get_comm_group());
+        if (current_proc_id_src_comp == 0)
+            record_time(max_duration, "src old router");
+        if (current_proc_id_dst_comp != -1)
+            MPI_Reduce(&duration, &max_duration, 1, MPI_DOUBLE, MPI_MAX, 0, dst_comp_node->get_comm_group());
+        if (current_proc_id_dst_comp == 0)
+            record_time(max_duration, "dst old router");
+
+        if (current_proc_id_src_comp != -1)
+            src_comp_node->get_performance_timing_mgr()->performance_timing_stop(TIMING_TYPE_COMPUTATION, -1, -1, "generating routing information old");
+        else dst_comp_node->get_performance_timing_mgr()->performance_timing_stop(TIMING_TYPE_COMPUTATION, -1, -1, "generating routing information old");
         if (current_proc_id_src_comp != -1) 
-			src_decomp_size = src_decomp_info->get_num_local_cells();
+            src_decomp_size = src_decomp_info->get_num_local_cells();
         if (current_proc_id_dst_comp != -1) 
-			dst_decomp_size = dst_decomp_info->get_num_local_cells();
+            dst_decomp_size = dst_decomp_info->get_num_local_cells();
+    }
+
+    if (current_proc_id_src_comp != -1)
+        EXECUTION_REPORT_LOG(REPORT_LOG, src_comp_id, true, "Finish generating router from (%s %s) to (%s %s)", src_comp_full_name, src_decomp_name, index_dst_comp_full_name, dst_decomp_name);
+    if (current_proc_id_dst_comp != -1)
+        EXECUTION_REPORT_LOG(REPORT_LOG, dst_comp_id, true, "Finish generating router from (%s %s) to (%s %s)", src_comp_full_name, src_decomp_name, index_dst_comp_full_name, dst_decomp_name);
+    
+}
+
+
+int Routing_info::calculate_max_power2(int origin_num_procs)
+{
+    int new_num_procs = origin_num_procs;
+    if (origin_num_procs > 1 && (origin_num_procs & (origin_num_procs-1)) != 0)
+        new_num_procs = pow(2, (int)log2(origin_num_procs));
+    EXECUTION_REPORT_ERROR_OPTIONALLY(REPORT_ERROR, -1, new_num_procs > 0 && new_num_procs <= origin_num_procs && 2*new_num_procs > origin_num_procs, "Software error in Routing_info::calculate_max_power2");
+        
+    return new_num_procs;
+}
+
+
+void Routing_info::merge_routing_mapping_tables(routing_mapping_table_entry **local_routing_mapping_table_entries, routing_mapping_table_entry *remote_routing_mapping_table_entries, int num_local_routing_mapping_table_entries, int num_remote_routing_mapping_table_entries, int min_key_value, int max_key_value, int *num_return_routing_mapping_table_entries)
+{
+    std::vector<routing_mapping_table_entry> temp_routing_mapping_table_entry_buffer;
+    int local_data_pointer = 0;
+    int remote_data_pointer = 0;
+
+    while (local_data_pointer < num_local_routing_mapping_table_entries && remote_data_pointer < num_remote_routing_mapping_table_entries) {
+        if ((*local_routing_mapping_table_entries)[local_data_pointer].key <= remote_routing_mapping_table_entries[remote_data_pointer].key) {
+            if ((*local_routing_mapping_table_entries)[local_data_pointer].key >= min_key_value && (*local_routing_mapping_table_entries)[local_data_pointer].key < max_key_value)
+                temp_routing_mapping_table_entry_buffer.push_back((*local_routing_mapping_table_entries)[local_data_pointer]);
+            local_data_pointer ++;
+        }
+        else {
+            if (remote_routing_mapping_table_entries[remote_data_pointer].key >= min_key_value && remote_routing_mapping_table_entries[remote_data_pointer].key < max_key_value)
+                temp_routing_mapping_table_entry_buffer.push_back(remote_routing_mapping_table_entries[remote_data_pointer]);
+            remote_data_pointer++;
+        }
+    }
+    for (; local_data_pointer < num_local_routing_mapping_table_entries; local_data_pointer ++)
+        if ( (*local_routing_mapping_table_entries)[local_data_pointer].key >= min_key_value && (*local_routing_mapping_table_entries)[local_data_pointer].key < max_key_value)
+            temp_routing_mapping_table_entry_buffer.push_back((*local_routing_mapping_table_entries)[local_data_pointer]);
+    for (; remote_data_pointer < num_remote_routing_mapping_table_entries; remote_data_pointer ++)
+        if (remote_routing_mapping_table_entries[remote_data_pointer].key >= min_key_value && remote_routing_mapping_table_entries[remote_data_pointer].key < max_key_value)
+            temp_routing_mapping_table_entry_buffer.push_back(remote_routing_mapping_table_entries[remote_data_pointer]);
+    
+    *num_return_routing_mapping_table_entries = temp_routing_mapping_table_entry_buffer.size();
+    if ((*local_routing_mapping_table_entries) != NULL)
+        delete [] (*local_routing_mapping_table_entries);
+    (*local_routing_mapping_table_entries) = NULL;
+    if (*num_return_routing_mapping_table_entries > 0) {
+        (*local_routing_mapping_table_entries) = new routing_mapping_table_entry [*num_return_routing_mapping_table_entries];
+        for (int i = 0; i < *num_return_routing_mapping_table_entries; i ++)
+            (*local_routing_mapping_table_entries)[i] = temp_routing_mapping_table_entry_buffer[i];
+    }
+}
+
+
+void Routing_info::exchange_routing_mapping_tables_between_processes(int set_size, routing_mapping_table_entry **set_send_routing_mapping_table_entries, routing_mapping_table_entry **set_recv_routing_mapping_table_entries, int *set_num_send_routing_mapping_table_entries, int *set_num_recv_routing_mapping_table_entries, int *set_proc_id_send_to, int *set_proc_id_recv_from, MPI_Comm comm, int *set_send_recv_mark)
+{
+    MPI_Status status;
+    MPI_Request *mpi_requests;
+    int num_mpi_requests = 0;
+
+
+    mpi_requests = new MPI_Request [2*set_size];
+    for (int i = 0; i < set_size; i ++) {
+        set_recv_routing_mapping_table_entries[i] = NULL;
+        if ((set_send_recv_mark[i] & ROUTER_SEND) > 0)
+            MPI_Isend(set_num_send_routing_mapping_table_entries+i, 1, MPI_INT, set_proc_id_send_to[i], 0, comm, &mpi_requests[num_mpi_requests++]);
+        if ((set_send_recv_mark[i] & ROUTER_RECV) > 0)
+            MPI_Irecv(set_num_recv_routing_mapping_table_entries+i, 1, MPI_INT, set_proc_id_recv_from[i], 0, comm, &mpi_requests[num_mpi_requests++]);
+    }
+    for (int i = 0; i < num_mpi_requests; i ++)
+        MPI_Wait(&mpi_requests[i], &status);
+
+    num_mpi_requests = 0;
+    for (int i = 0; i < set_size; i ++) {
+        if ((set_send_recv_mark[i] & ROUTER_SEND) > 0 && set_num_send_routing_mapping_table_entries[i] > 0)
+            MPI_Isend((char*)(set_send_routing_mapping_table_entries[i]), sizeof(struct routing_mapping_table_entry)*set_num_send_routing_mapping_table_entries[i], MPI_CHAR, set_proc_id_send_to[i], 0, comm, &mpi_requests[num_mpi_requests++]);
+        if ((set_send_recv_mark[i] & ROUTER_RECV) > 0 && set_num_recv_routing_mapping_table_entries[i] > 0) {
+            set_recv_routing_mapping_table_entries[i] = new routing_mapping_table_entry [set_num_recv_routing_mapping_table_entries[i]];
+            MPI_Irecv((char*)(set_recv_routing_mapping_table_entries[i]), sizeof(struct routing_mapping_table_entry)*(set_num_recv_routing_mapping_table_entries[i]), MPI_CHAR, set_proc_id_recv_from[i], 0, comm, &mpi_requests[num_mpi_requests++]);
+        }
     }
+    for (int i = 0; i < num_mpi_requests; i ++)
+        MPI_Wait(&mpi_requests[i], &status);
+
+    delete [] mpi_requests;
+}
+
+
+void Routing_info::calculate_min_max_grid_index(int num_grid_cells, int min_proc_id, int max_proc_id, int ref_proc_num, int proc_scale_factor, int* min_grid_index, int* max_grid_index)
+{
+    *min_grid_index = (num_grid_cells / ref_proc_num) * (min_proc_id * proc_scale_factor);
+    *min_grid_index += std::min(num_grid_cells % ref_proc_num, min_proc_id * proc_scale_factor);
+    *max_grid_index = (num_grid_cells / ref_proc_num) * (max_proc_id + 1) * proc_scale_factor;
+    *max_grid_index += std::min(num_grid_cells % ref_proc_num, (max_proc_id + 1) * proc_scale_factor);
+}
+
+
+void Routing_info::check_routing_mapping_table_entries(routing_mapping_table_entry *routing_mapping_table_entries, int num_local_routing_mapping_table_entries, int min_key_value, int max_key_value, char* hint)
+{
+    if (!report_error_enabled)
+        return;
+    
+    for (int i = 0; i < num_local_routing_mapping_table_entries - 1; i ++)
+        EXECUTION_REPORT(REPORT_ERROR, -1, routing_mapping_table_entries[i].key >= min_key_value && routing_mapping_table_entries[i].key < max_key_value && routing_mapping_table_entries[i+1].key >= min_key_value && routing_mapping_table_entries[i+1].key < max_key_value && routing_mapping_table_entries[i].key <= routing_mapping_table_entries[i+1].key, "ERROR in check_routing_mapping_table_entries (%s): %d th is %ld, while the range is %d %d, next routing_mapping_table_entry key is %d\n", hint, i, routing_mapping_table_entries[i].key, min_key_value, max_key_value, routing_mapping_table_entries[i+1].key);
+}
+
 
-	if (current_proc_id_src_comp != 0)
-		EXECUTION_REPORT_LOG(REPORT_LOG, src_comp_id, true, "Finish generating router from (%s %s) to (%s %s)", src_comp_full_name, src_decomp_name, index_dst_comp_full_name, dst_decomp_name);
-	if (current_proc_id_dst_comp != 0)
-		EXECUTION_REPORT_LOG(REPORT_LOG, dst_comp_id, true, "Finish generating router from (%s %s) to (%s %s)", src_comp_full_name, src_decomp_name, index_dst_comp_full_name, dst_decomp_name);
+void Routing_info::output_routing_mapping_table(routing_mapping_table_entry *routing_mapping_table_entries, char *hint, int num_local_routing_mapping_table_entries, int current_proc_id)
+{
+    EXECUTION_REPORT_LOG(REPORT_LOG, -1, true, "output routing_mapping_table with the hint \"%s\"", hint);
+    for (int i = 0; i < num_local_routing_mapping_table_entries; i ++)
+        EXECUTION_REPORT_LOG(REPORT_LOG, -1, true, "table entry (%d): %d %d %d %d %d\n", i, routing_mapping_table_entries[i].key, routing_mapping_table_entries[i].global_index, routing_mapping_table_entries[i].local_process_id, routing_mapping_table_entries[i].local_index, routing_mapping_table_entries[i].remote_local_process_id, routing_mapping_table_entries[i].remote_local_index);
+}
+
+
+void Routing_info::exchange_routing_mapping_tables_between_components(int num_src_procs_adjust, int num_dst_procs_adjust, Decomp_info *decomp_info, bool exchange_src)
+{
+    int comp_max_num_proc_adjust, src_proc_scale_factor, dst_proc_scale_factor;
+    int remote_proc_local_id_recv_from, remote_proc_local_id_send_to, *set_remote_proc_global_id_send_to, *set_remote_proc_global_id_recv_from, j, k;
+    int send_addr_disp = 0, *set_send_entry_count;
+    int min_grid_index, max_grid_index;
+    routing_mapping_table_entry **set_send_routing_mapping_table_entries_buffer, **set_recv_routing_mapping_table_entries_buffer, *send_routing_mapping_table_entries, **recv_routing_mapping_table_entries;
+    int *set_num_recv_routing_mapping_table_entries, num_send_routing_mapping_table_entries, *num_recv_routing_mapping_table_entries;
+    int *set_send_recv_mark, send_proc_scale_factor, max_proc_scale_factor;
+    
+
+    if (!(current_proc_id_src_comp != -1 && current_proc_id_src_comp < num_src_procs_adjust || current_proc_id_dst_comp != -1 && current_proc_id_dst_comp < num_dst_procs_adjust))
+        return;
+
+    comp_max_num_proc_adjust = std::max(num_src_procs_adjust, num_dst_procs_adjust);
+    src_proc_scale_factor = comp_max_num_proc_adjust / num_src_procs_adjust;
+    dst_proc_scale_factor = comp_max_num_proc_adjust / num_dst_procs_adjust;
+    max_proc_scale_factor = std::max(src_proc_scale_factor, dst_proc_scale_factor);
+    set_send_recv_mark = new int [max_proc_scale_factor];
+    set_send_routing_mapping_table_entries_buffer = new routing_mapping_table_entry *[max_proc_scale_factor];
+    set_recv_routing_mapping_table_entries_buffer = new routing_mapping_table_entry *[max_proc_scale_factor];
+    set_num_recv_routing_mapping_table_entries = new int [max_proc_scale_factor];
+    set_send_entry_count = new int [max_proc_scale_factor];
+    set_remote_proc_global_id_send_to = new int [max_proc_scale_factor];
+    set_remote_proc_global_id_recv_from = new int [max_proc_scale_factor];
+    send_routing_mapping_table_entries = NULL;
+    recv_routing_mapping_table_entries = NULL;
+    num_recv_routing_mapping_table_entries = NULL;
+    
+    if (exchange_src) {
+        if (current_proc_id_src_comp != -1 && current_proc_id_src_comp < num_src_procs_adjust) {
+            send_routing_mapping_table_entries = src_local_routing_mapping_table_entries;
+            num_send_routing_mapping_table_entries = num_src_local_routing_mapping_table_entries;
+            send_proc_scale_factor = src_proc_scale_factor;
+        }
+        if (current_proc_id_dst_comp != -1 && current_proc_id_dst_comp < num_dst_procs_adjust) {
+            recv_routing_mapping_table_entries = &src_remote_routing_mapping_table_entries;
+            num_recv_routing_mapping_table_entries = &num_src_remote_routing_mapping_table_entries;
+        }
+    }
+    else {
+        if (current_proc_id_src_comp != -1 && current_proc_id_src_comp < num_src_procs_adjust) {
+            recv_routing_mapping_table_entries = &dst_remote_routing_mapping_table_entries;
+            num_recv_routing_mapping_table_entries = &num_dst_remote_routing_mapping_table_entries;
+        }
+        if (current_proc_id_dst_comp != -1 && current_proc_id_dst_comp < num_dst_procs_adjust) {
+            send_routing_mapping_table_entries = dst_local_routing_mapping_table_entries;
+            num_send_routing_mapping_table_entries = num_dst_local_routing_mapping_table_entries;
+            send_proc_scale_factor = dst_proc_scale_factor;
+        }
+    }
+
+    for (int i = 0; i < max_proc_scale_factor; i ++) {
+        set_send_recv_mark[i] = 0;
+        set_remote_proc_global_id_send_to[i] = -1;
+        set_remote_proc_global_id_recv_from[i] = -1; 
+        if (exchange_src) {
+            if (current_proc_id_src_comp != -1 && current_proc_id_src_comp < num_src_procs_adjust && (i%dst_proc_scale_factor) == 0) {
+                set_send_recv_mark[i] = set_send_recv_mark[i] | ROUTER_SEND;
+                remote_proc_local_id_send_to = current_proc_id_src_comp * num_dst_procs_adjust / num_src_procs_adjust + i;
+                set_remote_proc_global_id_send_to[i] = dst_comp_node->get_local_proc_global_id(remote_proc_local_id_send_to);
+            }
+            if (current_proc_id_dst_comp != -1 && current_proc_id_dst_comp < num_dst_procs_adjust && (i%src_proc_scale_factor) == 0) {
+                set_send_recv_mark[i] = set_send_recv_mark[i] | ROUTER_RECV;
+                remote_proc_local_id_recv_from = current_proc_id_dst_comp * num_src_procs_adjust / num_dst_procs_adjust + i;
+                set_remote_proc_global_id_recv_from[i] = src_comp_node->get_local_proc_global_id(remote_proc_local_id_recv_from);
+            }
+        }
+        else {
+            if (current_proc_id_src_comp != -1 && current_proc_id_src_comp < num_src_procs_adjust && (i%dst_proc_scale_factor) == 0) {
+                set_send_recv_mark[i] = set_send_recv_mark[i] | ROUTER_RECV;
+                remote_proc_local_id_recv_from = current_proc_id_src_comp * num_dst_procs_adjust / num_src_procs_adjust + i;
+                set_remote_proc_global_id_recv_from[i] = dst_comp_node->get_local_proc_global_id(remote_proc_local_id_recv_from);
+            }
+            if (current_proc_id_dst_comp != -1 && current_proc_id_dst_comp < num_dst_procs_adjust && (i%src_proc_scale_factor) == 0) {
+                set_send_recv_mark[i] = set_send_recv_mark[i] | ROUTER_SEND;
+                remote_proc_local_id_send_to = current_proc_id_dst_comp * num_src_procs_adjust / num_dst_procs_adjust + i;
+                set_remote_proc_global_id_send_to[i] = src_comp_node->get_local_proc_global_id(remote_proc_local_id_send_to);
+            }
+        }
+        if (set_send_recv_mark[i] == 0)
+            continue;
+        if ((set_send_recv_mark[i] & ROUTER_SEND) > 0) {
+            if (send_proc_scale_factor == 1) {
+				EXECUTION_REPORT_ERROR_OPTIONALLY(REPORT_ERROR, -1, send_addr_disp == 0, "Software error in Routing_info::exchange_routing_mapping_tables_between_components");
+                set_send_entry_count[i] = num_send_routing_mapping_table_entries;
+            } else {
+                calculate_min_max_grid_index(decomp_info->get_num_global_cells(), remote_proc_local_id_send_to, remote_proc_local_id_send_to, comp_max_num_proc_adjust, 1, &min_grid_index, &max_grid_index);
+                for (; send_addr_disp < num_send_routing_mapping_table_entries; send_addr_disp ++) {
+                    if(send_routing_mapping_table_entries[send_addr_disp].global_index >= min_grid_index)
+                        break;
+                }
+                set_send_entry_count[i] = 0;
+                for (j = send_addr_disp; j < num_send_routing_mapping_table_entries; j ++, set_send_entry_count[i] ++) {
+                    if((send_routing_mapping_table_entries)[j].global_index >= max_grid_index)
+                        break;
+                }
+				if (i == send_proc_scale_factor - 1)
+					EXECUTION_REPORT_ERROR_OPTIONALLY(REPORT_ERROR, -1, j == num_send_routing_mapping_table_entries, "Software error in Routing_info::exchange_routing_mapping_tables_between_components");					
+            }
+			set_send_routing_mapping_table_entries_buffer[i] = send_routing_mapping_table_entries + send_addr_disp;
+        }
+    }
+
+    exchange_routing_mapping_tables_between_processes(max_proc_scale_factor, set_send_routing_mapping_table_entries_buffer, set_recv_routing_mapping_table_entries_buffer, set_send_entry_count, set_num_recv_routing_mapping_table_entries, set_remote_proc_global_id_send_to, set_remote_proc_global_id_recv_from, MPI_COMM_WORLD, set_send_recv_mark);
+
+    if (num_recv_routing_mapping_table_entries != NULL) {
+        *num_recv_routing_mapping_table_entries = 0;
+        for (int i = 0; i < max_proc_scale_factor; i ++) 
+            if ((set_send_recv_mark[i] & ROUTER_RECV) > 0)
+                *num_recv_routing_mapping_table_entries += set_num_recv_routing_mapping_table_entries[i];
+		EXECUTION_REPORT_ERROR_OPTIONALLY(REPORT_ERROR, -1, *recv_routing_mapping_table_entries == NULL, "Software error in Routing_info::exchange_routing_mapping_tables_between_components");
+        *recv_routing_mapping_table_entries = new routing_mapping_table_entry [*num_recv_routing_mapping_table_entries];
+        *num_recv_routing_mapping_table_entries = 0;
+        for (int i = 0; i < max_proc_scale_factor; i ++) 
+            if ((set_send_recv_mark[i] & ROUTER_RECV) > 0 && set_recv_routing_mapping_table_entries_buffer[i] != NULL) {
+                memcpy((*recv_routing_mapping_table_entries)+*num_recv_routing_mapping_table_entries, set_recv_routing_mapping_table_entries_buffer[i], sizeof(struct routing_mapping_table_entry)*set_num_recv_routing_mapping_table_entries[i]);
+                delete [] set_recv_routing_mapping_table_entries_buffer[i];
+                *num_recv_routing_mapping_table_entries += set_num_recv_routing_mapping_table_entries[i];
+            }
+    }
+
+    delete [] set_send_recv_mark;
+    delete [] set_send_routing_mapping_table_entries_buffer;
+    delete [] set_recv_routing_mapping_table_entries_buffer;
+    delete [] set_num_recv_routing_mapping_table_entries;
+    delete [] set_send_entry_count;
+    delete [] set_remote_proc_global_id_send_to;
+    delete [] set_remote_proc_global_id_recv_from;
+}
+
+
+void Routing_info::intersect_routing_mapping_tables_between_components(routing_mapping_table_entry **local_routing_mapping_table_entries, routing_mapping_table_entry *remote_routing_mapping_table_entries, int *num_local_routing_mapping_table_entries, int num_remote_routing_mapping_table_entries, bool is_src)
+{
+    std::vector<routing_mapping_table_entry> mapping_routing_mapping_table_entries_pairs;
+    int local_pointer = 0, remote_pointer = 0;
+
+    if (*num_local_routing_mapping_table_entries == 0 || num_remote_routing_mapping_table_entries == 0) {
+        if ((*local_routing_mapping_table_entries) != NULL)
+            delete [] (*local_routing_mapping_table_entries);
+        (*local_routing_mapping_table_entries) = NULL;
+        *num_local_routing_mapping_table_entries = 0;
+        return;
+    }
+
+    while (local_pointer < *num_local_routing_mapping_table_entries && remote_pointer < num_remote_routing_mapping_table_entries) {
+        while((local_pointer < *num_local_routing_mapping_table_entries) && ((*local_routing_mapping_table_entries)[local_pointer].global_index < remote_routing_mapping_table_entries[remote_pointer].global_index))
+            local_pointer ++;
+        while ((remote_pointer < num_remote_routing_mapping_table_entries) && ((*local_routing_mapping_table_entries)[local_pointer].global_index > remote_routing_mapping_table_entries[remote_pointer].global_index))
+            remote_pointer ++;
+        
+        if ((*local_routing_mapping_table_entries)[local_pointer].global_index == remote_routing_mapping_table_entries[remote_pointer].global_index) {
+            int num_local_routing_mapping_table_entry_same = 1, num_remote_routing_mapping_table_entry_same = 1;
+            while ((local_pointer+num_local_routing_mapping_table_entry_same < *num_local_routing_mapping_table_entries) && ((*local_routing_mapping_table_entries)[local_pointer].global_index == (*local_routing_mapping_table_entries)[local_pointer+num_local_routing_mapping_table_entry_same].global_index))
+                num_local_routing_mapping_table_entry_same ++;
+            while ((remote_pointer+num_remote_routing_mapping_table_entry_same < num_remote_routing_mapping_table_entries) && (remote_routing_mapping_table_entries[remote_pointer].global_index == remote_routing_mapping_table_entries[remote_pointer+num_remote_routing_mapping_table_entry_same].global_index))
+                num_remote_routing_mapping_table_entry_same ++;
+            
+            if (is_src) {
+                for (int j = 0; j < num_remote_routing_mapping_table_entry_same; j ++) {
+                    routing_mapping_table_entry temp_routing_mapping_table_entry = { -1,
+                        (*local_routing_mapping_table_entries)[local_pointer + j%num_local_routing_mapping_table_entry_same].global_index,
+                        (*local_routing_mapping_table_entries)[local_pointer + j%num_local_routing_mapping_table_entry_same].local_index,            
+                        (*local_routing_mapping_table_entries)[local_pointer + j%num_local_routing_mapping_table_entry_same].local_process_id,
+                        remote_routing_mapping_table_entries[remote_pointer + j].local_index,
+                        remote_routing_mapping_table_entries[remote_pointer + j].local_process_id
+                    };
+                    mapping_routing_mapping_table_entries_pairs.push_back(temp_routing_mapping_table_entry);
+					EXECUTION_REPORT_ERROR_OPTIONALLY(REPORT_ERROR, -1, (*local_routing_mapping_table_entries)[local_pointer + j%num_local_routing_mapping_table_entry_same].global_index == remote_routing_mapping_table_entries[remote_pointer + j].global_index, "Software error in Routing_info::intersect_routing_mapping_tables_between_components");
+					if (num_local_routing_mapping_table_entry_same > 1)
+						EXECUTION_REPORT_LOG(REPORT_LOG, true, src_comp_node->get_comp_id(), "Router generation detects multiple input of the same cell (%d), and then generates a connection from src (%d %d) to dst (%d %d)", temp_routing_mapping_table_entry.global_index, temp_routing_mapping_table_entry.local_process_id, temp_routing_mapping_table_entry.local_index, temp_routing_mapping_table_entry.remote_local_process_id, temp_routing_mapping_table_entry.remote_local_index);
+                }
+            }
+            else { 
+                for (int j = 0; j < num_local_routing_mapping_table_entry_same; j ++) {
+                    routing_mapping_table_entry temp_routing_mapping_table_entry = { -1, 
+                        (*local_routing_mapping_table_entries)[local_pointer + j].global_index,
+                        (*local_routing_mapping_table_entries)[local_pointer + j].local_index,            
+                        (*local_routing_mapping_table_entries)[local_pointer + j].local_process_id,
+                        remote_routing_mapping_table_entries[remote_pointer + j%num_remote_routing_mapping_table_entry_same].local_index,
+                        remote_routing_mapping_table_entries[remote_pointer + j%num_remote_routing_mapping_table_entry_same].local_process_id
+                    };
+                    mapping_routing_mapping_table_entries_pairs.push_back(temp_routing_mapping_table_entry);
+					EXECUTION_REPORT_ERROR_OPTIONALLY(REPORT_ERROR, -1, (*local_routing_mapping_table_entries)[local_pointer + j].global_index == remote_routing_mapping_table_entries[remote_pointer + j%num_remote_routing_mapping_table_entry_same].global_index, "Software error in Routing_info::intersect_routing_mapping_tables_between_components");
+                }
+            }
+            local_pointer += num_local_routing_mapping_table_entry_same;
+            remote_pointer += num_remote_routing_mapping_table_entry_same;
+        }
+    }
+
+    *num_local_routing_mapping_table_entries = mapping_routing_mapping_table_entries_pairs.size();
+    if ((*local_routing_mapping_table_entries) != NULL)
+        delete [] (*local_routing_mapping_table_entries);
+    (*local_routing_mapping_table_entries) = NULL;
+    if (*num_local_routing_mapping_table_entries > 0 ) {
+        (*local_routing_mapping_table_entries) = new routing_mapping_table_entry [*num_local_routing_mapping_table_entries];
+        for (int i = 0; i < *num_local_routing_mapping_table_entries; i ++) {
+            (*local_routing_mapping_table_entries)[i] = mapping_routing_mapping_table_entries_pairs[i];
+        }
+    }
+}
+
+
+void Routing_info::initialize_routing_mapping_table(routing_mapping_table_entry **routing_mapping_table_entries, Decomp_info *decomp_info, Comp_comm_group_mgt_node *comp_node, int *num_local_routing_mapping_table_entries, int current_proc_id, int num_local_procs, int num_local_procs_adjust)
+{
+    int i = 0, j = 0;
+    routing_mapping_table_entry *temp_routing_mapping_table_entries;
+    int temp_num_routing_mapping_table_entries;
+    const int *local_cells_gobal_index = decomp_info->get_local_cell_global_indx();
+    int send_recv_mark, proc_id_send_to, proc_id_recv_from;
+
+
+    if (*num_local_routing_mapping_table_entries > 0) {
+        (*routing_mapping_table_entries) = new routing_mapping_table_entry [*num_local_routing_mapping_table_entries];
+        for (int i = 0; i < *num_local_routing_mapping_table_entries; i ++) {
+            if (local_cells_gobal_index[i] == CCPL_NULL_INT)
+                continue;
+            (*routing_mapping_table_entries)[j].global_index = local_cells_gobal_index[i];    
+            (*routing_mapping_table_entries)[j].key = (*routing_mapping_table_entries)[j].global_index;
+            (*routing_mapping_table_entries)[j].local_index = i;
+            (*routing_mapping_table_entries)[j].local_process_id = current_proc_id;
+            (*routing_mapping_table_entries)[j].remote_local_index = -1;
+            (*routing_mapping_table_entries)[j].remote_local_process_id = -1;
+            j++;
+        }
+        *num_local_routing_mapping_table_entries = j;
+        do_quick_sort(*routing_mapping_table_entries, (int*)NULL, 0, *num_local_routing_mapping_table_entries-1);
+    }
+
+    if (num_local_procs != num_local_procs_adjust) {
+        proc_id_send_to = current_proc_id-num_local_procs_adjust;
+        proc_id_recv_from = current_proc_id+num_local_procs_adjust;
+        if (current_proc_id >= num_local_procs_adjust) {
+            send_recv_mark = ROUTER_SEND;
+            exchange_routing_mapping_tables_between_processes(1, routing_mapping_table_entries, &temp_routing_mapping_table_entries, num_local_routing_mapping_table_entries, &temp_num_routing_mapping_table_entries, &proc_id_send_to, &proc_id_recv_from, comp_node->get_comm_group(), &send_recv_mark);
+            *num_local_routing_mapping_table_entries = 0; // proc_id > 2^n, so the routing_mapping_table_entries number is 0
+        } 
+        else if (current_proc_id <= (num_local_procs-num_local_procs_adjust-1)) {
+            send_recv_mark = ROUTER_RECV;
+            exchange_routing_mapping_tables_between_processes(1, routing_mapping_table_entries, &temp_routing_mapping_table_entries, num_local_routing_mapping_table_entries, &temp_num_routing_mapping_table_entries, &proc_id_send_to, &proc_id_recv_from, comp_node->get_comm_group(), &send_recv_mark);
+            merge_routing_mapping_tables(routing_mapping_table_entries, temp_routing_mapping_table_entries, *num_local_routing_mapping_table_entries, temp_num_routing_mapping_table_entries, 0, decomp_info->get_num_global_cells(), num_local_routing_mapping_table_entries);
+            if (temp_routing_mapping_table_entries != NULL)
+                delete [] temp_routing_mapping_table_entries;
+        }
+    }
+}
+
+// compare_option is 1: based on global_index, 2: based on local_process_id
+void Routing_info::sort_routing_mapping_table_entries(routing_mapping_table_entry** routing_mapping_table_entries, Decomp_info* decomp_info, Comp_comm_group_mgt_node* comp_node, int* num_local_routing_mapping_table_entries, int current_proc_id, int num_local_procs, int num_local_procs_adjust, int num_remote_procs_adjust, int compare_option)
+{
+    int temp_num_routing_mapping_table_entries;
+    int ref_proc_num = std::max(num_local_procs_adjust, num_remote_procs_adjust);
+    int proc_scale_factor = ref_proc_num / num_local_procs_adjust;
+    routing_mapping_table_entry *temp_routing_mapping_table_entries = NULL;
+    int min_proc_id = 0, max_proc_id = num_local_procs_adjust - 1, mid_proc_id, remote_proc_id;
+    int min_key_value, mid_key_value, max_key_value, send_recv_mark;
+    int proc_id_send_to, proc_id_recv_from;
+
+    if (current_proc_id < num_local_procs_adjust) {
+        while (min_proc_id != max_proc_id) {
+            mid_proc_id = (max_proc_id - min_proc_id + 1) / 2 + min_proc_id - 1;            
+            if (compare_option == 1 ) {
+                calculate_min_max_grid_index(decomp_info->get_num_global_cells(), min_proc_id, max_proc_id, ref_proc_num, proc_scale_factor, &min_key_value, &max_key_value);
+                mid_key_value = (decomp_info->get_num_global_cells() / ref_proc_num) * (mid_proc_id + 1) * proc_scale_factor;
+                mid_key_value += std::min(decomp_info->get_num_global_cells() % ref_proc_num, (mid_proc_id + 1) * proc_scale_factor);
+            }
+            else if (compare_option == 2) {
+                min_key_value = min_proc_id;
+				mid_key_value = mid_proc_id + 1;
+				max_key_value = max_proc_id + 1;
+            }
+
+            send_recv_mark = ROUTER_SEND|ROUTER_RECV;
+            if (current_proc_id <= mid_proc_id ) {
+                remote_proc_id = current_proc_id + (max_proc_id - min_proc_id + 1) / 2;
+                exchange_routing_mapping_tables_between_processes(1, routing_mapping_table_entries, &temp_routing_mapping_table_entries, num_local_routing_mapping_table_entries, &temp_num_routing_mapping_table_entries, &remote_proc_id, &remote_proc_id, comp_node->get_comm_group(), &send_recv_mark);
+                merge_routing_mapping_tables(routing_mapping_table_entries, temp_routing_mapping_table_entries, *num_local_routing_mapping_table_entries, temp_num_routing_mapping_table_entries, min_key_value, mid_key_value, num_local_routing_mapping_table_entries); 
+				max_proc_id = mid_proc_id;
+            } else {
+                remote_proc_id = current_proc_id - (max_proc_id - min_proc_id +  1) / 2;
+                exchange_routing_mapping_tables_between_processes(1, routing_mapping_table_entries, &temp_routing_mapping_table_entries, num_local_routing_mapping_table_entries, &temp_num_routing_mapping_table_entries, &remote_proc_id, &remote_proc_id, comp_node->get_comm_group(), &send_recv_mark);
+                merge_routing_mapping_tables(routing_mapping_table_entries, temp_routing_mapping_table_entries, *num_local_routing_mapping_table_entries, temp_num_routing_mapping_table_entries, mid_key_value, max_key_value, num_local_routing_mapping_table_entries);
+				min_proc_id = mid_proc_id + 1;
+            }
+            check_routing_mapping_table_entries(*routing_mapping_table_entries, *num_local_routing_mapping_table_entries, min_key_value, max_key_value, "in sort_routing_mapping_table_entries"); 
+
+            if (temp_routing_mapping_table_entries != NULL)
+                delete [] temp_routing_mapping_table_entries;
+        }
+		EXECUTION_REPORT_ERROR_OPTIONALLY(REPORT_ERROR, -1, min_proc_id == current_proc_id && current_proc_id == max_proc_id, "Software error in Routing_info::sort_routing_mapping_table_entries");
+    }
+    
+    if(compare_option == 2 && num_local_procs != num_local_procs_adjust) {
+        proc_id_send_to = current_proc_id + num_local_procs_adjust;
+        proc_id_recv_from = current_proc_id - num_local_procs_adjust;
+        if (current_proc_id < num_local_procs-num_local_procs_adjust) {
+            send_recv_mark = ROUTER_SEND;
+            exchange_routing_mapping_tables_between_processes(1, routing_mapping_table_entries, &temp_routing_mapping_table_entries, num_local_routing_mapping_table_entries, NULL, &proc_id_send_to, &proc_id_recv_from, comp_node->get_comm_group(), &send_recv_mark);
+        } 
+        else if (current_proc_id >= num_local_procs_adjust) {
+            send_recv_mark = ROUTER_RECV;
+            exchange_routing_mapping_tables_between_processes(1, &temp_routing_mapping_table_entries, routing_mapping_table_entries, NULL, num_local_routing_mapping_table_entries, &proc_id_send_to, &proc_id_recv_from, comp_node->get_comm_group(), &send_recv_mark);
+        }
+        for (int i = 0; i < *num_local_routing_mapping_table_entries; i ++)
+            (*routing_mapping_table_entries)[i].key = (*routing_mapping_table_entries)[i].local_process_id;
+        merge_routing_mapping_tables(routing_mapping_table_entries, (routing_mapping_table_entry*)NULL, *num_local_routing_mapping_table_entries, 0, current_proc_id, current_proc_id+1, num_local_routing_mapping_table_entries);
+    }
+}
+
+
+void Routing_info::calculate_routing_mapping_tables()
+{
+    int num_src_procs = src_comp_node->get_num_procs();
+    int num_src_procs_adjust = calculate_max_power2(num_src_procs);
+    int num_dst_procs = dst_comp_node->get_num_procs();
+    int num_dst_procs_adjust = calculate_max_power2(num_dst_procs);
+    
+    int num_src_global_routing_mapping_table_entries, num_dst_global_routing_mapping_table_entries;
+ 
+    if (current_proc_id_src_comp != -1) {
+        EXECUTION_REPORT_ERROR_OPTIONALLY(REPORT_ERROR, -1, src_decomp_info != NULL, "Software error in Routing_info::calculate_routing_mapping_tables: NULL src decomp info");
+        num_src_local_routing_mapping_table_entries = src_decomp_info->get_num_local_cells();
+        initialize_routing_mapping_table(&src_local_routing_mapping_table_entries, src_decomp_info, src_comp_node, &num_src_local_routing_mapping_table_entries, current_proc_id_src_comp, num_src_procs, num_src_procs_adjust);
+        sort_routing_mapping_table_entries(&src_local_routing_mapping_table_entries, src_decomp_info, src_comp_node, &num_src_local_routing_mapping_table_entries, current_proc_id_src_comp, num_src_procs, num_src_procs_adjust, num_dst_procs_adjust, 1);
+    }
+
+    if (current_proc_id_dst_comp != -1) {
+        EXECUTION_REPORT_ERROR_OPTIONALLY(REPORT_ERROR, -1, dst_decomp_info != NULL, "Software error in Routing_info::calculate_routing_mapping_tables: NULL dst decomp info");
+        num_dst_local_routing_mapping_table_entries = dst_decomp_info->get_num_local_cells();
+        initialize_routing_mapping_table(&dst_local_routing_mapping_table_entries, dst_decomp_info, dst_comp_node, &num_dst_local_routing_mapping_table_entries, current_proc_id_dst_comp, num_dst_procs, num_dst_procs_adjust);        
+        sort_routing_mapping_table_entries(&dst_local_routing_mapping_table_entries, dst_decomp_info, dst_comp_node, &num_dst_local_routing_mapping_table_entries, current_proc_id_dst_comp, num_dst_procs, num_dst_procs_adjust, num_src_procs_adjust, 1);
+    }
+
+    exchange_routing_mapping_tables_between_components(num_src_procs_adjust, num_dst_procs_adjust, src_decomp_info, true);        
+    exchange_routing_mapping_tables_between_components(num_src_procs_adjust, num_dst_procs_adjust, dst_decomp_info, false);
+       
+    if (current_proc_id_src_comp != -1) 
+        intersect_routing_mapping_tables_between_components(&src_local_routing_mapping_table_entries, dst_remote_routing_mapping_table_entries, &num_src_local_routing_mapping_table_entries, num_dst_remote_routing_mapping_table_entries, true);
+    if (current_proc_id_dst_comp != -1)
+        intersect_routing_mapping_tables_between_components(&dst_local_routing_mapping_table_entries, src_remote_routing_mapping_table_entries, &num_dst_local_routing_mapping_table_entries, num_src_remote_routing_mapping_table_entries, false);
+    if (src_remote_routing_mapping_table_entries != NULL)
+        delete [] src_remote_routing_mapping_table_entries;
+    if (dst_remote_routing_mapping_table_entries != NULL)
+        delete [] dst_remote_routing_mapping_table_entries;
+
+    if (current_proc_id_src_comp != -1) {
+        for (int i = 0; i < num_src_local_routing_mapping_table_entries; i ++)
+            src_local_routing_mapping_table_entries[i].key = src_local_routing_mapping_table_entries[i].local_process_id % num_src_procs_adjust;
+        do_quick_sort(src_local_routing_mapping_table_entries, (int*)NULL, 0, num_src_local_routing_mapping_table_entries-1);
+        sort_routing_mapping_table_entries(&src_local_routing_mapping_table_entries, src_decomp_info, src_comp_node, &num_src_local_routing_mapping_table_entries, current_proc_id_src_comp, num_src_procs, num_src_procs_adjust, num_src_procs_adjust, 2);        
+        for (int i = 0; i < num_src_local_routing_mapping_table_entries; i ++)
+            src_local_routing_mapping_table_entries[i].key = src_local_routing_mapping_table_entries[i].remote_local_process_id;
+        do_quick_sort(src_local_routing_mapping_table_entries, (int*)NULL, 0, num_src_local_routing_mapping_table_entries-1);
+    }
+
+    if (current_proc_id_dst_comp != -1) {
+        for (int i = 0; i < num_dst_local_routing_mapping_table_entries; i ++)
+            dst_local_routing_mapping_table_entries[i].key = dst_local_routing_mapping_table_entries[i].local_process_id % num_dst_procs_adjust;
+        do_quick_sort(dst_local_routing_mapping_table_entries, (int*)NULL, 0, num_dst_local_routing_mapping_table_entries-1);
+        sort_routing_mapping_table_entries(&dst_local_routing_mapping_table_entries, dst_decomp_info, dst_comp_node, &num_dst_local_routing_mapping_table_entries, current_proc_id_dst_comp, num_dst_procs, num_dst_procs_adjust, num_dst_procs_adjust, 2);
+        for (int i = 0; i < num_dst_local_routing_mapping_table_entries; i ++)
+            dst_local_routing_mapping_table_entries[i].key = dst_local_routing_mapping_table_entries[i].remote_local_process_id;
+        do_quick_sort(dst_local_routing_mapping_table_entries, (int*)NULL, 0, num_dst_local_routing_mapping_table_entries-1);
+    }
 }
 
 
@@ -120,6 +675,99 @@ bool Routing_info::match_router(const int src_comp_id, const int dst_comp_id, co
 }
 
 
+Routing_info_with_one_process *Routing_info::generate_routing_info_between_procs(routing_mapping_table_entry* local_routing_mapping_table_entries, int num_local_routing_mapping_table_entries, int remote_proc_global_id, bool is_src)
+{
+    Routing_info_with_one_process *routing_info;
+	int last_reference_local_index;
+
+    routing_info = new Routing_info_with_one_process;
+    routing_info->num_elements_transferred = num_local_routing_mapping_table_entries;
+    routing_info->num_local_indx_segments = 0;
+    routing_info->remote_proc_global_id = remote_proc_global_id;
+
+	if (num_local_routing_mapping_table_entries == 0)
+		return routing_info;
+
+	if (report_error_enabled) 
+		for (int i = 1; i < num_local_routing_mapping_table_entries; i ++)
+			EXECUTION_REPORT_ERROR_OPTIONALLY(REPORT_ERROR, -1, local_routing_mapping_table_entries[0].remote_local_process_id == local_routing_mapping_table_entries[i].remote_local_process_id, "Software error in Routing_info::generate_routing_info_between_procs");
+
+    if (is_src)
+        for (int i = 0; i < num_local_routing_mapping_table_entries; i ++)
+            local_routing_mapping_table_entries[i].key = local_routing_mapping_table_entries[i].remote_local_index;
+    else
+        for (int i = 0; i < num_local_routing_mapping_table_entries; i ++)
+            local_routing_mapping_table_entries[i].key = local_routing_mapping_table_entries[i].local_index;
+    do_quick_sort(local_routing_mapping_table_entries, (int*)NULL, 0, num_local_routing_mapping_table_entries-1);
+
+	last_reference_local_index = -100;
+	for (int i = 0; i < num_local_routing_mapping_table_entries; i ++) {
+		if (last_reference_local_index + 1 != local_routing_mapping_table_entries[i].local_index)
+            routing_info->num_local_indx_segments ++;
+        last_reference_local_index = local_routing_mapping_table_entries[i].local_index;
+	}
+
+	EXECUTION_REPORT_ERROR_OPTIONALLY(REPORT_ERROR, -1, routing_info->num_local_indx_segments > 0, "Software error in Routing_info::generate_routing_info_between_procs");
+	routing_info->local_indx_segment_starts = new int [routing_info->num_local_indx_segments];
+	routing_info->local_indx_segment_lengths = new int [routing_info->num_local_indx_segments];
+	routing_info->num_local_indx_segments = 0;
+	last_reference_local_index = -100;
+	for (int i = 0; i < num_local_routing_mapping_table_entries; i ++) {
+		if (last_reference_local_index + 1 != local_routing_mapping_table_entries[i].local_index) {
+			routing_info->local_indx_segment_starts[routing_info->num_local_indx_segments] = local_routing_mapping_table_entries[i].local_index;
+            routing_info->local_indx_segment_lengths[routing_info->num_local_indx_segments] = 1;
+            routing_info->num_local_indx_segments ++;
+		}
+		else routing_info->local_indx_segment_lengths[routing_info->num_local_indx_segments - 1] ++;
+        last_reference_local_index = local_routing_mapping_table_entries[i].local_index;
+	}
+
+    return routing_info;
+}
+
+
+void Routing_info::build_router_based_on_routing_mapping_tables()
+{
+    Routing_info_with_one_process *routing_info;
+
+    
+    if (current_proc_id_src_comp != -1) {
+		int *remote_proc_num_routing_mapping_table_entries = new int [dst_comp_node->get_num_procs()];
+		for (int i = 0; i < dst_comp_node->get_num_procs(); i ++)
+			remote_proc_num_routing_mapping_table_entries[i] = 0;
+        for (int i = 0; i < num_src_local_routing_mapping_table_entries; i ++)
+			remote_proc_num_routing_mapping_table_entries[src_local_routing_mapping_table_entries[i].remote_local_process_id] ++;
+		int offset = 0;
+        for (int i = 0; i < dst_comp_node->get_num_procs(); i ++) {
+            routing_info = generate_routing_info_between_procs(src_local_routing_mapping_table_entries+offset, remote_proc_num_routing_mapping_table_entries[i], dst_comp_node->get_local_proc_global_id(i), true);
+            send_to_remote_procs_routing_info.push_back(routing_info);
+			offset += remote_proc_num_routing_mapping_table_entries[i];
+        }
+		delete [] remote_proc_num_routing_mapping_table_entries;
+    }
+
+    if (current_proc_id_dst_comp != -1) {
+		int *remote_proc_num_routing_mapping_table_entries = new int [src_comp_node->get_num_procs()];
+		for (int i = 0; i < src_comp_node->get_num_procs(); i ++)
+			remote_proc_num_routing_mapping_table_entries[i] = 0;
+        for (int i = 0; i < num_dst_local_routing_mapping_table_entries; i ++)
+			remote_proc_num_routing_mapping_table_entries[dst_local_routing_mapping_table_entries[i].remote_local_process_id] ++;
+		int offset = 0;
+        for (int i = 0; i < src_comp_node->get_num_procs(); i ++) {
+            routing_info = generate_routing_info_between_procs(dst_local_routing_mapping_table_entries+offset, remote_proc_num_routing_mapping_table_entries[i], src_comp_node->get_local_proc_global_id(i), false);
+            recv_from_remote_procs_routing_info.push_back(routing_info);
+			offset += remote_proc_num_routing_mapping_table_entries[i];
+        }
+		delete [] remote_proc_num_routing_mapping_table_entries;
+    }
+
+//    if (src_local_routing_mapping_table_entries != NULL)
+//        delete [] src_local_routing_mapping_table_entries;
+//    if (dst_local_routing_mapping_table_entries != NULL)
+//        delete [] dst_local_routing_mapping_table_entries;
+}
+
+
 void Routing_info::build_2D_router()
 {
     int num_src_procs = src_comp_node->get_num_procs();
@@ -132,94 +780,143 @@ void Routing_info::build_2D_router()
     int src_comp_root_proc_global_id = src_comp_node->get_root_proc_global_id();
     int dst_comp_root_proc_global_id = dst_comp_node->get_root_proc_global_id();
     Routing_info_with_one_process *routing_info;
-	long total_src_cells, total_dst_cells;
-
+    long total_src_cells, total_dst_cells;
 
     if (current_proc_id_src_comp != -1) {
-		EXECUTION_REPORT(REPORT_ERROR, -1, src_decomp_info != NULL, "Software error in Routing_info::build_2D_router: NULL src decomp info");
+        EXECUTION_REPORT_ERROR_OPTIONALLY(REPORT_ERROR, -1, src_decomp_info != NULL, "Software error in Routing_info::build_2D_router: NULL src decomp info");
         num_local_src_cells = src_decomp_info->get_num_local_cells();
-		*num_global_src_cells = src_decomp_info->get_num_global_cells();
-		gather_array_in_one_comp(num_src_procs, current_proc_id_src_comp, (void*)src_decomp_info->get_local_cell_global_indx(), num_local_src_cells, 
-			                     sizeof(int), num_cells_each_src_proc, (void**)(&cells_indx_each_src_proc), total_src_cells, src_comp_node->get_comm_group());
+        *num_global_src_cells = src_decomp_info->get_num_global_cells();
+        gather_array_in_one_comp(num_src_procs, current_proc_id_src_comp, (void*)src_decomp_info->get_local_cell_global_indx(), num_local_src_cells, 
+                                 sizeof(int), num_cells_each_src_proc, (void**)(&cells_indx_each_src_proc), total_src_cells, src_comp_node->get_comm_group());
     }
     if (current_proc_id_dst_comp != -1) {
-		EXECUTION_REPORT(REPORT_ERROR, -1, dst_decomp_info != NULL, "Software error in Routing_info::build_2D_router: NULL dst decomp info");
+        EXECUTION_REPORT_ERROR_OPTIONALLY(REPORT_ERROR, -1, dst_decomp_info != NULL, "Software error in Routing_info::build_2D_router: NULL dst decomp info");
         num_local_dst_cells = dst_decomp_info->get_num_local_cells();
-		*num_global_dst_cells = dst_decomp_info->get_num_global_cells();
-		gather_array_in_one_comp(num_dst_procs, current_proc_id_dst_comp, (void*)dst_decomp_info->get_local_cell_global_indx(), num_local_dst_cells, 
-								 sizeof(int), num_cells_each_dst_proc, (void**)(&cells_indx_each_dst_proc), total_dst_cells, dst_comp_node->get_comm_group());
-    }
-
-	long temp_size = num_src_procs*sizeof(int);
-	transfer_array_from_one_comp_to_another(current_proc_id_src_comp, src_comp_root_proc_global_id, current_proc_id_dst_comp, dst_comp_root_proc_global_id, dst_comp_node->get_comm_group(), (char**)(&num_cells_each_src_proc), temp_size);
-	temp_size = num_dst_procs*sizeof(int);
-	transfer_array_from_one_comp_to_another(current_proc_id_dst_comp, dst_comp_root_proc_global_id, current_proc_id_src_comp, src_comp_root_proc_global_id, src_comp_node->get_comm_group(), (char**)(&num_cells_each_dst_proc), temp_size);
-	temp_size = sizeof(int);
-	transfer_array_from_one_comp_to_another(current_proc_id_src_comp, src_comp_root_proc_global_id, current_proc_id_dst_comp, dst_comp_root_proc_global_id, dst_comp_node->get_comm_group(), (char**)(&num_global_src_cells), temp_size);	
-	if (current_proc_id_dst_comp != -1)
-		EXECUTION_REPORT(REPORT_ERROR, -1, *num_global_src_cells == *num_global_dst_cells, "Software error in Routing_info::build_2D_router: different global decomp grid size: %d vs %d", *num_global_src_cells, *num_global_dst_cells);
-	total_src_cells = 0;
-	for (int i = 0; i < num_src_procs; i ++) 
-		total_src_cells += num_cells_each_src_proc[i] * sizeof(int);
-	total_dst_cells = 0;
-	for (int i = 0; i < num_dst_procs; i ++) 
-		total_dst_cells += num_cells_each_dst_proc[i] * sizeof(int);
-	transfer_array_from_one_comp_to_another(current_proc_id_src_comp, src_comp_root_proc_global_id, current_proc_id_dst_comp, dst_comp_root_proc_global_id, dst_comp_node->get_comm_group(), (char**)(&cells_indx_each_src_proc), total_src_cells);
-	transfer_array_from_one_comp_to_another(current_proc_id_dst_comp, dst_comp_root_proc_global_id, current_proc_id_src_comp, src_comp_root_proc_global_id, src_comp_node->get_comm_group(), (char**)(&cells_indx_each_dst_proc), total_dst_cells);
+        *num_global_dst_cells = dst_decomp_info->get_num_global_cells();
+        gather_array_in_one_comp(num_dst_procs, current_proc_id_dst_comp, (void*)dst_decomp_info->get_local_cell_global_indx(), num_local_dst_cells, 
+                                 sizeof(int), num_cells_each_dst_proc, (void**)(&cells_indx_each_dst_proc), total_dst_cells, dst_comp_node->get_comm_group());
+    }
+
+    long temp_size = num_src_procs*sizeof(int);
+    transfer_array_from_one_comp_to_another(current_proc_id_src_comp, src_comp_root_proc_global_id, current_proc_id_dst_comp, dst_comp_root_proc_global_id, dst_comp_node->get_comm_group(), (char**)(&num_cells_each_src_proc), temp_size);
+    temp_size = num_dst_procs*sizeof(int);
+    transfer_array_from_one_comp_to_another(current_proc_id_dst_comp, dst_comp_root_proc_global_id, current_proc_id_src_comp, src_comp_root_proc_global_id, src_comp_node->get_comm_group(), (char**)(&num_cells_each_dst_proc), temp_size);
+    temp_size = sizeof(int);
+    transfer_array_from_one_comp_to_another(current_proc_id_src_comp, src_comp_root_proc_global_id, current_proc_id_dst_comp, dst_comp_root_proc_global_id, dst_comp_node->get_comm_group(), (char**)(&num_global_src_cells), temp_size);    
+    if (current_proc_id_dst_comp != -1)
+        EXECUTION_REPORT_ERROR_OPTIONALLY(REPORT_ERROR, -1, *num_global_src_cells == *num_global_dst_cells, "Software error in Routing_info::build_2D_router: different global decomp grid size: %d vs %d", *num_global_src_cells, *num_global_dst_cells);
+    total_src_cells = 0;
+    for (int i = 0; i < num_src_procs; i ++) 
+        total_src_cells += num_cells_each_src_proc[i] * sizeof(int);
+    total_dst_cells = 0;
+    for (int i = 0; i < num_dst_procs; i ++) 
+        total_dst_cells += num_cells_each_dst_proc[i] * sizeof(int);
+    transfer_array_from_one_comp_to_another(current_proc_id_src_comp, src_comp_root_proc_global_id, current_proc_id_dst_comp, dst_comp_root_proc_global_id, dst_comp_node->get_comm_group(), (char**)(&cells_indx_each_src_proc), total_src_cells);
+    transfer_array_from_one_comp_to_another(current_proc_id_dst_comp, dst_comp_root_proc_global_id, current_proc_id_src_comp, src_comp_root_proc_global_id, src_comp_node->get_comm_group(), (char**)(&cells_indx_each_dst_proc), total_dst_cells);
+
+	logical_indx_lookup_table_remote = new int [*num_global_src_cells];
+	logical_indx_lookup_table_local = new int [*num_global_src_cells];
+	for (int j = 0; j < *num_global_src_cells; j ++) {
+			logical_indx_lookup_table_local[j] = -1;
+			logical_indx_lookup_table_remote[j] = -1;
+	}
 	
     if (current_proc_id_src_comp != -1) {
+        int *temp_num_cells_each_dst_proc_disp = new int [num_dst_procs];
+        int *temp_num_cells_each_dst_proc_count = new int [num_dst_procs];
+        for (int i = 0; i < num_dst_procs; i ++) {
+            temp_num_cells_each_dst_proc_disp[i] = 0;
+            temp_num_cells_each_dst_proc_count[i] = 0;
+        }
+        int last_dst_proc = -1;
+        for (int i = 0; i < num_src_local_routing_mapping_table_entries; i ++) {
+            if (src_local_routing_mapping_table_entries[i].remote_local_process_id != last_dst_proc) {
+                last_dst_proc = src_local_routing_mapping_table_entries[i].remote_local_process_id;
+                temp_num_cells_each_dst_proc_disp[last_dst_proc] = i; 
+            }
+            temp_num_cells_each_dst_proc_count[last_dst_proc] ++;
+        }
+
         int tmp_displs = 0;
         for (int i = 0; i < num_dst_procs; i ++) {
             routing_info = compute_routing_info_between_decomps(num_local_src_cells, src_decomp_info->get_local_cell_global_indx(), num_cells_each_dst_proc[i], cells_indx_each_dst_proc+tmp_displs, 
-                                                                src_decomp_info->get_num_global_cells(), comp_comm_group_mgt_mgr->get_current_proc_global_id(), dst_comp_node->get_local_proc_global_id(i), true);
+                                                                src_decomp_info->get_num_global_cells(), comp_comm_group_mgt_mgr->get_current_proc_global_id(), dst_comp_node->get_local_proc_global_id(i), true,
+                                                                src_local_routing_mapping_table_entries+temp_num_cells_each_dst_proc_disp[i], temp_num_cells_each_dst_proc_count[i]);
+            
             tmp_displs += num_cells_each_dst_proc[i];
-			send_to_remote_procs_routing_info.push_back(routing_info);
+			if (routing_info != NULL)
+	            send_to_remote_procs_routing_info.push_back(routing_info);
         }
+		delete [] temp_num_cells_each_dst_proc_disp;
+		delete [] temp_num_cells_each_dst_proc_count;
     }
-
+	
     if (current_proc_id_dst_comp != -1) {
+        int *temp_num_cells_each_src_proc_disp = new int [num_src_procs];
+        int *temp_num_cells_each_src_proc_count = new int [num_src_procs];
+        for (int i = 0; i < num_src_procs; i ++) {
+            temp_num_cells_each_src_proc_disp[i] = 0;
+            temp_num_cells_each_src_proc_count[i] = 0;
+        }
+        int last_src_proc = -1;
+        for (int i = 0; i < num_dst_local_routing_mapping_table_entries; i ++) {
+            if (dst_local_routing_mapping_table_entries[i].remote_local_process_id != last_src_proc) {
+                last_src_proc = dst_local_routing_mapping_table_entries[i].remote_local_process_id;
+                temp_num_cells_each_src_proc_disp[last_src_proc] = i; 
+            }
+            temp_num_cells_each_src_proc_count[last_src_proc] ++;
+        }
+
         int tmp_displs = 0;
         for (int i = 0; i < num_src_procs; i ++) {
             routing_info = compute_routing_info_between_decomps(num_local_dst_cells, dst_decomp_info->get_local_cell_global_indx(), num_cells_each_src_proc[i], cells_indx_each_src_proc+tmp_displs, 
-                                                                dst_decomp_info->get_num_global_cells(), comp_comm_group_mgt_mgr->get_current_proc_global_id(), src_comp_node->get_local_proc_global_id(i), false);
+                                                                dst_decomp_info->get_num_global_cells(), comp_comm_group_mgt_mgr->get_current_proc_global_id(), src_comp_node->get_local_proc_global_id(i), false,
+                                                                dst_local_routing_mapping_table_entries+temp_num_cells_each_src_proc_disp[i], temp_num_cells_each_src_proc_count[i]);
             tmp_displs += num_cells_each_src_proc[i];
-			recv_from_remote_procs_routing_info.push_back(routing_info);
+			if (routing_info != NULL)
+	            recv_from_remote_procs_routing_info.push_back(routing_info);
         }
     }
-    
+
+    delete [] logical_indx_lookup_table_remote;
+    delete [] logical_indx_lookup_table_local;
+
+    if (src_local_routing_mapping_table_entries != NULL)
+        delete [] src_local_routing_mapping_table_entries;
+    if (dst_local_routing_mapping_table_entries != NULL)
+        delete [] dst_local_routing_mapping_table_entries;
     if (cells_indx_each_src_proc != NULL) 
-		delete [] cells_indx_each_src_proc;
+        delete [] cells_indx_each_src_proc;
     if (cells_indx_each_dst_proc != NULL) 
-		delete [] cells_indx_each_dst_proc;
+        delete [] cells_indx_each_dst_proc;
     delete [] num_cells_each_src_proc; 
     delete [] num_cells_each_dst_proc;
-	delete [] num_global_src_cells;
-	delete [] num_global_dst_cells;
+    delete [] num_global_src_cells;
+    delete [] num_global_dst_cells;
 }
 
 
 Routing_info_with_one_process *Routing_info::compute_routing_info_between_decomps(int num_local_cells_local, const int *local_cells_global_indexes_local, 
                                                   int num_local_cells_remote, const int *local_cells_global_indexes_remote, 
-                                                  int num_global_cells, int local_proc_id, int remote_proc_id, bool is_src)
+                                                  int num_global_cells, int local_proc_id, int remote_proc_id, bool is_src,
+                                                  routing_mapping_table_entry* local_routing_mapping_table_entries, int routing_mapping_table_entries_count)
 {
     Routing_info_with_one_process *routing_info;
     const int *reference_cell_indx;
-    int *logical_indx_lookup_table_local, *logical_indx_lookup_table_remote; 
     int num_reference_cells;
     int last_local_logical_indx;
     int j;
 
-
     routing_info = new Routing_info_with_one_process;
     routing_info->num_elements_transferred = 0;
     routing_info->num_local_indx_segments = 0;
     routing_info->remote_proc_global_id = remote_proc_id;
 
-	if (num_local_cells_local == 0)
-		return routing_info;
+    if (num_local_cells_local == 0)
+        return routing_info;
     
     /* Determine the reference cell index table according to the table size */
-    if (num_local_cells_remote < num_local_cells_local || (num_local_cells_remote == num_local_cells_local && is_src)) {
+    if (is_src) {
         reference_cell_indx = local_cells_global_indexes_remote;
         num_reference_cells = num_local_cells_remote;  
     }
@@ -227,31 +924,40 @@ Routing_info_with_one_process *Routing_info::compute_routing_info_between_decomp
         reference_cell_indx = local_cells_global_indexes_local;
         num_reference_cells = num_local_cells_local; 
     }
-
-    logical_indx_lookup_table_remote = new int [num_global_cells];
-    logical_indx_lookup_table_local = new int [num_global_cells];
-    for (j = 0; j < num_global_cells; j ++) {
-        logical_indx_lookup_table_local[j] = -1;
-        logical_indx_lookup_table_remote[j] = -1;
-    }
     
     for (j = 0; j < num_local_cells_local; j ++)
-		if (local_cells_global_indexes_local[j] >= 0)
-			if (local_cells_global_indexes_local[j] != CCPL_NULL_INT)
-		    	logical_indx_lookup_table_local[local_cells_global_indexes_local[j]] = j;
+        if (local_cells_global_indexes_local[j] >= 0)
+            if (local_cells_global_indexes_local[j] != CCPL_NULL_INT)
+                logical_indx_lookup_table_local[local_cells_global_indexes_local[j]] = j;
     for (j = 0; j < num_local_cells_remote; j ++)
-		if (local_cells_global_indexes_remote[j] >= 0)
-			if (local_cells_global_indexes_remote[j] != CCPL_NULL_INT)
-		        logical_indx_lookup_table_remote[local_cells_global_indexes_remote[j]] = j;
+        if (local_cells_global_indexes_remote[j] >= 0)
+            if (local_cells_global_indexes_remote[j] != CCPL_NULL_INT)
+                logical_indx_lookup_table_remote[local_cells_global_indexes_remote[j]] = j;
+
+    if (is_src)
+        for (int i = 0; i < routing_mapping_table_entries_count; i ++)
+            local_routing_mapping_table_entries[i].key = local_routing_mapping_table_entries[i].remote_local_index;
+    else
+        for (int i = 0; i < routing_mapping_table_entries_count; i ++)
+            local_routing_mapping_table_entries[i].key = local_routing_mapping_table_entries[i].local_index;
+    do_quick_sort(local_routing_mapping_table_entries, (int*)NULL, 0, routing_mapping_table_entries_count-1);
 
     /* Compute the number of common cells and the number of segments of common cells */
     last_local_logical_indx = -100;
     for (j = 0; j < num_reference_cells; j ++) 
         if (reference_cell_indx[j] != CCPL_NULL_INT && logical_indx_lookup_table_local[reference_cell_indx[j]] != -1 && logical_indx_lookup_table_remote[reference_cell_indx[j]] != -1) {
-            if (last_local_logical_indx + 1 != logical_indx_lookup_table_local[reference_cell_indx[j]]) 
-                routing_info->num_local_indx_segments ++;
-            last_local_logical_indx = logical_indx_lookup_table_local[reference_cell_indx[j]];
-            routing_info->num_elements_transferred ++;
+            if (reference_cell_indx == local_cells_global_indexes_local) {
+                if (last_local_logical_indx + 1 != j) 
+                    routing_info->num_local_indx_segments ++;
+                last_local_logical_indx = j; 
+                routing_info->num_elements_transferred ++;
+            }
+            else {
+                if (last_local_logical_indx + 1 != logical_indx_lookup_table_local[reference_cell_indx[j]]) 
+                    routing_info->num_local_indx_segments ++;
+                last_local_logical_indx = logical_indx_lookup_table_local[reference_cell_indx[j]];
+                routing_info->num_elements_transferred ++;
+            }
         }
 
     /* Compute the info of segments when there are common cells */
@@ -262,39 +968,55 @@ Routing_info_with_one_process *Routing_info::compute_routing_info_between_decomp
         routing_info->num_local_indx_segments = 0;
         for (j = 0; j < num_reference_cells; j ++) 
             if (reference_cell_indx[j] != CCPL_NULL_INT && logical_indx_lookup_table_local[reference_cell_indx[j]] != -1 && logical_indx_lookup_table_remote[reference_cell_indx[j]] != -1) {
-                if (last_local_logical_indx + 1 != logical_indx_lookup_table_local[reference_cell_indx[j]]) {
-                    routing_info->local_indx_segment_starts[routing_info->num_local_indx_segments] = logical_indx_lookup_table_local[reference_cell_indx[j]];
-                    routing_info->local_indx_segment_lengths[routing_info->num_local_indx_segments] = 1;
-                    routing_info->num_local_indx_segments ++;
+                if (reference_cell_indx == local_cells_global_indexes_local) {
+                    if (last_local_logical_indx + 1 != j) {
+                        routing_info->local_indx_segment_starts[routing_info->num_local_indx_segments] = j;
+                        routing_info->local_indx_segment_lengths[routing_info->num_local_indx_segments] = 1;
+                        routing_info->num_local_indx_segments ++;
+                    }
+                    else routing_info->local_indx_segment_lengths[routing_info->num_local_indx_segments - 1] ++;
+                    last_local_logical_indx = j;
+                }
+                else {
+                    if (last_local_logical_indx + 1 != logical_indx_lookup_table_local[reference_cell_indx[j]]) {
+                        routing_info->local_indx_segment_starts[routing_info->num_local_indx_segments] = logical_indx_lookup_table_local[reference_cell_indx[j]];
+                        routing_info->local_indx_segment_lengths[routing_info->num_local_indx_segments] = 1;
+                        routing_info->num_local_indx_segments ++;
+                    }
+                    else routing_info->local_indx_segment_lengths[routing_info->num_local_indx_segments - 1] ++;
+                    last_local_logical_indx = logical_indx_lookup_table_local[reference_cell_indx[j]];
                 }
-                else routing_info->local_indx_segment_lengths[routing_info->num_local_indx_segments - 1] ++;
-                last_local_logical_indx = logical_indx_lookup_table_local[reference_cell_indx[j]];
             }
     }
 
-    delete [] logical_indx_lookup_table_remote;
-    delete [] logical_indx_lookup_table_local;
 
-	return routing_info;
+    for (j = 0; j < num_local_cells_local; j ++)
+        if (local_cells_global_indexes_local[j] >= 0 && local_cells_global_indexes_local[j] != CCPL_NULL_INT)
+                        logical_indx_lookup_table_local[local_cells_global_indexes_local[j]] = -1;
+    for (j = 0; j < num_local_cells_remote; j ++)
+        if (local_cells_global_indexes_remote[j] >= 0 && local_cells_global_indexes_remote[j] != CCPL_NULL_INT)
+            logical_indx_lookup_table_remote[local_cells_global_indexes_remote[j]] = -1;
+
+    return routing_info;
 }
 
 
 Routing_info_with_one_process *Routing_info::get_routing_info(bool is_send, int i)
 {
-	if (is_send) {
-		EXECUTION_REPORT(REPORT_ERROR, -1, i >= 0 && i < send_to_remote_procs_routing_info.size(), "Software error in Routing_info::get_num_elements_transferred_with_remote_proc: wrong i at sender");
-		return send_to_remote_procs_routing_info[i];
-	}
-	else {
-		EXECUTION_REPORT(REPORT_ERROR, -1, i >= 0 && i < recv_from_remote_procs_routing_info.size(), "Software error in Routing_info::get_num_elements_transferred_with_remote_proc: wrong i at receiver");
-		return recv_from_remote_procs_routing_info[i];
-	}
+    if (is_send) {
+        EXECUTION_REPORT_ERROR_OPTIONALLY(REPORT_ERROR, -1, i >= 0 && i < send_to_remote_procs_routing_info.size(), "Software error in Routing_info::get_num_elements_transferred_with_remote_proc: wrong i at sender");
+        return send_to_remote_procs_routing_info[i];
+    }
+    else {
+        EXECUTION_REPORT_ERROR_OPTIONALLY(REPORT_ERROR, -1, i >= 0 && i < recv_from_remote_procs_routing_info.size(), "Software error in Routing_info::get_num_elements_transferred_with_remote_proc: wrong i at receiver");
+        return recv_from_remote_procs_routing_info[i];
+    }
 }
 
 
 Comp_comm_group_mgt_node *Routing_info::get_src_comp_node() 
 { 
-	return comp_comm_group_mgt_mgr->search_global_node(src_comp_full_name); 
+    return comp_comm_group_mgt_mgr->search_global_node(src_comp_full_name); 
 }
 
 
@@ -302,5 +1024,3 @@ Comp_comm_group_mgt_node *Routing_info::get_dst_comp_node()
 { 
     return comp_comm_group_mgt_mgr->search_global_node(true_dst_comp_full_name); 
 }
-
-
diff --git a/src/Parallel_MGT/routing_info_mgt.h b/src/Parallel_MGT/routing_info_mgt.h
index ee70f8b..24794f2 100644
--- a/src/Parallel_MGT/routing_info_mgt.h
+++ b/src/Parallel_MGT/routing_info_mgt.h
@@ -16,8 +16,23 @@
 #include "common_utils.h" 
 #include "decomp_info_mgt.h"
 #include "compset_communicators_info_mgt.h"
+#include "quick_sort.h"
 #include <vector>
 
+struct routing_mapping_table_entry
+{
+    int key;
+    int global_index;         
+    int local_index;          
+    int local_process_id;       
+    int remote_local_index;   
+    int remote_local_process_id;
+
+    bool operator<(const routing_mapping_table_entry b) const { return this->key < b.key; }
+    bool operator>(const routing_mapping_table_entry b) const { return this->key > b.key; }   
+    bool operator==(const routing_mapping_table_entry b) const { return this->key == b.key; }
+};
+
 
 struct Routing_info_with_one_process
 {
@@ -35,51 +50,75 @@ class Routing_info
     private:
         int src_comp_id;
         int dst_comp_id;
-		char src_comp_full_name[NAME_STR_SIZE];
-		char index_dst_comp_full_name[NAME_STR_SIZE];
+        char src_comp_full_name[NAME_STR_SIZE];
+        char index_dst_comp_full_name[NAME_STR_SIZE];
         char true_dst_comp_full_name[NAME_STR_SIZE];
         char src_decomp_name[NAME_STR_SIZE];
         char dst_decomp_name[NAME_STR_SIZE];
         int src_decomp_size;
         int dst_decomp_size;
-		Decomp_info *src_decomp_info;
-		Decomp_info *dst_decomp_info;
+        Decomp_info *src_decomp_info;
+        Decomp_info *dst_decomp_info;
         Comp_comm_group_mgt_node * src_comp_node;
         Comp_comm_group_mgt_node * dst_comp_node;
-		int src_comp_node_id;
-		int dst_comp_node_id;
-		int current_proc_id_src_comp;
-		int current_proc_id_dst_comp;
+        int src_comp_node_id;
+        int dst_comp_node_id;
+        int current_proc_id_src_comp;
+        int current_proc_id_dst_comp;
         char remote_comp_name[NAME_STR_SIZE];
         char local_decomp_name[NAME_STR_SIZE];
         char remote_decomp_name[NAME_STR_SIZE];
         int num_dimensions;
         int total_num_transferred_cells;
         long local_decomp_size;
-		long remap_decomp_size;
+        long remap_decomp_size;
+        int *logical_indx_lookup_table_local;
+        int *logical_indx_lookup_table_remote;
         std::vector<Routing_info_with_one_process *> recv_from_remote_procs_routing_info;
-		std::vector<Routing_info_with_one_process *> send_to_remote_procs_routing_info;
+        std::vector<Routing_info_with_one_process *> send_to_remote_procs_routing_info;
 
-    public:
+        routing_mapping_table_entry *src_local_routing_mapping_table_entries;
+		routing_mapping_table_entry *dst_local_routing_mapping_table_entries;
+        routing_mapping_table_entry *src_remote_routing_mapping_table_entries;
+		routing_mapping_table_entry *dst_remote_routing_mapping_table_entries;
+        int num_src_local_routing_mapping_table_entries;
+		int num_dst_local_routing_mapping_table_entries;
+        int num_src_remote_routing_mapping_table_entries;
+		int num_dst_remote_routing_mapping_table_entries;
+		
+public:
         Routing_info(const int, const int, const char*, const char*);
         ~Routing_info();
         Routing_info_with_one_process *get_routing_info(bool, int);
         int get_num_elements_transferred_with_remote_proc(bool is_send, int i) { return get_routing_info(is_send,i)->num_elements_transferred; }
-		int *get_local_indx_segment_starts_with_remote_proc(bool is_send, int i) { return get_routing_info(is_send,i)->local_indx_segment_starts; }
-		int *get_local_indx_segment_lengths_with_remote_proc(bool is_send, int i) { return get_routing_info(is_send,i)->local_indx_segment_lengths; }
-		int get_num_local_indx_segments_with_remote_proc(bool is_send, int i) { return get_routing_info(is_send,i)->num_local_indx_segments; }
+        int *get_local_indx_segment_starts_with_remote_proc(bool is_send, int i) { return get_routing_info(is_send,i)->local_indx_segment_starts; }
+        int *get_local_indx_segment_lengths_with_remote_proc(bool is_send, int i) { return get_routing_info(is_send,i)->local_indx_segment_lengths; }
+        int get_num_local_indx_segments_with_remote_proc(bool is_send, int i) { return get_routing_info(is_send,i)->num_local_indx_segments; }
         bool match_router(const int, const int, const char*, const char*);
         int get_num_dimensions() { return num_dimensions; }
         long get_local_decomp_size() { return local_decomp_size; }
-		long get_remap_decomp_size() { return remap_decomp_size; }
+        long get_remap_decomp_size() { return remap_decomp_size; }
         Comp_comm_group_mgt_node *get_src_comp_node();
         Comp_comm_group_mgt_node *get_dst_comp_node();
         long get_src_decomp_size() { return src_decomp_size; }
         long get_dst_decomp_size() { return dst_decomp_size; }
         
     private:
+        void intersect_routing_mapping_tables_between_components(routing_mapping_table_entry**, routing_mapping_table_entry*, int*, int, bool);
+        void initialize_routing_mapping_table(routing_mapping_table_entry**, Decomp_info*, Comp_comm_group_mgt_node*, int*, int, int, int );
+        void exchange_routing_mapping_tables_between_components(int, int, Decomp_info*, bool);
+        void sort_routing_mapping_table_entries(routing_mapping_table_entry**, Decomp_info*, Comp_comm_group_mgt_node*, int*, int, int, int, int, int);
+        void output_routing_mapping_table(routing_mapping_table_entry*, char*, int, int);
+        void check_routing_mapping_table_entries(routing_mapping_table_entry*, int, int, int, char*);
+        void calculate_min_max_grid_index(int, int, int, int, int, int*, int*);	
+		void exchange_routing_mapping_tables_between_processes(int, routing_mapping_table_entry **, routing_mapping_table_entry **, int *, int *, int *, int *, MPI_Comm comm, int *);
+        int calculate_max_power2(int);
+        void merge_routing_mapping_tables(routing_mapping_table_entry**, routing_mapping_table_entry*, int, int, int, int, int*);
+        void calculate_routing_mapping_tables();
+		void build_router_based_on_routing_mapping_tables();
         void build_2D_router();
-        Routing_info_with_one_process *compute_routing_info_between_decomps(int, const int*, int, const int*, int, int, int, bool);
+        Routing_info_with_one_process *compute_routing_info_between_decomps(int, const int*, int, const int*, int, int, int, bool, routing_mapping_table_entry*, int);		
+		Routing_info_with_one_process *generate_routing_info_between_procs(routing_mapping_table_entry *, int, int, bool);
 };
 
 
diff --git a/src/Runtime_MGT/Runtime_Algorithm_Basis.cxx b/src/Runtime_MGT/Runtime_Algorithm_Basis.cxx
old mode 100644
new mode 100755
index 43df877..fa00989
--- a/src/Runtime_MGT/Runtime_Algorithm_Basis.cxx
+++ b/src/Runtime_MGT/Runtime_Algorithm_Basis.cxx
@@ -20,39 +20,39 @@ Runtime_algorithm_basis::Runtime_algorithm_basis()
 {
     num_src_fields = 0;
     num_dst_fields = 0;
-	cumulate_average_algorithm_before_run = NULL;
-	algorithm_id = global_algorithm_id;
-	global_algorithm_id ++;
+    cumulate_average_algorithm_before_run = NULL;
+    algorithm_id = global_algorithm_id;
+    global_algorithm_id ++;
 
     comp_names = NULL;
-	field_names = NULL;
-	field_local_decomp_names = NULL;
-	field_grid_names = NULL;
-	buf_marks = NULL;
-	average_mark = NULL;
+    field_names = NULL;
+    field_local_decomp_names = NULL;
+    field_grid_names = NULL;
+    buf_marks = NULL;
+    average_mark = NULL;
 }
 
 
 Runtime_algorithm_basis::~Runtime_algorithm_basis()
 {
-//	if (num_src_fields + num_dst_fields > 0)
-//		EXECUTION_REPORT(REPORT_ERROR,-1, comp_names == NULL && field_names == NULL && field_local_decomp_names == NULL && field_grid_names == NULL && buf_marks == NULL && average_mark == NULL, "C-Coupler software error when deleting Runtime_algorithm_basis");
-
-	if (comp_names == NULL)
-		return;
-
-	for (int i = 0; i < num_src_fields+num_dst_fields; i ++) {
-		delete [] comp_names[i];
-		delete [] field_names[i];
-		delete [] field_local_decomp_names[i];
-		delete [] field_grid_names[i];
-	}
-	delete [] comp_names;
-	delete [] field_names;
-	delete [] field_local_decomp_names;
-	delete [] field_grid_names;
-	delete [] buf_marks;
-	delete [] average_mark;
+//    if (num_src_fields + num_dst_fields > 0)
+//        EXECUTION_REPORT(REPORT_ERROR,-1, comp_names == NULL && field_names == NULL && field_local_decomp_names == NULL && field_grid_names == NULL && buf_marks == NULL && average_mark == NULL, "C-Coupler software error when deleting Runtime_algorithm_basis");
+
+    if (comp_names == NULL)
+        return;
+
+    for (int i = 0; i < num_src_fields+num_dst_fields; i ++) {
+        delete [] comp_names[i];
+        delete [] field_names[i];
+        delete [] field_local_decomp_names[i];
+        delete [] field_grid_names[i];
+    }
+    delete [] comp_names;
+    delete [] field_names;
+    delete [] field_local_decomp_names;
+    delete [] field_grid_names;
+    delete [] buf_marks;
+    delete [] average_mark;
 }
 
 
@@ -65,11 +65,11 @@ void Runtime_algorithm_basis::runtime_algorithm_common_initialize(const int num_
 
 void Runtime_algorithm_basis::cumulate_average_before_run(bool is_algorithm_in_kernel_stage)
 {
-	if (cumulate_average_algorithm_before_run != NULL) {
-		EXECUTION_REPORT_LOG(REPORT_LOG,-1, true, "before implicit cumulating and averaging");
-		cumulate_average_algorithm_before_run->run(is_algorithm_in_kernel_stage);
-		EXECUTION_REPORT_LOG(REPORT_LOG,-1, true, "after implicit cumulating and averaging");
-	}
+    if (cumulate_average_algorithm_before_run != NULL) {
+        EXECUTION_REPORT_LOG(REPORT_LOG,-1, true, "before implicit cumulating and averaging");
+        cumulate_average_algorithm_before_run->run(is_algorithm_in_kernel_stage);
+        EXECUTION_REPORT_LOG(REPORT_LOG,-1, true, "after implicit cumulating and averaging");
+    }
 }
 
 
@@ -84,30 +84,30 @@ void Runtime_algorithm_basis::transfer_fields_data_type_after_run()
 
 
 void Runtime_algorithm_basis::allocate_basic_data_structure(int num_src_fields, int num_dst_fields)
-{	
-	this->num_src_fields = num_src_fields;
-	this->num_dst_fields = num_dst_fields;
+{    
+    this->num_src_fields = num_src_fields;
+    this->num_dst_fields = num_dst_fields;
 
-	EXECUTION_REPORT(REPORT_ERROR,-1, num_src_fields >= 0 && num_dst_fields >= 0,
-					 "C-Coupler software error in allocate_basic_data_structure for Runtime_algorithm_basis");
+    EXECUTION_REPORT(REPORT_ERROR,-1, num_src_fields >= 0 && num_dst_fields >= 0,
+                     "C-Coupler software error in allocate_basic_data_structure for Runtime_algorithm_basis");
 
-	if (num_src_fields + num_dst_fields == 0)
-		return;
+    if (num_src_fields + num_dst_fields == 0)
+        return;
 
-	comp_names = new char* [num_src_fields+num_dst_fields];
-	field_names = new char* [num_src_fields+num_dst_fields];
+    comp_names = new char* [num_src_fields+num_dst_fields];
+    field_names = new char* [num_src_fields+num_dst_fields];
     field_local_decomp_names = new char* [num_src_fields+num_dst_fields];
     field_grid_names = new char* [num_src_fields+num_dst_fields];
-	buf_marks = new int [num_src_fields+num_dst_fields];
-	average_mark = new bool [num_src_fields+num_dst_fields];	
+    buf_marks = new int [num_src_fields+num_dst_fields];
+    average_mark = new bool [num_src_fields+num_dst_fields];    
 
-	for (int i = 0; i < num_src_fields+num_dst_fields; i ++) {
-		comp_names[i] = new char [NAME_STR_SIZE];
-		field_names[i] = new char [NAME_STR_SIZE];
+    for (int i = 0; i < num_src_fields+num_dst_fields; i ++) {
+        comp_names[i] = new char [NAME_STR_SIZE];
+        field_names[i] = new char [NAME_STR_SIZE];
         field_local_decomp_names[i] = new char [NAME_STR_SIZE];
         field_grid_names[i] = new char [NAME_STR_SIZE];
-		buf_marks[i] = -1;
-		average_mark[i] = false;
-	}
+        buf_marks[i] = -1;
+        average_mark[i] = false;
+    }
 }
 
diff --git a/src/Runtime_MGT/Runtime_Algorithm_Basis.h b/src/Runtime_MGT/Runtime_Algorithm_Basis.h
old mode 100644
new mode 100755
index b9f9bfc..1b0a38d
--- a/src/Runtime_MGT/Runtime_Algorithm_Basis.h
+++ b/src/Runtime_MGT/Runtime_Algorithm_Basis.h
@@ -22,21 +22,21 @@ class Runtime_cumulate_average_algorithm;
 class Runtime_algorithm_basis
 {
     protected:
-		int algorithm_id;
-		char algorithm_cfg_name[NAME_STR_SIZE];
-		bool fields_allocated;
+        int algorithm_id;
+        char algorithm_cfg_name[NAME_STR_SIZE];
+        bool fields_allocated;
         int num_src_fields;
         int num_dst_fields;
-		char **comp_names;
-		char **field_names;
+        char **comp_names;
+        char **field_names;
         char **field_local_decomp_names;
         char **field_grid_names;
-		int *buf_marks;
-		bool *average_mark;
+        int *buf_marks;
+        bool *average_mark;
 
-		int comp_id;
+        int comp_id;
 
-		Runtime_cumulate_average_algorithm *cumulate_average_algorithm_before_run;
+        Runtime_cumulate_average_algorithm *cumulate_average_algorithm_before_run;
 
         void runtime_algorithm_common_initialize(const int, const int);
 
@@ -44,12 +44,12 @@ class Runtime_algorithm_basis
         Runtime_algorithm_basis();
         virtual ~Runtime_algorithm_basis();
         virtual bool run(bool) = 0;
-		virtual void allocate_src_dst_fields(bool) = 0;
-//		virtual void generate_algorithm_info_from_cfg_file() = 0;
-		void allocate_basic_data_structure(int, int);
-		void transfer_fields_data_type_before_run();
-		void transfer_fields_data_type_after_run();
-		void cumulate_average_before_run(bool);
+        virtual void allocate_src_dst_fields(bool) = 0;
+//        virtual void generate_algorithm_info_from_cfg_file() = 0;
+        void allocate_basic_data_structure(int, int);
+        void transfer_fields_data_type_before_run();
+        void transfer_fields_data_type_after_run();
+        void cumulate_average_before_run(bool);
 };
 
 extern int global_algorithm_id;
diff --git a/src/Runtime_MGT/coupling_generator.cxx b/src/Runtime_MGT/coupling_generator.cxx
old mode 100644
new mode 100755
index 42e009b..a90b748
--- a/src/Runtime_MGT/coupling_generator.cxx
+++ b/src/Runtime_MGT/coupling_generator.cxx
@@ -16,11 +16,11 @@
 
 void clean_string_pair_vector(std::vector< std::pair<const char*, const char *> > &string_pair_vector)
 {
-	for (int i = 0; i < string_pair_vector.size(); i ++) {
-		delete [] string_pair_vector[i].first;
-		delete [] string_pair_vector[i].second;
-	}
-	string_pair_vector.clear();
+    for (int i = 0; i < string_pair_vector.size(); i ++) {
+        delete [] string_pair_vector[i].first;
+        delete [] string_pair_vector[i].second;
+    }
+    string_pair_vector.clear();
 }
 
 
@@ -33,7 +33,7 @@ MPI_Comm create_union_comm_common(MPI_Comm comp1, MPI_Comm comm2, int current_pr
     int intersection_size;
     int comp_num_procs1 = procs_global_ids1.size();
     int comp_num_procs2 = procs_global_ids2.size();
-	
+    
 
     proc_ranks1 = new int[comp_num_procs1];
     proc_ranks2 = new int[comp_num_procs2];
@@ -43,10 +43,10 @@ MPI_Comm create_union_comm_common(MPI_Comm comp1, MPI_Comm comm2, int current_pr
     for (int i = 0; i < comp_num_procs2; i ++)
         proc_ranks2[i] = procs_global_ids2[i];
 
-	if (current_proc_id1 != -1)
-		MPI_Barrier(comp1);
-	if (current_proc_id2 != -1)
-		MPI_Barrier(comm2);
+    if (current_proc_id1 != -1)
+        MPI_Barrier(comp1);
+    if (current_proc_id2 != -1)
+        MPI_Barrier(comm2);
 
     MPI_Comm_group(MPI_COMM_WORLD, &common_group);
     MPI_Group_incl(common_group, comp_num_procs1, proc_ranks1, &comm_group1);
@@ -75,7 +75,7 @@ MPI_Comm create_union_comm_common(MPI_Comm comp1, MPI_Comm comm2, int current_pr
         if (current_proc_id2 != -1) {
             int color = 1;
             if (current_proc_id1 != -1) 
-				color = 0;
+                color = 0;
             MPI_Comm_split(comm2, color, 0, &exclusive_comm);
         }
         if (current_proc_id1 != -1) {
@@ -96,88 +96,88 @@ MPI_Comm create_union_comm_common(MPI_Comm comp1, MPI_Comm comm2, int current_pr
     }
 
     for (int i = 0; i < comp_num_procs1; i ++) 
-		proc_ranks1[i] = i;
+        proc_ranks1[i] = i;
     for (int i = 0; i < comp_num_procs2; i ++) 
-		proc_ranks2[i] = i;
+        proc_ranks2[i] = i;
 
     MPI_Comm_group(union_comm, &union_group);
-	if (proc_ranks_in_union_comm1 != NULL)
-	    MPI_Group_translate_ranks(comm_group1, comp_num_procs1, proc_ranks1, union_group, proc_ranks_in_union_comm1);
-	if (proc_ranks_in_union_comm2 != NULL)
-	    MPI_Group_translate_ranks(comm_group2, comp_num_procs2, proc_ranks2, union_group, proc_ranks_in_union_comm2);
+    if (proc_ranks_in_union_comm1 != NULL)
+        MPI_Group_translate_ranks(comm_group1, comp_num_procs1, proc_ranks1, union_group, proc_ranks_in_union_comm1);
+    if (proc_ranks_in_union_comm2 != NULL)
+        MPI_Group_translate_ranks(comm_group2, comp_num_procs2, proc_ranks2, union_group, proc_ranks_in_union_comm2);
 
     delete [] proc_ranks1;
     delete [] proc_ranks2;
 
-	return union_comm;
+    return union_comm;
 }
 
 
 Coupling_connection::Coupling_connection(int id)
 {
-	import_interface = NULL;
-	export_interface = NULL;
-	import_procedure = NULL;
-	export_procedure = NULL;
-	connection_id = id;
+    import_interface = NULL;
+    export_interface = NULL;
+    import_procedure = NULL;
+    export_procedure = NULL;
+    connection_id = id;
     union_comm = MPI_COMM_NULL;
     src_proc_ranks_in_union_comm = NULL;
     dst_proc_ranks_in_union_comm = NULL;
-	if (connection_id > coupling_generator->get_latest_connection_id())
-		coupling_generator->set_latest_connection_id(connection_id);
+    if (connection_id > coupling_generator->get_latest_connection_id())
+        coupling_generator->set_latest_connection_id(connection_id);
 }
 
 
 Coupling_connection::~Coupling_connection()
 {
-	clean_string_pair_vector(src_comp_interfaces);
+    clean_string_pair_vector(src_comp_interfaces);
 }
 
 
 void Coupling_connection::generate_a_coupling_procedure(bool has_frac_remapping)
 {
-	src_comp_node = comp_comm_group_mgt_mgr->search_global_node(src_comp_interfaces[0].first);
-	dst_comp_node =comp_comm_group_mgt_mgr->search_global_node(dst_comp_full_name);
-	EXECUTION_REPORT(REPORT_ERROR, -1, src_comp_node != NULL, "Software error in Coupling_connection::generate_a_coupling_procedure: Cannot find the src comp_node for \"%s\"", src_comp_interfaces[0].first);
-	EXECUTION_REPORT(REPORT_ERROR, -1, dst_comp_node != NULL, "Software error in Coupling_connection::generate_a_coupling_procedure: Cannot find the dst comp_node for \"%s\"", dst_comp_full_name);
-	current_proc_id_src_comp = src_comp_node->get_current_proc_local_id();
-	current_proc_id_dst_comp = dst_comp_node->get_current_proc_local_id();
-	src_comp_root_proc_global_id = src_comp_node->get_root_proc_global_id();
-	dst_comp_root_proc_global_id = dst_comp_node->get_root_proc_global_id();
-	
-	if (current_proc_id_src_comp == -1 && current_proc_id_dst_comp == -1)
-		return;
-
-	if (current_proc_id_src_comp != -1) {
-		export_interface = inout_interface_mgr->get_interface(src_comp_interfaces[0].first, src_comp_interfaces[0].second);
-		EXECUTION_REPORT(REPORT_ERROR, -1, export_interface != NULL, "Software error in Coupling_connection::generate_a_coupling_procedure: NULL export interface");
-		EXECUTION_REPORT_LOG(REPORT_LOG, src_comp_node->get_comp_id(), true, "start to generate a coupling connection from \"%s\" (current component) to \"%s\". The connection id is %d", src_comp_interfaces[0].first, dst_comp_full_name, connection_id);
-	}
-	if (current_proc_id_dst_comp != -1) {
-		import_interface = inout_interface_mgr->get_interface(dst_comp_full_name, dst_interface_name);
-		EXECUTION_REPORT(REPORT_ERROR, -1, import_interface != NULL, "Software error in Coupling_connection::generate_a_coupling_procedure: NULL import interface");
-		EXECUTION_REPORT_LOG(REPORT_LOG, dst_comp_node->get_comp_id(), true, "start to generate a coupling connection from \"%s\" to \"%s\" (current component). The connection id is %d", src_comp_interfaces[0].first, dst_comp_full_name, connection_id);
-	}
+    src_comp_node = comp_comm_group_mgt_mgr->search_global_node(src_comp_interfaces[0].first);
+    dst_comp_node =comp_comm_group_mgt_mgr->search_global_node(dst_comp_full_name);
+    EXECUTION_REPORT(REPORT_ERROR, -1, src_comp_node != NULL, "Software error in Coupling_connection::generate_a_coupling_procedure: Cannot find the src comp_node for \"%s\"", src_comp_interfaces[0].first);
+    EXECUTION_REPORT(REPORT_ERROR, -1, dst_comp_node != NULL, "Software error in Coupling_connection::generate_a_coupling_procedure: Cannot find the dst comp_node for \"%s\"", dst_comp_full_name);
+    current_proc_id_src_comp = src_comp_node->get_current_proc_local_id();
+    current_proc_id_dst_comp = dst_comp_node->get_current_proc_local_id();
+    src_comp_root_proc_global_id = src_comp_node->get_root_proc_global_id();
+    dst_comp_root_proc_global_id = dst_comp_node->get_root_proc_global_id();
+    
+    if (current_proc_id_src_comp == -1 && current_proc_id_dst_comp == -1)
+        return;
+
+    if (current_proc_id_src_comp != -1) {
+        export_interface = inout_interface_mgr->get_interface(src_comp_interfaces[0].first, src_comp_interfaces[0].second);
+        EXECUTION_REPORT(REPORT_ERROR, -1, export_interface != NULL, "Software error in Coupling_connection::generate_a_coupling_procedure: NULL export interface");
+        EXECUTION_REPORT_LOG(REPORT_LOG, src_comp_node->get_comp_id(), true, "start to generate a coupling connection from \"%s\" (current component) to \"%s\". The connection id is %d", src_comp_interfaces[0].first, dst_comp_full_name, connection_id);
+    }
+    if (current_proc_id_dst_comp != -1) {
+        import_interface = inout_interface_mgr->get_interface(dst_comp_full_name, dst_interface_name);
+        EXECUTION_REPORT(REPORT_ERROR, -1, import_interface != NULL, "Software error in Coupling_connection::generate_a_coupling_procedure: NULL import interface");
+        EXECUTION_REPORT_LOG(REPORT_LOG, dst_comp_node->get_comp_id(), true, "start to generate a coupling connection from \"%s\" to \"%s\" (current component). The connection id is %d", src_comp_interfaces[0].first, dst_comp_full_name, connection_id);
+    }
 
     create_union_comm();
-	exchange_connection_fields_info();
-	generate_interpolation(has_frac_remapping);
-
-	if (current_proc_id_src_comp != -1) {
-		export_procedure = new Connection_coupling_procedure(export_interface, this);
-		export_interface->add_coupling_procedure(export_procedure);
-	}
-	if (current_proc_id_dst_comp != -1) {
-		import_procedure = new Connection_coupling_procedure(import_interface, this);
-		import_interface->add_coupling_procedure(import_procedure);
-	}
-
-	generate_data_transfer();
-
-	if (current_proc_id_src_comp != -1)
-		EXECUTION_REPORT_LOG(REPORT_LOG, src_comp_node->get_comp_id(), true, "Finish generating a coupling connection from \"%s\" (current component) to \"%s\". The connection id is %d", src_comp_interfaces[0].first, dst_comp_full_name, connection_id);
-	if (current_proc_id_dst_comp != -1)
-		EXECUTION_REPORT_LOG(REPORT_LOG, dst_comp_node->get_comp_id(), true, "Finish generating a coupling connection from \"%s\" to \"%s\" (current component). The connection id is %d", src_comp_interfaces[0].first, dst_comp_full_name, connection_id);
+    exchange_connection_fields_info();
+    generate_interpolation(has_frac_remapping);
+
+    if (current_proc_id_src_comp != -1) {
+        export_procedure = new Connection_coupling_procedure(export_interface, this);
+        export_interface->add_coupling_procedure(export_procedure);
+    }
+    if (current_proc_id_dst_comp != -1) {
+        import_procedure = new Connection_coupling_procedure(import_interface, this);
+        import_interface->add_coupling_procedure(import_procedure);
+    }
+
+    generate_data_transfer();
+
+    if (current_proc_id_src_comp != -1)
+        EXECUTION_REPORT_LOG(REPORT_LOG, src_comp_node->get_comp_id(), true, "Finish generating a coupling connection from \"%s\" (current component) to \"%s\". The connection id is %d", src_comp_interfaces[0].first, dst_comp_full_name, connection_id);
+    if (current_proc_id_dst_comp != -1)
+        EXECUTION_REPORT_LOG(REPORT_LOG, dst_comp_node->get_comp_id(), true, "Finish generating a coupling connection from \"%s\" to \"%s\" (current component). The connection id is %d", src_comp_interfaces[0].first, dst_comp_full_name, connection_id);
 }
 
 
@@ -185,755 +185,776 @@ void Coupling_connection::create_union_comm()
 {
     int src_comp_num_procs = src_comp_node->get_num_procs();
     int dst_comp_num_procs = dst_comp_node->get_num_procs();
-	std::vector<int> src_procs_global_ids, dst_procs_global_ids;
+    std::vector<int> src_procs_global_ids, dst_procs_global_ids;
 
 
-	if (current_proc_id_src_comp != -1) {
-		EXECUTION_REPORT_LOG(REPORT_LOG, src_comp_node->get_comp_id(), true, "start to create union comm between components \"%s\" and \"%s\". The connection id is %d", src_comp_interfaces[0].first, dst_comp_full_name, connection_id);
-		MPI_Barrier(src_comp_node->get_comm_group());
-	}
-	if (current_proc_id_dst_comp != -1) {
-		EXECUTION_REPORT_LOG(REPORT_LOG, dst_comp_node->get_comp_id(), true, "start to create union comm between components \"%s\" and \"%s\". The connection id is %d", src_comp_interfaces[0].first, dst_comp_full_name, connection_id);
-		MPI_Barrier(dst_comp_node->get_comm_group());
-	}
+    if (current_proc_id_src_comp != -1) {
+        EXECUTION_REPORT_LOG(REPORT_LOG, src_comp_node->get_comp_id(), true, "start to create union comm between components \"%s\" and \"%s\". The connection id is %d", src_comp_interfaces[0].first, dst_comp_full_name, connection_id);
+        MPI_Barrier(src_comp_node->get_comm_group());
+    }
+    if (current_proc_id_dst_comp != -1) {
+        EXECUTION_REPORT_LOG(REPORT_LOG, dst_comp_node->get_comp_id(), true, "start to create union comm between components \"%s\" and \"%s\". The connection id is %d", src_comp_interfaces[0].first, dst_comp_full_name, connection_id);
+        MPI_Barrier(dst_comp_node->get_comm_group());
+    }
 
     for (int i = 0; i < src_comp_num_procs; i ++)
         src_procs_global_ids.push_back(src_comp_node->get_local_proc_global_id(i));
     for (int i = 0; i < dst_comp_num_procs; i ++)
         dst_procs_global_ids.push_back(dst_comp_node->get_local_proc_global_id(i));
     if (src_proc_ranks_in_union_comm == NULL) 
-		src_proc_ranks_in_union_comm = new int[src_comp_num_procs]; 
+        src_proc_ranks_in_union_comm = new int[src_comp_num_procs]; 
     if (dst_proc_ranks_in_union_comm == NULL) 
-		dst_proc_ranks_in_union_comm = new int[dst_comp_num_procs]; 
-
-	union_comm = create_union_comm_common(src_comp_node->get_comm_group(), dst_comp_node->get_comm_group(), current_proc_id_src_comp, current_proc_id_dst_comp, src_procs_global_ids, dst_procs_global_ids, connection_id, src_proc_ranks_in_union_comm, dst_proc_ranks_in_union_comm);
-	
-	if (current_proc_id_src_comp != -1)
-		EXECUTION_REPORT_LOG(REPORT_LOG, src_comp_node->get_comp_id(), true, "Finish creating union comm between components \"%s\" and \"%s\". The connection id is %d", src_comp_interfaces[0].first, dst_comp_full_name, connection_id);
-	if (current_proc_id_dst_comp != -1)
-		EXECUTION_REPORT_LOG(REPORT_LOG, dst_comp_node->get_comp_id(), true, "Finish creating union comm between components \"%s\" and \"%s\". The connection id is %d", src_comp_interfaces[0].first, dst_comp_full_name, connection_id);
+        dst_proc_ranks_in_union_comm = new int[dst_comp_num_procs]; 
+
+    union_comm = create_union_comm_common(src_comp_node->get_comm_group(), dst_comp_node->get_comm_group(), current_proc_id_src_comp, current_proc_id_dst_comp, src_procs_global_ids, dst_procs_global_ids, connection_id, src_proc_ranks_in_union_comm, dst_proc_ranks_in_union_comm);
+    
+    if (current_proc_id_src_comp != -1)
+        EXECUTION_REPORT_LOG(REPORT_LOG, src_comp_node->get_comp_id(), true, "Finish creating union comm between components \"%s\" and \"%s\". The connection id is %d", src_comp_interfaces[0].first, dst_comp_full_name, connection_id);
+    if (current_proc_id_dst_comp != -1)
+        EXECUTION_REPORT_LOG(REPORT_LOG, dst_comp_node->get_comp_id(), true, "Finish creating union comm between components \"%s\" and \"%s\". The connection id is %d", src_comp_interfaces[0].first, dst_comp_full_name, connection_id);
 }
 
 
 void Coupling_connection::generate_data_transfer()
 {
-	Field_mem_info **src_fields_mem = new Field_mem_info *[src_fields_info.size()];
-	Field_mem_info **dst_fields_mem = new Field_mem_info *[src_fields_info.size()];
-	Routing_info **fields_router = new Routing_info *[src_fields_info.size()];
-	Runtime_trans_algorithm * send_algorithm_object = NULL;
-	Runtime_trans_algorithm * recv_algorithm_object = NULL;
+    Field_mem_info **src_fields_mem = new Field_mem_info *[src_fields_info.size()];
+    Field_mem_info **dst_fields_mem = new Field_mem_info *[src_fields_info.size()];
+    Routing_info **fields_router = new Routing_info *[src_fields_info.size()];
+    Runtime_trans_algorithm * send_algorithm_object = NULL;
+    Runtime_trans_algorithm * recv_algorithm_object = NULL;
     MPI_Win data_win, tag_win;
-	int dst_comp_id;
-	long content_size = NAME_STR_SIZE;
-	char *temp_dst_decomp_name = new char [NAME_STR_SIZE];
-
-
-	if (current_proc_id_src_comp != -1)
-		EXECUTION_REPORT_LOG(REPORT_LOG, src_comp_node->get_comp_id(), true, "Start to generate runtime data transfer algorithm from component \"%s\" (current component) to \"%s\". The connection id is %d", src_comp_interfaces[0].first, dst_comp_full_name, connection_id);
-	if (current_proc_id_dst_comp != -1)
-		EXECUTION_REPORT_LOG(REPORT_LOG, dst_comp_node->get_comp_id(), true, "Start to generate runtime data transfer algorithm from component \"%s\" to \"%s\" (current component). The connection id is %d", src_comp_interfaces[0].first, dst_comp_full_name, connection_id);
-
-	for (int i = 0; i < src_fields_info.size(); i ++) { 
-		if (dst_fields_info[i]->runtime_remapping_weights != NULL && dst_fields_info[i]->runtime_remapping_weights->get_src_decomp_info() != NULL) {
-			strcpy(temp_dst_decomp_name, dst_fields_info[i]->runtime_remapping_weights->get_src_decomp_info()->get_decomp_name());
-			dst_comp_id = dst_fields_info[i]->runtime_remapping_weights->get_src_decomp_info()->get_comp_id();
-		}
-		else {
-			strcpy(temp_dst_decomp_name, dst_fields_info[i]->decomp_name);
-			dst_comp_id = dst_comp_node->get_comp_id();
-		}
-		transfer_array_from_one_comp_to_another(current_proc_id_dst_comp, dst_comp_root_proc_global_id, current_proc_id_src_comp, src_comp_root_proc_global_id, src_comp_node->get_comm_group(), &temp_dst_decomp_name, content_size);
-		fields_router[i] = routing_info_mgr->search_or_add_router(src_comp_node->get_comp_id(), dst_comp_id, src_fields_info[i]->decomp_name, temp_dst_decomp_name);
-		if (current_proc_id_src_comp != -1)
-			src_fields_mem[i] = export_procedure->get_data_transfer_field_instance(i);
-		if (current_proc_id_dst_comp != -1)
-			dst_fields_mem[i] = import_procedure->get_data_transfer_field_instance(i);
-	}
+    int dst_comp_id;
+    long content_size = NAME_STR_SIZE;
+    char *temp_dst_decomp_name = new char [NAME_STR_SIZE];
+
+
+    if (current_proc_id_src_comp != -1)
+        EXECUTION_REPORT_LOG(REPORT_LOG, src_comp_node->get_comp_id(), true, "Start to generate runtime data transfer algorithm from component \"%s\" (current component) to \"%s\". The connection id is %d", src_comp_interfaces[0].first, dst_comp_full_name, connection_id);
+    if (current_proc_id_dst_comp != -1)
+        EXECUTION_REPORT_LOG(REPORT_LOG, dst_comp_node->get_comp_id(), true, "Start to generate runtime data transfer algorithm from component \"%s\" to \"%s\" (current component). The connection id is %d", src_comp_interfaces[0].first, dst_comp_full_name, connection_id);
+
+    for (int i = 0; i < src_fields_info.size(); i ++) { 
+        if (dst_fields_info[i]->runtime_remapping_weights != NULL && dst_fields_info[i]->runtime_remapping_weights->get_src_decomp_info() != NULL) {
+            strcpy(temp_dst_decomp_name, dst_fields_info[i]->runtime_remapping_weights->get_src_decomp_info()->get_decomp_name());
+            dst_comp_id = dst_fields_info[i]->runtime_remapping_weights->get_src_decomp_info()->get_comp_id();
+        }
+        else {
+            strcpy(temp_dst_decomp_name, dst_fields_info[i]->decomp_name);
+            dst_comp_id = dst_comp_node->get_comp_id();
+        }
+        transfer_array_from_one_comp_to_another(current_proc_id_dst_comp, dst_comp_root_proc_global_id, current_proc_id_src_comp, src_comp_root_proc_global_id, src_comp_node->get_comm_group(), &temp_dst_decomp_name, content_size);
+        fields_router[i] = routing_info_mgr->search_or_add_router(src_comp_node->get_comp_id(), dst_comp_id, src_fields_info[i]->decomp_name, temp_dst_decomp_name);
+        if (current_proc_id_src_comp != -1)
+            src_fields_mem[i] = export_procedure->get_data_transfer_field_instance(i);
+        if (current_proc_id_dst_comp != -1)
+            dst_fields_mem[i] = import_procedure->get_data_transfer_field_instance(i);
+    }
 
     if (current_proc_id_dst_comp != -1) {
         recv_algorithm_object = new Runtime_trans_algorithm(false, src_fields_info.size(), dst_fields_mem, fields_router, union_comm, src_proc_ranks_in_union_comm, connection_id);
-		import_procedure->add_data_transfer_algorithm(recv_algorithm_object);
-		inout_interface_mgr->add_runtime_receive_algorithm(recv_algorithm_object);
+        import_procedure->add_data_transfer_algorithm(recv_algorithm_object);
+        inout_interface_mgr->add_runtime_receive_algorithm(recv_algorithm_object);
     }
     if (current_proc_id_src_comp != -1) {
         send_algorithm_object = new Runtime_trans_algorithm(true, src_fields_info.size(), src_fields_mem, fields_router, union_comm, dst_proc_ranks_in_union_comm, connection_id);
         export_procedure->add_data_transfer_algorithm(send_algorithm_object);
     }
     if (current_proc_id_dst_comp != -1) {
-		MPI_Win_create(recv_algorithm_object->get_total_buf(), recv_algorithm_object->get_total_buf_size()*sizeof(char), sizeof(char), MPI_INFO_NULL, union_comm, &data_win);
+        MPI_Win_create(recv_algorithm_object->get_total_buf(), recv_algorithm_object->get_total_buf_size()*sizeof(char), sizeof(char), MPI_INFO_NULL, union_comm, &data_win);
         //MPI_Win_create(recv_algorithm_object->get_data_buf(), recv_algorithm_object->get_data_buf_size()*sizeof(char), sizeof(char), MPI_INFO_NULL, union_comm, &data_win);
         //MPI_Win_create(recv_algorithm_object->get_tag_buf(), recv_algorithm_object->get_tag_buf_size()*sizeof(long), sizeof(long), MPI_INFO_NULL, union_comm, &tag_win);
         recv_algorithm_object->set_data_win(data_win);
         //recv_algorithm_object->set_tag_win(tag_win);
-		inout_interface_mgr->add_MPI_win(data_win);
-		//inout_interface_mgr->add_MPI_win(tag_win);
+        inout_interface_mgr->add_MPI_win(data_win);
+        //inout_interface_mgr->add_MPI_win(tag_win);
     }
     if (current_proc_id_src_comp != -1) {
-		if (current_proc_id_dst_comp == -1) {
-	        MPI_Win_create(NULL, 0, sizeof(char), MPI_INFO_NULL, union_comm, &data_win);
-	        //MPI_Win_create(NULL, 0, sizeof(long), MPI_INFO_NULL, union_comm, &tag_win);
-			inout_interface_mgr->add_MPI_win(data_win);
-			//inout_interface_mgr->add_MPI_win(tag_win);
-		}
+        if (current_proc_id_dst_comp == -1) {
+            MPI_Win_create(NULL, 0, sizeof(char), MPI_INFO_NULL, union_comm, &data_win);
+            //MPI_Win_create(NULL, 0, sizeof(long), MPI_INFO_NULL, union_comm, &tag_win);
+            inout_interface_mgr->add_MPI_win(data_win);
+            //inout_interface_mgr->add_MPI_win(tag_win);
+        }
         send_algorithm_object->set_data_win(data_win);
         //send_algorithm_object->set_tag_win(tag_win);
     }
 
-	delete [] src_fields_mem;
-	delete [] dst_fields_mem;
-	delete [] fields_router;
-	delete [] temp_dst_decomp_name;
+    delete [] src_fields_mem;
+    delete [] dst_fields_mem;
+    delete [] fields_router;
+    delete [] temp_dst_decomp_name;
 
-	if (current_proc_id_src_comp != -1)
-		EXECUTION_REPORT_LOG(REPORT_LOG, src_comp_node->get_comp_id(), true, "Finish generating runtime data transfer algorithm from component \"%s\" (current component) to \"%s\". The connection id is %d", src_comp_interfaces[0].first, dst_comp_full_name, connection_id);
-	if (current_proc_id_dst_comp != -1)
-		EXECUTION_REPORT_LOG(REPORT_LOG, dst_comp_node->get_comp_id(), true, "Finish generating runtime data transfer algorithm from component \"%s\" to \"%s\" (current component). The connection id is %d", src_comp_interfaces[0].first, dst_comp_full_name, connection_id);
+    if (current_proc_id_src_comp != -1)
+        EXECUTION_REPORT_LOG(REPORT_LOG, src_comp_node->get_comp_id(), true, "Finish generating runtime data transfer algorithm from component \"%s\" (current component) to \"%s\". The connection id is %d", src_comp_interfaces[0].first, dst_comp_full_name, connection_id);
+    if (current_proc_id_dst_comp != -1)
+        EXECUTION_REPORT_LOG(REPORT_LOG, dst_comp_node->get_comp_id(), true, "Finish generating runtime data transfer algorithm from component \"%s\" to \"%s\" (current component). The connection id is %d", src_comp_interfaces[0].first, dst_comp_full_name, connection_id);
 }
 
 
 bool Coupling_connection::exchange_grid(Comp_comm_group_mgt_node *sender_comp_node, Comp_comm_group_mgt_node *receiver_comp_node, const char *grid_name)
 {
-	char *temp_array_buffer = NULL;
-	long buffer_max_size, buffer_content_size;
-	int original_grid_status, *all_original_grid_status, num_processes, bottom_field_variation_type;
-	long checksum_lon, checksum_lat, checksum_mask;
-	bool should_exchange_grid = false;
-
-
-	Original_grid_info *sender_original_grid = original_grid_mgr->search_grid_info(grid_name, sender_comp_node->get_comp_id());
-	Original_grid_info *receiver_original_grid = original_grid_mgr->search_grid_info(grid_name, receiver_comp_node->get_comp_id());
-	
-	original_grid_status = 0;
-	if (sender_original_grid != NULL && receiver_original_grid != NULL && sender_original_grid->get_original_CoR_grid() == receiver_original_grid->get_original_CoR_grid())
-		original_grid_status = 1;
-	MPI_Comm_size(union_comm, &num_processes);
-	all_original_grid_status = new int [num_processes];
-	MPI_Allgather(&original_grid_status, 1, MPI_INT, all_original_grid_status, 1, MPI_INT, union_comm);
-	for (int i = 0; i < num_processes; i ++)
-		if (all_original_grid_status[i] == 1) {
-			delete [] all_original_grid_status;
-			if (sender_comp_node->get_current_proc_local_id() != -1)
-				EXECUTION_REPORT_LOG(REPORT_LOG, sender_comp_node->get_comp_id(), true, "Does not exchange grid \"%s\" from \"%s\" to \"%s\" because the CoR grid is the same", grid_name, sender_comp_node->get_comp_full_name(), receiver_comp_node->get_comp_full_name());
-			if (receiver_comp_node->get_current_proc_local_id() != -1)
-				EXECUTION_REPORT_LOG(REPORT_LOG, receiver_comp_node->get_comp_id(), true, "Does not exchange grid \"%s\" from \"%s\" to \"%s\" because the CoR grid is the same", grid_name, sender_comp_node->get_comp_full_name(), receiver_comp_node->get_comp_full_name());
-			return false;
-		}
-	
-	original_grid_status = sender_original_grid == NULL? 0 : 1;
-	MPI_Allgather(&original_grid_status, 1, MPI_INT, all_original_grid_status, 1, MPI_INT, union_comm);
-	for (int i = 0; i < num_processes; i ++)
-		if (all_original_grid_status[i] == 0) {
-			should_exchange_grid = true;
-			break;
-		}
-	delete [] all_original_grid_status;
-	if (!should_exchange_grid) {
-		if (sender_comp_node->get_current_proc_local_id() != -1)
-			EXECUTION_REPORT_LOG(REPORT_LOG, sender_comp_node->get_comp_id(), true, "Does not exchange grid \"%s\" from \"%s\" to \"%s\" again", grid_name, sender_comp_node->get_comp_full_name(), receiver_comp_node->get_comp_full_name());
-		if (receiver_comp_node->get_current_proc_local_id() != -1)
-			EXECUTION_REPORT_LOG(REPORT_LOG, receiver_comp_node->get_comp_id(), true, "Does not exchange grid \"%s\" from \"%s\" to \"%s\" again", grid_name, sender_comp_node->get_comp_full_name(), receiver_comp_node->get_comp_full_name());
-		return true;
-	}
-
-	if (sender_comp_node->get_current_proc_local_id() != -1) 
-		EXECUTION_REPORT_LOG(REPORT_LOG, sender_comp_node->get_comp_id(), true, "Send grid %s to component \"%s\"", grid_name, receiver_comp_node->get_full_name());
-	if (receiver_comp_node->get_current_proc_local_id() != -1) 
-		EXECUTION_REPORT_LOG(REPORT_LOG, receiver_comp_node->get_comp_id(), true, "Receive grid %s from component \"%s\"", grid_name, sender_comp_node->get_full_name());
-
-	if (sender_original_grid != NULL)
-		sender_original_grid->write_grid_into_array(&temp_array_buffer, buffer_max_size, buffer_content_size);
-	transfer_array_from_one_comp_to_another(sender_comp_node->get_current_proc_local_id(), sender_comp_node->get_root_proc_global_id(), receiver_comp_node->get_current_proc_local_id(), receiver_comp_node->get_root_proc_global_id(), receiver_comp_node->get_comm_group(), &temp_array_buffer, buffer_content_size);
-
-	if (original_grid_status == 0) {
-		read_data_from_array_buffer(&checksum_mask, sizeof(long), temp_array_buffer, buffer_content_size, true);
-		read_data_from_array_buffer(&bottom_field_variation_type, sizeof(int), temp_array_buffer, buffer_content_size, true);
-		Remap_grid_class *mirror_grid = new Remap_grid_class(NULL, sender_comp_node->get_full_name(), temp_array_buffer, buffer_content_size);
-		mirror_grid = remap_grid_manager->search_remap_grid_with_grid_name(mirror_grid->get_grid_name());
-		EXECUTION_REPORT(REPORT_ERROR, -1, buffer_content_size == 0, "software error in Coupling_connection::exchange_grid: wrong buffer_content_size");
-		receiver_original_grid = original_grid_mgr->get_original_grid(original_grid_mgr->add_original_grid(sender_comp_node->get_comp_id(), grid_name, mirror_grid));
-		if (receiver_original_grid->get_bottom_field_variation_type() != bottom_field_variation_type)
-			EXECUTION_REPORT(REPORT_ERROR, -1, receiver_original_grid->get_original_CoR_grid()->is_sigma_grid(), "Software error in Coupling_connection::exchange_grid regarding bottom_field_variation_type");
-		receiver_original_grid->set_bottom_field_variation_type(bottom_field_variation_type);
-		receiver_original_grid->set_grid_checksum(checksum_mask);
-	}
-
-	if (temp_array_buffer != NULL)
-		delete [] temp_array_buffer;
-
-	return true;
+    char *temp_array_buffer = NULL;
+    long buffer_max_size, buffer_content_size;
+    int original_grid_status, *all_original_grid_status, num_processes, bottom_field_variation_type, V3D_lev_field_variation_type;
+    long checksum_lon, checksum_lat, checksum_mask;
+    bool should_exchange_grid = false;
+
+
+    Original_grid_info *sender_original_grid = original_grid_mgr->search_grid_info(grid_name, sender_comp_node->get_comp_id());
+    Original_grid_info *receiver_original_grid = original_grid_mgr->search_grid_info(grid_name, receiver_comp_node->get_comp_id());
+    
+    original_grid_status = 0;
+    if (sender_original_grid != NULL && receiver_original_grid != NULL && sender_original_grid->get_original_CoR_grid() == receiver_original_grid->get_original_CoR_grid())
+        original_grid_status = 1;
+    MPI_Comm_size(union_comm, &num_processes);
+    all_original_grid_status = new int [num_processes];
+    MPI_Allgather(&original_grid_status, 1, MPI_INT, all_original_grid_status, 1, MPI_INT, union_comm);
+    for (int i = 0; i < num_processes; i ++)
+        if (all_original_grid_status[i] == 1) {
+            delete [] all_original_grid_status;
+            if (sender_comp_node->get_current_proc_local_id() != -1)
+                EXECUTION_REPORT_LOG(REPORT_LOG, sender_comp_node->get_comp_id(), true, "Does not exchange grid \"%s\" from \"%s\" to \"%s\" because the CoR grid is the same", grid_name, sender_comp_node->get_comp_full_name(), receiver_comp_node->get_comp_full_name());
+            if (receiver_comp_node->get_current_proc_local_id() != -1)
+                EXECUTION_REPORT_LOG(REPORT_LOG, receiver_comp_node->get_comp_id(), true, "Does not exchange grid \"%s\" from \"%s\" to \"%s\" because the CoR grid is the same", grid_name, sender_comp_node->get_comp_full_name(), receiver_comp_node->get_comp_full_name());
+            return false;
+        }
+    
+    original_grid_status = sender_original_grid == NULL? 0 : 1;
+    MPI_Allgather(&original_grid_status, 1, MPI_INT, all_original_grid_status, 1, MPI_INT, union_comm);
+    for (int i = 0; i < num_processes; i ++)
+        if (all_original_grid_status[i] == 0) {
+            should_exchange_grid = true;
+            break;
+        }
+    delete [] all_original_grid_status;
+    if (!should_exchange_grid) {
+        if (sender_comp_node->get_current_proc_local_id() != -1)
+            EXECUTION_REPORT_LOG(REPORT_LOG, sender_comp_node->get_comp_id(), true, "Does not exchange grid \"%s\" from \"%s\" to \"%s\" again", grid_name, sender_comp_node->get_comp_full_name(), receiver_comp_node->get_comp_full_name());
+        if (receiver_comp_node->get_current_proc_local_id() != -1)
+            EXECUTION_REPORT_LOG(REPORT_LOG, receiver_comp_node->get_comp_id(), true, "Does not exchange grid \"%s\" from \"%s\" to \"%s\" again", grid_name, sender_comp_node->get_comp_full_name(), receiver_comp_node->get_comp_full_name());
+        return true;
+    }
+
+    if (sender_comp_node->get_current_proc_local_id() != -1) 
+        EXECUTION_REPORT_LOG(REPORT_LOG, sender_comp_node->get_comp_id(), true, "Send grid %s to component \"%s\"", grid_name, receiver_comp_node->get_full_name());
+    if (receiver_comp_node->get_current_proc_local_id() != -1) 
+        EXECUTION_REPORT_LOG(REPORT_LOG, receiver_comp_node->get_comp_id(), true, "Receive grid %s from component \"%s\"", grid_name, sender_comp_node->get_full_name());
+
+    if (sender_original_grid != NULL)
+        sender_original_grid->write_grid_into_array(&temp_array_buffer, buffer_max_size, buffer_content_size);
+    transfer_array_from_one_comp_to_another(sender_comp_node->get_current_proc_local_id(), sender_comp_node->get_root_proc_global_id(), receiver_comp_node->get_current_proc_local_id(), receiver_comp_node->get_root_proc_global_id(), receiver_comp_node->get_comm_group(), &temp_array_buffer, buffer_content_size);
+
+    if (original_grid_status == 0) {
+        read_data_from_array_buffer(&checksum_mask, sizeof(long), temp_array_buffer, buffer_content_size, true);
+        read_data_from_array_buffer(&bottom_field_variation_type, sizeof(int), temp_array_buffer, buffer_content_size, true);
+        read_data_from_array_buffer(&V3D_lev_field_variation_type, sizeof(int), temp_array_buffer, buffer_content_size, true);
+        Remap_grid_class *mirror_grid = new Remap_grid_class(NULL, sender_comp_node->get_full_name(), temp_array_buffer, buffer_content_size);
+        mirror_grid = remap_grid_manager->search_remap_grid_with_grid_name(mirror_grid->get_grid_name());
+        EXECUTION_REPORT(REPORT_ERROR, -1, buffer_content_size == 0, "software error in Coupling_connection::exchange_grid: wrong buffer_content_size");
+        receiver_original_grid = original_grid_mgr->get_original_grid(original_grid_mgr->add_original_grid(sender_comp_node->get_comp_id(), grid_name, mirror_grid));
+        if (receiver_original_grid->get_bottom_field_variation_type() != bottom_field_variation_type)
+            EXECUTION_REPORT(REPORT_ERROR, -1, receiver_original_grid->get_original_CoR_grid()->is_sigma_grid(), "Software error in Coupling_connection::exchange_grid regarding bottom_field_variation_type");
+        receiver_original_grid->set_bottom_field_variation_type(bottom_field_variation_type);
+		receiver_original_grid->set_V3D_lev_field_variation_type(V3D_lev_field_variation_type);
+        receiver_original_grid->set_grid_checksum(checksum_mask);
+    }
+
+    if (temp_array_buffer != NULL)
+        delete [] temp_array_buffer;
+
+    return true;
 }
 
 
 void Coupling_connection::exchange_remapping_setting(int i, Remapping_setting &field_remapping_setting)
 {
-	char *array = NULL;
-	long buffer_max_size, buffer_content_size;
-	
-	if (current_proc_id_src_comp != -1) {
-		remapping_configuration_mgr->get_field_remapping_setting(field_remapping_setting, src_comp_node->get_comp_id(), fields_name[i]);
-		field_remapping_setting.write_remapping_setting_into_array(&array, buffer_max_size, buffer_content_size);
-	}
-	transfer_array_from_one_comp_to_another(current_proc_id_src_comp, src_comp_root_proc_global_id, current_proc_id_dst_comp, dst_comp_root_proc_global_id, dst_comp_node->get_comm_group(), &array, buffer_content_size);	
-	if (current_proc_id_dst_comp != -1)
-		field_remapping_setting.read_remapping_setting_from_array(array, buffer_content_size);
-
-	delete [] array;
+    char *array = NULL;
+    long buffer_max_size, buffer_content_size;
+    
+    if (current_proc_id_src_comp != -1) {
+        remapping_configuration_mgr->get_field_remapping_setting(field_remapping_setting, src_comp_node->get_comp_id(), fields_name[i]);
+        field_remapping_setting.write_remapping_setting_into_array(&array, buffer_max_size, buffer_content_size);
+    }
+    transfer_array_from_one_comp_to_another(current_proc_id_src_comp, src_comp_root_proc_global_id, current_proc_id_dst_comp, dst_comp_root_proc_global_id, dst_comp_node->get_comm_group(), &array, buffer_content_size);    
+    if (current_proc_id_dst_comp != -1)
+        field_remapping_setting.read_remapping_setting_from_array(array, buffer_content_size);
+
+    delete [] array;
 }
 
 
 void Coupling_connection::add_bottom_field_coupling_info(int field_connection_indx, Runtime_remapping_weights *V3D_remapping_weights, Remapping_setting *remapping_setting)
 {
-	for (int i = 0; i < dst_bottom_fields_coupling_info.size(); i ++)
-		if (dst_bottom_fields_coupling_info[i]->V3D_runtime_remapping_weights == V3D_remapping_weights)
-			return;
-
-	V3D_grid_bottom_field_coupling_info *bottom_field_coupling_info = new V3D_grid_bottom_field_coupling_info;
-	bottom_field_coupling_info->V3D_runtime_remapping_weights = V3D_remapping_weights;
-	bottom_field_coupling_info->field_connection_indx = field_connection_indx;
-	bottom_field_coupling_info->is_dynamic_bottom_field = V3D_remapping_weights->get_src_original_grid()->get_bottom_field_variation_type() == BOTTOM_FIELD_VARIATION_DYNAMIC;
-	bottom_field_coupling_info->bottom_field_inst = V3D_remapping_weights->allocate_intermediate_V3D_grid_bottom_field();
-	bottom_field_coupling_info->H2D_runtime_remapping_weights = runtime_remapping_weights_mgr->search_or_generate_runtime_remapping_weights(src_comp_node->get_comp_full_name(), dst_comp_node->get_comp_full_name(), 
-		original_grid_mgr->get_original_grid(V3D_remapping_weights->get_src_decomp_info()->get_grid_id()), original_grid_mgr->get_original_grid(V3D_remapping_weights->get_dst_decomp_info()->get_grid_id()), 
-		remapping_setting, V3D_remapping_weights->get_dst_decomp_info());
-
-	if (V3D_remapping_weights->get_parallel_remapping_weights() != NULL) {
-		Remap_weight_of_operator_class *dynamic_V1D_remap_weight_of_operator = V3D_remapping_weights->get_parallel_remapping_weights()->get_dynamic_V1D_remap_weight_of_operator();
-		EXECUTION_REPORT(REPORT_ERROR, -1, dynamic_V1D_remap_weight_of_operator != NULL, "Software error in Coupling_connection::add_bottom_field_coupling_info: do not have dynamic_V1D_remap_weight_of_operator");
-		
-		EXECUTION_REPORT(REPORT_ERROR, -1, bottom_field_coupling_info->bottom_field_inst->get_field_data()->get_coord_value_grid()->is_subset_of_grid(dynamic_V1D_remap_weight_of_operator->get_field_data_grid_src()) && bottom_field_coupling_info->bottom_field_inst->get_field_data()->get_coord_value_grid()->is_subset_of_grid(dynamic_V1D_remap_weight_of_operator->get_field_data_grid_dst()), "Software error in Coupling_connection::add_bottom_field_coupling_info: wrong surface field grid or wrong 2-D+1-D order");
-		if (dynamic_V1D_remap_weight_of_operator->get_field_data_grid_src()->get_sigma_grid_dynamic_surface_value_field() != NULL)
-			EXECUTION_REPORT(REPORT_ERROR, -1, dynamic_V1D_remap_weight_of_operator->get_field_data_grid_src()->get_sigma_grid_dynamic_surface_value_field() == bottom_field_coupling_info->bottom_field_inst->get_field_data(), "Software error in Coupling_connection::add_bottom_field_coupling_info: the surface field of the same grid has been set to different data fields");
-		else dynamic_V1D_remap_weight_of_operator->get_field_data_grid_src()->set_sigma_grid_dynamic_surface_value_field(bottom_field_coupling_info->bottom_field_inst->get_field_data());
-
-		if (V3D_remapping_weights->get_dst_original_grid()->get_bottom_field_variation_type() == BOTTOM_FIELD_VARIATION_EXTERNAL) {
-			if (dynamic_V1D_remap_weight_of_operator->get_field_data_grid_dst()->get_sigma_grid_dynamic_surface_value_field() != NULL)
-				EXECUTION_REPORT(REPORT_ERROR, -1, dynamic_V1D_remap_weight_of_operator->get_field_data_grid_dst()->get_sigma_grid_dynamic_surface_value_field() == bottom_field_coupling_info->bottom_field_inst->get_field_data(), "Software error in Coupling_connection::add_bottom_field_coupling_info: the surface field of the same grid has been set to different data fields");
-			else dynamic_V1D_remap_weight_of_operator->get_field_data_grid_dst()->set_sigma_grid_dynamic_surface_value_field(bottom_field_coupling_info->bottom_field_inst->get_field_data());
-		}
-	}
-
-	dst_bottom_fields_coupling_info.push_back(bottom_field_coupling_info);
+    for (int i = 0; i < dst_bottom_fields_coupling_info.size(); i ++)
+        if (dst_bottom_fields_coupling_info[i]->V3D_runtime_remapping_weights == V3D_remapping_weights)
+            return;
+
+    V3D_grid_bottom_field_coupling_info *bottom_field_coupling_info = new V3D_grid_bottom_field_coupling_info;
+    bottom_field_coupling_info->V3D_runtime_remapping_weights = V3D_remapping_weights;
+    bottom_field_coupling_info->field_connection_indx = field_connection_indx;
+	if (V3D_remapping_weights->get_src_original_grid()->get_original_CoR_grid()->is_sigma_grid())
+	    bottom_field_coupling_info->is_dynamic_bottom_field = V3D_remapping_weights->get_src_original_grid()->get_bottom_field_variation_type() == BOTTOM_FIELD_VARIATION_DYNAMIC;
+	else bottom_field_coupling_info->is_dynamic_bottom_field = V3D_remapping_weights->get_src_original_grid()->get_V3D_lev_field_variation_type() == BOTTOM_FIELD_VARIATION_DYNAMIC;
+    bottom_field_coupling_info->bottom_field_inst = V3D_remapping_weights->allocate_intermediate_V3D_grid_bottom_field();
+	if (V3D_remapping_weights->get_src_original_grid()->get_original_CoR_grid()->is_sigma_grid())
+	    bottom_field_coupling_info->H2D_runtime_remapping_weights = runtime_remapping_weights_mgr->search_or_generate_runtime_remapping_weights(src_comp_node->get_comp_full_name(), dst_comp_node->get_comp_full_name(), 
+	        original_grid_mgr->get_original_grid(V3D_remapping_weights->get_src_decomp_info()->get_grid_id()), original_grid_mgr->get_original_grid(V3D_remapping_weights->get_dst_decomp_info()->get_grid_id()), 
+    	    remapping_setting, V3D_remapping_weights->get_dst_decomp_info());
+	else bottom_field_coupling_info->H2D_runtime_remapping_weights = V3D_remapping_weights;
+
+    if (V3D_remapping_weights->get_parallel_remapping_weights() != NULL) {
+        Remap_weight_of_operator_class *dynamic_V1D_remap_weight_of_operator = V3D_remapping_weights->get_parallel_remapping_weights()->get_dynamic_V1D_remap_weight_of_operator();
+        EXECUTION_REPORT(REPORT_ERROR, -1, dynamic_V1D_remap_weight_of_operator != NULL, "Software error in Coupling_connection::add_bottom_field_coupling_info: do not have dynamic_V1D_remap_weight_of_operator");
+        EXECUTION_REPORT(REPORT_ERROR, -1, !bottom_field_coupling_info->bottom_field_inst->get_field_data()->get_coord_value_grid()->is_sigma_grid(), "Software error in Coupling_connection::add_bottom_field_coupling_info: wrong surface field grid or wrong 2-D+1-D order");
+        if (dynamic_V1D_remap_weight_of_operator->get_field_data_grid_src()->get_level_V3D_coord_dynamic_trigger_field() != NULL)
+            EXECUTION_REPORT(REPORT_ERROR, -1, dynamic_V1D_remap_weight_of_operator->get_field_data_grid_src()->get_level_V3D_coord_dynamic_trigger_field() == bottom_field_coupling_info->bottom_field_inst->get_field_data(), "Software error in Coupling_connection::add_bottom_field_coupling_info: the surface field of the same grid has been set to different data fields");
+        else dynamic_V1D_remap_weight_of_operator->get_field_data_grid_src()->set_level_V3D_coord_dynamic_trigger_field(bottom_field_coupling_info->bottom_field_inst->get_field_data());
+
+        if (V3D_remapping_weights->get_dst_original_grid()->get_bottom_field_variation_type() == BOTTOM_FIELD_VARIATION_EXTERNAL) {
+            if (dynamic_V1D_remap_weight_of_operator->get_field_data_grid_dst()->get_level_V3D_coord_dynamic_trigger_field() != NULL)
+                EXECUTION_REPORT(REPORT_ERROR, -1, dynamic_V1D_remap_weight_of_operator->get_field_data_grid_dst()->get_level_V3D_coord_dynamic_trigger_field() == bottom_field_coupling_info->bottom_field_inst->get_field_data(), "Software error in Coupling_connection::add_bottom_field_coupling_info: the surface field of the same grid has been set to different data fields");
+            else dynamic_V1D_remap_weight_of_operator->get_field_data_grid_dst()->set_level_V3D_coord_dynamic_trigger_field(bottom_field_coupling_info->bottom_field_inst->get_field_data());
+        }
+    }
+
+    dst_bottom_fields_coupling_info.push_back(bottom_field_coupling_info);
 }
 
 
 void Coupling_connection::generate_src_bottom_field_coupling_info()
 {
-	int *bottom_fields_indx = NULL;
-	long buffer_max_size = 0, buffer_content_size = 0;
-
-
-	if (current_proc_id_dst_comp != -1)
-		for (int i = dst_bottom_fields_coupling_info.size()-1; i >= 0; i --)
-			write_data_into_array_buffer(&(dst_bottom_fields_coupling_info[i]->field_connection_indx), sizeof(int), (char**)(&bottom_fields_indx), buffer_max_size, buffer_content_size);
-	transfer_array_from_one_comp_to_another(current_proc_id_dst_comp, dst_comp_root_proc_global_id, current_proc_id_src_comp, src_comp_root_proc_global_id, src_comp_node->get_comm_group(), (char**)(&bottom_fields_indx), buffer_content_size);
-	if (current_proc_id_src_comp != -1) {
-		for (int i = 0; i < buffer_content_size / 4; i ++) {
-			V3D_grid_bottom_field_coupling_info *bottom_field_coupling_info = new V3D_grid_bottom_field_coupling_info;
-			bottom_field_coupling_info->V3D_runtime_remapping_weights = NULL;
-			bottom_field_coupling_info->H2D_runtime_remapping_weights = NULL; 
-			bottom_field_coupling_info->field_connection_indx = bottom_fields_indx[i];
-			Original_grid_info *src_original_grid = original_grid_mgr->search_grid_info(src_fields_info[bottom_fields_indx[i]]->grid_name, comp_comm_group_mgt_mgr->search_global_node(src_comp_interfaces[0].first)->get_comp_id());
-			EXECUTION_REPORT(REPORT_ERROR, -1, src_original_grid->is_3D_grid() && src_original_grid->get_bottom_field_variation_type() == BOTTOM_FIELD_VARIATION_DYNAMIC || src_original_grid->get_bottom_field_variation_type() == BOTTOM_FIELD_VARIATION_STATIC, "Software error in Coupling_connection::generate_src_bottom_field_coupling_info: wrong grid");
-			bottom_field_coupling_info->is_dynamic_bottom_field = src_original_grid->get_bottom_field_variation_type() == BOTTOM_FIELD_VARIATION_DYNAMIC;
-			bottom_field_coupling_info->bottom_field_inst = memory_manager->get_field_instance(src_original_grid->get_bottom_field_id());
-			EXECUTION_REPORT(REPORT_ERROR, -1, original_grid_mgr->get_original_CoR_grid(bottom_field_coupling_info->bottom_field_inst->get_grid_id())->is_subset_of_grid(src_original_grid->get_original_CoR_grid()), "Software error in Coupling_connection::generate_src_bottom_field_coupling_info: wrong grid relation");
-			src_bottom_fields_coupling_info.push_back(bottom_field_coupling_info);
-		}		
-	}
-
-	if (bottom_fields_indx != NULL)
-		delete [] bottom_fields_indx;
+    int *bottom_fields_indx = NULL;
+    long buffer_max_size = 0, buffer_content_size = 0;
+
+
+    if (current_proc_id_dst_comp != -1)
+        for (int i = dst_bottom_fields_coupling_info.size()-1; i >= 0; i --)
+            write_data_into_array_buffer(&(dst_bottom_fields_coupling_info[i]->field_connection_indx), sizeof(int), (char**)(&bottom_fields_indx), buffer_max_size, buffer_content_size);
+    transfer_array_from_one_comp_to_another(current_proc_id_dst_comp, dst_comp_root_proc_global_id, current_proc_id_src_comp, src_comp_root_proc_global_id, src_comp_node->get_comm_group(), (char**)(&bottom_fields_indx), buffer_content_size);
+    if (current_proc_id_src_comp != -1) {
+        for (int i = 0; i < buffer_content_size / 4; i ++) {
+            V3D_grid_bottom_field_coupling_info *bottom_field_coupling_info = new V3D_grid_bottom_field_coupling_info;
+            bottom_field_coupling_info->V3D_runtime_remapping_weights = NULL;
+            bottom_field_coupling_info->H2D_runtime_remapping_weights = NULL; 
+            bottom_field_coupling_info->field_connection_indx = bottom_fields_indx[i];
+            Original_grid_info *src_original_grid = original_grid_mgr->search_grid_info(src_fields_info[bottom_fields_indx[i]]->grid_name, comp_comm_group_mgt_mgr->search_global_node(src_comp_interfaces[0].first)->get_comp_id());
+			if (src_original_grid->get_bottom_field_id() != -1) {				
+				EXECUTION_REPORT(REPORT_ERROR, -1, src_original_grid->is_3D_grid() && src_original_grid->get_bottom_field_variation_type() == BOTTOM_FIELD_VARIATION_DYNAMIC || src_original_grid->get_bottom_field_variation_type() == BOTTOM_FIELD_VARIATION_STATIC, "Software error in Coupling_connection::generate_src_bottom_field_coupling_info: wrong grid");
+				bottom_field_coupling_info->is_dynamic_bottom_field = src_original_grid->get_bottom_field_variation_type() == BOTTOM_FIELD_VARIATION_DYNAMIC;
+	            bottom_field_coupling_info->bottom_field_inst = memory_manager->get_field_instance(src_original_grid->get_bottom_field_id());
+			}
+			else if (src_original_grid->get_V3D_lev_field_id() != -1) {
+				EXECUTION_REPORT(REPORT_ERROR, -1, src_original_grid->get_V3D_lev_field_variation_type() == BOTTOM_FIELD_VARIATION_DYNAMIC || src_original_grid->get_V3D_lev_field_variation_type() == BOTTOM_FIELD_VARIATION_STATIC, "Software error in Coupling_connection::generate_src_bottom_field_coupling_info: wrong grid");
+				bottom_field_coupling_info->is_dynamic_bottom_field = src_original_grid->get_V3D_lev_field_variation_type() == BOTTOM_FIELD_VARIATION_DYNAMIC;
+	            bottom_field_coupling_info->bottom_field_inst = memory_manager->get_field_instance(src_original_grid->get_V3D_lev_field_id());
+			}
+			else EXECUTION_REPORT_ERROR_OPTIONALLY(REPORT_ERROR, -1, false, "Software error in Coupling_connection::generate_src_bottom_field_coupling_info");
+            EXECUTION_REPORT(REPORT_ERROR, -1, original_grid_mgr->get_original_CoR_grid(bottom_field_coupling_info->bottom_field_inst->get_grid_id())->is_subset_of_grid(src_original_grid->get_original_CoR_grid()), "Software error in Coupling_connection::generate_src_bottom_field_coupling_info: wrong grid relation");
+            src_bottom_fields_coupling_info.push_back(bottom_field_coupling_info);
+        }        
+    }
+
+    if (bottom_fields_indx != NULL)
+        delete [] bottom_fields_indx;
 }
 
 
 void Coupling_connection::generate_interpolation(bool has_frac_remapping)
 {
-	Original_grid_info *src_original_grid = NULL, *dst_original_grid = NULL;
-	int i, j;
-
-	
-	if (current_proc_id_src_comp != -1)
-		EXECUTION_REPORT_LOG(REPORT_LOG, src_comp_node->get_comp_id(), true, "start to generate interpolation between components \"%s\" and \"%s\". The connection id is %d", src_comp_interfaces[0].first, dst_comp_full_name, connection_id);
-	if (current_proc_id_dst_comp != -1)
-		EXECUTION_REPORT_LOG(REPORT_LOG, dst_comp_node->get_comp_id(), true, "start to generate interpolation between components \"%s\" and \"%s\". The connection id is %d", src_comp_interfaces[0].first, dst_comp_full_name, connection_id);
-
-	for (int i = 0; i < fields_name.size(); i ++) {
-		src_fields_info[i]->runtime_remapping_weights = NULL;
-		dst_fields_info[i]->runtime_remapping_weights = NULL;
-		if (words_are_the_same(dst_fields_info[i]->grid_name, "NULL"))
-			continue;
-		if (src_comp_node == dst_comp_node && words_are_the_same(src_fields_info[i]->grid_name, dst_fields_info[i]->grid_name))
-			continue;
-		Remapping_setting field_remapping_setting;	
-		if (words_are_the_same(fields_name[i], "remap_frac")) {
-			EXECUTION_REPORT(REPORT_ERROR, -1, fields_name.size() > 1 && i == fields_name.size()-1, "Software error in Coupling_connection::generate_interpolation");
-			exchange_remapping_setting(0, field_remapping_setting);
-		}
-		else exchange_remapping_setting(i, field_remapping_setting);
-//		exchange_grid(dst_comp_node, src_comp_node, dst_fields_info[i]->grid_name);
-		exchange_grid(src_comp_node, dst_comp_node, src_fields_info[i]->grid_name);
-		if (current_proc_id_dst_comp != -1) {
-			dst_original_grid = original_grid_mgr->search_grid_info(dst_fields_info[i]->grid_name, comp_comm_group_mgt_mgr->search_global_node(dst_comp_full_name)->get_comp_id());
-			src_original_grid = original_grid_mgr->search_grid_info(src_fields_info[i]->grid_name, comp_comm_group_mgt_mgr->search_global_node(src_comp_interfaces[0].first)->get_comp_id());
-			if (src_original_grid->is_H2D_grid_and_the_same_as_another_grid(dst_original_grid)) {
-				EXECUTION_REPORT_LOG(REPORT_LOG, dst_comp_node->get_comp_id(), true, "The data interpolation from grid \"%s\" to \"%s\" is bypassed as these too grids are the same", src_original_grid->get_grid_name(), dst_original_grid->get_grid_name());
-				continue;
-			}
-			else EXECUTION_REPORT_LOG(REPORT_LOG, dst_comp_node->get_comp_id(), true, "The data interpolation from grid \"%s\" to \"%s\" is necessary", src_original_grid->get_grid_name(), dst_original_grid->get_grid_name());
-			EXECUTION_REPORT(REPORT_ERROR, dst_comp_node->get_comp_id(), words_are_the_same(src_fields_info[i]->data_type, DATA_TYPE_FLOAT) || words_are_the_same(src_fields_info[i]->data_type, DATA_TYPE_DOUBLE),  "Error happens when trying to generate data interpolation for the field \%s\" in the coupling from the component model \"%s\" (interface is \"%s\") to the component model \"%s\" (interface is \"%s\"): the data type in the source component model is not floating-point but %s. Please verify.", fields_name[i], src_comp_interfaces[0].first, src_comp_interfaces[0].second, dst_comp_full_name, dst_interface_name, src_fields_info[i]->data_type);
-			EXECUTION_REPORT(REPORT_ERROR, dst_comp_node->get_comp_id(), words_are_the_same(dst_fields_info[i]->data_type, DATA_TYPE_FLOAT) || words_are_the_same(dst_fields_info[i]->data_type, DATA_TYPE_DOUBLE),  "Error happens when trying to generate data interpolation for the field \%s\" in the coupling from the component model \"%s\" (interface is \"%s\") to the component model \"%s\" (interface is \"%s\"): the data type in the source component model is not floating-point but %s. Please verify.", fields_name[i], src_comp_interfaces[0].first, src_comp_interfaces[0].second, dst_comp_full_name, dst_interface_name, dst_fields_info[i]->data_type);	
-			if (src_original_grid->get_original_CoR_grid()->is_sigma_grid()) {
-				EXECUTION_REPORT(REPORT_ERROR, dst_comp_node->get_comp_id(), src_original_grid->get_bottom_field_variation_type() != BOTTOM_FIELD_VARIATION_UNSET, "Fail to generate an interpolation from component model \"%s\" to \"%s\": the surface field of the source 3-D grid \"%s\" with SIGMA or HYBRID vertical coordinate has not been specified. Please verify.", src_comp_interfaces[0].first, dst_comp_full_name, src_original_grid->get_grid_name());
-				EXECUTION_REPORT(REPORT_ERROR, dst_comp_node->get_comp_id(), src_original_grid->get_bottom_field_variation_type() != BOTTOM_FIELD_VARIATION_EXTERNAL, "Fail to generate an interpolation from component model \"%s\" to \"%s\": the source 3-D grid \"%s\" with SIGMA or HYBRID vertical coordinate has an external surface field while a 3-D grid with external surface field cannot be referred as a source grid in interpolation. Please verify.", src_comp_interfaces[0].first, dst_comp_full_name, src_original_grid->get_grid_name());
-			}
-			if (dst_original_grid->get_original_CoR_grid()->is_sigma_grid()) {
-				EXECUTION_REPORT(REPORT_ERROR, dst_comp_node->get_comp_id(), dst_original_grid->get_bottom_field_variation_type() != BOTTOM_FIELD_VARIATION_UNSET, "Fail to generate an interpolation from component model \"%s\" to \"%s\": the surface field of the target 3-D grid \"%s\" that includes SIGMA or HYBRID vertical coordinate has not been specified. Please verify.", src_comp_interfaces[0].first, dst_comp_full_name, dst_original_grid->get_grid_name());
-				if (dst_original_grid->get_bottom_field_variation_type() == BOTTOM_FIELD_VARIATION_EXTERNAL)
-					EXECUTION_REPORT(REPORT_ERROR, dst_comp_node->get_comp_id(), src_original_grid->get_original_CoR_grid()->is_sigma_grid(), "Fail to generate an interpolation from component model \"%s\" to \"%s\": the target 3-D grid \"%s\" has an external surface field; at this time, the source 3-D grid \"%s\" should include SIGMA or HYBRID vertical coordinate but actually not. Please verify. ", src_comp_interfaces[0].first, dst_comp_full_name, dst_original_grid->get_grid_name(), src_original_grid->get_grid_name());
-			}	
-			dst_fields_info[i]->runtime_remapping_weights = runtime_remapping_weights_mgr->search_or_generate_runtime_remapping_weights(src_comp_node->get_comp_full_name(), dst_comp_node->get_comp_full_name(), src_original_grid, dst_original_grid, &field_remapping_setting, decomps_info_mgr->search_decomp_info(dst_fields_info[i]->decomp_name, dst_comp_node->get_comp_id()));
-			if (src_original_grid->get_original_CoR_grid()->is_sigma_grid())
-				add_bottom_field_coupling_info(i, dst_fields_info[i]->runtime_remapping_weights, &field_remapping_setting);
-		}
-	}
-	
-	int *remapping_weights_index_table = new int [fields_name.size()];
-	long array_size = fields_name.size()*sizeof(int);
-	if (current_proc_id_dst_comp != -1) 
-		for (int i = 0; i < fields_name.size(); i ++)
-			if (dst_fields_info[i]->runtime_remapping_weights == NULL || !dst_fields_info[i]->runtime_remapping_weights->get_src_original_grid()->is_H2D_grid())
-				remapping_weights_index_table[i] = -1;
-			else {
-				for (j = 0; j < i; j ++)
-					if (dst_fields_info[i]->runtime_remapping_weights == dst_fields_info[j]->runtime_remapping_weights)
-						break;
-				remapping_weights_index_table[i] = j;
-			}
-	transfer_array_from_one_comp_to_another(current_proc_id_dst_comp, dst_comp_node->get_local_proc_global_id(0), current_proc_id_src_comp, src_comp_node->get_local_proc_global_id(0), src_comp_node->get_comm_group(), (char**)(&remapping_weights_index_table), array_size);
-	for (int i = 0; i < fields_name.size(); i ++) {
-		if (remapping_weights_index_table[i] == -1)
-			continue;
-		if (remapping_weights_index_table[i] != i) {
-			if (current_proc_id_src_comp != -1)
-				src_fields_info[i]->runtime_remapping_weights = src_fields_info[remapping_weights_index_table[i]]->runtime_remapping_weights;	
-		}
-		else runtime_remapping_weights_mgr->transfer_runtime_remapping_weights(dst_fields_info[i]->runtime_remapping_weights, &(src_fields_info[i]->runtime_remapping_weights), dst_comp_node, src_comp_node);
-	}
-	delete [] remapping_weights_index_table;
-
-	generate_src_bottom_field_coupling_info();
-	exchange_bottom_fields_info();
-
-	if (current_proc_id_src_comp != -1)
-		EXECUTION_REPORT_LOG(REPORT_LOG, src_comp_node->get_comp_id(), true, "finish generating interpolation between components \"%s\" and \"%s\". The connection id is %d", src_comp_interfaces[0].first, dst_comp_full_name, connection_id);
-	if (current_proc_id_dst_comp != -1)
-		EXECUTION_REPORT_LOG(REPORT_LOG, dst_comp_node->get_comp_id(), true, "finish generating interpolation between components \"%s\" and \"%s\". The connection id is %d", src_comp_interfaces[0].first, dst_comp_full_name, connection_id);
+    Original_grid_info *src_original_grid = NULL, *dst_original_grid = NULL;
+    int i, j;
+
+    
+    if (current_proc_id_src_comp != -1)
+        EXECUTION_REPORT_LOG(REPORT_LOG, src_comp_node->get_comp_id(), true, "start to generate interpolation between components \"%s\" and \"%s\". The connection id is %d", src_comp_interfaces[0].first, dst_comp_full_name, connection_id);
+    if (current_proc_id_dst_comp != -1)
+        EXECUTION_REPORT_LOG(REPORT_LOG, dst_comp_node->get_comp_id(), true, "start to generate interpolation between components \"%s\" and \"%s\". The connection id is %d", src_comp_interfaces[0].first, dst_comp_full_name, connection_id);
+
+    for (int i = 0; i < fields_name.size(); i ++) {
+        src_fields_info[i]->runtime_remapping_weights = NULL;
+        dst_fields_info[i]->runtime_remapping_weights = NULL;
+        if (words_are_the_same(dst_fields_info[i]->grid_name, "NULL")) {
+			if (current_proc_id_dst_comp != -1)
+				EXECUTION_REPORT_ERROR_OPTIONALLY(REPORT_ERROR, dst_comp_node->get_comp_id(), words_are_the_same(src_fields_info[i]->grid_name, "NULL"), "Error happens when trying to generate data interpolation for the field \"%s\" in the coupling from the component model \"%s\" (interface is \"%s\") to the component model \"%s\" (interface is \"%s\"): the field is scalar (not on a grid) on the target component model while is on a grid \"%s\" on the source component model. Please verify.", fields_name[i], src_comp_interfaces[0].first, src_comp_interfaces[0].second, dst_comp_full_name, dst_interface_name, dst_fields_info[i]->grid_name);
+            continue;
+        }
+        if (words_are_the_same(src_fields_info[i]->grid_name, "NULL")) {
+			if (current_proc_id_dst_comp != -1)
+				EXECUTION_REPORT_ERROR_OPTIONALLY(REPORT_ERROR, dst_comp_node->get_comp_id(), words_are_the_same(dst_fields_info[i]->grid_name, "NULL"), "Error happens when trying to generate data interpolation for the field \"%s\" in the coupling from the component model \"%s\" (interface is \"%s\") to the component model \"%s\" (interface is \"%s\"): the field is scalar (not on a grid) on the source component model while is on a grid \"%s\" on the target component model. Please verify.", fields_name[i], src_comp_interfaces[0].first, src_comp_interfaces[0].second, dst_comp_full_name, dst_interface_name, dst_fields_info[i]->grid_name);
+            continue;
+        }
+        if (src_comp_node == dst_comp_node && words_are_the_same(src_fields_info[i]->grid_name, dst_fields_info[i]->grid_name))
+            continue;
+        Remapping_setting field_remapping_setting;    
+        if (words_are_the_same(fields_name[i], "remap_frac")) {
+            EXECUTION_REPORT(REPORT_ERROR, -1, fields_name.size() > 1 && i == fields_name.size()-1, "Software error in Coupling_connection::generate_interpolation");
+            exchange_remapping_setting(0, field_remapping_setting);
+        }
+        else exchange_remapping_setting(i, field_remapping_setting);
+//        exchange_grid(dst_comp_node, src_comp_node, dst_fields_info[i]->grid_name);
+        exchange_grid(src_comp_node, dst_comp_node, src_fields_info[i]->grid_name);
+        if (current_proc_id_dst_comp != -1) {
+            dst_original_grid = original_grid_mgr->search_grid_info(dst_fields_info[i]->grid_name, comp_comm_group_mgt_mgr->search_global_node(dst_comp_full_name)->get_comp_id());
+            src_original_grid = original_grid_mgr->search_grid_info(src_fields_info[i]->grid_name, comp_comm_group_mgt_mgr->search_global_node(src_comp_interfaces[0].first)->get_comp_id());
+            if (src_original_grid->is_H2D_grid_and_the_same_as_another_grid(dst_original_grid)) {
+                EXECUTION_REPORT_LOG(REPORT_LOG, dst_comp_node->get_comp_id(), true, "The data interpolation from grid \"%s\" to \"%s\" is bypassed as these too grids are the same", src_original_grid->get_grid_name(), dst_original_grid->get_grid_name());
+                continue;
+            }
+            else EXECUTION_REPORT_LOG(REPORT_LOG, dst_comp_node->get_comp_id(), true, "The data interpolation from grid \"%s\" to \"%s\" is necessary", src_original_grid->get_grid_name(), dst_original_grid->get_grid_name());
+            EXECUTION_REPORT(REPORT_ERROR, dst_comp_node->get_comp_id(), words_are_the_same(src_fields_info[i]->data_type, DATA_TYPE_FLOAT) || words_are_the_same(src_fields_info[i]->data_type, DATA_TYPE_DOUBLE),  "Error happens when trying to generate data interpolation for the field \%s\" in the coupling from the component model \"%s\" (interface is \"%s\") to the component model \"%s\" (interface is \"%s\"): the data type in the source component model is not floating-point but %s. Please verify.", fields_name[i], src_comp_interfaces[0].first, src_comp_interfaces[0].second, dst_comp_full_name, dst_interface_name, src_fields_info[i]->data_type);
+            EXECUTION_REPORT(REPORT_ERROR, dst_comp_node->get_comp_id(), words_are_the_same(dst_fields_info[i]->data_type, DATA_TYPE_FLOAT) || words_are_the_same(dst_fields_info[i]->data_type, DATA_TYPE_DOUBLE),  "Error happens when trying to generate data interpolation for the field \%s\" in the coupling from the component model \"%s\" (interface is \"%s\") to the component model \"%s\" (interface is \"%s\"): the data type in the source component model is not floating-point but %s. Please verify.", fields_name[i], src_comp_interfaces[0].first, src_comp_interfaces[0].second, dst_comp_full_name, dst_interface_name, dst_fields_info[i]->data_type);    
+            if (src_original_grid->get_original_CoR_grid()->is_sigma_grid()) {
+                EXECUTION_REPORT(REPORT_ERROR, dst_comp_node->get_comp_id(), src_original_grid->get_bottom_field_variation_type() != BOTTOM_FIELD_VARIATION_UNSET, "Fail to generate an interpolation from component model \"%s\" to \"%s\": the surface field of the source 3-D grid \"%s\" with SIGMA or HYBRID vertical coordinate has not been specified. Please verify.", src_comp_interfaces[0].first, dst_comp_full_name, src_original_grid->get_grid_name());
+                EXECUTION_REPORT(REPORT_ERROR, dst_comp_node->get_comp_id(), src_original_grid->get_bottom_field_variation_type() != BOTTOM_FIELD_VARIATION_EXTERNAL, "Fail to generate an interpolation from component model \"%s\" to \"%s\": the source 3-D grid \"%s\" with SIGMA or HYBRID vertical coordinate has an external surface field while a 3-D grid with external surface field cannot be referred as a source grid in interpolation. Please verify.", src_comp_interfaces[0].first, dst_comp_full_name, src_original_grid->get_grid_name());
+            }
+            if (dst_original_grid->get_original_CoR_grid()->is_sigma_grid()) {
+                EXECUTION_REPORT(REPORT_ERROR, dst_comp_node->get_comp_id(), dst_original_grid->get_bottom_field_variation_type() != BOTTOM_FIELD_VARIATION_UNSET, "Fail to generate an interpolation from component model \"%s\" to \"%s\": the surface field of the target 3-D grid \"%s\" that includes SIGMA or HYBRID vertical coordinate has not been specified. Please verify.", src_comp_interfaces[0].first, dst_comp_full_name, dst_original_grid->get_grid_name());
+                if (dst_original_grid->get_bottom_field_variation_type() == BOTTOM_FIELD_VARIATION_EXTERNAL)
+                    EXECUTION_REPORT(REPORT_ERROR, dst_comp_node->get_comp_id(), src_original_grid->get_original_CoR_grid()->is_sigma_grid(), "Fail to generate an interpolation from component model \"%s\" to \"%s\": the target 3-D grid \"%s\" has an external surface field; at this time, the source 3-D grid \"%s\" should include SIGMA or HYBRID vertical coordinate but actually not. Please verify. ", src_comp_interfaces[0].first, dst_comp_full_name, dst_original_grid->get_grid_name(), src_original_grid->get_grid_name());
+            }    
+            dst_fields_info[i]->runtime_remapping_weights = runtime_remapping_weights_mgr->search_or_generate_runtime_remapping_weights(src_comp_node->get_comp_full_name(), dst_comp_node->get_comp_full_name(), src_original_grid, dst_original_grid, &field_remapping_setting, decomps_info_mgr->search_decomp_info(dst_fields_info[i]->decomp_name, dst_comp_node->get_comp_id()));
+            if (src_original_grid->get_original_CoR_grid()->is_sigma_grid() || src_original_grid->get_original_CoR_grid()->does_use_V3D_level_coord())
+                add_bottom_field_coupling_info(i, dst_fields_info[i]->runtime_remapping_weights, &field_remapping_setting);
+        }
+    }
+    
+    int *remapping_weights_index_table = new int [fields_name.size()];
+    long array_size = fields_name.size()*sizeof(int);
+    if (current_proc_id_dst_comp != -1) 
+        for (int i = 0; i < fields_name.size(); i ++)
+            if (dst_fields_info[i]->runtime_remapping_weights == NULL || !dst_fields_info[i]->runtime_remapping_weights->get_src_original_grid()->is_H2D_grid())
+                remapping_weights_index_table[i] = -1;
+            else {
+                for (j = 0; j < i; j ++)
+                    if (dst_fields_info[i]->runtime_remapping_weights == dst_fields_info[j]->runtime_remapping_weights)
+                        break;
+                remapping_weights_index_table[i] = j;
+            }
+    transfer_array_from_one_comp_to_another(current_proc_id_dst_comp, dst_comp_node->get_local_proc_global_id(0), current_proc_id_src_comp, src_comp_node->get_local_proc_global_id(0), src_comp_node->get_comm_group(), (char**)(&remapping_weights_index_table), array_size);
+    for (int i = 0; i < fields_name.size(); i ++) {
+        if (remapping_weights_index_table[i] == -1)
+            continue;
+        if (remapping_weights_index_table[i] != i) {
+            if (current_proc_id_src_comp != -1)
+                src_fields_info[i]->runtime_remapping_weights = src_fields_info[remapping_weights_index_table[i]]->runtime_remapping_weights;    
+        }
+        else runtime_remapping_weights_mgr->transfer_runtime_remapping_weights(dst_fields_info[i]->runtime_remapping_weights, &(src_fields_info[i]->runtime_remapping_weights), dst_comp_node, src_comp_node);
+    }
+    delete [] remapping_weights_index_table;
+
+    generate_src_bottom_field_coupling_info();
+    exchange_bottom_fields_info();
+
+    if (current_proc_id_src_comp != -1)
+        EXECUTION_REPORT_LOG(REPORT_LOG, src_comp_node->get_comp_id(), true, "finish generating interpolation between components \"%s\" and \"%s\". The connection id is %d", src_comp_interfaces[0].first, dst_comp_full_name, connection_id);
+    if (current_proc_id_dst_comp != -1)
+        EXECUTION_REPORT_LOG(REPORT_LOG, dst_comp_node->get_comp_id(), true, "finish generating interpolation between components \"%s\" and \"%s\". The connection id is %d", src_comp_interfaces[0].first, dst_comp_full_name, connection_id);
 }
 
 
 void Coupling_connection::exchange_connection_fields_info()
 {
-	char *src_fields_info_array = NULL, *dst_fields_info_array = NULL;
-	long src_fields_info_array_size, dst_fields_info_array_size, buffer_max_size, comp_id;
-
-
-	if (current_proc_id_dst_comp != -1)
-		write_connection_fields_info_into_array(import_interface, &dst_fields_info_array, buffer_max_size, dst_fields_info_array_size, &dst_timer, dst_inst_or_aver, dst_time_step_in_second, dst_current_year, dst_current_month, dst_current_day, dst_current_second);
-	if (current_proc_id_src_comp != -1)
-		write_connection_fields_info_into_array(export_interface, &src_fields_info_array, buffer_max_size, src_fields_info_array_size, &src_timer, src_inst_or_aver, src_time_step_in_second, src_current_year, src_current_month, src_current_day, src_current_second);
-	transfer_array_from_one_comp_to_another(current_proc_id_src_comp, src_comp_root_proc_global_id, current_proc_id_dst_comp, dst_comp_root_proc_global_id, dst_comp_node->get_comm_group(), &src_fields_info_array, src_fields_info_array_size);
-	transfer_array_from_one_comp_to_another(current_proc_id_dst_comp, dst_comp_root_proc_global_id, current_proc_id_src_comp, src_comp_root_proc_global_id, src_comp_node->get_comm_group(), &dst_fields_info_array, dst_fields_info_array_size);
-	comp_id = export_interface != NULL? export_interface->get_comp_id() : import_interface->get_comp_id();
-	read_connection_fields_info_from_array(src_fields_info, src_fields_info_array, src_fields_info_array_size, comp_id, &src_timer, src_inst_or_aver, src_time_step_in_second, src_current_year, src_current_month, src_current_day, src_current_second);
-	comp_id = import_interface != NULL? import_interface->get_comp_id() : export_interface->get_comp_id();
-	read_connection_fields_info_from_array(dst_fields_info, dst_fields_info_array, dst_fields_info_array_size, comp_id, &dst_timer, dst_inst_or_aver, dst_time_step_in_second, dst_current_year, dst_current_month, dst_current_day, dst_current_second);
-	EXECUTION_REPORT(REPORT_ERROR, -1, fields_name.size() == src_fields_info.size() && fields_name.size() == dst_fields_info.size(), "Software error in Coupling_connection::exchange_connection_fields_info");
-
-	src_timer->reset_remote_lag_count();
-	
-	delete [] src_fields_info_array;
-	delete [] dst_fields_info_array;
+    char *src_fields_info_array = NULL, *dst_fields_info_array = NULL;
+    long src_fields_info_array_size, dst_fields_info_array_size, buffer_max_size, comp_id;
+
+
+    if (current_proc_id_dst_comp != -1)
+        write_connection_fields_info_into_array(import_interface, &dst_fields_info_array, buffer_max_size, dst_fields_info_array_size, &dst_timer, dst_inst_or_aver, dst_time_step_in_second, dst_current_year, dst_current_month, dst_current_day, dst_current_second);
+    if (current_proc_id_src_comp != -1)
+        write_connection_fields_info_into_array(export_interface, &src_fields_info_array, buffer_max_size, src_fields_info_array_size, &src_timer, src_inst_or_aver, src_time_step_in_second, src_current_year, src_current_month, src_current_day, src_current_second);
+    transfer_array_from_one_comp_to_another(current_proc_id_src_comp, src_comp_root_proc_global_id, current_proc_id_dst_comp, dst_comp_root_proc_global_id, dst_comp_node->get_comm_group(), &src_fields_info_array, src_fields_info_array_size);
+    transfer_array_from_one_comp_to_another(current_proc_id_dst_comp, dst_comp_root_proc_global_id, current_proc_id_src_comp, src_comp_root_proc_global_id, src_comp_node->get_comm_group(), &dst_fields_info_array, dst_fields_info_array_size);
+    comp_id = export_interface != NULL? export_interface->get_comp_id() : import_interface->get_comp_id();
+    read_connection_fields_info_from_array(src_fields_info, src_fields_info_array, src_fields_info_array_size, comp_id, &src_timer, src_inst_or_aver, src_time_step_in_second, src_current_year, src_current_month, src_current_day, src_current_second);
+    comp_id = import_interface != NULL? import_interface->get_comp_id() : export_interface->get_comp_id();
+    read_connection_fields_info_from_array(dst_fields_info, dst_fields_info_array, dst_fields_info_array_size, comp_id, &dst_timer, dst_inst_or_aver, dst_time_step_in_second, dst_current_year, dst_current_month, dst_current_day, dst_current_second);
+    EXECUTION_REPORT(REPORT_ERROR, -1, fields_name.size() == src_fields_info.size() && fields_name.size() == dst_fields_info.size(), "Software error in Coupling_connection::exchange_connection_fields_info");
+
+    src_timer->reset_remote_lag_count();
+    
+    delete [] src_fields_info_array;
+    delete [] dst_fields_info_array;
 }
 
 
 void Coupling_connection::read_fields_info_from_array(std::vector<Interface_field_info*> &fields_info, const char *array_buffer, long buffer_content_iter)
 {
-	while (buffer_content_iter > 0) {
-		Interface_field_info *field_info = new Interface_field_info;
-		field_info->bottom_field_indx = -1;
-		field_info->runtime_remapping_weights = NULL;
-		read_data_from_array_buffer(field_info->decomp_name, NAME_STR_SIZE, array_buffer, buffer_content_iter, true);
-		read_data_from_array_buffer(field_info->grid_name, NAME_STR_SIZE, array_buffer, buffer_content_iter, true);
-		read_data_from_array_buffer(field_info->unit, NAME_STR_SIZE, array_buffer, buffer_content_iter, true);
-		read_data_from_array_buffer(field_info->data_type, NAME_STR_SIZE, array_buffer, buffer_content_iter, true);
-		fields_info.push_back(field_info);
-	}
-
-	EXECUTION_REPORT(REPORT_ERROR, -1, buffer_content_iter == 0, "Software error in Coupling_connection::read_fields_info_from_array: wrong buffer_content_iter");
+    while (buffer_content_iter > 0) {
+        Interface_field_info *field_info = new Interface_field_info;
+        field_info->bottom_field_indx = -1;
+        field_info->runtime_remapping_weights = NULL;
+        read_data_from_array_buffer(field_info->decomp_name, NAME_STR_SIZE, array_buffer, buffer_content_iter, true);
+        read_data_from_array_buffer(field_info->grid_name, NAME_STR_SIZE, array_buffer, buffer_content_iter, true);
+        read_data_from_array_buffer(field_info->unit, NAME_STR_SIZE, array_buffer, buffer_content_iter, true);
+        read_data_from_array_buffer(field_info->data_type, NAME_STR_SIZE, array_buffer, buffer_content_iter, true);
+        fields_info.push_back(field_info);
+    }
+
+    EXECUTION_REPORT(REPORT_ERROR, -1, buffer_content_iter == 0, "Software error in Coupling_connection::read_fields_info_from_array: wrong buffer_content_iter");
 }
 
 
 void Coupling_connection::read_connection_fields_info_from_array(std::vector<Interface_field_info*> &fields_info, const char *array_buffer, long buffer_content_iter, int comp_id, Coupling_timer **timer, int &inst_or_aver, int &time_step_in_second,
-	                                                                             int &current_year, int &current_month, int &current_day, int &current_second)
+                                                                                 int &current_year, int &current_month, int &current_day, int &current_second)
 {
-	bool successful;
-
-	read_data_from_array_buffer(&current_second, sizeof(int), array_buffer, buffer_content_iter, true);
-	read_data_from_array_buffer(&current_day, sizeof(int), array_buffer, buffer_content_iter, true);
-	read_data_from_array_buffer(&current_month, sizeof(int), array_buffer, buffer_content_iter, true);
-	read_data_from_array_buffer(&current_year, sizeof(int), array_buffer, buffer_content_iter, true);
-	read_data_from_array_buffer(&time_step_in_second, sizeof(int), array_buffer, buffer_content_iter, true);
-	read_data_from_array_buffer(&inst_or_aver, sizeof(int), array_buffer, buffer_content_iter, true);
-	*timer = new Coupling_timer(array_buffer, buffer_content_iter, comp_id, true, successful);
-
-	read_fields_info_from_array(fields_info, array_buffer, buffer_content_iter);
-	EXECUTION_REPORT(REPORT_ERROR, -1, fields_info.size() == fields_name.size(), "Software error in Coupling_connection::read_connection_fields_info_from_array: wrong size of fields_info");
+    bool successful;
+
+    read_data_from_array_buffer(&current_second, sizeof(int), array_buffer, buffer_content_iter, true);
+    read_data_from_array_buffer(&current_day, sizeof(int), array_buffer, buffer_content_iter, true);
+    read_data_from_array_buffer(&current_month, sizeof(int), array_buffer, buffer_content_iter, true);
+    read_data_from_array_buffer(&current_year, sizeof(int), array_buffer, buffer_content_iter, true);
+    read_data_from_array_buffer(&time_step_in_second, sizeof(int), array_buffer, buffer_content_iter, true);
+    read_data_from_array_buffer(&inst_or_aver, sizeof(int), array_buffer, buffer_content_iter, true);
+    *timer = new Coupling_timer(array_buffer, buffer_content_iter, comp_id, true, successful);
+
+    read_fields_info_from_array(fields_info, array_buffer, buffer_content_iter);
+    EXECUTION_REPORT(REPORT_ERROR, -1, fields_info.size() == fields_name.size(), "Software error in Coupling_connection::read_connection_fields_info_from_array: wrong size of fields_info");
 }
 
 
 void Coupling_connection::write_field_info_into_array(Field_mem_info *field, char **array, long &buffer_max_size, long &buffer_content_size)
 {
-	char tmp_string[NAME_STR_SIZE];
-
-	
-	EXECUTION_REPORT(REPORT_ERROR, -1, field != NULL, "Software error in Coupling_connection::write_field_info_into_array");
-	write_data_into_array_buffer(field->get_field_data()->get_grid_data_field()->data_type_in_application, NAME_STR_SIZE, array, buffer_max_size, buffer_content_size);
-	write_data_into_array_buffer(field->get_unit(), NAME_STR_SIZE, array, buffer_max_size, buffer_content_size);
-	const char *grid_name = field->get_grid_name();
-	if (grid_name == NULL) {
-		strcpy(tmp_string, "NULL");
-		write_data_into_array_buffer(tmp_string, NAME_STR_SIZE, array, buffer_max_size, buffer_content_size);
-	}
-	else write_data_into_array_buffer(grid_name, NAME_STR_SIZE, array, buffer_max_size, buffer_content_size);
-	const char *decomp_name = field->get_decomp_name();
-	if (decomp_name == NULL) {
-		strcpy(tmp_string, "NULL");
-		write_data_into_array_buffer(tmp_string, NAME_STR_SIZE, array, buffer_max_size, buffer_content_size);
-	}
-	else write_data_into_array_buffer(decomp_name, NAME_STR_SIZE, array, buffer_max_size, buffer_content_size);
+    char tmp_string[NAME_STR_SIZE];
+
+    
+    EXECUTION_REPORT(REPORT_ERROR, -1, field != NULL, "Software error in Coupling_connection::write_field_info_into_array");
+    write_data_into_array_buffer(field->get_field_data()->get_grid_data_field()->data_type_in_application, NAME_STR_SIZE, array, buffer_max_size, buffer_content_size);
+    write_data_into_array_buffer(field->get_unit(), NAME_STR_SIZE, array, buffer_max_size, buffer_content_size);
+    const char *grid_name = field->get_grid_name();
+    if (grid_name == NULL) {
+        strcpy(tmp_string, "NULL");
+        write_data_into_array_buffer(tmp_string, NAME_STR_SIZE, array, buffer_max_size, buffer_content_size);
+    }
+    else write_data_into_array_buffer(grid_name, NAME_STR_SIZE, array, buffer_max_size, buffer_content_size);
+    const char *decomp_name = field->get_decomp_name();
+    if (decomp_name == NULL) {
+        strcpy(tmp_string, "NULL");
+        write_data_into_array_buffer(tmp_string, NAME_STR_SIZE, array, buffer_max_size, buffer_content_size);
+    }
+    else write_data_into_array_buffer(decomp_name, NAME_STR_SIZE, array, buffer_max_size, buffer_content_size);
 }
  
 
 void Coupling_connection::write_connection_fields_info_into_array(Inout_interface *inout_interface, char **array, long &buffer_max_size, long &buffer_content_size, Coupling_timer **timer, int &inst_or_aver, int &time_step_in_second, 
-	                                                                               int &current_year, int &current_month, int &current_day, int &current_second)
+                                                                                   int &current_year, int &current_month, int &current_day, int &current_second)
 {
-	char tmp_string[NAME_STR_SIZE];
-	int field_local_index;
-
-	
-	for (int i = fields_name.size() - 1; i >= 0; i --) {
-		Field_mem_info *field = inout_interface->search_registered_field_instance(fields_name[i], field_local_index);
-		if (field == NULL)
-			EXECUTION_REPORT(REPORT_ERROR, inout_interface->get_comp_id(), field != NULL, "Software error in Coupling_connection::write_connection_fields_info_into_array: %s %s", inout_interface->get_interface_name(), fields_name[i]);
-		write_field_info_into_array(field, array, buffer_max_size, buffer_content_size);
-	}
-	*timer = inout_interface->get_timer();
-	inst_or_aver = inout_interface->get_inst_or_aver();
-	time_step_in_second = components_time_mgrs->get_time_mgr(inout_interface->get_comp_id())->get_time_step_in_second();
-	components_time_mgrs->get_time_mgr(inout_interface->get_comp_id())->get_current_time(current_year, current_month, current_day, current_second, 0, "in Coupling_connection::write_connection_fields_info_into_array");
-	(*timer)->write_timer_into_array(array, buffer_max_size, buffer_content_size);
-	write_data_into_array_buffer(&inst_or_aver, sizeof(int), array, buffer_max_size, buffer_content_size);
-	write_data_into_array_buffer(&time_step_in_second, sizeof(int), array, buffer_max_size, buffer_content_size);
-	write_data_into_array_buffer(&current_year, sizeof(int), array, buffer_max_size, buffer_content_size);
-	write_data_into_array_buffer(&current_month, sizeof(int), array, buffer_max_size, buffer_content_size);
-	write_data_into_array_buffer(&current_day, sizeof(int), array, buffer_max_size, buffer_content_size);
-	write_data_into_array_buffer(&current_second, sizeof(int), array, buffer_max_size, buffer_content_size);
+    char tmp_string[NAME_STR_SIZE];
+    int field_local_index;
+
+    
+    for (int i = fields_name.size() - 1; i >= 0; i --) {
+        Field_mem_info *field = inout_interface->search_registered_field_instance(fields_name[i], field_local_index);
+        if (field == NULL)
+            EXECUTION_REPORT(REPORT_ERROR, inout_interface->get_comp_id(), field != NULL, "Software error in Coupling_connection::write_connection_fields_info_into_array: %s %s", inout_interface->get_interface_name(), fields_name[i]);
+        write_field_info_into_array(field, array, buffer_max_size, buffer_content_size);
+    }
+    *timer = inout_interface->get_timer();
+    inst_or_aver = inout_interface->get_inst_or_aver();
+    time_step_in_second = components_time_mgrs->get_time_mgr(inout_interface->get_comp_id())->get_time_step_in_second();
+    components_time_mgrs->get_time_mgr(inout_interface->get_comp_id())->get_current_time(current_year, current_month, current_day, current_second, 0, "in Coupling_connection::write_connection_fields_info_into_array");
+    (*timer)->write_timer_into_array(array, buffer_max_size, buffer_content_size);
+    write_data_into_array_buffer(&inst_or_aver, sizeof(int), array, buffer_max_size, buffer_content_size);
+    write_data_into_array_buffer(&time_step_in_second, sizeof(int), array, buffer_max_size, buffer_content_size);
+    write_data_into_array_buffer(&current_year, sizeof(int), array, buffer_max_size, buffer_content_size);
+    write_data_into_array_buffer(&current_month, sizeof(int), array, buffer_max_size, buffer_content_size);
+    write_data_into_array_buffer(&current_day, sizeof(int), array, buffer_max_size, buffer_content_size);
+    write_data_into_array_buffer(&current_second, sizeof(int), array, buffer_max_size, buffer_content_size);
 }
 
 
 void Coupling_connection::exchange_bottom_fields_info()
 {
-	char *src_fields_info_array = NULL, *dst_fields_info_array = NULL;
-	long src_fields_info_array_size = 0, dst_fields_info_array_size = 0, buffer_max_size;
-
-
-	if (current_proc_id_dst_comp != -1)
-		for (int i = dst_bottom_fields_coupling_info.size() - 1; i >= 0; i --)
-			write_field_info_into_array(dst_bottom_fields_coupling_info[i]->bottom_field_inst, &dst_fields_info_array, buffer_max_size, dst_fields_info_array_size);
-	if (current_proc_id_src_comp != -1)
-		for (int i = src_bottom_fields_coupling_info.size() - 1; i >= 0; i --)
-			write_field_info_into_array(src_bottom_fields_coupling_info[i]->bottom_field_inst, &src_fields_info_array, buffer_max_size, src_fields_info_array_size);
-
-	transfer_array_from_one_comp_to_another(current_proc_id_src_comp, src_comp_root_proc_global_id, current_proc_id_dst_comp, dst_comp_root_proc_global_id, dst_comp_node->get_comm_group(), &src_fields_info_array, src_fields_info_array_size);
-	transfer_array_from_one_comp_to_another(current_proc_id_dst_comp, dst_comp_root_proc_global_id, current_proc_id_src_comp, src_comp_root_proc_global_id, src_comp_node->get_comm_group(), &dst_fields_info_array, dst_fields_info_array_size);
-
-	read_fields_info_from_array(src_fields_info, src_fields_info_array, src_fields_info_array_size);
-	read_fields_info_from_array(dst_fields_info, dst_fields_info_array, dst_fields_info_array_size);
-
-	EXECUTION_REPORT(REPORT_ERROR, -1, dst_fields_info.size() == src_fields_info.size(), "Software error in Coupling_connection::exchange_bottom_fields_info");
-	
-	for (int i = fields_name.size(); i < dst_fields_info.size(); i ++) {
-		dst_fields_info[i]->bottom_field_indx = i - fields_name.size();
-		src_fields_info[i]->bottom_field_indx = dst_fields_info[i]->bottom_field_indx;
-		if (current_proc_id_dst_comp != -1)
-			dst_fields_info[i]->runtime_remapping_weights = dst_bottom_fields_coupling_info[dst_fields_info[i]->bottom_field_indx]->H2D_runtime_remapping_weights;
-	}
-
-	if (src_fields_info_array != NULL)
-		delete [] src_fields_info_array;
-	if (dst_fields_info_array != NULL)
-		delete [] dst_fields_info_array;
+    char *src_fields_info_array = NULL, *dst_fields_info_array = NULL;
+    long src_fields_info_array_size = 0, dst_fields_info_array_size = 0, buffer_max_size;
+
+
+    if (current_proc_id_dst_comp != -1)
+        for (int i = dst_bottom_fields_coupling_info.size() - 1; i >= 0; i --)
+            write_field_info_into_array(dst_bottom_fields_coupling_info[i]->bottom_field_inst, &dst_fields_info_array, buffer_max_size, dst_fields_info_array_size);
+    if (current_proc_id_src_comp != -1)
+        for (int i = src_bottom_fields_coupling_info.size() - 1; i >= 0; i --)
+            write_field_info_into_array(src_bottom_fields_coupling_info[i]->bottom_field_inst, &src_fields_info_array, buffer_max_size, src_fields_info_array_size);
+
+    transfer_array_from_one_comp_to_another(current_proc_id_src_comp, src_comp_root_proc_global_id, current_proc_id_dst_comp, dst_comp_root_proc_global_id, dst_comp_node->get_comm_group(), &src_fields_info_array, src_fields_info_array_size);
+    transfer_array_from_one_comp_to_another(current_proc_id_dst_comp, dst_comp_root_proc_global_id, current_proc_id_src_comp, src_comp_root_proc_global_id, src_comp_node->get_comm_group(), &dst_fields_info_array, dst_fields_info_array_size);
+
+    read_fields_info_from_array(src_fields_info, src_fields_info_array, src_fields_info_array_size);
+    read_fields_info_from_array(dst_fields_info, dst_fields_info_array, dst_fields_info_array_size);
+
+    EXECUTION_REPORT(REPORT_ERROR, -1, dst_fields_info.size() == src_fields_info.size(), "Software error in Coupling_connection::exchange_bottom_fields_info");
+    
+    for (int i = fields_name.size(); i < dst_fields_info.size(); i ++) {
+        dst_fields_info[i]->bottom_field_indx = i - fields_name.size();
+        src_fields_info[i]->bottom_field_indx = dst_fields_info[i]->bottom_field_indx;
+        if (current_proc_id_dst_comp != -1)
+            dst_fields_info[i]->runtime_remapping_weights = dst_bottom_fields_coupling_info[dst_fields_info[i]->bottom_field_indx]->H2D_runtime_remapping_weights;
+    }
+
+    if (src_fields_info_array != NULL)
+        delete [] src_fields_info_array;
+    if (dst_fields_info_array != NULL)
+        delete [] dst_fields_info_array;
 }
 
 
 Field_mem_info *Coupling_connection::get_bottom_field(bool export_or_import, int bottom_field_indx)
 {
-	if (export_or_import) {
-		EXECUTION_REPORT(REPORT_ERROR, -1, bottom_field_indx < src_bottom_fields_coupling_info.size(), "Software error in Coupling_connection::get_bottom_field: wrong bottom_field_indx");
-		return src_bottom_fields_coupling_info[bottom_field_indx]->bottom_field_inst;
-	}
-	else {
-		EXECUTION_REPORT(REPORT_ERROR, -1, bottom_field_indx < dst_bottom_fields_coupling_info.size(), "Software error in Coupling_connection::get_bottom_field: wrong bottom_field_indx");
-
-		return dst_bottom_fields_coupling_info[bottom_field_indx]->bottom_field_inst;
-	}
+    if (export_or_import) {
+        EXECUTION_REPORT(REPORT_ERROR, -1, bottom_field_indx < src_bottom_fields_coupling_info.size(), "Software error in Coupling_connection::get_bottom_field: wrong bottom_field_indx");
+        return src_bottom_fields_coupling_info[bottom_field_indx]->bottom_field_inst;
+    }
+    else {
+        EXECUTION_REPORT(REPORT_ERROR, -1, bottom_field_indx < dst_bottom_fields_coupling_info.size(), "Software error in Coupling_connection::get_bottom_field: wrong bottom_field_indx");
+
+        return dst_bottom_fields_coupling_info[bottom_field_indx]->bottom_field_inst;
+    }
 }
 
 
 bool Coupling_connection::get_is_bottom_field_dynamic(int field_indx)
 {
-	if (current_proc_id_src_comp != -1)
-		return src_bottom_fields_coupling_info[src_fields_info[field_indx]->bottom_field_indx]->is_dynamic_bottom_field;
+    if (current_proc_id_src_comp != -1)
+        return src_bottom_fields_coupling_info[src_fields_info[field_indx]->bottom_field_indx]->is_dynamic_bottom_field;
 
-	return dst_bottom_fields_coupling_info[dst_fields_info[field_indx]->bottom_field_indx]->is_dynamic_bottom_field;
+    return dst_bottom_fields_coupling_info[dst_fields_info[field_indx]->bottom_field_indx]->is_dynamic_bottom_field;
 }
 
 
 Import_direction_setting::Import_direction_setting(int host_comp_id, Import_interface_configuration *interface_configuration, const char *comp_full_name, const char *interface_name, TiXmlElement *redirection_element, const char *XML_file_name, std::vector<const char*> &interface_fields_name, int *fields_count, bool check_comp_existence)
 {
-	TiXmlElement *fields_element = NULL, *components_element = NULL, *remapping_element = NULL, *merge_element = NULL;
-	int i, line_number;
-	std::pair<const char*, const char*> producer_info;
-
-
-	strcpy(this->interface_name, interface_name);
-	for (TiXmlNode *detailed_element_node = redirection_element->FirstChild(); detailed_element_node != NULL; detailed_element_node = detailed_element_node->NextSibling()) {		
-		if (detailed_element_node->Type() != TiXmlNode::TINYXML_ELEMENT)
-			continue;
-		TiXmlElement *detailed_element = detailed_element_node->ToElement();
-		if (words_are_the_same(detailed_element->Value(), "fields")) {
-			if (!is_XML_setting_on(host_comp_id, detailed_element, XML_file_name, "the status of \"fields\"", "import interface configuration file"))
-				continue;
-			EXECUTION_REPORT(REPORT_ERROR, host_comp_id, fields_element == NULL, "When setting a coupling connection configuration of the import interface \"%s\" in the XML file \"%s\", the attribute of \"fields\" can be set only once but currently has been set at least twice. Please verify the XML file arround the line number %d.", interface_name, XML_file_name, detailed_element->Row());
-			fields_element = detailed_element;
-			const char *default_str = get_XML_attribute(host_comp_id, -1, detailed_element, "default", XML_file_name, line_number, "default setting of \"fields\"", "import interface configuration file", true);
-			EXECUTION_REPORT(REPORT_ERROR, host_comp_id, words_are_the_same(default_str, "off") || words_are_the_same(default_str, "all") || words_are_the_same(default_str, "remain"), "When setting a coupling connection configuration of the import interface \"%s\" in the XML file \"%s\", the value of \"default\" for the attribute of \"fields\" is wrong (legal values are \"off\", \"all\" and \"remain\"). Please verify the XML file arround the line number %d.", interface_name, XML_file_name, line_number);
-			if (words_are_the_same(default_str, "off")) {
-				fields_default_setting = 0;
-				for (TiXmlNode *field_element_node = detailed_element->FirstChild(); field_element_node != NULL; field_element_node = field_element_node->NextSibling()) {
-					if (field_element_node->Type() != TiXmlNode::TINYXML_ELEMENT)
-						continue;					
-					TiXmlElement *field_element = field_element_node->ToElement();
-					EXECUTION_REPORT(REPORT_ERROR, host_comp_id, words_are_the_same(field_element->Value(),"field"), "When setting the attribute \"fields\" for an coupling connection configuration of the import interface \"%s\" in the XML file \"%s\", please use the keyword \"field\" for the name of a field. Please verify the XML file arround the line number %d.", interface_name, XML_file_name, field_element->Row());
-					const char *field_name = get_XML_attribute(host_comp_id, -1, field_element, "name", XML_file_name, line_number, "the name of a field", "import interface configuration file", true);	
-					check_and_verify_name_format_of_string_for_XML(host_comp_id, field_name, "the field", XML_file_name, line_number);
-					EXECUTION_REPORT(REPORT_ERROR, host_comp_id, fields_info->search_field_info(field_name) != NULL, "When setting the attribute \"fields\" for an coupling connection configuration of the import interface \"%s\" in the XML file \"%s\", an illegal field name (\"%s\") is detected. Please verify the XML file arround the line number %d.", interface_name, XML_file_name, field_name, field_element->Row());
-					for (i = 0; i < interface_fields_name.size(); i ++)
-						if (words_are_the_same(interface_fields_name[i], field_name))
-							break;
-					if (i < interface_fields_name.size())
-						fields_name.push_back(strdup(interface_fields_name[i]));
-					else EXECUTION_REPORT(REPORT_WARNING, host_comp_id, true, "When setting the attribute \"fields\" for the coupling connection configuration of the import interface \"%s\" in the XML file \"%s\", the interface does not contain a field with the name of \"%s\"", interface_name, XML_file_name, field_name);
-				}
-				EXECUTION_REPORT(REPORT_WARNING, host_comp_id, fields_name.size() > 0, "When setting a coupling connection configuration of the import interface \"%s\" in the XML file \"%s\", there are no fields specified. Please note the XML file arround the line number %d.", interface_name, XML_file_name, detailed_element->Row());
-			}
-			else if (words_are_the_same(default_str, "all")) {
-				fields_default_setting = 1;
-				for (i = 0; i < interface_fields_name.size(); i ++) {
-					EXECUTION_REPORT(REPORT_ERROR, host_comp_id, fields_count[i] == 0, "When setting the coupling connection configuration of the import interface \"%s\" in the XML file \"%s\", the configuration information of field \"%s\" has been set more than once. This is not allowed. Please note that the default value \"all\" means all fields. Please verify the XML file arround the line number %d.", interface_name, XML_file_name, interface_fields_name[i], detailed_element->Row()); 
-					fields_count[i] ++;
-					fields_name.push_back(strdup(interface_fields_name[i]));					
-				}
-			}
-			else {
-				fields_default_setting = 2;
-				for (i = 0; i < interface_fields_name.size(); i ++) {
-					if (fields_count[i] != 0)
-						continue;
-					fields_count[i] ++;
-					fields_name.push_back(strdup(interface_fields_name[i]));					
-				}
-			}
-		}
-		else if (words_are_the_same(detailed_element->Value(), "components")) {
-			if (!is_XML_setting_on(host_comp_id, detailed_element, XML_file_name, "the status of \"components\"", "import interface configuration file"))
-				continue;
-			EXECUTION_REPORT(REPORT_ERROR, host_comp_id, components_element == NULL, "When setting the coupling connection configuration of the import interface \"%s\" in the XML file \"%s\", the attribute of \"components\" has been set at least twice in a coupling connection specification. Please verify the XML file arround the line number %d.", interface_name, XML_file_name, redirection_element->Row());
-			components_element = detailed_element;
-			const char *default_str = get_XML_attribute(host_comp_id, -1, detailed_element, "default", XML_file_name, line_number, "default setting for components", "import interface configuration file", true);
-			EXECUTION_REPORT(REPORT_ERROR, host_comp_id, words_are_the_same(default_str, "off") || words_are_the_same(default_str, "all"), "When setting the coupling connection configuration of the import interface \"%s\" in the XML file \"%s\", the value of \"default\" for the attribute of \"componets\" is wrong (legal values are \"off\" and \"all\"). Please verify the XML file arround the line number %d.", interface_name, XML_file_name, line_number);
-			if (words_are_the_same(default_str, "off")) {
-				components_default_setting = 0;
-				for (TiXmlNode *component_element_node = detailed_element->FirstChild(); component_element_node != NULL; component_element_node = component_element_node->NextSibling()) {
-					if (component_element_node->Type() != TiXmlNode::TINYXML_ELEMENT)
-						continue;
-					TiXmlElement *component_element = component_element_node->ToElement();
-					EXECUTION_REPORT(REPORT_ERROR, host_comp_id, words_are_the_same(component_element->Value(),"component"), "When setting the attribute \"components\" for the coupling connection configuration of the import interface \"%s\" in the XML file \"%s\", please use the keyword \"component\" for a specification of source component models (current wrong keyword is \"%s\"). Please verify the XML file arround the line number %d.", interface_name, XML_file_name, component_element->Value(), component_element->Row());
-					const char *full_name = get_XML_attribute(host_comp_id, 512, component_element, "comp_full_name", XML_file_name, line_number, "the full name of a component", "import interface configuration file", false);
-//					if (check_comp_existence)
-//						EXECUTION_REPORT(REPORT_ERROR, host_comp_id, comp_comm_group_mgt_mgr->search_global_node(full_name) != NULL, "When setting the coupling connection configuration of the import interface \"%s\" in the XML file \"%s\", the full component name (\"%s\") is wrong. Please verify the XML file arround the line number %d.", interface_name, XML_file_name, full_name, line_number);
-					const char *interface_name = component_element->Attribute("interface_name", &line_number);
-					if (full_name == NULL && interface_name == NULL)
-						continue;
-					if (full_name == NULL)
-						producer_info.first = strdup("\0");
-					else producer_info.first = strdup(full_name);
-					if (interface_name == NULL)
-						producer_info.second = strdup("\0");
-					else producer_info.second = strdup(interface_name);
-					for (i = 0; i < producers_info.size(); i ++)
-						if (words_are_the_same(producers_info[i].first, producer_info.first) && words_are_the_same(producers_info[i].second, producer_info.second))
-							break;
-					if (i == producers_info.size())
-						producers_info.push_back(producer_info);				
-				}
-			}
-			else {
-				components_default_setting = 1;
-				const int *all_components_ids = comp_comm_group_mgt_mgr->get_all_components_ids();
-				for (i = 1; i < all_components_ids[0]; i ++) {
-					producer_info.first = strdup(comp_comm_group_mgt_mgr->get_global_node_of_local_comp(all_components_ids[i],false,"in Import_direction_setting()")->get_comp_full_name());
-					producer_info.second = strdup("\0");
-					producers_info.push_back(producer_info);
-				}
-			}
-		}
-		else if (words_are_the_same(detailed_element->Value(), "merge_setting")) {
-			EXECUTION_REPORT(REPORT_ERROR, host_comp_id, false, "When setting the coupling connection configuration of the import interface \"%s\" in the XML file \"%s\", the attribute of \"merge_setting\" is not supported currently", interface_name, XML_file_name);
-		}
-		else EXECUTION_REPORT(REPORT_ERROR, host_comp_id, false, "When setting the coupling connection configuration of the import interface \"%s\" in the XML file \"%s\", \"%s\" is not a legal attribute. Please verify the XML file arround the line number %d.", interface_name, XML_file_name, detailed_element->Value(), detailed_element->Row());
-	}		
-	EXECUTION_REPORT(REPORT_ERROR, host_comp_id, fields_element != NULL, "For a coupling connection configuration of the import interface \"%s\" in the XML file \"%s\", the information about fields is not set. Please verify the XML file arround the line number %d.", interface_name, XML_file_name, redirection_element->Row());
-	EXECUTION_REPORT(REPORT_ERROR, host_comp_id, components_element != NULL, "For a coupling connection configuration of the import interface \"%s\" in the XML file \"%s\", the information about source component models is not set. Please verify the XML file arround the line number %d.", interface_name, XML_file_name, redirection_element->Row());
-	for (i = 0; i < fields_name.size(); i ++)
-		for (int j = 0; j < producers_info.size(); j ++)
-			interface_configuration->add_field_src_component(host_comp_id, fields_name[i], producers_info[j]);
+    TiXmlElement *fields_element = NULL, *components_element = NULL, *remapping_element = NULL, *merge_element = NULL;
+    int i, line_number;
+    std::pair<const char*, const char*> producer_info;
+
+
+    strcpy(this->interface_name, interface_name);
+    for (TiXmlNode *detailed_element_node = redirection_element->FirstChild(); detailed_element_node != NULL; detailed_element_node = detailed_element_node->NextSibling()) {        
+        if (detailed_element_node->Type() != TiXmlNode::TINYXML_ELEMENT)
+            continue;
+        TiXmlElement *detailed_element = detailed_element_node->ToElement();
+        if (words_are_the_same(detailed_element->Value(), "fields")) {
+            if (!is_XML_setting_on(host_comp_id, detailed_element, XML_file_name, "the status of \"fields\"", "import interface configuration file"))
+                continue;
+            EXECUTION_REPORT(REPORT_ERROR, host_comp_id, fields_element == NULL, "When setting a coupling connection configuration of the import interface \"%s\" in the XML file \"%s\", the attribute of \"fields\" can be set only once but currently has been set at least twice. Please verify the XML file arround the line number %d.", interface_name, XML_file_name, detailed_element->Row());
+            fields_element = detailed_element;
+            const char *default_str = get_XML_attribute(host_comp_id, -1, detailed_element, "default", XML_file_name, line_number, "default setting of \"fields\"", "import interface configuration file", true);
+            EXECUTION_REPORT(REPORT_ERROR, host_comp_id, words_are_the_same(default_str, "off") || words_are_the_same(default_str, "all") || words_are_the_same(default_str, "remain"), "When setting a coupling connection configuration of the import interface \"%s\" in the XML file \"%s\", the value of \"default\" for the attribute of \"fields\" is wrong (legal values are \"off\", \"all\" and \"remain\"). Please verify the XML file arround the line number %d.", interface_name, XML_file_name, line_number);
+            if (words_are_the_same(default_str, "off")) {
+                fields_default_setting = 0;
+                for (TiXmlNode *field_element_node = detailed_element->FirstChild(); field_element_node != NULL; field_element_node = field_element_node->NextSibling()) {
+                    if (field_element_node->Type() != TiXmlNode::TINYXML_ELEMENT)
+                        continue;                    
+                    TiXmlElement *field_element = field_element_node->ToElement();
+                    EXECUTION_REPORT(REPORT_ERROR, host_comp_id, words_are_the_same(field_element->Value(),"field"), "When setting the attribute \"fields\" for an coupling connection configuration of the import interface \"%s\" in the XML file \"%s\", please use the keyword \"field\" for the name of a field. Please verify the XML file arround the line number %d.", interface_name, XML_file_name, field_element->Row());
+                    const char *field_name = get_XML_attribute(host_comp_id, -1, field_element, "name", XML_file_name, line_number, "the name of a field", "import interface configuration file", true);    
+                    check_and_verify_name_format_of_string_for_XML(host_comp_id, field_name, "the field", XML_file_name, line_number);
+                    EXECUTION_REPORT(REPORT_ERROR, host_comp_id, fields_info->search_field_info(field_name) != NULL, "When setting the attribute \"fields\" for an coupling connection configuration of the import interface \"%s\" in the XML file \"%s\", an illegal field name (\"%s\") is detected. Please verify the XML file arround the line number %d.", interface_name, XML_file_name, field_name, field_element->Row());
+                    for (i = 0; i < interface_fields_name.size(); i ++)
+                        if (words_are_the_same(interface_fields_name[i], field_name))
+                            break;
+                    if (i < interface_fields_name.size())
+                        fields_name.push_back(strdup(interface_fields_name[i]));
+                    else EXECUTION_REPORT(REPORT_WARNING, host_comp_id, false, "When setting the attribute \"fields\" for the coupling connection configuration of the import interface \"%s\" in the XML file \"%s\", the interface does not contain a field with the name of \"%s\"", interface_name, XML_file_name, field_name);
+                }
+                EXECUTION_REPORT(REPORT_WARNING, host_comp_id, fields_name.size() > 0, "When setting a coupling connection configuration of the import interface \"%s\" in the XML file \"%s\", there are no fields specified. Please note the XML file arround the line number %d.", interface_name, XML_file_name, detailed_element->Row());
+            }
+            else if (words_are_the_same(default_str, "all")) {
+                fields_default_setting = 1;
+                for (i = 0; i < interface_fields_name.size(); i ++) {
+                    EXECUTION_REPORT(REPORT_ERROR, host_comp_id, fields_count[i] == 0, "When setting the coupling connection configuration of the import interface \"%s\" in the XML file \"%s\", the configuration information of field \"%s\" has been set more than once. This is not allowed. Please note that the default value \"all\" means all fields. Please verify the XML file arround the line number %d.", interface_name, XML_file_name, interface_fields_name[i], detailed_element->Row()); 
+                    fields_count[i] ++;
+                    fields_name.push_back(strdup(interface_fields_name[i]));                    
+                }
+            }
+            else {
+                fields_default_setting = 2;
+                for (i = 0; i < interface_fields_name.size(); i ++) {
+                    if (fields_count[i] != 0)
+                        continue;
+                    fields_count[i] ++;
+                    fields_name.push_back(strdup(interface_fields_name[i]));                    
+                }
+            }
+        }
+        else if (words_are_the_same(detailed_element->Value(), "components")) {
+            if (!is_XML_setting_on(host_comp_id, detailed_element, XML_file_name, "the status of \"components\"", "import interface configuration file"))
+                continue;
+            EXECUTION_REPORT(REPORT_ERROR, host_comp_id, components_element == NULL, "When setting the coupling connection configuration of the import interface \"%s\" in the XML file \"%s\", the attribute of \"components\" has been set at least twice in a coupling connection specification. Please verify the XML file arround the line number %d.", interface_name, XML_file_name, redirection_element->Row());
+            components_element = detailed_element;
+            const char *default_str = get_XML_attribute(host_comp_id, -1, detailed_element, "default", XML_file_name, line_number, "default setting for components", "import interface configuration file", true);
+            EXECUTION_REPORT(REPORT_ERROR, host_comp_id, words_are_the_same(default_str, "off") || words_are_the_same(default_str, "all"), "When setting the coupling connection configuration of the import interface \"%s\" in the XML file \"%s\", the value of \"default\" for the attribute of \"componets\" is wrong (legal values are \"off\" and \"all\"). Please verify the XML file arround the line number %d.", interface_name, XML_file_name, line_number);
+            if (words_are_the_same(default_str, "off")) {
+                components_default_setting = 0;
+                for (TiXmlNode *component_element_node = detailed_element->FirstChild(); component_element_node != NULL; component_element_node = component_element_node->NextSibling()) {
+                    if (component_element_node->Type() != TiXmlNode::TINYXML_ELEMENT)
+                        continue;
+                    TiXmlElement *component_element = component_element_node->ToElement();
+                    EXECUTION_REPORT(REPORT_ERROR, host_comp_id, words_are_the_same(component_element->Value(),"component") || words_are_the_same(component_element->Value(),"interface") || words_are_the_same(component_element->Value(),"entry"), "When setting the attribute \"components\" for the coupling connection configuration of the import interface \"%s\" in the XML file \"%s\", please use the keyword \"component\", \"interface\" or \"entry\" for a specification of source component models or export interfaces (current wrong keyword is \"%s\"). Please verify the XML file arround the line number %d.", interface_name, XML_file_name, component_element->Value(), component_element->Row());
+                    const char *full_name = get_XML_attribute(host_comp_id, 512, component_element, "comp_full_name", XML_file_name, line_number, "the full name of a component", "import interface configuration file", false);
+//                    if (check_comp_existence)
+//                        EXECUTION_REPORT(REPORT_ERROR, host_comp_id, comp_comm_group_mgt_mgr->search_global_node(full_name) != NULL, "When setting the coupling connection configuration of the import interface \"%s\" in the XML file \"%s\", the full component name (\"%s\") is wrong. Please verify the XML file arround the line number %d.", interface_name, XML_file_name, full_name, line_number);
+                    const char *interface_name = component_element->Attribute("interface_name", &line_number);
+                    if (full_name == NULL && interface_name == NULL)
+                        continue;
+                    if (full_name == NULL)
+                        producer_info.first = strdup("\0");
+                    else producer_info.first = strdup(full_name);
+                    if (interface_name == NULL)
+                        producer_info.second = strdup("\0");
+                    else producer_info.second = strdup(interface_name);
+                    for (i = 0; i < producers_info.size(); i ++)
+                        if (words_are_the_same(producers_info[i].first, producer_info.first) && words_are_the_same(producers_info[i].second, producer_info.second))
+                            break;
+                    if (i == producers_info.size())
+                        producers_info.push_back(producer_info);                
+                }
+            }
+            else {
+                components_default_setting = 1;
+                const int *all_components_ids = comp_comm_group_mgt_mgr->get_all_components_ids();
+                for (i = 1; i < all_components_ids[0]; i ++) {
+                    producer_info.first = strdup(comp_comm_group_mgt_mgr->get_global_node_of_local_comp(all_components_ids[i],false,"in Import_direction_setting()")->get_comp_full_name());
+                    producer_info.second = strdup("\0");
+                    producers_info.push_back(producer_info);
+                }
+            }
+        }
+        else if (words_are_the_same(detailed_element->Value(), "merge_setting")) {
+            EXECUTION_REPORT(REPORT_ERROR, host_comp_id, false, "When setting the coupling connection configuration of the import interface \"%s\" in the XML file \"%s\", the attribute of \"merge_setting\" is not supported currently", interface_name, XML_file_name);
+        }
+        else EXECUTION_REPORT(REPORT_ERROR, host_comp_id, false, "When setting the coupling connection configuration of the import interface \"%s\" in the XML file \"%s\", \"%s\" is not a legal attribute. Please verify the XML file arround the line number %d.", interface_name, XML_file_name, detailed_element->Value(), detailed_element->Row());
+    }        
+    EXECUTION_REPORT(REPORT_ERROR, host_comp_id, fields_element != NULL, "For a coupling connection configuration of the import interface \"%s\" in the XML file \"%s\", the information about fields is not set. Please verify the XML file arround the line number %d.", interface_name, XML_file_name, redirection_element->Row());
+    EXECUTION_REPORT(REPORT_ERROR, host_comp_id, components_element != NULL, "For a coupling connection configuration of the import interface \"%s\" in the XML file \"%s\", the information about source component models is not set. Please verify the XML file arround the line number %d.", interface_name, XML_file_name, redirection_element->Row());
+    for (i = 0; i < fields_name.size(); i ++)
+        for (int j = 0; j < producers_info.size(); j ++)
+            interface_configuration->add_field_src_component(host_comp_id, fields_name[i], producers_info[j]);
 }
 
 
 Import_direction_setting::~Import_direction_setting()
 {
-	clean_string_pair_vector(producers_info);
+    clean_string_pair_vector(producers_info);
 }
 
 
 Import_interface_configuration::Import_interface_configuration(int host_comp_id, const char *comp_full_name, const char *interface_name, TiXmlElement *interface_element, const char *XML_file_name, Inout_interface_mgt *all_interfaces_mgr, bool check_comp_existence)
 {
-	int *fields_count, line_number;
-	Inout_interface *interface_ptr = all_interfaces_mgr->get_interface(comp_full_name, interface_name);
-	std::vector<std::pair<const char*, const char*> > producers_info;
-	
-	
-	strcpy(this->interface_name, interface_name);
-	interface_ptr->get_fields_name(&fields_name);
-	fields_count = new int [fields_name.size()];
-	for (int i = 0; i < fields_name.size(); i ++)
-		fields_count[i] = 0;
-
-	for (int i = 0; i < fields_name.size(); i ++)
-		fields_src_producers_info.push_back(producers_info);
-
-	for (TiXmlNode *redirection_element_node = interface_element->FirstChild(); redirection_element_node != NULL; redirection_element_node = redirection_element_node->NextSibling()) {
-		if (redirection_element_node->Type() != TiXmlNode::TINYXML_ELEMENT)
-			continue;
-		TiXmlElement *redirection_element = redirection_element_node->ToElement();
-		EXECUTION_REPORT(REPORT_ERROR, interface_ptr->get_comp_id(), words_are_the_same(redirection_element->Value(),"import_connection"), "When setting the coupling connection configuration of the import interface \"%s\" in the XML file \"%s\", the XML element for specifying the coupling connection configuration should be named \"import_connection\" (current wrong name is \"%s\"). Please verify the XML file arround the line number %d.", interface_name, XML_file_name, redirection_element->Value(), redirection_element->Row());
-		if (!is_XML_setting_on(interface_ptr->get_comp_id(), redirection_element, XML_file_name, "the status of some coupling connection configurations for an import interface", "import interface configuration file"))
-			continue;
-		import_directions.push_back(new Import_direction_setting(host_comp_id, this, comp_full_name, interface_name, redirection_element, XML_file_name, fields_name, fields_count, check_comp_existence));
-	}
-
-	delete [] fields_count;
+    int *fields_count, line_number;
+    Inout_interface *interface_ptr = all_interfaces_mgr->get_interface(comp_full_name, interface_name);
+    std::vector<std::pair<const char*, const char*> > producers_info;
+    
+    
+    strcpy(this->interface_name, interface_name);
+    interface_ptr->get_fields_name(&fields_name);
+    fields_count = new int [fields_name.size()];
+    for (int i = 0; i < fields_name.size(); i ++)
+        fields_count[i] = 0;
+
+    for (int i = 0; i < fields_name.size(); i ++)
+        fields_src_producers_info.push_back(producers_info);
+
+    for (TiXmlNode *redirection_element_node = interface_element->FirstChild(); redirection_element_node != NULL; redirection_element_node = redirection_element_node->NextSibling()) {
+        if (redirection_element_node->Type() != TiXmlNode::TINYXML_ELEMENT)
+            continue;
+        TiXmlElement *redirection_element = redirection_element_node->ToElement();
+        EXECUTION_REPORT(REPORT_ERROR, interface_ptr->get_comp_id(), words_are_the_same(redirection_element->Value(),"import_connection"), "When setting the coupling connection configuration of the import interface \"%s\" in the XML file \"%s\", the XML element for specifying the coupling connection configuration should be named \"import_connection\" (current wrong name is \"%s\"). Please verify the XML file arround the line number %d.", interface_name, XML_file_name, redirection_element->Value(), redirection_element->Row());
+        if (!is_XML_setting_on(interface_ptr->get_comp_id(), redirection_element, XML_file_name, "the status of some coupling connection configurations for an import interface", "import interface configuration file"))
+            continue;
+        import_directions.push_back(new Import_direction_setting(host_comp_id, this, comp_full_name, interface_name, redirection_element, XML_file_name, fields_name, fields_count, check_comp_existence));
+    }
+
+    delete [] fields_count;
 }
 
 
 void Import_interface_configuration::add_field_src_component(int comp_id, const char *field_name, std::pair<const char*, const char*> producer_info)
 {
-	int i;
-	
-	for (i = 0; i < fields_name.size(); i ++)
-		if (words_are_the_same(field_name, fields_name[i]))
-			break;
-	EXECUTION_REPORT(REPORT_ERROR, comp_id, i < fields_name.size(), "Software error in Import_interface_configuration::add_field_src_component");	
-	fields_src_producers_info[i].push_back(std::make_pair(strdup(producer_info.first), strdup(producer_info.second)));
+    int i;
+    
+    for (i = 0; i < fields_name.size(); i ++)
+        if (words_are_the_same(field_name, fields_name[i]))
+            break;
+    EXECUTION_REPORT(REPORT_ERROR, comp_id, i < fields_name.size(), "Software error in Import_interface_configuration::add_field_src_component");    
+    fields_src_producers_info[i].push_back(std::make_pair(strdup(producer_info.first), strdup(producer_info.second)));
 }
 
 
 void Import_interface_configuration::get_field_import_configuration(const char *field_name, std::vector<std::pair<const char*, const char*> > &producers_info)
 {
-	int i;
+    int i;
 
 
-	for (i = 0; i < fields_name.size(); i ++)
-		if (words_are_the_same(fields_name[i], field_name)) {
-			for (int j = 0; j < fields_src_producers_info[i].size(); j ++)
-				producers_info.push_back(std::make_pair(strdup(fields_src_producers_info[i][j].first), strdup(fields_src_producers_info[i][j].second)));
-			break;
-		}
+    for (i = 0; i < fields_name.size(); i ++)
+        if (words_are_the_same(fields_name[i], field_name)) {
+            for (int j = 0; j < fields_src_producers_info[i].size(); j ++)
+                producers_info.push_back(std::make_pair(strdup(fields_src_producers_info[i][j].first), strdup(fields_src_producers_info[i][j].second)));
+            break;
+        }
 
-	EXECUTION_REPORT(REPORT_ERROR, -1, i < fields_name.size(), "Software error in Import_interface_configuration::get_field_import_configuration");
+    EXECUTION_REPORT(REPORT_ERROR, -1, i < fields_name.size(), "Software error in Import_interface_configuration::get_field_import_configuration");
 }
 
 
 Import_interface_configuration::~Import_interface_configuration()
 {
-	for (int i = 0; i < fields_src_producers_info.size(); i ++)
-		clean_string_pair_vector(fields_src_producers_info[i]);
+    for (int i = 0; i < fields_src_producers_info.size(); i ++)
+        clean_string_pair_vector(fields_src_producers_info[i]);
 }
 
 
 Component_import_interfaces_configuration::Component_import_interfaces_configuration(int host_comp_id, const char *comp_full_name, Inout_interface_mgt *interface_mgr, bool check_comp_existence)
 {
-	char XML_file_name[NAME_STR_SIZE];
-	int line_number;
-
-
-	strcpy(this->comp_full_name, comp_full_name);
-	sprintf(XML_file_name, "%s/all/coupling_connections/%s.coupling_connections.xml", comp_comm_group_mgt_mgr->get_config_root_dir(), comp_full_name);
-	TiXmlDocument *XML_file = open_XML_file_to_read(host_comp_id, XML_file_name, MPI_COMM_NULL, false);	
-	if (XML_file == NULL) {
-		EXECUTION_REPORT_LOG(REPORT_LOG, -1, true, "As there is no import interface configuration file (the file name should be \"%s.coupling_connections.xml\") specified for the component \"%s\", the coupling procedures of the import/export interfaces of this component will be generated automatically", 
-			             comp_full_name, comp_full_name);
-		return;
-	}
-	TiXmlElement *root_XML_element = XML_file->FirstChildElement();
-	TiXmlNode *root_XML_element_node = get_XML_first_child_of_unique_root(host_comp_id, XML_file_name, XML_file);
-	for (; root_XML_element_node != NULL; root_XML_element_node = root_XML_element_node->NextSibling()) {	
-		if (root_XML_element_node->Type() != TiXmlNode::TINYXML_ELEMENT)
-			continue;
-		root_XML_element = root_XML_element_node->ToElement();
-		if (words_are_the_same(root_XML_element->Value(),"local_import_interfaces"))
-			break;
-	}
-	if (root_XML_element_node == NULL) {
-		delete XML_file;
-		return;
-	}
-
-	for (TiXmlNode *interface_XML_element_node = root_XML_element->FirstChild(); interface_XML_element_node != NULL; interface_XML_element_node = interface_XML_element_node->NextSibling()) {
-		if (interface_XML_element_node->Type() != TiXmlNode::TINYXML_ELEMENT)
-			continue;
-		TiXmlElement *interface_XML_element = interface_XML_element_node->ToElement();
-		EXECUTION_REPORT(REPORT_ERROR, -1, words_are_the_same(interface_XML_element->Value(),"import_interface"), "Detect a wrong name (\"%s\") of an XML element in the XML configuration file \"%s\": the XML element for specifying the coupling connection configuration of an import interface should be named \"import_interface\". Please verify the XML file arround the line number %d.", interface_XML_element->Value(), XML_file_name, interface_XML_element->Row());
-		const char *interface_name = get_XML_attribute(host_comp_id, CCPL_NAME_STR_LEN, interface_XML_element, "name", XML_file_name, line_number, "the \"name\" of an import interface", "import interface configuration file", true);
-		if (!is_XML_setting_on(host_comp_id, interface_XML_element, XML_file_name, "the \"status\" of the coupling connection configurations for an import interface", "import interface configuration file"))
-			continue;
-		check_and_verify_name_format_of_string_for_XML(-1, interface_name, "the import interface", XML_file_name, line_number);
-		Inout_interface *import_interface = interface_mgr->get_interface(comp_full_name, interface_name);
-		if (import_interface == NULL) {
-			EXECUTION_REPORT(REPORT_WARNING, -1, false, "The coupling connection configuration of the import interface named \"%s\" has been specified in the XML configuration file \"%s\", while the component \"%s\" does not register the corresponding import interface. So this coupling connection configuration information is negleted.\"", 
-				             interface_name, XML_file_name, comp_full_name);
-			continue;
-		}
-		EXECUTION_REPORT(REPORT_ERROR, -1, import_interface->get_interface_type() == COUPLING_INTERFACE_MARK_IMPORT, "Detect the coupling connection configuration of a non-import interface \"%s\" of the component model \"%s\" in the XML configuration file \"%s\": please note that it is meaningless and not allowed to specify coupling connections of a non-export interface. Please verify the model code or the XML file arround the line number %d",
-			             interface_name, comp_full_name, XML_file_name, interface_XML_element->Row());
-		for (int i = 0; i < import_interfaces_configuration.size(); i ++)
-			EXECUTION_REPORT(REPORT_ERROR, -1, !words_are_the_same(import_interfaces_configuration[i]->get_interface_name(), import_interface->get_interface_name()), "The coupling connection configuration of the import interface named \"%s\" has been set more than once in the XML file \"%s\", which is not allowed (only once for an interface). Please verify.", import_interface->get_interface_name(), XML_file_name);
-		import_interfaces_configuration.push_back(new Import_interface_configuration(host_comp_id, comp_full_name, import_interface->get_interface_name(), interface_XML_element, XML_file_name, interface_mgr, check_comp_existence));
-	}
-
-	delete XML_file;
-	EXECUTION_REPORT_LOG(REPORT_LOG, host_comp_id, true, "Finish loading the configuration of import interfaces from the XML file %s", XML_file_name);
+    char XML_file_name[NAME_STR_SIZE];
+    int line_number;
+
+
+    strcpy(this->comp_full_name, comp_full_name);
+    sprintf(XML_file_name, "%s/all/coupling_connections/%s.coupling_connections.xml", comp_comm_group_mgt_mgr->get_config_root_dir(), comp_full_name);
+    TiXmlDocument *XML_file = open_XML_file_to_read(host_comp_id, XML_file_name, MPI_COMM_NULL, false);    
+    if (XML_file == NULL) {
+        EXECUTION_REPORT_LOG(REPORT_LOG, -1, true, "As there is no import interface configuration file (the file name should be \"%s.coupling_connections.xml\") specified for the component \"%s\", the coupling procedures of the import/export interfaces of this component will be generated automatically", 
+                         comp_full_name, comp_full_name);
+        return;
+    }
+    TiXmlElement *root_XML_element = XML_file->FirstChildElement();
+    TiXmlNode *root_XML_element_node = get_XML_first_child_of_unique_root(host_comp_id, XML_file_name, XML_file);
+    for (; root_XML_element_node != NULL; root_XML_element_node = root_XML_element_node->NextSibling()) {    
+        if (root_XML_element_node->Type() != TiXmlNode::TINYXML_ELEMENT)
+            continue;
+        root_XML_element = root_XML_element_node->ToElement();
+        if (words_are_the_same(root_XML_element->Value(),"local_import_interfaces"))
+            break;
+    }
+    if (root_XML_element_node == NULL) {
+        delete XML_file;
+        return;
+    }
+
+    for (TiXmlNode *interface_XML_element_node = root_XML_element->FirstChild(); interface_XML_element_node != NULL; interface_XML_element_node = interface_XML_element_node->NextSibling()) {
+        if (interface_XML_element_node->Type() != TiXmlNode::TINYXML_ELEMENT)
+            continue;
+        TiXmlElement *interface_XML_element = interface_XML_element_node->ToElement();
+        EXECUTION_REPORT(REPORT_ERROR, -1, words_are_the_same(interface_XML_element->Value(),"import_interface"), "Detect a wrong name (\"%s\") of an XML element in the XML configuration file \"%s\": the XML element for specifying the coupling connection configuration of an import interface should be named \"import_interface\". Please verify the XML file arround the line number %d.", interface_XML_element->Value(), XML_file_name, interface_XML_element->Row());
+        const char *interface_name = get_XML_attribute(host_comp_id, CCPL_NAME_STR_LEN, interface_XML_element, "name", XML_file_name, line_number, "the \"name\" of an import interface", "import interface configuration file", true);
+        if (!is_XML_setting_on(host_comp_id, interface_XML_element, XML_file_name, "the \"status\" of the coupling connection configurations for an import interface", "import interface configuration file"))
+            continue;
+        check_and_verify_name_format_of_string_for_XML(-1, interface_name, "the import interface", XML_file_name, line_number);
+        Inout_interface *import_interface = interface_mgr->get_interface(comp_full_name, interface_name);
+        if (import_interface == NULL) {
+            EXECUTION_REPORT(REPORT_WARNING, -1, false, "The coupling connection configuration of the import interface named \"%s\" has been specified in the XML configuration file \"%s\", while the component \"%s\" does not register the corresponding import interface. So this coupling connection configuration information is negleted.\"", 
+                             interface_name, XML_file_name, comp_full_name);
+            continue;
+        }
+        EXECUTION_REPORT(REPORT_ERROR, -1, import_interface->get_interface_type() == COUPLING_INTERFACE_MARK_IMPORT, "Detect the coupling connection configuration of a non-import interface \"%s\" of the component model \"%s\" in the XML configuration file \"%s\": please note that it is meaningless and not allowed to specify coupling connections of a non-export interface. Please verify the model code or the XML file arround the line number %d",
+                         interface_name, comp_full_name, XML_file_name, interface_XML_element->Row());
+        for (int i = 0; i < import_interfaces_configuration.size(); i ++)
+            EXECUTION_REPORT(REPORT_ERROR, -1, !words_are_the_same(import_interfaces_configuration[i]->get_interface_name(), import_interface->get_interface_name()), "The coupling connection configuration of the import interface named \"%s\" has been set more than once in the XML file \"%s\", which is not allowed (only once for an interface). Please verify.", import_interface->get_interface_name(), XML_file_name);
+        import_interfaces_configuration.push_back(new Import_interface_configuration(host_comp_id, comp_full_name, import_interface->get_interface_name(), interface_XML_element, XML_file_name, interface_mgr, check_comp_existence));
+    }
+
+    delete XML_file;
+    EXECUTION_REPORT_LOG(REPORT_LOG, host_comp_id, true, "Finish loading the configuration of import interfaces from the XML file %s", XML_file_name);
 }
 
 
@@ -944,726 +965,726 @@ Component_import_interfaces_configuration::~Component_import_interfaces_configur
 
 void Component_import_interfaces_configuration::get_interface_field_import_configuration(const char *interface_name, const char *field_name, std::vector<std::pair<const char*, const char*> > &producers_info)
 {
-	clean_string_pair_vector(producers_info);
-	for (int i = 0; i < import_interfaces_configuration.size(); i ++)
-		if (words_are_the_same(import_interfaces_configuration[i]->get_interface_name(), interface_name)) 
-			import_interfaces_configuration[i]->get_field_import_configuration(field_name, producers_info);
+    clean_string_pair_vector(producers_info);
+    for (int i = 0; i < import_interfaces_configuration.size(); i ++)
+        if (words_are_the_same(import_interfaces_configuration[i]->get_interface_name(), interface_name)) 
+            import_interfaces_configuration[i]->get_field_import_configuration(field_name, producers_info);
 }
 
 
 Coupling_generator::~Coupling_generator()
 {
-	clear();
+    clear();
 }
 
 
 void Coupling_generator::clear()
 {
-	if (import_field_index_lookup_table != NULL)
-		delete import_field_index_lookup_table;
-	if (export_field_index_lookup_table != NULL)
-		delete export_field_index_lookup_table;
-	import_field_index_lookup_table = NULL;
-	export_field_index_lookup_table = NULL;
-
-	for (int i = 0; i < string_in_export_fields_dst_components.size(); i ++)
-		delete [] string_in_export_fields_dst_components[i];
-	string_in_export_fields_dst_components.clear();
-	export_fields_dst_components.clear();
-
-	all_coupling_connections.clear();
-	all_IO_connections.clear();
-
-	for (int i = 0; i < all_comp_fullnames_for_coupling_generation.size(); i ++)
-		delete [] all_comp_fullnames_for_coupling_generation[i];
-	all_comp_fullnames_for_coupling_generation.clear();
-	individual_or_family_generation.clear();
+    if (import_field_index_lookup_table != NULL)
+        delete import_field_index_lookup_table;
+    if (export_field_index_lookup_table != NULL)
+        delete export_field_index_lookup_table;
+    import_field_index_lookup_table = NULL;
+    export_field_index_lookup_table = NULL;
+
+    for (int i = 0; i < string_in_export_fields_dst_components.size(); i ++)
+        delete [] string_in_export_fields_dst_components[i];
+    string_in_export_fields_dst_components.clear();
+    export_fields_dst_components.clear();
+
+    all_coupling_connections.clear();
+    all_IO_connections.clear();
+
+    for (int i = 0; i < all_comp_fullnames_for_coupling_generation.size(); i ++)
+        delete [] all_comp_fullnames_for_coupling_generation[i];
+    all_comp_fullnames_for_coupling_generation.clear();
+    individual_or_family_generation.clear();
 }
 
 
 void Coupling_generator::synchronize_latest_connection_id(MPI_Comm comm)
 {
-	int overall_latest_connection_id;
-	MPI_Allreduce(&latest_connection_id, &overall_latest_connection_id, 1, MPI_INT, MPI_MAX, comm);
-	latest_connection_id = overall_latest_connection_id;
+    int overall_latest_connection_id;
+    MPI_Allreduce(&latest_connection_id, &overall_latest_connection_id, 1, MPI_INT, MPI_MAX, comm);
+    latest_connection_id = overall_latest_connection_id;
 }
 
 
-void Coupling_generator::generate_coupling_procedures_common(int API_id, MPI_Comm comm, bool is_overall_generation, const char *annotation)
+void Coupling_generator::generate_coupling_procedures_common(int API_id, MPI_Comm comm, bool is_overall_generation, bool is_internal_generation, const char *annotation)
 {
-	char *temp_array_buffer = NULL, field_name[NAME_STR_SIZE];
-	long current_array_buffer_size, max_array_buffer_size;
-	int temp_int, num_pushed_comp_node = 0;	
-	Coupling_connection *coupling_connection;
-	std::pair<const char *,const char*> src_comp_interface;
-	int current_proc_local_id;
-	Comp_comm_group_mgt_node *local_comp_node = NULL, *temp_comp_node, *existing_comp_node;
-	char API_label[NAME_STR_SIZE];
-	
-
-	EXECUTION_REPORT(REPORT_ERROR, -1, MPI_Comm_rank(comm, &current_proc_local_id) == MPI_SUCCESS);	
-	get_API_hint(-1, API_id, API_label);
-	if (current_proc_local_id == 0)
-		EXECUTION_REPORT_LOG(REPORT_LOG, -1, true, "Start to generate coupling procedures commonly");
-	synchronize_latest_connection_id(comm);
-	inout_interface_mgr->get_all_unconnected_inout_interface_fields_info(all_comp_fullnames_for_coupling_generation, &temp_array_buffer, current_array_buffer_size, comm);
-	bcast_array_in_one_comp(current_proc_local_id, &temp_array_buffer, current_array_buffer_size, comm);
-
-	for (int i = 0; i < all_comp_fullnames_for_coupling_generation.size(); i ++) {
-		local_comp_node = comp_comm_group_mgt_mgr->search_global_node(all_comp_fullnames_for_coupling_generation[i]);
-		if (local_comp_node != NULL && local_comp_node->get_current_proc_local_id() != -1)
-			break;
-		local_comp_node = NULL;
-	}
-	EXECUTION_REPORT(REPORT_ERROR, -1, local_comp_node != NULL, "Software error in Coupling_generator::generate_coupling_procedures: wrong local_comp_node");
-
-	for (int i = 0; i < all_comp_fullnames_for_coupling_generation.size(); i ++) {
-		temp_comp_node = comp_comm_group_mgt_mgr->load_comp_info_from_XML(local_comp_node->get_comp_id(), all_comp_fullnames_for_coupling_generation[i], comm);
-		existing_comp_node = comp_comm_group_mgt_mgr->search_global_node(all_comp_fullnames_for_coupling_generation[i]);
-		if (existing_comp_node == NULL) {
-			comp_comm_group_mgt_mgr->push_comp_node(temp_comp_node);
-			num_pushed_comp_node ++;
-			existing_comp_node = temp_comp_node;
-		}
-		else delete temp_comp_node;
-		if (existing_comp_node->get_current_proc_local_id() != -1)
-			EXECUTION_REPORT(REPORT_ERROR, existing_comp_node->get_comp_id(), !components_time_mgrs->get_time_mgr(existing_comp_node->get_comp_id())->get_time_has_been_advanced(), "Error happens when calling the API \"%s\": fail to generate coupling procedures because the time of the component model \"%s\" has been advanced before this API call. Please check the model code related to the annotation \"%s\"", API_label, all_comp_fullnames_for_coupling_generation[i], annotation);
-	}
-
-	if (current_proc_local_id == 0) {
-		Inout_interface_mgt *all_interfaces_mgr = new Inout_interface_mgt(temp_array_buffer, current_array_buffer_size);
-		generate_interface_fields_source_dst(temp_array_buffer, current_array_buffer_size);
-		for (int i = 0; i < all_comp_fullnames_for_coupling_generation.size(); i ++) {
-			std::vector<Inout_interface*> import_interfaces_of_a_component;
-			all_interfaces_mgr->get_all_import_interfaces_of_a_component(import_interfaces_of_a_component, all_comp_fullnames_for_coupling_generation[i]);
-			Component_import_interfaces_configuration *comp_import_interfaces_config = new Component_import_interfaces_configuration(local_comp_node->get_comp_id(), all_comp_fullnames_for_coupling_generation[i], all_interfaces_mgr, is_overall_generation);
-			for (int j = 0; j < import_interfaces_of_a_component.size(); j ++) {
-				std::vector<const char*> import_fields_name;
-				import_interfaces_of_a_component[j]->get_fields_name(&import_fields_name);
-				for (int k = 0; k < import_fields_name.size(); k ++) {
-					std::vector<std::pair<const char*, const char*> > configuration_export_producer_info;
-					coupling_connection = new Coupling_connection(coupling_generator->apply_connection_id());
-					comp_import_interfaces_config->get_interface_field_import_configuration(import_interfaces_of_a_component[j]->get_interface_name(), import_fields_name[k], configuration_export_producer_info);
-					strcpy(coupling_connection->dst_comp_full_name, all_comp_fullnames_for_coupling_generation[i]);
-					strcpy(coupling_connection->dst_interface_name, import_interfaces_of_a_component[j]->get_interface_name());
-					coupling_connection->fields_name.push_back(strdup(import_fields_name[k]));					
-					int field_index = export_field_index_lookup_table->search(import_fields_name[k],false);
-					if (field_index != 0) {
-						if (configuration_export_producer_info.size() == 0) {						
-							for (int l = 0; l < export_fields_dst_components[field_index].size(); l ++) {
-								if (words_are_the_same(export_fields_dst_components[field_index][l].first, all_comp_fullnames_for_coupling_generation[i]))
-									continue;
-								src_comp_interface.first = strdup(export_fields_dst_components[field_index][l].first);
-								src_comp_interface.second = strdup(export_fields_dst_components[field_index][l].second);
-								coupling_connection->src_comp_interfaces.push_back(src_comp_interface);
-							}
-						}
-						else {
-							for (int l = 0; l < configuration_export_producer_info.size(); l ++) {
-								for (int m = 0; m < export_fields_dst_components[field_index].size(); m ++) {
-									bool matching = false;
-									if (strlen(configuration_export_producer_info[l].first) == 0)
-										matching = words_are_the_same(configuration_export_producer_info[l].second, export_fields_dst_components[field_index][m].second);
-									else if (words_are_the_same(configuration_export_producer_info[l].first, export_fields_dst_components[field_index][m].first))
-										matching = strlen(configuration_export_producer_info[l].second) == 0 || words_are_the_same(configuration_export_producer_info[l].second, export_fields_dst_components[field_index][m].second);
-									if (matching) {
-										src_comp_interface.first = strdup(export_fields_dst_components[field_index][m].first);
-										src_comp_interface.second = strdup(export_fields_dst_components[field_index][m].second);
-										coupling_connection->src_comp_interfaces.push_back(src_comp_interface);
-									}
-								}
-							}
-						}
-					}
-					char *report_string = NULL;
-					if (coupling_connection->src_comp_interfaces.size() > 0) {
-						report_string = new char [NAME_STR_SIZE*coupling_connection->src_comp_interfaces.size()];
-						report_string[0] = '\0';
-						for (int j = 0; j < coupling_connection->src_comp_interfaces.size(); j ++)
-							sprintf(report_string, "%s             %d) Component model is \"%s\", export interface is \"%s\"\n", report_string, j+1, coupling_connection->src_comp_interfaces[j].first, coupling_connection->src_comp_interfaces[j].second);					
-					}
-					if (coupling_connection->src_comp_interfaces.size() == 1) {
-						EXECUTION_REPORT_LOG(REPORT_LOG, -1, true, "Field \"%s\" of the import interface \"%s\" in the component model \"%s\" have one source as follows. %s\n", coupling_connection->fields_name[0], coupling_connection->dst_interface_name, coupling_connection->dst_comp_full_name, report_string);
-						all_coupling_connections.push_back(coupling_connection);
-					}	
-					else if (coupling_connection->src_comp_interfaces.size() > 1)
-						EXECUTION_REPORT(REPORT_ERROR, -1, false, "Error happens when calling the API \"%s\" for coupling generation: Field \"%s\" of the import interface \"%s\" in the component model \"%s\" have more than one source as follows. Please verify.\n%s\n", API_label, coupling_connection->fields_name[0], coupling_connection->dst_interface_name, coupling_connection->dst_comp_full_name, report_string);
-					else delete coupling_connection;
-					if (report_string != NULL)
-						delete [] report_string;
-				}
-			}
-			delete comp_import_interfaces_config;
-		}
-		
-		for (int j, i = all_coupling_connections.size() - 1; i >= 0; i --) {
-			for (j = 0; j < i; j ++)
-				if (words_are_the_same(all_coupling_connections[i]->src_comp_interfaces[0].first, all_coupling_connections[j]->src_comp_interfaces[0].first) &&
-					words_are_the_same(all_coupling_connections[i]->src_comp_interfaces[0].second, all_coupling_connections[j]->src_comp_interfaces[0].second) &&
-					words_are_the_same(all_coupling_connections[i]->dst_comp_full_name, all_coupling_connections[j]->dst_comp_full_name) &&
-					words_are_the_same(all_coupling_connections[i]->dst_interface_name, all_coupling_connections[j]->dst_interface_name))
-					break;
-			if (j < i) {
-				EXECUTION_REPORT(REPORT_ERROR, -1, all_coupling_connections[i]->fields_name.size() == 1,  "software error in Coupling_generator::generate_coupling_procedures: %d", all_coupling_connections[i]->fields_name.size());
-				all_coupling_connections[j]->fields_name.push_back(all_coupling_connections[i]->fields_name[0]);
-				all_coupling_connections.erase(all_coupling_connections.begin()+i);
-			}
-		}
+    char *temp_array_buffer = NULL, field_name[NAME_STR_SIZE];
+    long current_array_buffer_size, max_array_buffer_size;
+    int temp_int, num_pushed_comp_node = 0;    
+    Coupling_connection *coupling_connection;
+    std::pair<const char *,const char*> src_comp_interface;
+    int current_proc_local_id;
+    Comp_comm_group_mgt_node *local_comp_node = NULL, *temp_comp_node, *existing_comp_node;
+    char API_label[NAME_STR_SIZE];
+    
+
+    EXECUTION_REPORT(REPORT_ERROR, -1, MPI_Comm_rank(comm, &current_proc_local_id) == MPI_SUCCESS);    
+    get_API_hint(-1, API_id, API_label);
+    if (current_proc_local_id == 0)
+        EXECUTION_REPORT_LOG(REPORT_LOG, -1, true, "Start to generate coupling procedures commonly");
+    synchronize_latest_connection_id(comm);
+    inout_interface_mgr->get_all_unconnected_inout_interface_fields_info(all_comp_fullnames_for_coupling_generation, &temp_array_buffer, current_array_buffer_size, comm);
+    bcast_array_in_one_comp(current_proc_local_id, &temp_array_buffer, current_array_buffer_size, comm);
+
+    for (int i = 0; i < all_comp_fullnames_for_coupling_generation.size(); i ++) {
+        local_comp_node = comp_comm_group_mgt_mgr->search_global_node(all_comp_fullnames_for_coupling_generation[i]);
+        if (local_comp_node != NULL && local_comp_node->get_current_proc_local_id() != -1)
+            break;
+        local_comp_node = NULL;
+    }
+    EXECUTION_REPORT(REPORT_ERROR, -1, local_comp_node != NULL, "Software error in Coupling_generator::generate_coupling_procedures: wrong local_comp_node");
+
+    for (int i = 0; i < all_comp_fullnames_for_coupling_generation.size(); i ++) {
+        temp_comp_node = comp_comm_group_mgt_mgr->load_comp_info_from_XML(local_comp_node->get_comp_id(), all_comp_fullnames_for_coupling_generation[i], comm);
+        existing_comp_node = comp_comm_group_mgt_mgr->search_global_node(all_comp_fullnames_for_coupling_generation[i]);
+        if (existing_comp_node == NULL) {
+            comp_comm_group_mgt_mgr->push_comp_node(temp_comp_node);
+            num_pushed_comp_node ++;
+            existing_comp_node = temp_comp_node;
+        }
+        else delete temp_comp_node;
+        if (existing_comp_node->get_current_proc_local_id() != -1)
+            EXECUTION_REPORT(REPORT_ERROR, existing_comp_node->get_comp_id(), !components_time_mgrs->get_time_mgr(existing_comp_node->get_comp_id())->get_time_has_been_advanced(), "Error happens when calling the API \"%s\": fail to generate coupling procedures because the time of the component model \"%s\" has been advanced before this API call. Please check the model code related to the annotation \"%s\"", API_label, all_comp_fullnames_for_coupling_generation[i], annotation);
+    }
+
+    if (current_proc_local_id == 0) {
+        Inout_interface_mgt *all_interfaces_mgr = new Inout_interface_mgt(temp_array_buffer, current_array_buffer_size);
+        generate_interface_fields_source_dst(temp_array_buffer, current_array_buffer_size);
+        for (int i = 0; i < all_comp_fullnames_for_coupling_generation.size(); i ++) {
+            std::vector<Inout_interface*> import_interfaces_of_a_component;
+            all_interfaces_mgr->get_all_import_interfaces_of_a_component(import_interfaces_of_a_component, all_comp_fullnames_for_coupling_generation[i]);
+            Component_import_interfaces_configuration *comp_import_interfaces_config = new Component_import_interfaces_configuration(local_comp_node->get_comp_id(), all_comp_fullnames_for_coupling_generation[i], all_interfaces_mgr, is_overall_generation);
+            for (int j = 0; j < import_interfaces_of_a_component.size(); j ++) {
+                std::vector<const char*> import_fields_name;
+                import_interfaces_of_a_component[j]->get_fields_name(&import_fields_name);
+                for (int k = 0; k < import_fields_name.size(); k ++) {
+                    std::vector<std::pair<const char*, const char*> > configuration_export_producer_info;
+                    coupling_connection = new Coupling_connection(coupling_generator->apply_connection_id());
+                    comp_import_interfaces_config->get_interface_field_import_configuration(import_interfaces_of_a_component[j]->get_interface_name(), import_fields_name[k], configuration_export_producer_info);
+                    strcpy(coupling_connection->dst_comp_full_name, all_comp_fullnames_for_coupling_generation[i]);
+                    strcpy(coupling_connection->dst_interface_name, import_interfaces_of_a_component[j]->get_interface_name());
+                    coupling_connection->fields_name.push_back(strdup(import_fields_name[k]));                    
+                    int field_index = export_field_index_lookup_table->search(import_fields_name[k],false);
+                    if (field_index != 0) {
+                        if (configuration_export_producer_info.size() == 0) {                        
+                            for (int l = 0; l < export_fields_dst_components[field_index].size(); l ++) {
+                                if (!is_internal_generation && words_are_the_same(export_fields_dst_components[field_index][l].first, all_comp_fullnames_for_coupling_generation[i]))
+                                    continue;
+                                src_comp_interface.first = strdup(export_fields_dst_components[field_index][l].first);
+                                src_comp_interface.second = strdup(export_fields_dst_components[field_index][l].second);
+                                coupling_connection->src_comp_interfaces.push_back(src_comp_interface);
+                            }
+                        }
+                        else {
+                            for (int l = 0; l < configuration_export_producer_info.size(); l ++) {
+                                for (int m = 0; m < export_fields_dst_components[field_index].size(); m ++) {
+                                    bool matching = false;
+                                    if (strlen(configuration_export_producer_info[l].first) == 0)
+                                        matching = words_are_the_same(configuration_export_producer_info[l].second, export_fields_dst_components[field_index][m].second);
+                                    else if (words_are_the_same(configuration_export_producer_info[l].first, export_fields_dst_components[field_index][m].first))
+                                        matching = strlen(configuration_export_producer_info[l].second) == 0 || words_are_the_same(configuration_export_producer_info[l].second, export_fields_dst_components[field_index][m].second);
+                                    if (matching) {
+                                        src_comp_interface.first = strdup(export_fields_dst_components[field_index][m].first);
+                                        src_comp_interface.second = strdup(export_fields_dst_components[field_index][m].second);
+                                        coupling_connection->src_comp_interfaces.push_back(src_comp_interface);
+                                    }
+                                }
+                            }
+                        }
+                    }
+                    char *report_string = NULL;
+                    if (coupling_connection->src_comp_interfaces.size() > 0) {
+                        report_string = new char [NAME_STR_SIZE*coupling_connection->src_comp_interfaces.size()];
+                        report_string[0] = '\0';
+                        for (int j = 0; j < coupling_connection->src_comp_interfaces.size(); j ++)
+                            sprintf(report_string, "%s             %d) Component model is \"%s\", export interface is \"%s\"\n", report_string, j+1, coupling_connection->src_comp_interfaces[j].first, coupling_connection->src_comp_interfaces[j].second);                    
+                    }
+                    if (coupling_connection->src_comp_interfaces.size() == 1) {
+                        EXECUTION_REPORT_LOG(REPORT_LOG, -1, true, "Field \"%s\" of the import interface \"%s\" in the component model \"%s\" have one source as follows. %s\n", coupling_connection->fields_name[0], coupling_connection->dst_interface_name, coupling_connection->dst_comp_full_name, report_string);
+                        all_coupling_connections.push_back(coupling_connection);
+                    }    
+                    else if (coupling_connection->src_comp_interfaces.size() > 1)
+                        EXECUTION_REPORT(REPORT_ERROR, -1, false, "Error happens when calling the API \"%s\" for coupling generation: Field \"%s\" of the import interface \"%s\" in the component model \"%s\" have more than one source as follows. Please verify.\n%s\n", API_label, coupling_connection->fields_name[0], coupling_connection->dst_interface_name, coupling_connection->dst_comp_full_name, report_string);
+                    else delete coupling_connection;
+                    if (report_string != NULL)
+                        delete [] report_string;
+                }
+            }
+            delete comp_import_interfaces_config;
+        }
+        
+        for (int j, i = all_coupling_connections.size() - 1; i >= 0; i --) {
+            for (j = 0; j < i; j ++)
+                if (words_are_the_same(all_coupling_connections[i]->src_comp_interfaces[0].first, all_coupling_connections[j]->src_comp_interfaces[0].first) &&
+                    words_are_the_same(all_coupling_connections[i]->src_comp_interfaces[0].second, all_coupling_connections[j]->src_comp_interfaces[0].second) &&
+                    words_are_the_same(all_coupling_connections[i]->dst_comp_full_name, all_coupling_connections[j]->dst_comp_full_name) &&
+                    words_are_the_same(all_coupling_connections[i]->dst_interface_name, all_coupling_connections[j]->dst_interface_name))
+                    break;
+            if (j < i) {
+                EXECUTION_REPORT(REPORT_ERROR, -1, all_coupling_connections[i]->fields_name.size() == 1,  "software error in Coupling_generator::generate_coupling_procedures: %d", all_coupling_connections[i]->fields_name.size());
+                all_coupling_connections[j]->fields_name.push_back(all_coupling_connections[i]->fields_name[0]);
+                all_coupling_connections.erase(all_coupling_connections.begin()+i);
+            }
+        }
+
+        delete all_interfaces_mgr;
+
+        if (temp_array_buffer != NULL)
+            delete [] temp_array_buffer;
+        temp_array_buffer = NULL;
+        current_array_buffer_size = 0;
+
+        for (int i = all_coupling_connections.size() - 1; i >= 0; i --) {
+            // all_coupling_connections[i]->src_comp_interfaces.size() is 1
+            for (int j = all_coupling_connections[i]->src_comp_interfaces.size()-1; j >= 0; j --) {
+                write_data_into_array_buffer(all_coupling_connections[i]->src_comp_interfaces[j].second, NAME_STR_SIZE, &temp_array_buffer, max_array_buffer_size, current_array_buffer_size);
+                write_data_into_array_buffer(all_coupling_connections[i]->src_comp_interfaces[j].first, NAME_STR_SIZE, &temp_array_buffer, max_array_buffer_size, current_array_buffer_size);
+            }
+            temp_int = all_coupling_connections[i]->src_comp_interfaces.size();
+            write_data_into_array_buffer(&temp_int, sizeof(int), &temp_array_buffer, max_array_buffer_size, current_array_buffer_size);
+            for (int j = all_coupling_connections[i]->fields_name.size() - 1; j >= 0; j --)
+                write_data_into_array_buffer(all_coupling_connections[i]->fields_name[j], NAME_STR_SIZE, &temp_array_buffer, max_array_buffer_size, current_array_buffer_size);
+            temp_int = all_coupling_connections[i]->fields_name.size();
+            write_data_into_array_buffer(&temp_int, sizeof(int), &temp_array_buffer, max_array_buffer_size, current_array_buffer_size);            
+            write_data_into_array_buffer(all_coupling_connections[i]->dst_interface_name, NAME_STR_SIZE, &temp_array_buffer, max_array_buffer_size, current_array_buffer_size);
+            write_data_into_array_buffer(all_coupling_connections[i]->dst_comp_full_name, NAME_STR_SIZE, &temp_array_buffer, max_array_buffer_size, current_array_buffer_size);
+            write_data_into_array_buffer(&(all_coupling_connections[i]->connection_id), sizeof(int), &temp_array_buffer, max_array_buffer_size, current_array_buffer_size);
+        }
+        temp_int = all_coupling_connections.size();
+        write_data_into_array_buffer(&temp_int, sizeof(int), &temp_array_buffer, max_array_buffer_size, current_array_buffer_size);
+    }
+    
+    bcast_array_in_one_comp(current_proc_local_id, &temp_array_buffer, current_array_buffer_size, comm);
+    if (current_proc_local_id != 0) {
+        int num_connections, num_fields, num_sources;
+        long buffer_content_iter = current_array_buffer_size;
+        read_data_from_array_buffer(&num_connections, sizeof(int), temp_array_buffer, buffer_content_iter, true);
+        for (int i = 0; i < num_connections; i ++) {
+            int connection_id;
+            read_data_from_array_buffer(&connection_id, sizeof(int), temp_array_buffer, buffer_content_iter, true);
+            coupling_connection = new Coupling_connection(connection_id);
+            read_data_from_array_buffer(coupling_connection->dst_comp_full_name, NAME_STR_SIZE, temp_array_buffer, buffer_content_iter, true);
+            read_data_from_array_buffer(coupling_connection->dst_interface_name, NAME_STR_SIZE, temp_array_buffer, buffer_content_iter, true);
+            read_data_from_array_buffer(&num_fields, sizeof(int), temp_array_buffer, buffer_content_iter, true);
+            for (int j = 0; j < num_fields; j ++) {
+                read_data_from_array_buffer(field_name, NAME_STR_SIZE, temp_array_buffer, buffer_content_iter, true);
+                coupling_connection->fields_name.push_back(strdup(field_name));    
+                EXECUTION_REPORT_LOG(REPORT_LOG, -1, true, "connection field name %s for interface %s", coupling_connection->dst_interface_name, field_name);
+            }        
+            read_data_from_array_buffer(&num_sources, sizeof(int), temp_array_buffer, buffer_content_iter, true);
+            for (int j = 0; j < num_sources; j ++) {
+                char tmp_str[NAME_STR_SIZE];
+                read_data_from_array_buffer(tmp_str, NAME_STR_SIZE, temp_array_buffer, buffer_content_iter, true);
+                src_comp_interface.first = strdup(tmp_str);
+                read_data_from_array_buffer(tmp_str, NAME_STR_SIZE, temp_array_buffer, buffer_content_iter, true);
+                src_comp_interface.second = strdup(tmp_str);
+                coupling_connection->src_comp_interfaces.push_back(src_comp_interface);
+            }
+            all_coupling_connections.push_back(coupling_connection);
+        }
+        EXECUTION_REPORT(REPORT_ERROR, -1, buffer_content_iter == 0, "Software error in Coupling_generator::generate_coupling_procedures: %d", buffer_content_iter);
+    }
 
-		delete all_interfaces_mgr;
+    delete [] temp_array_buffer;
+    for (int i = 0; i < all_coupling_connections.size(); i ++) {
+        all_coupling_connections[i]->generate_a_coupling_procedure(false);
+    }
+    for (int i = 0; i < num_pushed_comp_node; i ++)
+        delete comp_comm_group_mgt_mgr->pop_comp_node();
 
-		if (temp_array_buffer != NULL)
-			delete [] temp_array_buffer;
-		temp_array_buffer = NULL;
-		current_array_buffer_size = 0;
+    clear();
 
-		for (int i = all_coupling_connections.size() - 1; i >= 0; i --) {
-			// all_coupling_connections[i]->src_comp_interfaces.size() is 1
-			for (int j = all_coupling_connections[i]->src_comp_interfaces.size()-1; j >= 0; j --) {
-				write_data_into_array_buffer(all_coupling_connections[i]->src_comp_interfaces[j].second, NAME_STR_SIZE, &temp_array_buffer, max_array_buffer_size, current_array_buffer_size);
-				write_data_into_array_buffer(all_coupling_connections[i]->src_comp_interfaces[j].first, NAME_STR_SIZE, &temp_array_buffer, max_array_buffer_size, current_array_buffer_size);
-			}
-			temp_int = all_coupling_connections[i]->src_comp_interfaces.size();
-			write_data_into_array_buffer(&temp_int, sizeof(int), &temp_array_buffer, max_array_buffer_size, current_array_buffer_size);
-			for (int j = all_coupling_connections[i]->fields_name.size() - 1; j >= 0; j --)
-				write_data_into_array_buffer(all_coupling_connections[i]->fields_name[j], NAME_STR_SIZE, &temp_array_buffer, max_array_buffer_size, current_array_buffer_size);
-			temp_int = all_coupling_connections[i]->fields_name.size();
-			write_data_into_array_buffer(&temp_int, sizeof(int), &temp_array_buffer, max_array_buffer_size, current_array_buffer_size);			
-			write_data_into_array_buffer(all_coupling_connections[i]->dst_interface_name, NAME_STR_SIZE, &temp_array_buffer, max_array_buffer_size, current_array_buffer_size);
-			write_data_into_array_buffer(all_coupling_connections[i]->dst_comp_full_name, NAME_STR_SIZE, &temp_array_buffer, max_array_buffer_size, current_array_buffer_size);
-			write_data_into_array_buffer(&(all_coupling_connections[i]->connection_id), sizeof(int), &temp_array_buffer, max_array_buffer_size, current_array_buffer_size);
-		}
-		temp_int = all_coupling_connections.size();
-		write_data_into_array_buffer(&temp_int, sizeof(int), &temp_array_buffer, max_array_buffer_size, current_array_buffer_size);
-	}
-	
-	bcast_array_in_one_comp(current_proc_local_id, &temp_array_buffer, current_array_buffer_size, comm);
-	if (current_proc_local_id != 0) {
-		int num_connections, num_fields, num_sources;
-		long buffer_content_iter = current_array_buffer_size;
-		read_data_from_array_buffer(&num_connections, sizeof(int), temp_array_buffer, buffer_content_iter, true);
-		for (int i = 0; i < num_connections; i ++) {
-			int connection_id;
-			read_data_from_array_buffer(&connection_id, sizeof(int), temp_array_buffer, buffer_content_iter, true);
-			coupling_connection = new Coupling_connection(connection_id);
-			read_data_from_array_buffer(coupling_connection->dst_comp_full_name, NAME_STR_SIZE, temp_array_buffer, buffer_content_iter, true);
-			read_data_from_array_buffer(coupling_connection->dst_interface_name, NAME_STR_SIZE, temp_array_buffer, buffer_content_iter, true);
-			read_data_from_array_buffer(&num_fields, sizeof(int), temp_array_buffer, buffer_content_iter, true);
-			for (int j = 0; j < num_fields; j ++) {
-				read_data_from_array_buffer(field_name, NAME_STR_SIZE, temp_array_buffer, buffer_content_iter, true);
-				coupling_connection->fields_name.push_back(strdup(field_name));	
-				EXECUTION_REPORT_LOG(REPORT_LOG, -1, true, "connection field name %s for interface %s", coupling_connection->dst_interface_name, field_name);
-			}		
-			read_data_from_array_buffer(&num_sources, sizeof(int), temp_array_buffer, buffer_content_iter, true);
-			for (int j = 0; j < num_sources; j ++) {
-				char tmp_str[NAME_STR_SIZE];
-				read_data_from_array_buffer(tmp_str, NAME_STR_SIZE, temp_array_buffer, buffer_content_iter, true);
-				src_comp_interface.first = strdup(tmp_str);
-				read_data_from_array_buffer(tmp_str, NAME_STR_SIZE, temp_array_buffer, buffer_content_iter, true);
-				src_comp_interface.second = strdup(tmp_str);
-				coupling_connection->src_comp_interfaces.push_back(src_comp_interface);
-			}
-			all_coupling_connections.push_back(coupling_connection);
-		}
-		EXECUTION_REPORT(REPORT_ERROR, -1, buffer_content_iter == 0, "Software error in Coupling_generator::generate_coupling_procedures: %d", buffer_content_iter);
-	}
-
-	delete [] temp_array_buffer;
-	for (int i = 0; i < all_coupling_connections.size(); i ++) {
-		all_coupling_connections[i]->generate_a_coupling_procedure(false);
-	}
-	for (int i = 0; i < num_pushed_comp_node; i ++)
-		delete comp_comm_group_mgt_mgr->pop_comp_node();
-
-	clear();
-
-	//original_grid_mgr->delete_external_original_grids();
-	
-	if (current_proc_local_id == 0)
-		EXECUTION_REPORT_LOG(REPORT_LOG, -1, true, "Finish generating coupling procedure");
+    //original_grid_mgr->delete_external_original_grids();
+    
+    if (current_proc_local_id == 0)
+        EXECUTION_REPORT_LOG(REPORT_LOG, -1, true, "Finish generating coupling procedure");
 }
 
 
 
-void Coupling_generator::generate_coupling_procedures_internal(int comp_id, bool family_generation, const char *annotation)
+void Coupling_generator::generate_coupling_procedures_internal(int comp_id, bool family_generation, bool is_internal_generation, const char *annotation)
 {
-	char *temp_array_buffer = NULL;
-	long current_array_buffer_size, max_array_buffer_size;
-
-
-	if (family_generation) {
-		comp_comm_group_mgt_mgr->get_global_node_of_local_comp(comp_id, true, "in Coupling_generator::generate_coupling_procedures")->get_all_descendant_real_comp_fullnames(comp_id, all_comp_fullnames_for_coupling_generation, &temp_array_buffer, max_array_buffer_size, current_array_buffer_size);
-		generate_coupling_procedures_common(API_ID_COUPLING_GEN_FAMILY, comp_comm_group_mgt_mgr->get_comm_group_of_local_comp(comp_id, "in Coupling_generator::generate_coupling_procedures"), (comp_id & TYPE_ID_SUFFIX_MASK)==0, annotation);
-	}
-	else {
-		all_comp_fullnames_for_coupling_generation.push_back(strdup(comp_comm_group_mgt_mgr->get_global_node_of_local_comp(comp_id, true, "in Coupling_generator::generate_coupling_procedures")->get_full_name()));
-		generate_coupling_procedures_common(API_ID_COUPLING_GEN_INDIVIDUAL, comp_comm_group_mgt_mgr->get_comm_group_of_local_comp(comp_id, "in Coupling_generator::generate_coupling_procedures"), (comp_id & TYPE_ID_SUFFIX_MASK)==0, annotation);
-	}
+    char *temp_array_buffer = NULL;
+    long current_array_buffer_size, max_array_buffer_size;
+
+
+    if (family_generation) {
+        comp_comm_group_mgt_mgr->get_global_node_of_local_comp(comp_id, true, "in Coupling_generator::generate_coupling_procedures")->get_all_descendant_real_comp_fullnames(comp_id, all_comp_fullnames_for_coupling_generation, &temp_array_buffer, max_array_buffer_size, current_array_buffer_size);
+        generate_coupling_procedures_common(API_ID_COUPLING_GEN_FAMILY, comp_comm_group_mgt_mgr->get_comm_group_of_local_comp(comp_id, "in Coupling_generator::generate_coupling_procedures"), (comp_id & TYPE_ID_SUFFIX_MASK)==0, is_internal_generation, annotation);
+    }
+    else {
+        all_comp_fullnames_for_coupling_generation.push_back(strdup(comp_comm_group_mgt_mgr->get_global_node_of_local_comp(comp_id, true, "in Coupling_generator::generate_coupling_procedures")->get_full_name()));
+        generate_coupling_procedures_common(API_ID_COUPLING_GEN_INDIVIDUAL, comp_comm_group_mgt_mgr->get_comm_group_of_local_comp(comp_id, "in Coupling_generator::generate_coupling_procedures"), (comp_id & TYPE_ID_SUFFIX_MASK)==0, is_internal_generation, annotation);
+    }
 }
 
 
 void Coupling_generator::generate_IO_procedures()
 {
-	return;   ////// to be modified
+    return;   ////// to be modified
 /*
-	const int *sorted_comp_ids = comp_comm_group_mgt_mgr->get_sorted_comp_ids();
-
-	components_IO_output_procedures_mgr->add_all_components_IO_output_procedures();
-	for (int i = 1; i < sorted_comp_ids[0]; i ++) {
-		if (comp_comm_group_mgt_mgr->get_current_proc_id_in_comp(sorted_comp_ids[i], "in Coupling_generator::generate_IO_procedures") == -1)
-			continue;
-		components_IO_output_procedures_mgr->get_component_IO_output_procedures(sorted_comp_ids[i])->generate_coupling_connection(all_IO_connections, all_coupling_connections.size());
-	}
-
-	for (int i = 0; i < all_IO_connections.size(); i ++) {
-		all_IO_connections[i]->generate_a_coupling_procedure(false);
-	}
+    const int *sorted_comp_ids = comp_comm_group_mgt_mgr->get_sorted_comp_ids();
+
+    components_IO_output_procedures_mgr->add_all_components_IO_output_procedures();
+    for (int i = 1; i < sorted_comp_ids[0]; i ++) {
+        if (comp_comm_group_mgt_mgr->get_current_proc_id_in_comp(sorted_comp_ids[i], "in Coupling_generator::generate_IO_procedures") == -1)
+            continue;
+        components_IO_output_procedures_mgr->get_component_IO_output_procedures(sorted_comp_ids[i])->generate_coupling_connection(all_IO_connections, all_coupling_connections.size());
+    }
+
+    for (int i = 0; i < all_IO_connections.size(); i ++) {
+        all_IO_connections[i]->generate_a_coupling_procedure(false);
+    }
 */
 }
 
 
 void Coupling_generator::generate_interface_fields_source_dst(const char *temp_array_buffer, int buffer_content_size)
 {
-	char comp_full_name[NAME_STR_SIZE], interface_name[NAME_STR_SIZE], field_name[NAME_STR_SIZE];
-	std::vector<const char*> distinct_import_fields_name;
-	std::vector<const char*> distinct_export_fields_name;
-
-
-	import_field_index_lookup_table = new Dictionary<int>(1024);
-	export_field_index_lookup_table = new Dictionary<int>(1024);
-
-	long buffer_content_iter = buffer_content_size;
-	int import_or_export, field_id_iter = 100, field_index, num_fields;
-	while (buffer_content_iter > 0) {
-		read_data_from_array_buffer(interface_name, NAME_STR_SIZE, temp_array_buffer, buffer_content_iter, true);
-		read_data_from_array_buffer(comp_full_name, NAME_STR_SIZE, temp_array_buffer, buffer_content_iter, true);
-		read_data_from_array_buffer(&import_or_export, sizeof(int), temp_array_buffer, buffer_content_iter, true);
-		read_data_from_array_buffer(&num_fields, sizeof(int), temp_array_buffer, buffer_content_iter, true);
-		for (int i = 0; i < num_fields; i ++) {
-			read_data_from_array_buffer(field_name, NAME_STR_SIZE, temp_array_buffer, buffer_content_iter, true);
-			if (import_or_export == 0) {
-				if (import_field_index_lookup_table->search(field_name, false) == 0) {
-					import_field_index_lookup_table->insert(field_name, field_id_iter++);
-					distinct_import_fields_name.push_back(strdup(field_name));
-				}
-				field_index = import_field_index_lookup_table->search(field_name, false);				}
-			else {
-				if (export_field_index_lookup_table->search(field_name, false) == 0) {
-					export_field_index_lookup_table->insert(field_name, field_id_iter++);
-					distinct_export_fields_name.push_back(strdup(field_name));
-				}
-				field_index = export_field_index_lookup_table->search(field_name, false);
-				char *str1 = strdup(comp_full_name);
-				char *str2 = strdup(interface_name);
-				export_fields_dst_components[field_index].push_back(std::pair<const char*,const char*>(str1,str2));
-				string_in_export_fields_dst_components.push_back(str1);
-				string_in_export_fields_dst_components.push_back(str2);
-			}
-		}
-	}
+    char comp_full_name[NAME_STR_SIZE], interface_name[NAME_STR_SIZE], field_name[NAME_STR_SIZE];
+    std::vector<const char*> distinct_import_fields_name;
+    std::vector<const char*> distinct_export_fields_name;
+
+
+    import_field_index_lookup_table = new Dictionary<int>(1024);
+    export_field_index_lookup_table = new Dictionary<int>(1024);
+
+    long buffer_content_iter = buffer_content_size;
+    int import_or_export, field_id_iter = 100, field_index, num_fields;
+    while (buffer_content_iter > 0) {
+        read_data_from_array_buffer(interface_name, NAME_STR_SIZE, temp_array_buffer, buffer_content_iter, true);
+        read_data_from_array_buffer(comp_full_name, NAME_STR_SIZE, temp_array_buffer, buffer_content_iter, true);
+        read_data_from_array_buffer(&import_or_export, sizeof(int), temp_array_buffer, buffer_content_iter, true);
+        read_data_from_array_buffer(&num_fields, sizeof(int), temp_array_buffer, buffer_content_iter, true);
+        for (int i = 0; i < num_fields; i ++) {
+            read_data_from_array_buffer(field_name, NAME_STR_SIZE, temp_array_buffer, buffer_content_iter, true);
+            if (import_or_export == 0) {
+                if (import_field_index_lookup_table->search(field_name, false) == 0) {
+                    import_field_index_lookup_table->insert(field_name, field_id_iter++);
+                    distinct_import_fields_name.push_back(strdup(field_name));
+                }
+                field_index = import_field_index_lookup_table->search(field_name, false);                }
+            else {
+                if (export_field_index_lookup_table->search(field_name, false) == 0) {
+                    export_field_index_lookup_table->insert(field_name, field_id_iter++);
+                    distinct_export_fields_name.push_back(strdup(field_name));
+                }
+                field_index = export_field_index_lookup_table->search(field_name, false);
+                char *str1 = strdup(comp_full_name);
+                char *str2 = strdup(interface_name);
+                export_fields_dst_components[field_index].push_back(std::pair<const char*,const char*>(str1,str2));
+                string_in_export_fields_dst_components.push_back(str1);
+                string_in_export_fields_dst_components.push_back(str2);
+            }
+        }
+    }
 }
 
 
 void Coupling_generator::transfer_interfaces_info_from_one_component_to_another(std::vector<Inout_interface*> &interfaces, Comp_comm_group_mgt_node *comp_node_src, Comp_comm_group_mgt_node *comp_node_dst)
 {
-	long buffer_max_size = 0, buffer_content_size = 0;
-	char *temp_array_buffer = NULL;
-
-	
-	for (int i = 0; i < interfaces.size(); i ++)
-		interfaces[i]->transform_interface_into_array(&temp_array_buffer, buffer_max_size, buffer_content_size);
-	transfer_array_from_one_comp_to_another(comp_node_src->get_current_proc_local_id(), comp_node_src->get_root_proc_global_id(), comp_node_dst->get_current_proc_local_id(), comp_node_dst->get_root_proc_global_id(), comp_node_dst->get_comm_group(), &temp_array_buffer, buffer_content_size);
-
-	if (comp_node_src->get_current_proc_local_id() < 0 && comp_node_dst->get_current_proc_local_id() >= 0) {
-		EXECUTION_REPORT(REPORT_ERROR, -1, interfaces.size() == 0, "software error in Coupling_generator::transfer_interfaces_info_from_one_component_to_another");
-		while (buffer_content_size > 0)
-			interfaces.push_back(new Inout_interface(temp_array_buffer, buffer_content_size));
-	}
-
-	if (temp_array_buffer != NULL)
-		delete [] temp_array_buffer;
+    long buffer_max_size = 0, buffer_content_size = 0;
+    char *temp_array_buffer = NULL;
+
+    
+    for (int i = 0; i < interfaces.size(); i ++)
+        interfaces[i]->transform_interface_into_array(&temp_array_buffer, buffer_max_size, buffer_content_size);
+    transfer_array_from_one_comp_to_another(comp_node_src->get_current_proc_local_id(), comp_node_src->get_root_proc_global_id(), comp_node_dst->get_current_proc_local_id(), comp_node_dst->get_root_proc_global_id(), comp_node_dst->get_comm_group(), &temp_array_buffer, buffer_content_size);
+
+    if (comp_node_src->get_current_proc_local_id() < 0 && comp_node_dst->get_current_proc_local_id() >= 0) {
+        EXECUTION_REPORT(REPORT_ERROR, -1, interfaces.size() == 0, "software error in Coupling_generator::transfer_interfaces_info_from_one_component_to_another");
+        while (buffer_content_size > 0)
+            interfaces.push_back(new Inout_interface(temp_array_buffer, buffer_content_size));
+    }
+
+    if (temp_array_buffer != NULL)
+        delete [] temp_array_buffer;
 }
 
 
 void Coupling_generator::begin_external_coupling_generation()
 {
-	EXECUTION_REPORT(REPORT_ERROR, -1, all_comp_fullnames_for_coupling_generation.size() == 0 && individual_or_family_generation.size() == 0, "Software error in Coupling_generator::begin_external_coupling_generation");
+    EXECUTION_REPORT(REPORT_ERROR, -1, all_comp_fullnames_for_coupling_generation.size() == 0 && individual_or_family_generation.size() == 0, "Software error in Coupling_generator::begin_external_coupling_generation");
 }
 
 
 void Coupling_generator::add_comp_for_external_coupling_generation(const char *comp_full_name, int individual_or_family, const char *annotation)
 {
-	int i;
-
-	
-	EXECUTION_REPORT(REPORT_ERROR, -1, strlen(comp_full_name) > 0, "ERROR happens when calling the API \"CCPL_do_external_coupling_generation\": the full name of a given component model cannot be an empty string. Please verify the model code with the annotation \"%s\"", annotation);
-	EXECUTION_REPORT(REPORT_ERROR, -1, individual_or_family == 1 || individual_or_family == 2, "ERROR happens when calling the API \"CCPL_do_external_coupling_generation\": the value of the parameter \"individual_or_family\" must be 1 (individual) or 2 (family). Please verify the model code with the annotation \"%s\"", annotation);
-	for (i = 0; i < all_comp_fullnames_for_coupling_generation.size(); i ++)
-		if (words_are_the_same(comp_full_name, all_comp_fullnames_for_coupling_generation[i])) {
-			if (individual_or_family_generation[i] == 1)
-				individual_or_family_generation[i] = individual_or_family;
-			break;
-		}
-	if (i == all_comp_fullnames_for_coupling_generation.size()) {
-		all_comp_fullnames_for_coupling_generation.push_back(strdup(comp_full_name));
-		individual_or_family_generation.push_back(individual_or_family);
-	}
+    int i;
+
+    
+    EXECUTION_REPORT(REPORT_ERROR, -1, strlen(comp_full_name) > 0, "ERROR happens when calling the API \"CCPL_do_external_coupling_generation\": the full name of a given component model cannot be an empty string. Please verify the model code with the annotation \"%s\"", annotation);
+    EXECUTION_REPORT(REPORT_ERROR, -1, individual_or_family == 1 || individual_or_family == 2, "ERROR happens when calling the API \"CCPL_do_external_coupling_generation\": the value of the parameter \"individual_or_family\" must be 1 (individual) or 2 (family). Please verify the model code with the annotation \"%s\"", annotation);
+    for (i = 0; i < all_comp_fullnames_for_coupling_generation.size(); i ++)
+        if (words_are_the_same(comp_full_name, all_comp_fullnames_for_coupling_generation[i])) {
+            if (individual_or_family_generation[i] == 1)
+                individual_or_family_generation[i] = individual_or_family;
+            break;
+        }
+    if (i == all_comp_fullnames_for_coupling_generation.size()) {
+        all_comp_fullnames_for_coupling_generation.push_back(strdup(comp_full_name));
+        individual_or_family_generation.push_back(individual_or_family);
+    }
 }
 
 
 void Coupling_generator::sort_comp_full_names(std::vector<const char*> &comp_full_names, std::vector<int> *comp_index)
 {
-	std::vector<const char *> temp_comp_full_names;
-	std::vector<int> temp_comp_index;
-	int i, j, k, num_comps = comp_full_names.size();
-
-
-	for (i = 0; i < num_comps; i ++) {
-		k = 0;
-		for (j = 1; j < comp_full_names.size(); j ++)
-			if (strcmp(comp_full_names[k], comp_full_names[j]) > 0)
-				k = j;
-		temp_comp_full_names.push_back(comp_full_names[k]);
-		comp_full_names.erase(comp_full_names.begin()+k);
-		if (comp_index != NULL) {
-			temp_comp_index.push_back((*comp_index)[k]);
-			comp_index->erase(comp_index->begin()+k);
-		}
-	}
-	EXECUTION_REPORT(REPORT_ERROR, -1, num_comps == temp_comp_full_names.size() && comp_full_names.size() == 0, "Software error in Coupling_generator::do_external_coupling_generation");
-
-	for (i = 0; i < temp_comp_full_names.size(); i ++) {
-		comp_full_names.push_back(temp_comp_full_names[i]);
-		if (comp_index != NULL)
-			comp_index->push_back(temp_comp_index[i]);
-	}	
+    std::vector<const char *> temp_comp_full_names;
+    std::vector<int> temp_comp_index;
+    int i, j, k, num_comps = comp_full_names.size();
+
+
+    for (i = 0; i < num_comps; i ++) {
+        k = 0;
+        for (j = 1; j < comp_full_names.size(); j ++)
+            if (strcmp(comp_full_names[k], comp_full_names[j]) > 0)
+                k = j;
+        temp_comp_full_names.push_back(comp_full_names[k]);
+        comp_full_names.erase(comp_full_names.begin()+k);
+        if (comp_index != NULL) {
+            temp_comp_index.push_back((*comp_index)[k]);
+            comp_index->erase(comp_index->begin()+k);
+        }
+    }
+    EXECUTION_REPORT(REPORT_ERROR, -1, num_comps == temp_comp_full_names.size() && comp_full_names.size() == 0, "Software error in Coupling_generator::do_external_coupling_generation");
+
+    for (i = 0; i < temp_comp_full_names.size(); i ++) {
+        comp_full_names.push_back(temp_comp_full_names[i]);
+        if (comp_index != NULL)
+            comp_index->push_back(temp_comp_index[i]);
+    }    
 }
 
 
 void Coupling_generator::do_overall_coupling_generation(const char *local_root_comp_full_name, const char *annotation)
 {
-	int i; 
-
-	
-	comp_comm_group_mgt_mgr->get_root_comps_for_overall_coupling_generation(all_comp_fullnames_for_coupling_generation);
-	for (i = 0; i < all_comp_fullnames_for_coupling_generation.size(); i ++)
-		if (words_are_the_same(local_root_comp_full_name, all_comp_fullnames_for_coupling_generation[i]))
-			break;
-	if (i == all_comp_fullnames_for_coupling_generation.size()) {
-		clear();
-		return;
-	}
-
-	for (i = 0; i < all_comp_fullnames_for_coupling_generation.size(); i ++)
-		individual_or_family_generation.push_back(2);	
-	do_external_coupling_generation(API_ID_COMP_MGT_END_COMP_REG, annotation);
+    int i; 
+
+    
+    comp_comm_group_mgt_mgr->get_root_comps_for_overall_coupling_generation(all_comp_fullnames_for_coupling_generation);
+    for (i = 0; i < all_comp_fullnames_for_coupling_generation.size(); i ++)
+        if (words_are_the_same(local_root_comp_full_name, all_comp_fullnames_for_coupling_generation[i]))
+            break;
+    if (i == all_comp_fullnames_for_coupling_generation.size()) {
+        clear();
+        return;
+    }
+
+    for (i = 0; i < all_comp_fullnames_for_coupling_generation.size(); i ++)
+        individual_or_family_generation.push_back(2);    
+    do_external_coupling_generation(API_ID_COMP_MGT_END_COMP_REG, annotation);
 }
 
 
 void Coupling_generator::do_external_coupling_generation(int API_id, const char *annotation)
 {
-	int i, j, k, num_comps = all_comp_fullnames_for_coupling_generation.size(), *temp_int_array;
-	std::vector<Comp_comm_group_mgt_node*> all_comp_nodes, loaded_comp_nodes;
-	Comp_comm_group_mgt_node *temp_comp_node, *local_comp_node, *existing_comp_node;
-	char *local_temp_array_buffer = NULL, *remote_temp_array_buffer = NULL;
-	long local_current_array_buffer_size, local_max_array_buffer_size, remote_current_array_buffer_size, remote_max_array_buffer_size, temp_array_size, str_size;
-	int current_connection_id, max_connection_id, remote_connection_id;
-	MPI_Request request_send, request_recv;
-	MPI_Status status;
-	MPI_Comm union_comm = MPI_COMM_NULL;
-	bool is_current_proc_in_union_comm = false;
-	int current_proc_id_in_union_comm, size_union_comm;
-	std::vector<int> proc_global_ids_in_union_comm, proc_global_ids_in_current_comm;
-	std::vector<const char*> temp_all_comp_fullnames_for_coupling_generation;
-
-
-	sort_comp_full_names(all_comp_fullnames_for_coupling_generation, &individual_or_family_generation);
-	temp_int_array = new int [individual_or_family_generation.size()];
-	for (i = 0; i < all_comp_fullnames_for_coupling_generation.size(); i ++) {
-		temp_int_array[i] = individual_or_family_generation[i];
-	}
-
-	for (i = 0; i < all_comp_fullnames_for_coupling_generation.size(); i ++)
-		if (comp_comm_group_mgt_mgr->search_global_node(all_comp_fullnames_for_coupling_generation[i]) != NULL)
-			break;
-	EXECUTION_REPORT(REPORT_ERROR, -1, i < all_comp_fullnames_for_coupling_generation.size(), "ERROR happens when calling the API \"CCPL_do_external_coupling_generation\": the current process is not in any component model specified in the parameter \"comps_full_names\". Please verify the model code with the annotation \"%s\"", annotation);
-		
-	for (i = 0; i < all_comp_fullnames_for_coupling_generation.size(); i ++) {
-		local_comp_node = comp_comm_group_mgt_mgr->search_global_node(all_comp_fullnames_for_coupling_generation[i]);
-		if (local_comp_node == NULL)
-			continue;
-		for (j = 0; j < all_comp_fullnames_for_coupling_generation.size(); j ++) {
-			EXECUTION_REPORT_LOG(REPORT_LOG, local_comp_node->get_comp_id(), true, "The API call of \"CCPL_do_external_coupling_generation\" at the model code with the annotation \"%s\" try to access the component model \"%s\". Deadlock will be happen if the full name of the component model is wrong.", annotation, all_comp_fullnames_for_coupling_generation[j]);
-			temp_comp_node = comp_comm_group_mgt_mgr->load_comp_info_from_XML(local_comp_node->get_comp_id(), all_comp_fullnames_for_coupling_generation[j], local_comp_node->get_comm_group());
-			existing_comp_node = comp_comm_group_mgt_mgr->search_global_node(all_comp_fullnames_for_coupling_generation[j]);
-			if (existing_comp_node != NULL) {
-				delete temp_comp_node;
-				temp_comp_node = existing_comp_node;
-			}
-			for (k = 0; k < all_comp_nodes.size(); k ++)
-				if (words_are_the_same(all_comp_nodes[k]->get_full_name(), all_comp_fullnames_for_coupling_generation[j]))
-					break;
-			if (k == all_comp_nodes.size()) {
-				all_comp_nodes.push_back(temp_comp_node);
-				if (existing_comp_node == NULL)
-					loaded_comp_nodes.push_back(temp_comp_node);
-			}
-			else if (existing_comp_node == NULL)
-				delete temp_comp_node;
-		}
-	}
-	EXECUTION_REPORT(REPORT_ERROR, -1, all_comp_nodes.size() == all_comp_fullnames_for_coupling_generation.size(), "Software error in Coupling_generator::do_external_coupling_generation: wrong all_comp_nodes.size()");
-
-	if (all_comp_fullnames_for_coupling_generation.size() == 1) {
-		generate_coupling_procedures_internal(all_comp_nodes[0]->get_comp_id(), individual_or_family_generation[0] == 2, annotation);
-		delete [] temp_int_array;
-		return;
-	}	
-
-	for (int i = 0; i < all_comp_fullnames_for_coupling_generation.size(); i ++)
-		dump_string(all_comp_fullnames_for_coupling_generation[i], -1, &local_temp_array_buffer, local_max_array_buffer_size, local_current_array_buffer_size);
-	write_data_into_array_buffer(local_temp_array_buffer, local_current_array_buffer_size, &remote_temp_array_buffer, remote_max_array_buffer_size, remote_current_array_buffer_size);
-	for (i = 0; i < all_comp_fullnames_for_coupling_generation.size(); i ++)
-		if (all_comp_nodes[i]->get_current_proc_local_id() >= 0) {
-			EXECUTION_REPORT_LOG(REPORT_LOG, all_comp_nodes[i]->get_comp_id(), true, "In the flowchart of executing the API \"CCPL_do_external_coupling_generation\" at the model code with the annotation \"%s\": before checking consistency of the parameters between all processes of this component model. Deadlock may happen if not all processes of this component model calls this API at the same time", annotation);
-			check_API_parameter_data_array(all_comp_nodes[i]->get_comp_id(), API_id, all_comp_nodes[i]->get_comm_group(), "coupling generation", local_current_array_buffer_size, sizeof(char), local_temp_array_buffer, "comps_full_names", annotation);
-			check_API_parameter_data_array(all_comp_nodes[i]->get_comp_id(), API_id, all_comp_nodes[i]->get_comm_group(), "coupling generation", individual_or_family_generation.size(), sizeof(int), (const char*) temp_int_array, "individual_or_familiy", annotation);
-			coupling_generator->synchronize_latest_connection_id(all_comp_nodes[i]->get_comm_group());
-			EXECUTION_REPORT_LOG(REPORT_LOG, all_comp_nodes[i]->get_comp_id(), true, "In the flowchart of executing the API \"CCPL_do_external_coupling_generation\" at the model code with the annotation \"%s\": after checking consistency of the parameters between all processes of this component model. Deadlock may happen if not all processes of this component model calls this API at the same time", annotation);			
-		}
-	max_connection_id = coupling_generator->get_latest_connection_id();
-	for (i = 1; i < all_comp_fullnames_for_coupling_generation.size(); i ++) {
-		if (all_comp_nodes[0]->get_current_proc_local_id() == 0) {
-			EXECUTION_REPORT_LOG(REPORT_LOG, all_comp_nodes[0]->get_comp_id(), true, "In the flowchart of executing the API \"CCPL_do_external_coupling_generation\" at the model code with the annotation \"%s\": check consistency of the parameters between the compoment models \"%s\" and \"%s\". Deadlock may happen if these two component models do not call this API at the same time", annotation, all_comp_fullnames_for_coupling_generation[0], all_comp_fullnames_for_coupling_generation[i]);
-			MPI_Irecv(&remote_connection_id, 1, MPI_INT, all_comp_nodes[i]->get_local_proc_global_id(0), 10101, MPI_COMM_WORLD, &request_recv);
-		}
-		if (all_comp_nodes[i]->get_current_proc_local_id() == 0) {
-			EXECUTION_REPORT_LOG(REPORT_LOG, all_comp_nodes[i]->get_comp_id(), true, "In the flowchart of executing the API \"CCPL_do_external_coupling_generation\" at the model code with the annotation \"%s\": check consistency of the parameters between the compoment models \"%s\" and \"%s\". Deadlock may happen if these two component models do not call this API at the same time", annotation, all_comp_fullnames_for_coupling_generation[i], all_comp_fullnames_for_coupling_generation[0]); 
-			MPI_Isend(&max_connection_id, 1, MPI_INT, all_comp_nodes[0]->get_local_proc_global_id(0), 10101, MPI_COMM_WORLD, &request_send);
-		}
-		if (all_comp_nodes[0]->get_current_proc_local_id() == 0) {
-			MPI_Wait(&request_recv, &status);
-			max_connection_id = remote_connection_id > max_connection_id? remote_connection_id : max_connection_id;
-		}
-		if (all_comp_nodes[i]->get_current_proc_local_id() == 0)
-			MPI_Wait(&request_send, &status);
-	}
-	for (i = 1; i < all_comp_fullnames_for_coupling_generation.size(); i ++) {
-		if (all_comp_nodes[0]->get_current_proc_local_id() == 0)
-			MPI_Isend(&max_connection_id, 1, MPI_INT, all_comp_nodes[i]->get_local_proc_global_id(0), 10101, MPI_COMM_WORLD, &request_send);
-		if (all_comp_nodes[i]->get_current_proc_local_id() == 0)
-			MPI_Irecv(&max_connection_id, 1, MPI_INT, all_comp_nodes[0]->get_local_proc_global_id(0), 10101, MPI_COMM_WORLD, &request_recv);
-		if (all_comp_nodes[0]->get_current_proc_local_id() == 0)
-			MPI_Wait(&request_send, &status);
-		if (all_comp_nodes[i]->get_current_proc_local_id() == 0)
-			MPI_Wait(&request_recv, &status);
-	}
-	for (i = 0; i < all_comp_fullnames_for_coupling_generation.size(); i ++)
-		if (all_comp_nodes[i]->get_current_proc_local_id() != -1)
-			MPI_Bcast(&max_connection_id, 1, MPI_INT, 0, all_comp_nodes[i]->get_comm_group());
-	coupling_generator->set_latest_connection_id(max_connection_id);
-	EXECUTION_REPORT_LOG(REPORT_LOG, -1, true, "The coupling connection id in Coupling_generator::do_external_coupling_generation is %d", coupling_generator->get_latest_connection_id());
-
-	for (i = 1; i < all_comp_fullnames_for_coupling_generation.size(); i ++)
-		if (all_comp_nodes[0]->get_current_proc_local_id() != -1 || all_comp_nodes[i]->get_current_proc_local_id() != -1) {
-			transfer_array_from_one_comp_to_another(all_comp_nodes[0]->get_current_proc_local_id(), all_comp_nodes[0]->get_local_proc_global_id(0), all_comp_nodes[i]->get_current_proc_local_id(), all_comp_nodes[i]->get_local_proc_global_id(0), all_comp_nodes[i]->get_comm_group(), &remote_temp_array_buffer, remote_current_array_buffer_size);
-			temp_array_size = individual_or_family_generation.size() * sizeof(int);
-			transfer_array_from_one_comp_to_another(all_comp_nodes[0]->get_current_proc_local_id(), all_comp_nodes[0]->get_local_proc_global_id(0), all_comp_nodes[i]->get_current_proc_local_id(), all_comp_nodes[i]->get_local_proc_global_id(0), all_comp_nodes[i]->get_comm_group(), (char**)(&temp_int_array), temp_array_size);
-			if (all_comp_nodes[i]->get_current_proc_local_id() != -1) {
-				EXECUTION_REPORT(REPORT_ERROR, all_comp_nodes[i]->get_comp_id(), remote_current_array_buffer_size == local_current_array_buffer_size, "ERROR happens when calling the API \"CCPL_do_external_coupling_generation\": the full names of component models specified through the input parameters are not consistency between the component models \"%s\" and \"%s\". Please check the model code with the annotation \"%s\"", all_comp_fullnames_for_coupling_generation[i], all_comp_fullnames_for_coupling_generation[0], annotation);
-				for (j = 0; j < local_current_array_buffer_size; j ++)
-					if (local_temp_array_buffer[j] != remote_temp_array_buffer[j])
-						break;
-				EXECUTION_REPORT(REPORT_ERROR, all_comp_nodes[i]->get_comp_id(), j == local_current_array_buffer_size, "ERROR happens when calling the API \"CCPL_do_external_coupling_generation\": the full names of component models specified through the input parameters are not consistency between the component models \"%s\" and \"%s\". Please check the model code with the annotation \"%s\"", all_comp_fullnames_for_coupling_generation[i], all_comp_fullnames_for_coupling_generation[0], annotation);
-				for (j = 0; j < individual_or_family_generation.size(); j ++)	
-					if (individual_or_family_generation[j] != temp_int_array[j])
-						break;
-				EXECUTION_REPORT(REPORT_ERROR, all_comp_nodes[i]->get_comp_id(), j == individual_or_family_generation.size(), "ERROR happens when calling the API \"CCPL_do_external_coupling_generation\": the values of the parameter \"individual_or_family\" are not consistency between the component models \"%s\" and \"%s\". Please check the model code with the annotation \"%s\"", all_comp_fullnames_for_coupling_generation[i], all_comp_fullnames_for_coupling_generation[0], annotation);
-			}
-		}
-	if (local_temp_array_buffer != NULL) {
-		delete [] local_temp_array_buffer;
-		local_temp_array_buffer = NULL;
-	}
-	if (remote_temp_array_buffer != NULL) {
-		delete [] remote_temp_array_buffer;
-		remote_temp_array_buffer = NULL;
-	}	
-
-	for (i = 0; i < all_comp_fullnames_for_coupling_generation.size(); i ++) {
-		current_connection_id = coupling_generator->apply_connection_id();
-		if (i == 0) {
-			if (all_comp_nodes[i]->get_current_proc_local_id() != -1)
-				union_comm = all_comp_nodes[i]->get_comm_group();
-		}
-		else if (is_current_proc_in_union_comm || all_comp_nodes[i]->get_current_proc_local_id() != -1) {
-			int *temp_proc_global_ids = NULL, proc_global_id;
-			long array_size;
-			MPI_Comm_rank(MPI_COMM_WORLD, &proc_global_id);
-			if (is_current_proc_in_union_comm) {
-				MPI_Comm_rank(union_comm, &current_proc_id_in_union_comm);
-				MPI_Comm_size(union_comm, &size_union_comm);
-				array_size = size_union_comm * sizeof(int);
-				temp_proc_global_ids = new int [size_union_comm];
-				MPI_Allgather(&proc_global_id, 1, MPI_INT, temp_proc_global_ids, 1, MPI_INT, union_comm);
-			}
-			else current_proc_id_in_union_comm = -1;
-			if (proc_global_id == all_comp_nodes[0]->get_local_proc_global_id(0) || all_comp_nodes[i]->get_current_proc_local_id() != -1) {
-				if (proc_global_id == all_comp_nodes[0]->get_local_proc_global_id(0))
-					transfer_array_from_one_comp_to_another(0, all_comp_nodes[0]->get_local_proc_global_id(0), all_comp_nodes[i]->get_current_proc_local_id(), all_comp_nodes[i]->get_local_proc_global_id(0), all_comp_nodes[i]->get_comm_group(), (char**) (&temp_proc_global_ids), array_size);
-				else transfer_array_from_one_comp_to_another(-1, all_comp_nodes[0]->get_local_proc_global_id(0), all_comp_nodes[i]->get_current_proc_local_id(), all_comp_nodes[i]->get_local_proc_global_id(0), all_comp_nodes[i]->get_comm_group(), (char**) (&temp_proc_global_ids), array_size);
-			}
-			proc_global_ids_in_union_comm.clear();
-			for (int i = 0; i < array_size/sizeof(int); i ++)
-				proc_global_ids_in_union_comm.push_back(temp_proc_global_ids[i]);
-			if (temp_proc_global_ids != NULL)
-				delete [] temp_proc_global_ids;
-			proc_global_ids_in_current_comm.clear();
-			for (j = 0; j < all_comp_nodes[i]->get_num_procs(); j ++)
-				proc_global_ids_in_current_comm.push_back(all_comp_nodes[i]->get_local_proc_global_id(j));
-			union_comm = create_union_comm_common(union_comm, all_comp_nodes[i]->get_comm_group(), current_proc_id_in_union_comm, all_comp_nodes[i]->get_current_proc_local_id(), proc_global_ids_in_union_comm, proc_global_ids_in_current_comm, current_connection_id, NULL, NULL);
-		}
-		if (all_comp_nodes[i]->get_current_proc_local_id() != -1)
-			is_current_proc_in_union_comm = true;
-	}
-
-	MPI_Comm_size(union_comm, &size_union_comm);
-	MPI_Comm_rank(union_comm, &current_proc_id_in_union_comm);
-	EXECUTION_REPORT_LOG(REPORT_LOG, -1, true, "Finish generating the union comm (%d) for external coupling generation", size_union_comm);
-
-	remote_max_array_buffer_size = 0; 
-	remote_current_array_buffer_size = 0;
-	for (i = 0; i < all_comp_fullnames_for_coupling_generation.size(); i ++) {
-		if (all_comp_nodes[i]->get_current_proc_local_id() != -1) {
-			if (individual_or_family_generation[i] == 2)
-				all_comp_nodes[i]->get_all_descendant_real_comp_fullnames(all_comp_nodes[i]->get_comp_id(), temp_all_comp_fullnames_for_coupling_generation, &local_temp_array_buffer, local_max_array_buffer_size, local_current_array_buffer_size);
-			else temp_all_comp_fullnames_for_coupling_generation.push_back(strdup(all_comp_fullnames_for_coupling_generation[i]));
-			if (all_comp_nodes[i]->get_current_proc_local_id() == 0)
-				for (j = 0; j < temp_all_comp_fullnames_for_coupling_generation.size(); j ++)
-					dump_string(temp_all_comp_fullnames_for_coupling_generation[j], -1, &remote_temp_array_buffer, remote_max_array_buffer_size, remote_current_array_buffer_size);
-			for (j = 0; j < temp_all_comp_fullnames_for_coupling_generation.size(); j ++)
-				delete [] temp_all_comp_fullnames_for_coupling_generation[j];
-			temp_all_comp_fullnames_for_coupling_generation.clear();
-		}
-	}
-	local_temp_array_buffer = NULL;
-	local_current_array_buffer_size = 0;
-	local_max_array_buffer_size = 0;
-	gather_array_in_one_comp(size_union_comm, current_proc_id_in_union_comm, remote_temp_array_buffer, remote_current_array_buffer_size, sizeof(char), NULL, (void**)(&local_temp_array_buffer), local_current_array_buffer_size, union_comm);
-	bcast_array_in_one_comp(current_proc_id_in_union_comm, &local_temp_array_buffer, local_current_array_buffer_size, union_comm);
-	for (i = 0; i < all_comp_fullnames_for_coupling_generation.size(); i ++)
-		delete [] all_comp_fullnames_for_coupling_generation[i];
-	all_comp_fullnames_for_coupling_generation.clear();
-	individual_or_family_generation.clear();
-	while (local_current_array_buffer_size > 0) {
-		const char *full_name = load_string(NULL, str_size, -1, local_temp_array_buffer, local_current_array_buffer_size, NULL);
-		add_comp_for_external_coupling_generation(full_name, 1, annotation);
-	}	
-	EXECUTION_REPORT(REPORT_ERROR, -1, local_current_array_buffer_size == 0, "Software error in Coupling_generator::do_external_coupling_generation");
-	if (local_temp_array_buffer != NULL)
-		delete [] local_temp_array_buffer;
-	if (remote_temp_array_buffer != NULL)
-		delete [] remote_temp_array_buffer;
-
-	if (current_proc_id_in_union_comm == 0) {		
-		for (int i = 0; i < all_comp_fullnames_for_coupling_generation.size(); i ++)
-			printf("comp for external generation %s at proc %d\n", all_comp_fullnames_for_coupling_generation[i], current_proc_id_in_union_comm);
-	}
-	generate_coupling_procedures_common(API_id, union_comm, false, annotation);
-
-	clear();
-	delete [] temp_int_array;
+    int i, j, k, num_comps = all_comp_fullnames_for_coupling_generation.size(), *temp_int_array;
+    std::vector<Comp_comm_group_mgt_node*> all_comp_nodes, loaded_comp_nodes;
+    Comp_comm_group_mgt_node *temp_comp_node, *local_comp_node, *existing_comp_node;
+    char *local_temp_array_buffer = NULL, *remote_temp_array_buffer = NULL;
+    long local_current_array_buffer_size, local_max_array_buffer_size, remote_current_array_buffer_size, remote_max_array_buffer_size, temp_array_size, str_size;
+    int current_connection_id, max_connection_id, remote_connection_id;
+    MPI_Request request_send, request_recv;
+    MPI_Status status;
+    MPI_Comm union_comm = MPI_COMM_NULL;
+    bool is_current_proc_in_union_comm = false;
+    int current_proc_id_in_union_comm, size_union_comm;
+    std::vector<int> proc_global_ids_in_union_comm, proc_global_ids_in_current_comm;
+    std::vector<const char*> temp_all_comp_fullnames_for_coupling_generation;
+
+
+    sort_comp_full_names(all_comp_fullnames_for_coupling_generation, &individual_or_family_generation);
+    temp_int_array = new int [individual_or_family_generation.size()];
+    for (i = 0; i < all_comp_fullnames_for_coupling_generation.size(); i ++) {
+        temp_int_array[i] = individual_or_family_generation[i];
+    }
+
+    for (i = 0; i < all_comp_fullnames_for_coupling_generation.size(); i ++)
+        if (comp_comm_group_mgt_mgr->search_global_node(all_comp_fullnames_for_coupling_generation[i]) != NULL)
+            break;
+    EXECUTION_REPORT(REPORT_ERROR, -1, i < all_comp_fullnames_for_coupling_generation.size(), "ERROR happens when calling the API \"CCPL_do_external_coupling_generation\": the current process is not in any component model specified in the parameter \"comps_full_names\". Please verify the model code with the annotation \"%s\"", annotation);
+        
+    for (i = 0; i < all_comp_fullnames_for_coupling_generation.size(); i ++) {
+        local_comp_node = comp_comm_group_mgt_mgr->search_global_node(all_comp_fullnames_for_coupling_generation[i]);
+        if (local_comp_node == NULL)
+            continue;
+        for (j = 0; j < all_comp_fullnames_for_coupling_generation.size(); j ++) {
+            EXECUTION_REPORT_LOG(REPORT_LOG, local_comp_node->get_comp_id(), true, "The API call of \"CCPL_do_external_coupling_generation\" at the model code with the annotation \"%s\" try to access the component model \"%s\". Deadlock will be happen if the full name of the component model is wrong.", annotation, all_comp_fullnames_for_coupling_generation[j]);
+            temp_comp_node = comp_comm_group_mgt_mgr->load_comp_info_from_XML(local_comp_node->get_comp_id(), all_comp_fullnames_for_coupling_generation[j], local_comp_node->get_comm_group());
+            existing_comp_node = comp_comm_group_mgt_mgr->search_global_node(all_comp_fullnames_for_coupling_generation[j]);
+            if (existing_comp_node != NULL) {
+                delete temp_comp_node;
+                temp_comp_node = existing_comp_node;
+            }
+            for (k = 0; k < all_comp_nodes.size(); k ++)
+                if (words_are_the_same(all_comp_nodes[k]->get_full_name(), all_comp_fullnames_for_coupling_generation[j]))
+                    break;
+            if (k == all_comp_nodes.size()) {
+                all_comp_nodes.push_back(temp_comp_node);
+                if (existing_comp_node == NULL)
+                    loaded_comp_nodes.push_back(temp_comp_node);
+            }
+            else if (existing_comp_node == NULL)
+                delete temp_comp_node;
+        }
+    }
+    EXECUTION_REPORT(REPORT_ERROR, -1, all_comp_nodes.size() == all_comp_fullnames_for_coupling_generation.size(), "Software error in Coupling_generator::do_external_coupling_generation: wrong all_comp_nodes.size()");
+
+    if (all_comp_fullnames_for_coupling_generation.size() == 1) {
+        generate_coupling_procedures_internal(all_comp_nodes[0]->get_comp_id(), individual_or_family_generation[0] == 2, false, annotation);
+        delete [] temp_int_array;
+        return;
+    }    
+
+    for (int i = 0; i < all_comp_fullnames_for_coupling_generation.size(); i ++)
+        dump_string(all_comp_fullnames_for_coupling_generation[i], -1, &local_temp_array_buffer, local_max_array_buffer_size, local_current_array_buffer_size);
+    write_data_into_array_buffer(local_temp_array_buffer, local_current_array_buffer_size, &remote_temp_array_buffer, remote_max_array_buffer_size, remote_current_array_buffer_size);
+    for (i = 0; i < all_comp_fullnames_for_coupling_generation.size(); i ++)
+        if (all_comp_nodes[i]->get_current_proc_local_id() >= 0) {
+            EXECUTION_REPORT_LOG(REPORT_LOG, all_comp_nodes[i]->get_comp_id(), true, "In the flowchart of executing the API \"CCPL_do_external_coupling_generation\" at the model code with the annotation \"%s\": before checking consistency of the parameters between all processes of this component model. Deadlock may happen if not all processes of this component model calls this API at the same time", annotation);
+            check_API_parameter_data_array(all_comp_nodes[i]->get_comp_id(), API_id, all_comp_nodes[i]->get_comm_group(), "coupling generation", local_current_array_buffer_size, sizeof(char), local_temp_array_buffer, "comps_full_names", annotation);
+            check_API_parameter_data_array(all_comp_nodes[i]->get_comp_id(), API_id, all_comp_nodes[i]->get_comm_group(), "coupling generation", individual_or_family_generation.size(), sizeof(int), (const char*) temp_int_array, "individual_or_familiy", annotation);
+            coupling_generator->synchronize_latest_connection_id(all_comp_nodes[i]->get_comm_group());
+            EXECUTION_REPORT_LOG(REPORT_LOG, all_comp_nodes[i]->get_comp_id(), true, "In the flowchart of executing the API \"CCPL_do_external_coupling_generation\" at the model code with the annotation \"%s\": after checking consistency of the parameters between all processes of this component model. Deadlock may happen if not all processes of this component model calls this API at the same time", annotation);            
+        }
+    max_connection_id = coupling_generator->get_latest_connection_id();
+    for (i = 1; i < all_comp_fullnames_for_coupling_generation.size(); i ++) {
+        if (all_comp_nodes[0]->get_current_proc_local_id() == 0) {
+            EXECUTION_REPORT_LOG(REPORT_LOG, all_comp_nodes[0]->get_comp_id(), true, "In the flowchart of executing the API \"CCPL_do_external_coupling_generation\" at the model code with the annotation \"%s\": check consistency of the parameters between the compoment models \"%s\" and \"%s\". Deadlock may happen if these two component models do not call this API at the same time", annotation, all_comp_fullnames_for_coupling_generation[0], all_comp_fullnames_for_coupling_generation[i]);
+            MPI_Irecv(&remote_connection_id, 1, MPI_INT, all_comp_nodes[i]->get_local_proc_global_id(0), 10101, MPI_COMM_WORLD, &request_recv);
+        }
+        if (all_comp_nodes[i]->get_current_proc_local_id() == 0) {
+            EXECUTION_REPORT_LOG(REPORT_LOG, all_comp_nodes[i]->get_comp_id(), true, "In the flowchart of executing the API \"CCPL_do_external_coupling_generation\" at the model code with the annotation \"%s\": check consistency of the parameters between the compoment models \"%s\" and \"%s\". Deadlock may happen if these two component models do not call this API at the same time", annotation, all_comp_fullnames_for_coupling_generation[i], all_comp_fullnames_for_coupling_generation[0]); 
+            MPI_Isend(&max_connection_id, 1, MPI_INT, all_comp_nodes[0]->get_local_proc_global_id(0), 10101, MPI_COMM_WORLD, &request_send);
+        }
+        if (all_comp_nodes[0]->get_current_proc_local_id() == 0) {
+            MPI_Wait(&request_recv, &status);
+            max_connection_id = remote_connection_id > max_connection_id? remote_connection_id : max_connection_id;
+        }
+        if (all_comp_nodes[i]->get_current_proc_local_id() == 0)
+            MPI_Wait(&request_send, &status);
+    }
+    for (i = 1; i < all_comp_fullnames_for_coupling_generation.size(); i ++) {
+        if (all_comp_nodes[0]->get_current_proc_local_id() == 0)
+            MPI_Isend(&max_connection_id, 1, MPI_INT, all_comp_nodes[i]->get_local_proc_global_id(0), 10101, MPI_COMM_WORLD, &request_send);
+        if (all_comp_nodes[i]->get_current_proc_local_id() == 0)
+            MPI_Irecv(&max_connection_id, 1, MPI_INT, all_comp_nodes[0]->get_local_proc_global_id(0), 10101, MPI_COMM_WORLD, &request_recv);
+        if (all_comp_nodes[0]->get_current_proc_local_id() == 0)
+            MPI_Wait(&request_send, &status);
+        if (all_comp_nodes[i]->get_current_proc_local_id() == 0)
+            MPI_Wait(&request_recv, &status);
+    }
+    for (i = 0; i < all_comp_fullnames_for_coupling_generation.size(); i ++)
+        if (all_comp_nodes[i]->get_current_proc_local_id() != -1)
+            MPI_Bcast(&max_connection_id, 1, MPI_INT, 0, all_comp_nodes[i]->get_comm_group());
+    coupling_generator->set_latest_connection_id(max_connection_id);
+    EXECUTION_REPORT_LOG(REPORT_LOG, -1, true, "The coupling connection id in Coupling_generator::do_external_coupling_generation is %d", coupling_generator->get_latest_connection_id());
+
+    for (i = 1; i < all_comp_fullnames_for_coupling_generation.size(); i ++)
+        if (all_comp_nodes[0]->get_current_proc_local_id() != -1 || all_comp_nodes[i]->get_current_proc_local_id() != -1) {
+            transfer_array_from_one_comp_to_another(all_comp_nodes[0]->get_current_proc_local_id(), all_comp_nodes[0]->get_local_proc_global_id(0), all_comp_nodes[i]->get_current_proc_local_id(), all_comp_nodes[i]->get_local_proc_global_id(0), all_comp_nodes[i]->get_comm_group(), &remote_temp_array_buffer, remote_current_array_buffer_size);
+            temp_array_size = individual_or_family_generation.size() * sizeof(int);
+            transfer_array_from_one_comp_to_another(all_comp_nodes[0]->get_current_proc_local_id(), all_comp_nodes[0]->get_local_proc_global_id(0), all_comp_nodes[i]->get_current_proc_local_id(), all_comp_nodes[i]->get_local_proc_global_id(0), all_comp_nodes[i]->get_comm_group(), (char**)(&temp_int_array), temp_array_size);
+            if (all_comp_nodes[i]->get_current_proc_local_id() != -1) {
+                EXECUTION_REPORT(REPORT_ERROR, all_comp_nodes[i]->get_comp_id(), remote_current_array_buffer_size == local_current_array_buffer_size, "ERROR happens when calling the API \"CCPL_do_external_coupling_generation\": the full names of component models specified through the input parameters are not consistency between the component models \"%s\" and \"%s\". Please check the model code with the annotation \"%s\"", all_comp_fullnames_for_coupling_generation[i], all_comp_fullnames_for_coupling_generation[0], annotation);
+                for (j = 0; j < local_current_array_buffer_size; j ++)
+                    if (local_temp_array_buffer[j] != remote_temp_array_buffer[j])
+                        break;
+                EXECUTION_REPORT(REPORT_ERROR, all_comp_nodes[i]->get_comp_id(), j == local_current_array_buffer_size, "ERROR happens when calling the API \"CCPL_do_external_coupling_generation\": the full names of component models specified through the input parameters are not consistency between the component models \"%s\" and \"%s\". Please check the model code with the annotation \"%s\"", all_comp_fullnames_for_coupling_generation[i], all_comp_fullnames_for_coupling_generation[0], annotation);
+                for (j = 0; j < individual_or_family_generation.size(); j ++)    
+                    if (individual_or_family_generation[j] != temp_int_array[j])
+                        break;
+                EXECUTION_REPORT(REPORT_ERROR, all_comp_nodes[i]->get_comp_id(), j == individual_or_family_generation.size(), "ERROR happens when calling the API \"CCPL_do_external_coupling_generation\": the values of the parameter \"individual_or_family\" are not consistency between the component models \"%s\" and \"%s\". Please check the model code with the annotation \"%s\"", all_comp_fullnames_for_coupling_generation[i], all_comp_fullnames_for_coupling_generation[0], annotation);
+            }
+        }
+    if (local_temp_array_buffer != NULL) {
+        delete [] local_temp_array_buffer;
+        local_temp_array_buffer = NULL;
+    }
+    if (remote_temp_array_buffer != NULL) {
+        delete [] remote_temp_array_buffer;
+        remote_temp_array_buffer = NULL;
+    }    
+
+    for (i = 0; i < all_comp_fullnames_for_coupling_generation.size(); i ++) {
+        current_connection_id = coupling_generator->apply_connection_id();
+        if (i == 0) {
+            if (all_comp_nodes[i]->get_current_proc_local_id() != -1)
+                union_comm = all_comp_nodes[i]->get_comm_group();
+        }
+        else if (is_current_proc_in_union_comm || all_comp_nodes[i]->get_current_proc_local_id() != -1) {
+            int *temp_proc_global_ids = NULL, proc_global_id;
+            long array_size;
+            MPI_Comm_rank(MPI_COMM_WORLD, &proc_global_id);
+            if (is_current_proc_in_union_comm) {
+                MPI_Comm_rank(union_comm, &current_proc_id_in_union_comm);
+                MPI_Comm_size(union_comm, &size_union_comm);
+                array_size = size_union_comm * sizeof(int);
+                temp_proc_global_ids = new int [size_union_comm];
+                MPI_Allgather(&proc_global_id, 1, MPI_INT, temp_proc_global_ids, 1, MPI_INT, union_comm);
+            }
+            else current_proc_id_in_union_comm = -1;
+            if (proc_global_id == all_comp_nodes[0]->get_local_proc_global_id(0) || all_comp_nodes[i]->get_current_proc_local_id() != -1) {
+                if (proc_global_id == all_comp_nodes[0]->get_local_proc_global_id(0))
+                    transfer_array_from_one_comp_to_another(0, all_comp_nodes[0]->get_local_proc_global_id(0), all_comp_nodes[i]->get_current_proc_local_id(), all_comp_nodes[i]->get_local_proc_global_id(0), all_comp_nodes[i]->get_comm_group(), (char**) (&temp_proc_global_ids), array_size);
+                else transfer_array_from_one_comp_to_another(-1, all_comp_nodes[0]->get_local_proc_global_id(0), all_comp_nodes[i]->get_current_proc_local_id(), all_comp_nodes[i]->get_local_proc_global_id(0), all_comp_nodes[i]->get_comm_group(), (char**) (&temp_proc_global_ids), array_size);
+            }
+            proc_global_ids_in_union_comm.clear();
+            for (int i = 0; i < array_size/sizeof(int); i ++)
+                proc_global_ids_in_union_comm.push_back(temp_proc_global_ids[i]);
+            if (temp_proc_global_ids != NULL)
+                delete [] temp_proc_global_ids;
+            proc_global_ids_in_current_comm.clear();
+            for (j = 0; j < all_comp_nodes[i]->get_num_procs(); j ++)
+                proc_global_ids_in_current_comm.push_back(all_comp_nodes[i]->get_local_proc_global_id(j));
+            union_comm = create_union_comm_common(union_comm, all_comp_nodes[i]->get_comm_group(), current_proc_id_in_union_comm, all_comp_nodes[i]->get_current_proc_local_id(), proc_global_ids_in_union_comm, proc_global_ids_in_current_comm, current_connection_id, NULL, NULL);
+        }
+        if (all_comp_nodes[i]->get_current_proc_local_id() != -1)
+            is_current_proc_in_union_comm = true;
+    }
+
+    MPI_Comm_size(union_comm, &size_union_comm);
+    MPI_Comm_rank(union_comm, &current_proc_id_in_union_comm);
+    EXECUTION_REPORT_LOG(REPORT_LOG, -1, true, "Finish generating the union comm (%d) for external coupling generation", size_union_comm);
+
+    remote_max_array_buffer_size = 0; 
+    remote_current_array_buffer_size = 0;
+    for (i = 0; i < all_comp_fullnames_for_coupling_generation.size(); i ++) {
+        if (all_comp_nodes[i]->get_current_proc_local_id() != -1) {
+            if (individual_or_family_generation[i] == 2)
+                all_comp_nodes[i]->get_all_descendant_real_comp_fullnames(all_comp_nodes[i]->get_comp_id(), temp_all_comp_fullnames_for_coupling_generation, &local_temp_array_buffer, local_max_array_buffer_size, local_current_array_buffer_size);
+            else temp_all_comp_fullnames_for_coupling_generation.push_back(strdup(all_comp_fullnames_for_coupling_generation[i]));
+            if (all_comp_nodes[i]->get_current_proc_local_id() == 0)
+                for (j = 0; j < temp_all_comp_fullnames_for_coupling_generation.size(); j ++)
+                    dump_string(temp_all_comp_fullnames_for_coupling_generation[j], -1, &remote_temp_array_buffer, remote_max_array_buffer_size, remote_current_array_buffer_size);
+            for (j = 0; j < temp_all_comp_fullnames_for_coupling_generation.size(); j ++)
+                delete [] temp_all_comp_fullnames_for_coupling_generation[j];
+            temp_all_comp_fullnames_for_coupling_generation.clear();
+        }
+    }
+    local_temp_array_buffer = NULL;
+    local_current_array_buffer_size = 0;
+    local_max_array_buffer_size = 0;
+    gather_array_in_one_comp(size_union_comm, current_proc_id_in_union_comm, remote_temp_array_buffer, remote_current_array_buffer_size, sizeof(char), NULL, (void**)(&local_temp_array_buffer), local_current_array_buffer_size, union_comm);
+    bcast_array_in_one_comp(current_proc_id_in_union_comm, &local_temp_array_buffer, local_current_array_buffer_size, union_comm);
+    for (i = 0; i < all_comp_fullnames_for_coupling_generation.size(); i ++)
+        delete [] all_comp_fullnames_for_coupling_generation[i];
+    all_comp_fullnames_for_coupling_generation.clear();
+    individual_or_family_generation.clear();
+    while (local_current_array_buffer_size > 0) {
+        const char *full_name = load_string(NULL, str_size, -1, local_temp_array_buffer, local_current_array_buffer_size, NULL);
+        add_comp_for_external_coupling_generation(full_name, 1, annotation);
+    }    
+    EXECUTION_REPORT(REPORT_ERROR, -1, local_current_array_buffer_size == 0, "Software error in Coupling_generator::do_external_coupling_generation");
+    if (local_temp_array_buffer != NULL)
+        delete [] local_temp_array_buffer;
+    if (remote_temp_array_buffer != NULL)
+        delete [] remote_temp_array_buffer;
+
+    if (current_proc_id_in_union_comm == 0) {        
+        for (int i = 0; i < all_comp_fullnames_for_coupling_generation.size(); i ++)
+            EXECUTION_REPORT_LOG(REPORT_ERROR, -1, true, "comp for external generation %s at proc %d\n", all_comp_fullnames_for_coupling_generation[i], current_proc_id_in_union_comm);
+    }
+    generate_coupling_procedures_common(API_id, union_comm, false, false, annotation);
+
+    clear();
+    delete [] temp_int_array;
 }
 
 
 void Coupling_generator::load_comps_full_names_from_config_file(int comp_id, const char *keyword, int size_comps_full_names, int size_individual_or_family, int *num_comps, const char *annotation)
 {
-	char XML_file_name[NAME_STR_SIZE];
-	const char *current_comp_full_name = comp_comm_group_mgt_mgr->get_global_node_of_local_comp(comp_id, true, "in Coupling_generator::load_comps_full_names_from_config_file")->get_full_name();
-	const char *temp_full_name;
-	const char *XML_keyword;
-	int line_number, i;
-
-
-	*num_comps = 0;
-	
-	sprintf(XML_file_name, "%s/all/coupling_connections/%s.coupling_connections.xml", comp_comm_group_mgt_mgr->get_config_root_dir(), current_comp_full_name);
-	TiXmlDocument *XML_file = open_XML_file_to_read(comp_id, XML_file_name, comp_comm_group_mgt_mgr->get_comm_group_of_local_comp(comp_id, "in Coupling_generator::load_comps_full_names_from_config_file"), false);
-	if (XML_file == NULL)
-		return;
-	
-	TiXmlElement *root_XML_element, *XML_element, *detailed_XML_element;
-	TiXmlNode *root_XML_element_node = get_XML_first_child_of_unique_root(comp_id, XML_file_name, XML_file), *XML_element_node = NULL, *detailed_XML_element_node = NULL;
-	for (; root_XML_element_node != NULL; root_XML_element_node = root_XML_element_node->NextSibling()) {
-		if (root_XML_element_node->Type() != TiXmlNode::TINYXML_ELEMENT)
-			continue;
-		root_XML_element = root_XML_element_node->ToElement();
-		if (words_are_the_same(root_XML_element->Value(),"component_full_names_sets"))
-			break;
-	}
-	if (root_XML_element_node == NULL)
-		return;
-
-	for (XML_element_node = root_XML_element->FirstChild(); XML_element_node != NULL; XML_element_node = XML_element_node->NextSibling()) {
-		XML_element = XML_element_node->ToElement();
-		if (!is_XML_setting_on(comp_id, XML_element, XML_file_name, "the status for the full names of a set of component models", "the coupling connection configuration file"))
-			continue;
-		XML_keyword = get_XML_attribute(comp_id, -1, XML_element, "keyword", XML_file_name, line_number, "the keyword of the set of component models' full names", "the coupling connection configuration file", true);
-		if (words_are_the_same(keyword, XML_keyword))
-			break;
-	}	
-	if (XML_element_node == NULL)
-		return;
-
-	for (detailed_XML_element_node = XML_element->FirstChild(); detailed_XML_element_node != NULL; detailed_XML_element_node = detailed_XML_element_node->NextSibling()) {
-		detailed_XML_element = detailed_XML_element_node->ToElement();
-		temp_full_name = get_XML_attribute(comp_id, -1, detailed_XML_element, "comp_full_name", XML_file_name, line_number, "the full name of a component model", "the coupling connection configuration file", true);
-		if (temp_full_name != NULL) {
-			for (i = 0; i < all_comp_fullnames_for_coupling_generation.size(); i ++)
-				if (words_are_the_same(temp_full_name, all_comp_fullnames_for_coupling_generation[i]))
-					break;			
-			if (i == all_comp_fullnames_for_coupling_generation.size())
-				all_comp_fullnames_for_coupling_generation.push_back(strdup(temp_full_name));
-			else EXECUTION_REPORT(REPORT_ERROR, comp_id, false, "ERROR happens when calling the API \"CCPL_get_configurable_comps_full_names\": when loading the set of component models corresponding to the keyword \"%s\" from the XML file \"%s\", there are more than one entry of the component model \"%s\". Please check the XML file around the line number %d", keyword, XML_file_name, temp_full_name, line_number);
-			const char *individual_or_family = detailed_XML_element->Attribute("individual_or_family", &line_number);
-			int value_individual_or_family = 1;
-			if (individual_or_family != NULL) {
-				EXECUTION_REPORT(REPORT_ERROR, comp_id, words_are_the_same(individual_or_family, "individual") || words_are_the_same(individual_or_family, "family"), "ERROR happens when calling the API \"CCPL_get_configurable_comps_full_names\": the value of \"individual_or_family\" in the XML file \"%s\" must be \"individual\" or \"family\" (currently is \"%s\"). Please verify the XML file at line %d", XML_file_name, individual_or_family, line_number);
-				if (words_are_the_same(individual_or_family, "family"))
-					value_individual_or_family = 2;
-			}
-			individual_or_family_generation.push_back(value_individual_or_family);
-		}
-	}
-
-	if (all_comp_fullnames_for_coupling_generation.size() > 0) {
-		for (i = 0; i < all_comp_fullnames_for_coupling_generation.size(); i ++)
-			if (words_are_the_same(current_comp_full_name, all_comp_fullnames_for_coupling_generation[i]))
-				break;
-		if (i == all_comp_fullnames_for_coupling_generation.size())
-			all_comp_fullnames_for_coupling_generation.push_back(strdup(current_comp_full_name));
-	}
-	
-	*num_comps = all_comp_fullnames_for_coupling_generation.size();
-
-	EXECUTION_REPORT(REPORT_ERROR, comp_id, size_comps_full_names >= *num_comps, "ERROR happens when calling the API \"CCPL_get_configurable_comps_full_names\" with the keyword \"%s\": the array size (currently is %d) of the input parameter \"comps_full_names\" is smaller than the number of component models (currently is %d) specified in the XML file \"%s\". Please verify the model code with the annotation \"%s\" or the configuration file.", keyword, size_comps_full_names, XML_file_name, *num_comps, annotation);
-	if (size_individual_or_family != -1)
-		EXECUTION_REPORT(REPORT_ERROR, comp_id, size_individual_or_family >= *num_comps, "ERROR happens when calling the API \"CCPL_get_configurable_comps_full_names\" with the keyword \"%s\": the array size (currently is %d) of the input parameter \"individual_or_family\" is smaller than the number of component models (currently is %d) specified in the XML file \"%s\". Please verify the model code with the annotation \"%s\" or the configuration file.", keyword, size_comps_full_names, XML_file_name, *num_comps, annotation);
-	
-	delete XML_file;
+    char XML_file_name[NAME_STR_SIZE];
+    const char *current_comp_full_name = comp_comm_group_mgt_mgr->get_global_node_of_local_comp(comp_id, true, "in Coupling_generator::load_comps_full_names_from_config_file")->get_full_name();
+    const char *temp_full_name;
+    const char *XML_keyword;
+    int line_number, i;
+
+
+    *num_comps = 0;
+    
+    sprintf(XML_file_name, "%s/all/coupling_connections/%s.coupling_connections.xml", comp_comm_group_mgt_mgr->get_config_root_dir(), current_comp_full_name);
+    TiXmlDocument *XML_file = open_XML_file_to_read(comp_id, XML_file_name, comp_comm_group_mgt_mgr->get_comm_group_of_local_comp(comp_id, "in Coupling_generator::load_comps_full_names_from_config_file"), false);
+    if (XML_file == NULL)
+        return;
+    
+    TiXmlElement *root_XML_element, *XML_element, *detailed_XML_element;
+    TiXmlNode *root_XML_element_node = get_XML_first_child_of_unique_root(comp_id, XML_file_name, XML_file), *XML_element_node = NULL, *detailed_XML_element_node = NULL;
+    for (; root_XML_element_node != NULL; root_XML_element_node = root_XML_element_node->NextSibling()) {
+        if (root_XML_element_node->Type() != TiXmlNode::TINYXML_ELEMENT)
+            continue;
+        root_XML_element = root_XML_element_node->ToElement();
+        if (words_are_the_same(root_XML_element->Value(),"component_full_names_sets"))
+            break;
+    }
+    if (root_XML_element_node == NULL)
+        return;
+
+    for (XML_element_node = root_XML_element->FirstChild(); XML_element_node != NULL; XML_element_node = XML_element_node->NextSibling()) {
+        XML_element = XML_element_node->ToElement();
+        if (!is_XML_setting_on(comp_id, XML_element, XML_file_name, "the status for the full names of a set of component models", "the coupling connection configuration file"))
+            continue;
+        XML_keyword = get_XML_attribute(comp_id, -1, XML_element, "keyword", XML_file_name, line_number, "the keyword of the set of component models' full names", "the coupling connection configuration file", true);
+        if (words_are_the_same(keyword, XML_keyword))
+            break;
+    }    
+    if (XML_element_node == NULL)
+        return;
+
+    for (detailed_XML_element_node = XML_element->FirstChild(); detailed_XML_element_node != NULL; detailed_XML_element_node = detailed_XML_element_node->NextSibling()) {
+        detailed_XML_element = detailed_XML_element_node->ToElement();
+        temp_full_name = get_XML_attribute(comp_id, -1, detailed_XML_element, "comp_full_name", XML_file_name, line_number, "the full name of a component model", "the coupling connection configuration file", true);
+        if (temp_full_name != NULL) {
+            for (i = 0; i < all_comp_fullnames_for_coupling_generation.size(); i ++)
+                if (words_are_the_same(temp_full_name, all_comp_fullnames_for_coupling_generation[i]))
+                    break;            
+            if (i == all_comp_fullnames_for_coupling_generation.size())
+                all_comp_fullnames_for_coupling_generation.push_back(strdup(temp_full_name));
+            else EXECUTION_REPORT(REPORT_ERROR, comp_id, false, "ERROR happens when calling the API \"CCPL_get_configurable_comps_full_names\": when loading the set of component models corresponding to the keyword \"%s\" from the XML file \"%s\", there are more than one entry of the component model \"%s\". Please check the XML file around the line number %d", keyword, XML_file_name, temp_full_name, line_number);
+            const char *individual_or_family = detailed_XML_element->Attribute("individual_or_family", &line_number);
+            int value_individual_or_family = 1;
+            if (individual_or_family != NULL) {
+                EXECUTION_REPORT(REPORT_ERROR, comp_id, words_are_the_same(individual_or_family, "individual") || words_are_the_same(individual_or_family, "family"), "ERROR happens when calling the API \"CCPL_get_configurable_comps_full_names\": the value of \"individual_or_family\" in the XML file \"%s\" must be \"individual\" or \"family\" (currently is \"%s\"). Please verify the XML file at line %d", XML_file_name, individual_or_family, line_number);
+                if (words_are_the_same(individual_or_family, "family"))
+                    value_individual_or_family = 2;
+            }
+            individual_or_family_generation.push_back(value_individual_or_family);
+        }
+    }
+
+    if (all_comp_fullnames_for_coupling_generation.size() > 0) {
+        for (i = 0; i < all_comp_fullnames_for_coupling_generation.size(); i ++)
+            if (words_are_the_same(current_comp_full_name, all_comp_fullnames_for_coupling_generation[i]))
+                break;
+        if (i == all_comp_fullnames_for_coupling_generation.size())
+            all_comp_fullnames_for_coupling_generation.push_back(strdup(current_comp_full_name));
+    }
+    
+    *num_comps = all_comp_fullnames_for_coupling_generation.size();
+
+    EXECUTION_REPORT(REPORT_ERROR, comp_id, size_comps_full_names >= *num_comps, "ERROR happens when calling the API \"CCPL_get_configurable_comps_full_names\" with the keyword \"%s\": the array size (currently is %d) of the input parameter \"comps_full_names\" is smaller than the number of component models (currently is %d) specified in the XML file \"%s\". Please verify the model code with the annotation \"%s\" or the configuration file.", keyword, size_comps_full_names, XML_file_name, *num_comps, annotation);
+    if (size_individual_or_family != -1)
+        EXECUTION_REPORT(REPORT_ERROR, comp_id, size_individual_or_family >= *num_comps, "ERROR happens when calling the API \"CCPL_get_configurable_comps_full_names\" with the keyword \"%s\": the array size (currently is %d) of the input parameter \"individual_or_family\" is smaller than the number of component models (currently is %d) specified in the XML file \"%s\". Please verify the model code with the annotation \"%s\" or the configuration file.", keyword, size_comps_full_names, XML_file_name, *num_comps, annotation);
+    
+    delete XML_file;
 }
 
 
 void Coupling_generator::get_one_comp_full_name(int comp_id, const char *keyword, int str_size, int index, char *comp_full_name, int *local_individual_or_family, const char *annotation)
 {
-	char XML_file_name[NAME_STR_SIZE];
+    char XML_file_name[NAME_STR_SIZE];
 
 
-	sprintf(XML_file_name, "%s/all/coupling_connections/%s.coupling_connections.xml", comp_comm_group_mgt_mgr->get_config_root_dir(), comp_comm_group_mgt_mgr->get_global_node_of_local_comp(comp_id, true, "in Coupling_generator::load_comps_full_names_from_config_file")->get_full_name());
-	EXECUTION_REPORT(REPORT_ERROR, comp_id, str_size >= strlen(all_comp_fullnames_for_coupling_generation[index]), "Error happens when calling the API \"CCPL_get_configurable_comps_full_names\" with the keyword \"%s\": the string length (currently is %d) of the input parameter \"comps_full_names\" is smaller than the length (currently is %d) of the full name of a component model (\"%s\") that is loaded from the XML file \"%s\". Please verify the model code with the annotation \"%s\".", keyword, str_size, strlen(all_comp_fullnames_for_coupling_generation[index]), all_comp_fullnames_for_coupling_generation[index], XML_file_name, annotation);
-	strncpy(comp_full_name, all_comp_fullnames_for_coupling_generation[index], strlen(all_comp_fullnames_for_coupling_generation[index]));
-	*local_individual_or_family = individual_or_family_generation[index];
-	for (int i = strlen(all_comp_fullnames_for_coupling_generation[index]); i < str_size; i ++)
-		comp_full_name[i] = ' ';
+    sprintf(XML_file_name, "%s/all/coupling_connections/%s.coupling_connections.xml", comp_comm_group_mgt_mgr->get_config_root_dir(), comp_comm_group_mgt_mgr->get_global_node_of_local_comp(comp_id, true, "in Coupling_generator::load_comps_full_names_from_config_file")->get_full_name());
+    EXECUTION_REPORT(REPORT_ERROR, comp_id, str_size >= strlen(all_comp_fullnames_for_coupling_generation[index]), "Error happens when calling the API \"CCPL_get_configurable_comps_full_names\" with the keyword \"%s\": the string length (currently is %d) of the input parameter \"comps_full_names\" is smaller than the length (currently is %d) of the full name of a component model (\"%s\") that is loaded from the XML file \"%s\". Please verify the model code with the annotation \"%s\".", keyword, str_size, strlen(all_comp_fullnames_for_coupling_generation[index]), all_comp_fullnames_for_coupling_generation[index], XML_file_name, annotation);
+    strncpy(comp_full_name, all_comp_fullnames_for_coupling_generation[index], strlen(all_comp_fullnames_for_coupling_generation[index]));
+    *local_individual_or_family = individual_or_family_generation[index];
+    for (int i = strlen(all_comp_fullnames_for_coupling_generation[index]); i < str_size; i ++)
+        comp_full_name[i] = ' ';
 }
 
diff --git a/src/Runtime_MGT/coupling_generator.h b/src/Runtime_MGT/coupling_generator.h
old mode 100644
new mode 100755
index b8f9ead..8c1f0f8
--- a/src/Runtime_MGT/coupling_generator.h
+++ b/src/Runtime_MGT/coupling_generator.h
@@ -33,174 +33,174 @@ class IO_output_procedure;
 
 struct Interface_field_info
 {
-	char grid_name[NAME_STR_SIZE];
-	char data_type[NAME_STR_SIZE];
+    char grid_name[NAME_STR_SIZE];
+    char data_type[NAME_STR_SIZE];
     char decomp_name[NAME_STR_SIZE];
-	char unit[NAME_STR_SIZE];
-	Runtime_remapping_weights *runtime_remapping_weights;
-	int bottom_field_indx;
+    char unit[NAME_STR_SIZE];
+    Runtime_remapping_weights *runtime_remapping_weights;
+    int bottom_field_indx;
 };
 
 
 struct V3D_grid_bottom_field_coupling_info
 {
-	Field_mem_info *bottom_field_inst;
-	Runtime_remapping_weights *V3D_runtime_remapping_weights;
-	Runtime_remapping_weights *H2D_runtime_remapping_weights;
-	int field_connection_indx;
-	bool is_dynamic_bottom_field;
+    Field_mem_info *bottom_field_inst;
+    Runtime_remapping_weights *V3D_runtime_remapping_weights;
+    Runtime_remapping_weights *H2D_runtime_remapping_weights;
+    int field_connection_indx;
+    bool is_dynamic_bottom_field;
 };
 
 
 class Coupling_connection
 {
-	private:
-		friend class Coupling_generator;
-		friend class Connection_coupling_procedure;
-		friend class IO_output_procedure;
-		friend class Inout_interface;
-		friend class Inout_interface_mgt;
-		int connection_id;
-		std::vector<const char*> fields_name;
-		std::vector<std::pair<const char*, const char*> > src_comp_interfaces;
-		char dst_comp_full_name[NAME_STR_SIZE];
-		char dst_interface_name[NAME_STR_SIZE];
-		std::vector<Interface_field_info*> src_fields_info;
-		std::vector<Interface_field_info*> dst_fields_info;
-		std::vector<V3D_grid_bottom_field_coupling_info*> src_bottom_fields_coupling_info; 
-		std::vector<V3D_grid_bottom_field_coupling_info*> dst_bottom_fields_coupling_info;
-		Inout_interface *import_interface;
-		Inout_interface *export_interface;
-		Coupling_timer *src_timer;
-		Coupling_timer *dst_timer;
-		int src_time_step_in_second;
-		int dst_time_step_in_second;
-		int src_inst_or_aver;
-	    int dst_inst_or_aver;
-		int src_current_year, src_current_month, src_current_day, src_current_second;
-		int dst_current_year, dst_current_month, dst_current_day, dst_current_second;
-		Connection_coupling_procedure *import_procedure;
-		Connection_coupling_procedure *export_procedure;
-		Comp_comm_group_mgt_node *src_comp_node;
-		Comp_comm_group_mgt_node *dst_comp_node;
-		int current_proc_id_src_comp;
-		int	current_proc_id_dst_comp;
-		int src_comp_root_proc_global_id;
-		int dst_comp_root_proc_global_id;
+    private:
+        friend class Coupling_generator;
+        friend class Connection_coupling_procedure;
+        friend class IO_output_procedure;
+        friend class Inout_interface;
+        friend class Inout_interface_mgt;
+        int connection_id;
+        std::vector<const char*> fields_name;
+        std::vector<std::pair<const char*, const char*> > src_comp_interfaces;
+        char dst_comp_full_name[NAME_STR_SIZE];
+        char dst_interface_name[NAME_STR_SIZE];
+        std::vector<Interface_field_info*> src_fields_info;
+        std::vector<Interface_field_info*> dst_fields_info;
+        std::vector<V3D_grid_bottom_field_coupling_info*> src_bottom_fields_coupling_info; 
+        std::vector<V3D_grid_bottom_field_coupling_info*> dst_bottom_fields_coupling_info;
+        Inout_interface *import_interface;
+        Inout_interface *export_interface;
+        Coupling_timer *src_timer;
+        Coupling_timer *dst_timer;
+        int src_time_step_in_second;
+        int dst_time_step_in_second;
+        int src_inst_or_aver;
+        int dst_inst_or_aver;
+        int src_current_year, src_current_month, src_current_day, src_current_second;
+        int dst_current_year, dst_current_month, dst_current_day, dst_current_second;
+        Connection_coupling_procedure *import_procedure;
+        Connection_coupling_procedure *export_procedure;
+        Comp_comm_group_mgt_node *src_comp_node;
+        Comp_comm_group_mgt_node *dst_comp_node;
+        int current_proc_id_src_comp;
+        int    current_proc_id_dst_comp;
+        int src_comp_root_proc_global_id;
+        int dst_comp_root_proc_global_id;
         MPI_Comm union_comm;
         int * src_proc_ranks_in_union_comm;
         int * dst_proc_ranks_in_union_comm;
 
-		void write_field_info_into_array(Field_mem_info *, char **, long &, long &);
-		void write_connection_fields_info_into_array(Inout_interface *, char **, long &, long &, Coupling_timer**, int&, int&, int&, int&, int&, int&);	
-		void read_fields_info_from_array(std::vector<Interface_field_info*> &, const char*, long);
-		void read_connection_fields_info_from_array(std::vector<Interface_field_info*>&, const char *, long, int, Coupling_timer **, int&, int&, int&, int&, int&, int&);
-		void exchange_connection_fields_info();
-		void exchange_bottom_fields_info();
-		void generate_interpolation(bool);
-		bool exchange_grid(Comp_comm_group_mgt_node *, Comp_comm_group_mgt_node *, const char *);
-		void exchange_remapping_setting(int, Remapping_setting &);
-		void add_bottom_field_coupling_info(int, Runtime_remapping_weights*, Remapping_setting *);
-		void generate_src_bottom_field_coupling_info();
-
-	public:
-		Coupling_connection(int);
-		~Coupling_connection();
-		void generate_a_coupling_procedure(bool);
+        void write_field_info_into_array(Field_mem_info *, char **, long &, long &);
+        void write_connection_fields_info_into_array(Inout_interface *, char **, long &, long &, Coupling_timer**, int&, int&, int&, int&, int&, int&);    
+        void read_fields_info_from_array(std::vector<Interface_field_info*> &, const char*, long);
+        void read_connection_fields_info_from_array(std::vector<Interface_field_info*>&, const char *, long, int, Coupling_timer **, int&, int&, int&, int&, int&, int&);
+        void exchange_connection_fields_info();
+        void exchange_bottom_fields_info();
+        void generate_interpolation(bool);
+        bool exchange_grid(Comp_comm_group_mgt_node *, Comp_comm_group_mgt_node *, const char *);
+        void exchange_remapping_setting(int, Remapping_setting &);
+        void add_bottom_field_coupling_info(int, Runtime_remapping_weights*, Remapping_setting *);
+        void generate_src_bottom_field_coupling_info();
+
+    public:
+        Coupling_connection(int);
+        ~Coupling_connection();
+        void generate_a_coupling_procedure(bool);
         void create_union_comm();
-		void generate_data_transfer();
-		Field_mem_info *get_bottom_field(bool, int);
-		bool get_is_bottom_field_dynamic(int);
-		const char *get_dst_comp_full_name() { return dst_comp_full_name; }
-		const char *get_dst_interface_name() { return dst_interface_name; }
-		const char *get_src_comp_full_name() { return src_comp_interfaces[0].first; }
+        void generate_data_transfer();
+        Field_mem_info *get_bottom_field(bool, int);
+        bool get_is_bottom_field_dynamic(int);
+        const char *get_dst_comp_full_name() { return dst_comp_full_name; }
+        const char *get_dst_interface_name() { return dst_interface_name; }
+        const char *get_src_comp_full_name() { return src_comp_interfaces[0].first; }
 };
 
 
 class Import_direction_setting
 {
-	private:
-		char interface_name[NAME_STR_SIZE];
-		int status;                      // 0 means off; 1 means on
-		int fields_default_setting;       // 0 means off; 1 means all; 2 means remain"
-		int components_default_setting;  // 0 means off; 1 means all;
-		std::vector<const char*> fields_name;
-		std::vector<std::pair<const char*, const char*> > producers_info;
-		
-		// ... remapping and merge setting;
-	
-	public:
-		Import_direction_setting(int, Import_interface_configuration *, const char*, const char*, TiXmlElement*, const char*, std::vector<const char*>&, int*, bool);
-		~Import_direction_setting();
+    private:
+        char interface_name[NAME_STR_SIZE];
+        int status;                      // 0 means off; 1 means on
+        int fields_default_setting;       // 0 means off; 1 means all; 2 means remain"
+        int components_default_setting;  // 0 means off; 1 means all;
+        std::vector<const char*> fields_name;
+        std::vector<std::pair<const char*, const char*> > producers_info;
+        
+        // ... remapping and merge setting;
+    
+    public:
+        Import_direction_setting(int, Import_interface_configuration *, const char*, const char*, TiXmlElement*, const char*, std::vector<const char*>&, int*, bool);
+        ~Import_direction_setting();
 };
 
 
 class Import_interface_configuration
 {
-	private:
-		char interface_name[NAME_STR_SIZE];
-		std::vector<Import_direction_setting*> import_directions;
-		std::vector<const char*> fields_name;
-		std::vector<std::vector<std::pair<const char*, const char*> > > fields_src_producers_info;
-
-	public:
-		Import_interface_configuration(int, const char*, const char*, TiXmlElement*, const char*, Inout_interface_mgt *, bool);
-		~Import_interface_configuration();
-		const char *get_interface_name() { return interface_name; }
-		void add_field_src_component(int comp_id, const char*, std::pair<const char*, const char*>);
-		void get_field_import_configuration(const char*, std::vector<std::pair<const char*, const char*> >&);
+    private:
+        char interface_name[NAME_STR_SIZE];
+        std::vector<Import_direction_setting*> import_directions;
+        std::vector<const char*> fields_name;
+        std::vector<std::vector<std::pair<const char*, const char*> > > fields_src_producers_info;
+
+    public:
+        Import_interface_configuration(int, const char*, const char*, TiXmlElement*, const char*, Inout_interface_mgt *, bool);
+        ~Import_interface_configuration();
+        const char *get_interface_name() { return interface_name; }
+        void add_field_src_component(int comp_id, const char*, std::pair<const char*, const char*>);
+        void get_field_import_configuration(const char*, std::vector<std::pair<const char*, const char*> >&);
 };
 
 
 class Component_import_interfaces_configuration
 {
-	private:
-		char comp_full_name[NAME_STR_SIZE];
-		std::vector<Import_interface_configuration*> import_interfaces_configuration;
-
-	public:	
-		Component_import_interfaces_configuration(int, const char *, Inout_interface_mgt *, bool);
-		~Component_import_interfaces_configuration();
-		void get_interface_field_import_configuration(const char*, const char*, std::vector<std::pair<const char*,const char*> >&);
+    private:
+        char comp_full_name[NAME_STR_SIZE];
+        std::vector<Import_interface_configuration*> import_interfaces_configuration;
+
+    public:    
+        Component_import_interfaces_configuration(int, const char *, Inout_interface_mgt *, bool);
+        ~Component_import_interfaces_configuration();
+        void get_interface_field_import_configuration(const char*, const char*, std::vector<std::pair<const char*,const char*> >&);
 };
 
 
 
 class Coupling_generator
 {
-	private:
-		std::map<int,std::vector<std::pair<const char*, const char*> > > export_fields_dst_components;
-		std::vector<const char*> string_in_export_fields_dst_components;
-		std::vector<const char *> all_comp_fullnames_for_coupling_generation;
-		std::vector<int> individual_or_family_generation;  // must be 1 (individual) or 2 (family)
-		Dictionary<int> *import_field_index_lookup_table;
-		Dictionary<int> *export_field_index_lookup_table;
-		std::vector<Coupling_connection*> all_coupling_connections;
+    private:
+        std::map<int,std::vector<std::pair<const char*, const char*> > > export_fields_dst_components;
+        std::vector<const char*> string_in_export_fields_dst_components;
+        std::vector<const char *> all_comp_fullnames_for_coupling_generation;
+        std::vector<int> individual_or_family_generation;  // must be 1 (individual) or 2 (family)
+        Dictionary<int> *import_field_index_lookup_table;
+        Dictionary<int> *export_field_index_lookup_table;
+        std::vector<Coupling_connection*> all_coupling_connections;
         std::vector<Coupling_connection*> all_IO_connections;
-		int latest_connection_id;
-		
-		void generate_interface_fields_source_dst(const char*, int);
-		void generate_components_connections();		
-		void generate_coupling_procedures_common(int, MPI_Comm, bool, const char*);
-		void sort_comp_full_names(std::vector<const char*> &, std::vector<int>*);
-
-	public:
-		Coupling_generator() { latest_connection_id = 1; import_field_index_lookup_table = NULL; export_field_index_lookup_table = NULL; }
-		~Coupling_generator();
-		void clear();
-		void generate_coupling_procedures_internal(int, bool, const char*);
+        int latest_connection_id;
+        
+        void generate_interface_fields_source_dst(const char*, int);
+        void generate_components_connections();        
+        void generate_coupling_procedures_common(int, MPI_Comm, bool, bool, const char*);
+        void sort_comp_full_names(std::vector<const char*> &, std::vector<int>*);
+
+    public:
+        Coupling_generator() { latest_connection_id = 1; import_field_index_lookup_table = NULL; export_field_index_lookup_table = NULL; }
+        ~Coupling_generator();
+        void clear();
+        void generate_coupling_procedures_internal(int, bool, bool, const char*);
         void generate_IO_procedures();
-		int apply_connection_id() {  return (++latest_connection_id); }
-		int get_latest_connection_id() { return latest_connection_id; }
-		void set_latest_connection_id(int connection_id) { latest_connection_id = connection_id; }
-		void synchronize_latest_connection_id(MPI_Comm);
-		void transfer_interfaces_info_from_one_component_to_another(std::vector<Inout_interface*> &, Comp_comm_group_mgt_node *, Comp_comm_group_mgt_node *);
-		void begin_external_coupling_generation();
-		void add_comp_for_external_coupling_generation(const char *, int, const char*);
-		void do_external_coupling_generation(int, const char*);
-		void load_comps_full_names_from_config_file(int, const char *, int, int, int *, const char *);
-		void get_one_comp_full_name(int, const char*, int, int, char *, int *, const char *);
-		void do_overall_coupling_generation(const char*, const char *);
+        int apply_connection_id() {  return (++latest_connection_id); }
+        int get_latest_connection_id() { return latest_connection_id; }
+        void set_latest_connection_id(int connection_id) { latest_connection_id = connection_id; }
+        void synchronize_latest_connection_id(MPI_Comm);
+        void transfer_interfaces_info_from_one_component_to_another(std::vector<Inout_interface*> &, Comp_comm_group_mgt_node *, Comp_comm_group_mgt_node *);
+        void begin_external_coupling_generation();
+        void add_comp_for_external_coupling_generation(const char *, int, const char*);
+        void do_external_coupling_generation(int, const char*);
+        void load_comps_full_names_from_config_file(int, const char *, int, int, int *, const char *);
+        void get_one_comp_full_name(int, const char*, int, int, char *, int *, const char *);
+        void do_overall_coupling_generation(const char*, const char *);
 };
 
 
diff --git a/src/Runtime_MGT/ensemble_mgt.cxx b/src/Runtime_MGT/ensemble_mgt.cxx
old mode 100644
new mode 100755
index 32fdd5f..0fe4ad2
--- a/src/Runtime_MGT/ensemble_mgt.cxx
+++ b/src/Runtime_MGT/ensemble_mgt.cxx
@@ -14,163 +14,163 @@
 
 Ensemble_mgt::Ensemble_mgt()
 {
-	ensemble_member_id = -1;
-	have_random_seed_for_perturbation = -1;
-	root_random_seed_for_perturbation = -1;
-	ensemble_random_seed_for_perturbation = -1;
+    ensemble_member_id = -1;
+    have_random_seed_for_perturbation = -1;
+    root_random_seed_for_perturbation = -1;
+    ensemble_random_seed_for_perturbation = -1;
 }
 
 
 void Ensemble_mgt::Initialize(int ensemble_member_id, int have_random_seed_for_perturbation, int root_random_seed_for_perturbation, const char *perturbation_type)
 {
-	EXECUTION_REPORT(REPORT_ERROR,-1, ensemble_member_id > 0, "The number of an ensemble member must be a positive integer\n");
-	EXECUTION_REPORT_LOG(REPORT_LOG,-1, true, "Ensemble is enabled. The ensemble member id is %d", ensemble_member_id);
-
-	this->ensemble_member_id = ensemble_member_id;
-	this->have_random_seed_for_perturbation = (have_random_seed_for_perturbation == 1);
-	this->root_random_seed_for_perturbation = root_random_seed_for_perturbation;
-	if (have_random_seed_for_perturbation) {
-		if (words_are_the_same("set_last_bit_to_1", perturbation_type))
-			this->perturbation_type_id = 1;
-		else if (words_are_the_same("set_last_bit_to_0", perturbation_type))
-			this->perturbation_type_id = 2;
-		else if (words_are_the_same("reverse_last_bit", perturbation_type))
-			this->perturbation_type_id = 3;
-		else if (words_are_the_same("xor_last_bit_with_a_bit", perturbation_type))
-			this->perturbation_type_id = 4;
-		else EXECUTION_REPORT(REPORT_ERROR,-1, false, "\"%s\" is not a right selection for perturbing the roundoff errors of the registerred fields. Existing selections include set_last_bit_to_1, set_last_bit_to_0, reverse_last_bit and xor_last_bit_with_a_bit", perturbation_type);
-		srand(root_random_seed_for_perturbation);
-		for (int i = 0; i < ensemble_member_id; i ++)
-			this->ensemble_random_seed_for_perturbation = rand();
-		srand(this->ensemble_random_seed_for_perturbation);
-		EXECUTION_REPORT_LOG(REPORT_LOG,-1, true, "In the ensemble experiment of perturbing roundoff errors, for the ensemble member %d, the seed of random number generation is %d", ensemble_member_id, this->ensemble_random_seed_for_perturbation);
-	}
+    EXECUTION_REPORT(REPORT_ERROR,-1, ensemble_member_id > 0, "The number of an ensemble member must be a positive integer\n");
+    EXECUTION_REPORT_LOG(REPORT_LOG,-1, true, "Ensemble is enabled. The ensemble member id is %d", ensemble_member_id);
+
+    this->ensemble_member_id = ensemble_member_id;
+    this->have_random_seed_for_perturbation = (have_random_seed_for_perturbation == 1);
+    this->root_random_seed_for_perturbation = root_random_seed_for_perturbation;
+    if (have_random_seed_for_perturbation) {
+        if (words_are_the_same("set_last_bit_to_1", perturbation_type))
+            this->perturbation_type_id = 1;
+        else if (words_are_the_same("set_last_bit_to_0", perturbation_type))
+            this->perturbation_type_id = 2;
+        else if (words_are_the_same("reverse_last_bit", perturbation_type))
+            this->perturbation_type_id = 3;
+        else if (words_are_the_same("xor_last_bit_with_a_bit", perturbation_type))
+            this->perturbation_type_id = 4;
+        else EXECUTION_REPORT(REPORT_ERROR,-1, false, "\"%s\" is not a right selection for perturbing the roundoff errors of the registered fields. Existing selections include set_last_bit_to_1, set_last_bit_to_0, reverse_last_bit and xor_last_bit_with_a_bit", perturbation_type);
+        srand(root_random_seed_for_perturbation);
+        for (int i = 0; i < ensemble_member_id; i ++)
+            this->ensemble_random_seed_for_perturbation = rand();
+        srand(this->ensemble_random_seed_for_perturbation);
+        EXECUTION_REPORT_LOG(REPORT_LOG,-1, true, "In the ensemble experiment of perturbing roundoff errors, for the ensemble member %d, the seed of random number generation is %d", ensemble_member_id, this->ensemble_random_seed_for_perturbation);
+    }
 }
 
 
 void Ensemble_mgt::register_a_field_for_perturbation(void *data_buf)
 {
-	Field_mem_info *registered_field;
+    Field_mem_info *registered_field;
 
 
-	registered_field = memory_manager->search_field_via_data_buf(data_buf, false);
-	EXECUTION_REPORT(REPORT_ERROR,-1, registered_field != NULL && registered_field->get_is_registered_model_buf(), 
-					 "The field data buffer for perturbing the roundoff errors has not been registerred to C-Coupler before. Please check.");
-	EXECUTION_REPORT(REPORT_ERROR,-1, words_are_the_same(registered_field->get_field_data()->get_grid_data_field()->data_type_in_application, DATA_TYPE_FLOAT) || words_are_the_same(registered_field->get_field_data()->get_grid_data_field()->data_type_in_application, DATA_TYPE_DOUBLE),
-					 "The data type of field %s is not real4 or real8. It cannot be used for perturbing the roundoff errors. Please check.", registered_field->get_field_name());
-	registered_fields_for_perturbation.push_back(registered_field);
+    registered_field = memory_manager->search_field_via_data_buf(data_buf, false);
+    EXECUTION_REPORT(REPORT_ERROR,-1, registered_field != NULL && registered_field->get_is_registered_model_buf(), 
+                     "The field data buffer for perturbing the roundoff errors has not been registered to C-Coupler before. Please check.");
+    EXECUTION_REPORT(REPORT_ERROR,-1, words_are_the_same(registered_field->get_field_data()->get_grid_data_field()->data_type_in_application, DATA_TYPE_FLOAT) || words_are_the_same(registered_field->get_field_data()->get_grid_data_field()->data_type_in_application, DATA_TYPE_DOUBLE),
+                     "The data type of field %s is not real4 or real8. It cannot be used for perturbing the roundoff errors. Please check.", registered_field->get_field_name());
+    registered_fields_for_perturbation.push_back(registered_field);
 }
 
 
 void Ensemble_mgt::perturb_a_field_through_set_last_bit_to_1(void *field_data_buf, const char *data_type, long field_size, int current_random_number)
 {
-	if (words_are_the_same(data_type, DATA_TYPE_FLOAT))
-		for (long i = 0; i < field_size; i ++) 
-			((int*) field_data_buf)[i] = (((int*) field_data_buf)[i] | ((int)1));
-	else if (words_are_the_same(data_type, DATA_TYPE_DOUBLE))
-		for (long i = 0; i < field_size; i ++) 
-			((long*) field_data_buf)[i] = (((long*) field_data_buf)[i] | ((long)1));
-	else EXECUTION_REPORT(REPORT_ERROR,-1, false, "C-Coupler software error in perturb_a_field_through_set_last_bit_to_1");
+    if (words_are_the_same(data_type, DATA_TYPE_FLOAT))
+        for (long i = 0; i < field_size; i ++) 
+            ((int*) field_data_buf)[i] = (((int*) field_data_buf)[i] | ((int)1));
+    else if (words_are_the_same(data_type, DATA_TYPE_DOUBLE))
+        for (long i = 0; i < field_size; i ++) 
+            ((long*) field_data_buf)[i] = (((long*) field_data_buf)[i] | ((long)1));
+    else EXECUTION_REPORT(REPORT_ERROR,-1, false, "C-Coupler software error in perturb_a_field_through_set_last_bit_to_1");
 }
 
 
 void Ensemble_mgt::perturb_a_field_through_set_last_bit_to_0(void *field_data_buf, const char *data_type, long field_size, int current_random_number)
 {
-	if (words_are_the_same(data_type, DATA_TYPE_FLOAT))
-		for (long i = 0; i < field_size; i ++) 
-			((int*) field_data_buf)[i] = (((int*) field_data_buf)[i] & ((int)0xFFFFFFFE));
-	else if (words_are_the_same(data_type, DATA_TYPE_DOUBLE))
-		for (long i = 0; i < field_size; i ++) 
-			((long*) field_data_buf)[i] = (((long*) field_data_buf)[i] & ((long)0xFFFFFFFFFFFFFFFE));
-	else EXECUTION_REPORT(REPORT_ERROR,-1, false, "C-Coupler software error in perturb_a_field_through_set_last_bit_to_0");
+    if (words_are_the_same(data_type, DATA_TYPE_FLOAT))
+        for (long i = 0; i < field_size; i ++) 
+            ((int*) field_data_buf)[i] = (((int*) field_data_buf)[i] & ((int)0xFFFFFFFE));
+    else if (words_are_the_same(data_type, DATA_TYPE_DOUBLE))
+        for (long i = 0; i < field_size; i ++) 
+            ((long*) field_data_buf)[i] = (((long*) field_data_buf)[i] & ((long)0xFFFFFFFFFFFFFFFE));
+    else EXECUTION_REPORT(REPORT_ERROR,-1, false, "C-Coupler software error in perturb_a_field_through_set_last_bit_to_0");
 }
 
 
 void Ensemble_mgt::perturb_a_field_through_reverse_last_bit(void *field_data_buf, const char *data_type, long field_size, int current_random_number)
 {
-	if (words_are_the_same(data_type, DATA_TYPE_FLOAT))
-		for (long i = 0; i < field_size; i ++)
-			((int*) field_data_buf)[i] = ((int*) field_data_buf)[i] ^ ((int)1);
-	else if (words_are_the_same(data_type, DATA_TYPE_DOUBLE))
-		for (long i = 0; i < field_size; i ++) 
-			((long*) field_data_buf)[i] = ((long*) field_data_buf)[i] ^ ((long)1);
-	else EXECUTION_REPORT(REPORT_ERROR,-1, false, "C-Coupler software error in perturb_a_field_through_reverse_last_bit");
+    if (words_are_the_same(data_type, DATA_TYPE_FLOAT))
+        for (long i = 0; i < field_size; i ++)
+            ((int*) field_data_buf)[i] = ((int*) field_data_buf)[i] ^ ((int)1);
+    else if (words_are_the_same(data_type, DATA_TYPE_DOUBLE))
+        for (long i = 0; i < field_size; i ++) 
+            ((long*) field_data_buf)[i] = ((long*) field_data_buf)[i] ^ ((long)1);
+    else EXECUTION_REPORT(REPORT_ERROR,-1, false, "C-Coupler software error in perturb_a_field_through_reverse_last_bit");
 }
 
 
 void Ensemble_mgt::perturb_a_field_through_xor_last_bit_with_a_bit(void *field_data_buf, const char *data_type, long field_size, int current_random_number)
-{	
-	if (words_are_the_same(data_type, DATA_TYPE_FLOAT)) {
-		unsigned int number_perturbing_bit = (((unsigned int) current_random_number) >> 1)%32;
-		unsigned int perturbing_bitmap = (((unsigned int)1) << number_perturbing_bit);
-		for (long i = 0; i < field_size; i ++) {
-			unsigned int perturbing_bit_value = ((((unsigned int*)field_data_buf)[i] & perturbing_bitmap) >> number_perturbing_bit);
-			if (!(perturbing_bit_value == 0 || perturbing_bit_value == 1))
-				EXECUTION_REPORT(REPORT_ERROR,-1, false, "C-Coupler software error1 in perturb_a_field_through_xor_last_bit_with_a_bit");
-			((unsigned int*) field_data_buf)[i] = ((unsigned int*) field_data_buf)[i] ^ perturbing_bit_value;
-		}
-	}
-	else if (words_are_the_same(data_type, DATA_TYPE_DOUBLE)) {
-		unsigned int number_perturbing_bit = (((unsigned int) current_random_number) >> 1)%64;
-		unsigned long perturbing_bitmap = (((unsigned long)1) << number_perturbing_bit);
-		for (long i = 0; i < field_size; i ++) {
-			unsigned long perturbing_bit_value = ((((unsigned long*)field_data_buf)[i] & perturbing_bitmap) >> number_perturbing_bit);
-			if (!(perturbing_bit_value == 0 || perturbing_bit_value == 1))
-				EXECUTION_REPORT(REPORT_ERROR,-1, false, "C-Coupler software error2 in perturb_a_field_through_xor_last_bit_with_a_bit");
-			((unsigned long*) field_data_buf)[i] = ((unsigned long*) field_data_buf)[i] ^ perturbing_bit_value;
-		}
-	}
-	else EXECUTION_REPORT(REPORT_ERROR,-1, false, "C-Coupler software error3 in perturb_a_field_through_xor_last_bit_with_a_bit");
+{    
+    if (words_are_the_same(data_type, DATA_TYPE_FLOAT)) {
+        unsigned int number_perturbing_bit = (((unsigned int) current_random_number) >> 1)%32;
+        unsigned int perturbing_bitmap = (((unsigned int)1) << number_perturbing_bit);
+        for (long i = 0; i < field_size; i ++) {
+            unsigned int perturbing_bit_value = ((((unsigned int*)field_data_buf)[i] & perturbing_bitmap) >> number_perturbing_bit);
+            if (!(perturbing_bit_value == 0 || perturbing_bit_value == 1))
+                EXECUTION_REPORT(REPORT_ERROR,-1, false, "C-Coupler software error1 in perturb_a_field_through_xor_last_bit_with_a_bit");
+            ((unsigned int*) field_data_buf)[i] = ((unsigned int*) field_data_buf)[i] ^ perturbing_bit_value;
+        }
+    }
+    else if (words_are_the_same(data_type, DATA_TYPE_DOUBLE)) {
+        unsigned int number_perturbing_bit = (((unsigned int) current_random_number) >> 1)%64;
+        unsigned long perturbing_bitmap = (((unsigned long)1) << number_perturbing_bit);
+        for (long i = 0; i < field_size; i ++) {
+            unsigned long perturbing_bit_value = ((((unsigned long*)field_data_buf)[i] & perturbing_bitmap) >> number_perturbing_bit);
+            if (!(perturbing_bit_value == 0 || perturbing_bit_value == 1))
+                EXECUTION_REPORT(REPORT_ERROR,-1, false, "C-Coupler software error2 in perturb_a_field_through_xor_last_bit_with_a_bit");
+            ((unsigned long*) field_data_buf)[i] = ((unsigned long*) field_data_buf)[i] ^ perturbing_bit_value;
+        }
+    }
+    else EXECUTION_REPORT(REPORT_ERROR,-1, false, "C-Coupler software error3 in perturb_a_field_through_xor_last_bit_with_a_bit");
 }
 
 
 void Ensemble_mgt::perturb_an_array(void *field_data_buf, const char *data_type, long field_size, int current_random_number)
 {
-	if (perturbation_type_id == 1)
-		perturb_a_field_through_set_last_bit_to_1(field_data_buf, data_type, field_size, current_random_number);
-	else if (perturbation_type_id == 2)
-		perturb_a_field_through_set_last_bit_to_0(field_data_buf, data_type, field_size, current_random_number);
-	else if (perturbation_type_id == 3)
-		perturb_a_field_through_reverse_last_bit(field_data_buf, data_type, field_size, current_random_number);
-	else if (perturbation_type_id == 4)
-		perturb_a_field_through_xor_last_bit_with_a_bit(field_data_buf, data_type, field_size, current_random_number);
-	else EXECUTION_REPORT(REPORT_ERROR,-1, false, "C-Coupler software error in Ensemble_mgt::run");
+    if (perturbation_type_id == 1)
+        perturb_a_field_through_set_last_bit_to_1(field_data_buf, data_type, field_size, current_random_number);
+    else if (perturbation_type_id == 2)
+        perturb_a_field_through_set_last_bit_to_0(field_data_buf, data_type, field_size, current_random_number);
+    else if (perturbation_type_id == 3)
+        perturb_a_field_through_reverse_last_bit(field_data_buf, data_type, field_size, current_random_number);
+    else if (perturbation_type_id == 4)
+        perturb_a_field_through_xor_last_bit_with_a_bit(field_data_buf, data_type, field_size, current_random_number);
+    else EXECUTION_REPORT(REPORT_ERROR,-1, false, "C-Coupler software error in Ensemble_mgt::run");
 }
 
 
 void Ensemble_mgt::perturb_a_model_array(void *field_data_buf, const char *data_type, long field_size)
 {
-	int current_random_number;
+    int current_random_number;
 
-	
-	if (ensemble_member_id <= 0 || !have_random_seed_for_perturbation)
-		return;
+    
+    if (ensemble_member_id <= 0 || !have_random_seed_for_perturbation)
+        return;
 
-	current_random_number = rand();
-	if ((current_random_number & (0x000000001)) == 0)
-		return;
+    current_random_number = rand();
+    if ((current_random_number & (0x000000001)) == 0)
+        return;
 
-	EXECUTION_REPORT_LOG(REPORT_LOG,-1, true, "Perturb the values of a model array with random roundoff errors");
-	perturb_an_array(field_data_buf, data_type, field_size, current_random_number);
+    EXECUTION_REPORT_LOG(REPORT_LOG,-1, true, "Perturb the values of a model array with random roundoff errors");
+    perturb_an_array(field_data_buf, data_type, field_size, current_random_number);
 }
 
 
 void Ensemble_mgt::run()
 {
-	int current_random_number;
+    int current_random_number;
 
-	
-	if (ensemble_member_id <= 0 || !have_random_seed_for_perturbation || registered_fields_for_perturbation.size() == 0)
-		return;
+    
+    if (ensemble_member_id <= 0 || !have_random_seed_for_perturbation || registered_fields_for_perturbation.size() == 0)
+        return;
 
-	current_random_number = rand();
-	if ((current_random_number & (0x000000001)) == 0)
-		return;
+    current_random_number = rand();
+    if ((current_random_number & (0x000000001)) == 0)
+        return;
 
-	for (int i = 0; i < registered_fields_for_perturbation.size(); i ++) {
-		EXECUTION_REPORT_LOG(REPORT_LOG,-1, true, "Perturb the values of field %s (on grid %s) with random roundoff errors", registered_fields_for_perturbation[i]->get_field_name(), registered_fields_for_perturbation[i]->get_grid_name());
-		perturb_an_array(registered_fields_for_perturbation[i]->get_data_buf(), registered_fields_for_perturbation[i]->get_field_data()->get_grid_data_field()->data_type_in_application,
-						 registered_fields_for_perturbation[i]->get_size_of_field(), current_random_number);
-	}
+    for (int i = 0; i < registered_fields_for_perturbation.size(); i ++) {
+        EXECUTION_REPORT_LOG(REPORT_LOG,-1, true, "Perturb the values of field %s (on grid %s) with random roundoff errors", registered_fields_for_perturbation[i]->get_field_name(), registered_fields_for_perturbation[i]->get_grid_name());
+        perturb_an_array(registered_fields_for_perturbation[i]->get_data_buf(), registered_fields_for_perturbation[i]->get_field_data()->get_grid_data_field()->data_type_in_application,
+                         registered_fields_for_perturbation[i]->get_size_of_field(), current_random_number);
+    }
 }
 
diff --git a/src/Runtime_MGT/ensemble_mgt.h b/src/Runtime_MGT/ensemble_mgt.h
old mode 100644
new mode 100755
index 50c4862..0b4479d
--- a/src/Runtime_MGT/ensemble_mgt.h
+++ b/src/Runtime_MGT/ensemble_mgt.h
@@ -17,28 +17,28 @@
 
 class Ensemble_mgt
 {
-	private:
-		int ensemble_member_id;
-		bool have_random_seed_for_perturbation;
-		int root_random_seed_for_perturbation;
-		int ensemble_random_seed_for_perturbation;
-		int perturbation_type_id;
-		std::vector<Field_mem_info *> registered_fields_for_perturbation;
-		
-		void perturb_a_field_through_set_last_bit_to_1(void*, const char*, long, int);
-		void perturb_a_field_through_set_last_bit_to_0(void*, const char*, long, int);
-		void perturb_a_field_through_reverse_last_bit(void*, const char*, long, int);
-		void perturb_a_field_through_xor_last_bit_with_a_bit(void*, const char*, long, int);
-		void perturb_an_array(void*, const char*, long, int);
-
-	public:
-		Ensemble_mgt();
-		void Initialize(int, int, int, const char*);
-		~Ensemble_mgt() {}
-		void register_a_field_for_perturbation(void *);
-		void perturb_fields_with_roundoff_errors();
-		void perturb_a_model_array(void*, const char*, long);
-		void run();
+    private:
+        int ensemble_member_id;
+        bool have_random_seed_for_perturbation;
+        int root_random_seed_for_perturbation;
+        int ensemble_random_seed_for_perturbation;
+        int perturbation_type_id;
+        std::vector<Field_mem_info *> registered_fields_for_perturbation;
+        
+        void perturb_a_field_through_set_last_bit_to_1(void*, const char*, long, int);
+        void perturb_a_field_through_set_last_bit_to_0(void*, const char*, long, int);
+        void perturb_a_field_through_reverse_last_bit(void*, const char*, long, int);
+        void perturb_a_field_through_xor_last_bit_with_a_bit(void*, const char*, long, int);
+        void perturb_an_array(void*, const char*, long, int);
+
+    public:
+        Ensemble_mgt();
+        void Initialize(int, int, int, const char*);
+        ~Ensemble_mgt() {}
+        void register_a_field_for_perturbation(void *);
+        void perturb_fields_with_roundoff_errors();
+        void perturb_a_model_array(void*, const char*, long);
+        void run();
 };
 
 
diff --git a/src/Runtime_MGT/inout_interface_mgt.cxx b/src/Runtime_MGT/inout_interface_mgt.cxx
old mode 100644
new mode 100755
index cdd23f8..c56bd53
--- a/src/Runtime_MGT/inout_interface_mgt.cxx
+++ b/src/Runtime_MGT/inout_interface_mgt.cxx
@@ -20,1225 +20,1274 @@
 
 Connection_field_time_info::Connection_field_time_info(Inout_interface *inout_interface, Coupling_timer *timer, int time_step_in_second, int current_year, int current_month, int current_day, int current_second, int inst_or_aver)
 {
-	this->inout_interface = inout_interface;
-	this->timer = timer;
-	this->inst_or_aver = inst_or_aver;
-	if (IS_TIME_UNIT_SECOND(timer->get_frequency_unit()))
-		lag_seconds = timer->get_remote_lag_count();
-	else lag_seconds = timer->get_remote_lag_count() * SECONDS_PER_DAY;
-
-	if (!(components_time_mgrs->get_time_mgr(inout_interface->get_comp_id())->get_runtype_mark() == RUNTYPE_MARK_CONTINUE || components_time_mgrs->get_time_mgr(inout_interface->get_comp_id())->get_runtype_mark() == RUNTYPE_MARK_BRANCH)) {
-		this->current_year = current_year;
-		this->current_month = current_month;
-		this->current_day = current_day;
-		this->current_second = current_second;
-		current_num_elapsed_days = components_time_mgrs->get_time_mgr(inout_interface->get_comp_id())->get_current_num_elapsed_day();
-		this->time_step_in_second = time_step_in_second;
-		if (components_time_mgrs->get_time_mgr(inout_interface->get_comp_id())->is_timer_on(timer->get_frequency_unit(), timer->get_frequency_count(), timer->get_local_lag_count())) {
-			last_timer_num_elapsed_days = current_num_elapsed_days;
-			last_timer_second = current_second;
-		}
-		else {
-			last_timer_num_elapsed_days = -1;
-			last_timer_second = -1;
-		}
-		next_timer_num_elapsed_days = -1;
-		next_timer_second = -1;
-		timer->get_time_of_next_timer_on(components_time_mgrs->get_time_mgr(inout_interface->get_comp_id()), current_year, current_month, current_day,
-			                             current_second, current_num_elapsed_days, time_step_in_second, next_timer_num_elapsed_days, next_timer_second, true);
-	}
+    this->inout_interface = inout_interface;
+    this->timer = timer;
+    this->inst_or_aver = inst_or_aver;
+    if (IS_TIME_UNIT_SECOND(timer->get_frequency_unit()))
+        lag_seconds = timer->get_remote_lag_count();
+    else lag_seconds = timer->get_remote_lag_count() * SECONDS_PER_DAY;
+
+    if (!(components_time_mgrs->get_time_mgr(inout_interface->get_comp_id())->get_runtype_mark() == RUNTYPE_MARK_CONTINUE || components_time_mgrs->get_time_mgr(inout_interface->get_comp_id())->get_runtype_mark() == RUNTYPE_MARK_BRANCH)) {
+        this->current_year = current_year;
+        this->current_month = current_month;
+        this->current_day = current_day;
+        this->current_second = current_second;
+        current_num_elapsed_days = components_time_mgrs->get_time_mgr(inout_interface->get_comp_id())->get_current_num_elapsed_day();
+        this->time_step_in_second = time_step_in_second;
+        if (components_time_mgrs->get_time_mgr(inout_interface->get_comp_id())->is_timer_on(timer->get_frequency_unit(), timer->get_frequency_count(), timer->get_local_lag_count())) {
+            last_timer_num_elapsed_days = current_num_elapsed_days;
+			last_timer_date = current_year*10000 + current_month*100 + current_day;
+            last_timer_second = current_second;
+        }
+        else {
+            last_timer_num_elapsed_days = -1;
+			last_timer_date = -1;
+            last_timer_second = -1;
+        }
+        next_timer_num_elapsed_days = -1;
+		next_timer_date = -1;
+        next_timer_second = -1;
+        timer->get_time_of_next_timer_on(components_time_mgrs->get_time_mgr(inout_interface->get_comp_id()), current_year, current_month, current_day,
+                                         current_second, current_num_elapsed_days, time_step_in_second, next_timer_num_elapsed_days, next_timer_date, next_timer_second, true);
+    }
 }
 
 
 void Connection_field_time_info::get_time_of_next_timer_on(bool advance)
 {
-	timer->get_time_of_next_timer_on(components_time_mgrs->get_time_mgr(inout_interface->get_comp_id()), current_year, current_month, current_day,
-		                             current_second, current_num_elapsed_days, time_step_in_second, next_timer_num_elapsed_days, next_timer_second, advance);
+    timer->get_time_of_next_timer_on(components_time_mgrs->get_time_mgr(inout_interface->get_comp_id()), current_year, current_month, current_day,
+                                     current_second, current_num_elapsed_days, time_step_in_second, next_timer_num_elapsed_days, next_timer_date, next_timer_second, advance);
 }
 
 
 void Connection_field_time_info::write_restart_mgt_info(Restart_buffer_container *restart_buffer)
 {
-	restart_buffer->dump_in_data(&current_year, sizeof(int));
-	restart_buffer->dump_in_data(&current_month, sizeof(int));
-	restart_buffer->dump_in_data(&current_day, sizeof(int));
-	restart_buffer->dump_in_data(&current_second, sizeof(int));
-	restart_buffer->dump_in_data(&current_num_elapsed_days, sizeof(int));
-	restart_buffer->dump_in_data(&last_timer_num_elapsed_days, sizeof(int));
-	restart_buffer->dump_in_data(&last_timer_second, sizeof(int));
-	restart_buffer->dump_in_data(&next_timer_num_elapsed_days, sizeof(int));
-	restart_buffer->dump_in_data(&next_timer_second, sizeof(int));
-	restart_buffer->dump_in_data(&time_step_in_second, sizeof(int));
-	restart_buffer->dump_in_data(&inst_or_aver, sizeof(int));
-	restart_buffer->dump_in_data(&lag_seconds, sizeof(int));
+    restart_buffer->dump_in_data(&current_year, sizeof(int));
+    restart_buffer->dump_in_data(&current_month, sizeof(int));
+    restart_buffer->dump_in_data(&current_day, sizeof(int));
+    restart_buffer->dump_in_data(&current_second, sizeof(int));
+    restart_buffer->dump_in_data(&current_num_elapsed_days, sizeof(int));
+    restart_buffer->dump_in_data(&last_timer_num_elapsed_days, sizeof(int));
+    restart_buffer->dump_in_data(&last_timer_second, sizeof(int));
+    restart_buffer->dump_in_data(&next_timer_num_elapsed_days, sizeof(int));
+    restart_buffer->dump_in_data(&next_timer_second, sizeof(int));
+    restart_buffer->dump_in_data(&time_step_in_second, sizeof(int));
+    restart_buffer->dump_in_data(&inst_or_aver, sizeof(int));
+    restart_buffer->dump_in_data(&lag_seconds, sizeof(int));
 }
 
 
 void Connection_field_time_info::import_restart_data(Restart_buffer_container *restart_buffer)
 {
-	int restart_inst_or_aver;
+    int restart_inst_or_aver;
 
-	
-	restart_buffer->load_restart_data(&lag_seconds, sizeof(int));
-	restart_buffer->load_restart_data(&restart_inst_or_aver, sizeof(int));
-	restart_buffer->load_restart_data(&time_step_in_second, sizeof(int));
-	restart_buffer->load_restart_data(&next_timer_second, sizeof(int));
-	restart_buffer->load_restart_data(&next_timer_num_elapsed_days, sizeof(int));
-	restart_buffer->load_restart_data(&last_timer_second, sizeof(int));
-	restart_buffer->load_restart_data(&last_timer_num_elapsed_days, sizeof(int));
-	restart_buffer->load_restart_data(&current_num_elapsed_days, sizeof(int));
-	restart_buffer->load_restart_data(&current_second, sizeof(int));
-	restart_buffer->load_restart_data(&current_day, sizeof(int));
-	restart_buffer->load_restart_data(&current_month, sizeof(int));
-	restart_buffer->load_restart_data(&current_year, sizeof(int));
+    
+    restart_buffer->load_restart_data(&lag_seconds, sizeof(int));
+    restart_buffer->load_restart_data(&restart_inst_or_aver, sizeof(int));
+    restart_buffer->load_restart_data(&time_step_in_second, sizeof(int));
+    restart_buffer->load_restart_data(&next_timer_second, sizeof(int));
+    restart_buffer->load_restart_data(&next_timer_num_elapsed_days, sizeof(int));
+    restart_buffer->load_restart_data(&last_timer_second, sizeof(int));
+    restart_buffer->load_restart_data(&last_timer_num_elapsed_days, sizeof(int));
+    restart_buffer->load_restart_data(&current_num_elapsed_days, sizeof(int));
+    restart_buffer->load_restart_data(&current_second, sizeof(int));
+    restart_buffer->load_restart_data(&current_day, sizeof(int));
+    restart_buffer->load_restart_data(&current_month, sizeof(int));
+    restart_buffer->load_restart_data(&current_year, sizeof(int));
 
-	EXECUTION_REPORT(REPORT_ERROR, inout_interface->get_comp_id(), inst_or_aver == restart_inst_or_aver, "Error happens when restarting the simulation in a \"continue\" run or a \"branch\" run: the values of \"inst_or aver\" of the coupling interface \"%s\" are not the same with the original value recorded in the restart data file (the original value is %d while the new value used in the restart run is %d)", inout_interface->get_interface_name(), restart_inst_or_aver, inst_or_aver);
+    EXECUTION_REPORT(REPORT_ERROR, inout_interface->get_comp_id(), inst_or_aver == restart_inst_or_aver, "Error happens when restarting the simulation in a \"continue\" run or a \"branch\" run: the values of \"inst_or aver\" of the coupling interface \"%s\" are not the same with the original value recorded in the restart data file (the original value is %d while the new value used in the restart run is %d)", inout_interface->get_interface_name(), restart_inst_or_aver, inst_or_aver);
 }
 
 
 Connection_coupling_procedure::Connection_coupling_procedure(Inout_interface *inout_interface, Coupling_connection *coupling_connection)
 {
-	int field_local_index;
-
-	
-	this->inout_interface = inout_interface;
-	this->coupling_connection = coupling_connection; 
-	coupling_connections_dumped = false;
-	remote_bypass_counter = -1;
-	is_coupling_time_out_of_execution = false;
-	restart_mgr = comp_comm_group_mgt_mgr->search_global_node(inout_interface->get_comp_id())->get_restart_mgr();
-
-	for (int i = 0; i < coupling_connection->fields_name.size(); i ++)
-		for (int j=i+1; j < coupling_connection->fields_name.size(); j ++)
-			EXECUTION_REPORT(REPORT_ERROR, -1, !words_are_the_same(coupling_connection->fields_name[i], coupling_connection->fields_name[j]), 
-			                 "Software error in Connection_coupling_procedure::Connection_coupling_procedure: duplicated field name \"%s\" in a coonection", 
-			                 coupling_connection->fields_name[i]);
-
-	fields_time_info_src = new Connection_field_time_info(inout_interface, coupling_connection->src_timer, coupling_connection->src_time_step_in_second, coupling_connection->src_current_year, coupling_connection->src_current_month, coupling_connection->src_current_day, coupling_connection->src_current_second, -1);
-	fields_time_info_dst = new Connection_field_time_info(inout_interface, coupling_connection->dst_timer, coupling_connection->dst_time_step_in_second, coupling_connection->dst_current_year, coupling_connection->dst_current_month, coupling_connection->dst_current_day, coupling_connection->dst_current_second, coupling_connection->dst_inst_or_aver);
-	if (inout_interface->get_interface_type() == COUPLING_INTERFACE_MARK_IMPORT)
-		fields_time_info_src->reset_last_timer_info();
-	else fields_time_info_dst->reset_last_timer_info();
-
-	for (int i = 0; i < coupling_connection->src_fields_info.size(); i ++) {
-		runtime_inner_averaging_algorithm.push_back(NULL);
-		runtime_inter_averaging_algorithm.push_back(NULL);
-		runtime_remap_algorithms.push_back(NULL);
-		runtime_unit_transform_algorithms.push_back(NULL);
-		runtime_datatype_transform_algorithms.push_back(NULL);
-		if (i < coupling_connection->fields_name.size()) {
-			fields_mem_registered.push_back(inout_interface->search_registered_field_instance(coupling_connection->fields_name[i], field_local_index));
-			field_interface_local_index.push_back(field_local_index);
-		}
-		else {
-			fields_mem_registered.push_back(coupling_connection->get_bottom_field(inout_interface->get_interface_type() == COUPLING_INTERFACE_MARK_EXPORT, i-coupling_connection->fields_name.size()));
-			field_interface_local_index.push_back(-1);
-		}
+    int field_local_index;
+
+    
+    this->inout_interface = inout_interface;
+    this->coupling_connection = coupling_connection; 
+    coupling_connections_dumped = false;
+    remote_bypass_counter = -1;
+	last_receive_sender_time = CCPL_NULL_LONG;
+    is_coupling_time_out_of_execution = false;
+    restart_mgr = comp_comm_group_mgt_mgr->search_global_node(inout_interface->get_comp_id())->get_restart_mgr();
+
+    for (int i = 0; i < coupling_connection->fields_name.size(); i ++)
+        for (int j=i+1; j < coupling_connection->fields_name.size(); j ++)
+            EXECUTION_REPORT(REPORT_ERROR, -1, !words_are_the_same(coupling_connection->fields_name[i], coupling_connection->fields_name[j]), 
+                             "Software error in Connection_coupling_procedure::Connection_coupling_procedure: duplicated field name \"%s\" in a coonection", 
+                             coupling_connection->fields_name[i]);
+
+    fields_time_info_src = new Connection_field_time_info(inout_interface, coupling_connection->src_timer, coupling_connection->src_time_step_in_second, coupling_connection->src_current_year, coupling_connection->src_current_month, coupling_connection->src_current_day, coupling_connection->src_current_second, -1);
+    fields_time_info_dst = new Connection_field_time_info(inout_interface, coupling_connection->dst_timer, coupling_connection->dst_time_step_in_second, coupling_connection->dst_current_year, coupling_connection->dst_current_month, coupling_connection->dst_current_day, coupling_connection->dst_current_second, coupling_connection->dst_inst_or_aver);
+    if (inout_interface->get_interface_type() == COUPLING_INTERFACE_MARK_IMPORT)
+        fields_time_info_src->reset_last_timer_info();
+    else fields_time_info_dst->reset_last_timer_info();
+
+    for (int i = 0; i < coupling_connection->src_fields_info.size(); i ++) {
+        runtime_inner_averaging_algorithm.push_back(NULL);
+        runtime_inter_averaging_algorithm.push_back(NULL);
+        runtime_remap_algorithms.push_back(NULL);
+        runtime_unit_transform_algorithms.push_back(NULL);
+        runtime_datatype_transform_algorithms.push_back(NULL);
+        if (i < coupling_connection->fields_name.size()) {
+            fields_mem_registered.push_back(inout_interface->search_registered_field_instance(coupling_connection->fields_name[i], field_local_index));
+            field_interface_local_index.push_back(field_local_index);
+        }
+        else {
+            fields_mem_registered.push_back(coupling_connection->get_bottom_field(inout_interface->get_interface_type() == COUPLING_INTERFACE_MARK_EXPORT, i-coupling_connection->fields_name.size()));
+            field_interface_local_index.push_back(-1);
+        }
+        current_remote_fields_elapsed_time = -1;
 		current_remote_fields_time = -1;
-		last_remote_fields_time = -1;
-		fields_mem_inner_step_averaged.push_back(NULL);
-		fields_mem_inter_step_averaged.push_back(NULL);
-		if (inout_interface->get_interface_type() == COUPLING_INTERFACE_MARK_EXPORT) {
-			if (fields_time_info_dst->inst_or_aver == USING_AVERAGE_VALUE)
-				fields_mem_inner_step_averaged[i] = memory_manager->alloc_mem(fields_mem_registered[i], BUF_MARK_AVERAGED_INNER, coupling_connection->connection_id, NULL, 
-		                                                                      inout_interface->get_interface_source() == INTERFACE_SOURCE_REGISTER && i < coupling_connection->fields_name.size());
-			else fields_mem_inner_step_averaged[i] = fields_mem_registered[i];
-			if (fields_time_info_dst->inst_or_aver == USING_AVERAGE_VALUE && !(fields_time_info_dst->lag_seconds == 0 && fields_time_info_dst->timer->is_the_same_with(fields_time_info_src->timer)))
-				fields_mem_inter_step_averaged[i] = memory_manager->alloc_mem(fields_mem_registered[i], BUF_MARK_AVERAGED_INTER, coupling_connection->connection_id, NULL, 
-				                                                              inout_interface->get_interface_source() == INTERFACE_SOURCE_REGISTER && i < coupling_connection->fields_name.size());
-			else fields_mem_inter_step_averaged[i] = fields_mem_inner_step_averaged[i];
-		}
-		fields_mem_remapped.push_back(NULL);
-		fields_mem_datatype_transformed.push_back(NULL);
-		fields_mem_unit_transformed.push_back(NULL);
-		fields_mem_transfer.push_back(NULL);
-
-		if (inout_interface->get_interface_type() == COUPLING_INTERFACE_MARK_EXPORT) {
-			if (fields_time_info_dst->inst_or_aver == USING_AVERAGE_VALUE)
-				runtime_inner_averaging_algorithm[i] = new Runtime_cumulate_average_algorithm(this, fields_mem_registered[i], fields_mem_inner_step_averaged[i]);
-			if (fields_mem_inter_step_averaged[i] != fields_mem_inner_step_averaged[i])
-				runtime_inter_averaging_algorithm[i] = new Runtime_cumulate_average_algorithm(this, fields_mem_inner_step_averaged[i], fields_mem_inter_step_averaged[i]);
-		}
-		const char *transfer_data_type = get_data_type_size(coupling_connection->src_fields_info[i]->data_type) <= get_data_type_size(coupling_connection->dst_fields_info[i]->data_type)? 
-			                             coupling_connection->src_fields_info[i]->data_type : coupling_connection->dst_fields_info[i]->data_type;
-		if (inout_interface->get_interface_type() == COUPLING_INTERFACE_MARK_EXPORT) {
-			if (!words_are_the_same(transfer_data_type, coupling_connection->src_fields_info[i]->data_type)) {
-				EXECUTION_REPORT_LOG(REPORT_LOG, inout_interface->get_comp_id(), true, 
-					             "For field %s, add data type transformation at src from %s to %s\n", 
-					             fields_mem_registered[i]->get_field_name(), coupling_connection->src_fields_info[i]->data_type, transfer_data_type);
-				fields_mem_datatype_transformed[i] = memory_manager->alloc_mem(fields_mem_registered[i], BUF_MARK_DATATYPE_TRANS, coupling_connection->connection_id, transfer_data_type, 
-					                                                           inout_interface->get_interface_source() == INTERFACE_SOURCE_REGISTER && i < coupling_connection->fields_name.size());
-				runtime_datatype_transform_algorithms[i] = new Runtime_datatype_transformer(fields_mem_inter_step_averaged[i], fields_mem_datatype_transformed[i]);
-			}	
-		}	
-		if (inout_interface->get_interface_type() == COUPLING_INTERFACE_MARK_IMPORT) {
-			if (coupling_connection->dst_fields_info[i]->runtime_remapping_weights == NULL || coupling_connection->dst_fields_info[i]->runtime_remapping_weights->get_parallel_remapping_weights() == NULL)
-				fields_mem_transfer[i] = memory_manager->alloc_mem(fields_mem_registered[i], BUF_MARK_DATA_TRANSFER, coupling_connection->connection_id, transfer_data_type, 
-				                                                   inout_interface->get_interface_source() == INTERFACE_SOURCE_REGISTER && i < coupling_connection->fields_name.size());
-			else {
-				fields_mem_transfer[i] = memory_manager->alloc_mem(fields_mem_registered[i]->get_field_name(), coupling_connection->dst_fields_info[i]->runtime_remapping_weights->get_src_decomp_info()->get_decomp_id(), 
-					                                               coupling_connection->dst_fields_info[i]->runtime_remapping_weights->get_src_original_grid()->get_grid_id(), BUF_MARK_DATA_TRANSFER^coupling_connection->connection_id, 
-					                                               transfer_data_type, fields_mem_registered[i]->get_unit(), "internal", inout_interface->get_interface_source() == INTERFACE_SOURCE_REGISTER && i < coupling_connection->fields_name.size());
-				fields_mem_remapped[i] = memory_manager->alloc_mem(fields_mem_registered[i]->get_field_name(), fields_mem_registered[i]->get_decomp_id(), fields_mem_registered[i]->get_grid_id(), 
-					                                               BUF_MARK_REMAP_NORMAL^coupling_connection->connection_id, transfer_data_type, fields_mem_registered[i]->get_unit(), "internal", 
-					                                               inout_interface->get_interface_source() == INTERFACE_SOURCE_REGISTER && i < coupling_connection->fields_name.size());
-				runtime_remap_algorithms[i] = new Runtime_remap_algorithm(coupling_connection->dst_fields_info[i]->runtime_remapping_weights, fields_mem_transfer[i], fields_mem_remapped[i], coupling_connection->connection_id);
-			}
-			if (!words_are_the_same(transfer_data_type, coupling_connection->dst_fields_info[i]->data_type)) {
-				EXECUTION_REPORT_LOG(REPORT_LOG, inout_interface->get_comp_id(), true, 
-					             "for field %s, add data type transformation at dst from %s to %s\n", 
-					             fields_mem_registered[i]->get_field_name(), transfer_data_type, coupling_connection->dst_fields_info[i]->data_type);
-				fields_mem_datatype_transformed[i] = memory_manager->alloc_mem(fields_mem_registered[i], BUF_MARK_DATATYPE_TRANS, coupling_connection->connection_id, coupling_connection->dst_fields_info[i]->data_type, 
-					                                                           inout_interface->get_interface_source() == INTERFACE_SOURCE_REGISTER && i < coupling_connection->fields_name.size());
-				if (fields_mem_remapped[i] == NULL)
-					runtime_datatype_transform_algorithms[i] = new Runtime_datatype_transformer(fields_mem_transfer[i], fields_mem_datatype_transformed[i]);
-				else runtime_datatype_transform_algorithms[i] = new Runtime_datatype_transformer(fields_mem_remapped[i], fields_mem_datatype_transformed[i]);
-			}
-		}
-		if (inout_interface->get_interface_type() == COUPLING_INTERFACE_MARK_EXPORT) {
-			if (fields_mem_remapped[i] != NULL)
-				fields_mem_transfer[i] = fields_mem_remapped[i];
-			else if (fields_mem_unit_transformed[i] != NULL)
-				fields_mem_transfer[i] = fields_mem_unit_transformed[i];
-			else if (fields_mem_datatype_transformed[i] != NULL)
-				fields_mem_transfer[i] = fields_mem_datatype_transformed[i];
-			else fields_mem_transfer[i] = fields_mem_inter_step_averaged[i];
-		}
-		else {
-			Field_mem_info *last_field_instance = fields_mem_transfer[i];
-			if (fields_mem_datatype_transformed[i] != NULL)
-				last_field_instance = fields_mem_datatype_transformed[i];
-			else if (fields_mem_remapped[i] != NULL)
-				last_field_instance = fields_mem_remapped[i];
-			else last_field_instance = fields_mem_transfer[i];
-			runtime_inter_averaging_algorithm[i] = new Runtime_cumulate_average_algorithm(this, last_field_instance, fields_mem_registered[i]);
-		}
-	}
-	
-	if (inout_interface->get_interface_type() == COUPLING_INTERFACE_MARK_IMPORT)
-		comp_comm_group_mgt_mgr->get_global_node_of_local_comp(inout_interface->get_comp_id(),false,"Connection_coupling_procedure::Connection_coupling_procedure")->update_min_max_remote_lag_seconds(fields_time_info_dst->lag_seconds);
+        last_remote_fields_time = -1;
+        fields_mem_inner_step_averaged.push_back(NULL);
+        fields_mem_inter_step_averaged.push_back(NULL);
+        if (inout_interface->get_interface_type() == COUPLING_INTERFACE_MARK_EXPORT) {
+            if (fields_time_info_dst->inst_or_aver == USING_AVERAGE_VALUE)
+                fields_mem_inner_step_averaged[i] = memory_manager->alloc_mem(fields_mem_registered[i], BUF_MARK_AVERAGED_INNER, coupling_connection->connection_id, NULL, 
+                                                                              inout_interface->get_interface_source() == INTERFACE_SOURCE_REGISTER && i < coupling_connection->fields_name.size());
+            else fields_mem_inner_step_averaged[i] = fields_mem_registered[i];
+            if (fields_time_info_dst->inst_or_aver == USING_AVERAGE_VALUE && !(fields_time_info_dst->lag_seconds == 0 && fields_time_info_dst->timer->is_the_same_with(fields_time_info_src->timer)))
+                fields_mem_inter_step_averaged[i] = memory_manager->alloc_mem(fields_mem_registered[i], BUF_MARK_AVERAGED_INTER, coupling_connection->connection_id, NULL, 
+                                                                              inout_interface->get_interface_source() == INTERFACE_SOURCE_REGISTER && i < coupling_connection->fields_name.size());
+            else fields_mem_inter_step_averaged[i] = fields_mem_inner_step_averaged[i];
+        }
+        fields_mem_remapped.push_back(NULL);
+        fields_mem_datatype_transformed.push_back(NULL);
+        fields_mem_unit_transformed.push_back(NULL);
+        fields_mem_transfer.push_back(NULL);
+
+        if (inout_interface->get_interface_type() == COUPLING_INTERFACE_MARK_EXPORT) {
+            if (fields_time_info_dst->inst_or_aver == USING_AVERAGE_VALUE)
+                runtime_inner_averaging_algorithm[i] = new Runtime_cumulate_average_algorithm(this, fields_mem_registered[i], fields_mem_inner_step_averaged[i]);
+            if (fields_mem_inter_step_averaged[i] != fields_mem_inner_step_averaged[i])
+                runtime_inter_averaging_algorithm[i] = new Runtime_cumulate_average_algorithm(this, fields_mem_inner_step_averaged[i], fields_mem_inter_step_averaged[i]);
+        }
+        const char *transfer_data_type = get_data_type_size(coupling_connection->src_fields_info[i]->data_type) <= get_data_type_size(coupling_connection->dst_fields_info[i]->data_type)? 
+                                         coupling_connection->src_fields_info[i]->data_type : coupling_connection->dst_fields_info[i]->data_type;
+        if (inout_interface->get_interface_type() == COUPLING_INTERFACE_MARK_EXPORT) {
+            if (!words_are_the_same(transfer_data_type, coupling_connection->src_fields_info[i]->data_type)) {
+                EXECUTION_REPORT_LOG(REPORT_LOG, inout_interface->get_comp_id(), true, 
+                                 "For field %s, add data type transformation at src from %s to %s\n", 
+                                 fields_mem_registered[i]->get_field_name(), coupling_connection->src_fields_info[i]->data_type, transfer_data_type);
+                fields_mem_datatype_transformed[i] = memory_manager->alloc_mem(fields_mem_registered[i], BUF_MARK_DATATYPE_TRANS, coupling_connection->connection_id, transfer_data_type, 
+                                                                               inout_interface->get_interface_source() == INTERFACE_SOURCE_REGISTER && i < coupling_connection->fields_name.size());
+                runtime_datatype_transform_algorithms[i] = new Runtime_datatype_transformer(fields_mem_inter_step_averaged[i], fields_mem_datatype_transformed[i]);
+            }    
+        }    
+        if (inout_interface->get_interface_type() == COUPLING_INTERFACE_MARK_IMPORT) {
+            if (coupling_connection->dst_fields_info[i]->runtime_remapping_weights == NULL || coupling_connection->dst_fields_info[i]->runtime_remapping_weights->get_parallel_remapping_weights() == NULL)
+                fields_mem_transfer[i] = memory_manager->alloc_mem(fields_mem_registered[i], BUF_MARK_DATA_TRANSFER, coupling_connection->connection_id, transfer_data_type, 
+                                                                   inout_interface->get_interface_source() == INTERFACE_SOURCE_REGISTER && i < coupling_connection->fields_name.size());
+            else {
+                fields_mem_transfer[i] = memory_manager->alloc_mem(fields_mem_registered[i]->get_field_name(), coupling_connection->dst_fields_info[i]->runtime_remapping_weights->get_src_decomp_info()->get_decomp_id(), 
+                                                                   coupling_connection->dst_fields_info[i]->runtime_remapping_weights->get_src_original_grid()->get_grid_id(), BUF_MARK_DATA_TRANSFER^coupling_connection->connection_id, 
+                                                                   transfer_data_type, fields_mem_registered[i]->get_unit(), "internal", inout_interface->get_interface_source() == INTERFACE_SOURCE_REGISTER && i < coupling_connection->fields_name.size());
+                fields_mem_remapped[i] = memory_manager->alloc_mem(fields_mem_registered[i]->get_field_name(), fields_mem_registered[i]->get_decomp_id(), fields_mem_registered[i]->get_grid_id(), 
+                                                                   BUF_MARK_REMAP_NORMAL^coupling_connection->connection_id, transfer_data_type, fields_mem_registered[i]->get_unit(), "internal", 
+                                                                   inout_interface->get_interface_source() == INTERFACE_SOURCE_REGISTER && i < coupling_connection->fields_name.size());
+                runtime_remap_algorithms[i] = new Runtime_remap_algorithm(coupling_connection->dst_fields_info[i]->runtime_remapping_weights, fields_mem_transfer[i], fields_mem_remapped[i], coupling_connection->connection_id);
+            }
+            if (!words_are_the_same(transfer_data_type, coupling_connection->dst_fields_info[i]->data_type)) {
+                fields_mem_datatype_transformed[i] = memory_manager->alloc_mem(fields_mem_registered[i], BUF_MARK_DATATYPE_TRANS, coupling_connection->connection_id, coupling_connection->dst_fields_info[i]->data_type, 
+                                                                               inout_interface->get_interface_source() == INTERFACE_SOURCE_REGISTER && i < coupling_connection->fields_name.size());
+                EXECUTION_REPORT_LOG(REPORT_LOG, inout_interface->get_comp_id(), true, 
+                                 "for field %s, add data type transformation at dst from %s to %s: %x %x %x\n", 
+                                 fields_mem_registered[i]->get_field_name(), transfer_data_type, coupling_connection->dst_fields_info[i]->data_type, fields_mem_datatype_transformed[i]->get_grid_id(), fields_mem_registered[i]->get_grid_id(), fields_mem_transfer[i]->get_grid_id());
+                if (fields_mem_remapped[i] == NULL)
+                    runtime_datatype_transform_algorithms[i] = new Runtime_datatype_transformer(fields_mem_transfer[i], fields_mem_datatype_transformed[i]);
+                else runtime_datatype_transform_algorithms[i] = new Runtime_datatype_transformer(fields_mem_remapped[i], fields_mem_datatype_transformed[i]);
+            }
+        }
+        if (inout_interface->get_interface_type() == COUPLING_INTERFACE_MARK_EXPORT) {
+            if (fields_mem_remapped[i] != NULL)
+                fields_mem_transfer[i] = fields_mem_remapped[i];
+            else if (fields_mem_unit_transformed[i] != NULL)
+                fields_mem_transfer[i] = fields_mem_unit_transformed[i];
+            else if (fields_mem_datatype_transformed[i] != NULL)
+                fields_mem_transfer[i] = fields_mem_datatype_transformed[i];
+            else fields_mem_transfer[i] = fields_mem_inter_step_averaged[i];
+        }
+        else {
+            Field_mem_info *last_field_instance = fields_mem_transfer[i];
+            if (fields_mem_datatype_transformed[i] != NULL)
+                last_field_instance = fields_mem_datatype_transformed[i];
+            else if (fields_mem_remapped[i] != NULL)
+                last_field_instance = fields_mem_remapped[i];
+            else last_field_instance = fields_mem_transfer[i];
+            runtime_inter_averaging_algorithm[i] = new Runtime_cumulate_average_algorithm(this, last_field_instance, fields_mem_registered[i]);
+        }
+    }
+    
+    if (inout_interface->get_interface_type() == COUPLING_INTERFACE_MARK_IMPORT)
+        comp_comm_group_mgt_mgr->get_global_node_of_local_comp(inout_interface->get_comp_id(),false,"Connection_coupling_procedure::Connection_coupling_procedure")->update_min_max_remote_lag_seconds(fields_time_info_dst->lag_seconds);
 }
 
 
 Connection_coupling_procedure::~Connection_coupling_procedure()
 {
-	delete fields_time_info_src;
-	delete fields_time_info_dst;
-
-	for (int i = 0; i < runtime_inner_averaging_algorithm.size(); i ++) {
-		if (runtime_inner_averaging_algorithm[i] != NULL)
-			delete runtime_inner_averaging_algorithm[i];
-		if (runtime_inter_averaging_algorithm[i] != NULL)
-			delete runtime_inter_averaging_algorithm[i];
-		if (runtime_remap_algorithms[i] != NULL)
-			delete runtime_remap_algorithms[i];
-		if (runtime_unit_transform_algorithms[i] != NULL)
-			delete runtime_unit_transform_algorithms[i];
-		if (runtime_datatype_transform_algorithms[i] != NULL)
-			delete runtime_datatype_transform_algorithms[i];
-	}
+    delete fields_time_info_src;
+    delete fields_time_info_dst;
+
+    for (int i = 0; i < runtime_inner_averaging_algorithm.size(); i ++) {
+        if (runtime_inner_averaging_algorithm[i] != NULL)
+            delete runtime_inner_averaging_algorithm[i];
+        if (runtime_inter_averaging_algorithm[i] != NULL)
+            delete runtime_inter_averaging_algorithm[i];
+        if (runtime_remap_algorithms[i] != NULL)
+            delete runtime_remap_algorithms[i];
+        if (runtime_unit_transform_algorithms[i] != NULL)
+            delete runtime_unit_transform_algorithms[i];
+        if (runtime_datatype_transform_algorithms[i] != NULL)
+            delete runtime_datatype_transform_algorithms[i];
+    }
 
-	inout_interface_mgr->erase_runtime_receive_algorithm(runtime_data_transfer_algorithm);
-	delete runtime_data_transfer_algorithm;
+    inout_interface_mgr->erase_runtime_receive_algorithm(runtime_data_transfer_algorithm);
+    delete runtime_data_transfer_algorithm;
 }
 
 
 void Connection_coupling_procedure::execute(bool bypass_timer, int *field_update_status, const char *annotation)
 {
-	Time_mgt *time_mgr = components_time_mgrs->get_time_mgr(inout_interface->get_comp_id());
-	int lag_seconds;
+    Time_mgt *time_mgr = components_time_mgrs->get_time_mgr(inout_interface->get_comp_id());
+    int lag_seconds;
 
 
-	finish_status = false;
-	transfer_data = false;
+    finish_status = false;
+    transfer_data = false;
 
-	if (!bypass_timer) {	
-		Connection_field_time_info *local_fields_time_info, *remote_fields_time_info;		
-		if (inout_interface->get_interface_type() == COUPLING_INTERFACE_MARK_IMPORT) {
-			local_fields_time_info = fields_time_info_dst;
-			remote_fields_time_info = fields_time_info_src;
-			lag_seconds = local_fields_time_info->lag_seconds;
-		}
-		else {
-			local_fields_time_info = fields_time_info_src;
-			remote_fields_time_info = fields_time_info_dst;
-			lag_seconds = -remote_fields_time_info->lag_seconds;
-		}
-		time_mgr->get_current_time(local_fields_time_info->current_year, local_fields_time_info->current_month, local_fields_time_info->current_day, local_fields_time_info->current_second, 0, "CCPL internal");
-		local_fields_time_info->current_num_elapsed_days = time_mgr->get_current_num_elapsed_day();  
-		EXECUTION_REPORT_ERROR_OPTIONALLY(REPORT_ERROR, local_fields_time_info->inout_interface->get_comp_id(), !((local_fields_time_info->last_timer_num_elapsed_days != -1)) || ((long)local_fields_time_info->current_num_elapsed_days)*100000+local_fields_time_info->current_second >= ((long)local_fields_time_info->last_timer_num_elapsed_days)*100000+local_fields_time_info->last_timer_second,
-		                 "Software error in Connection_coupling_procedure::execute: current time is earlier than last timer time");
-		EXECUTION_REPORT_ERROR_OPTIONALLY(REPORT_ERROR, local_fields_time_info->inout_interface->get_comp_id(), ((long)local_fields_time_info->current_num_elapsed_days)*100000+local_fields_time_info->current_second <= ((long)local_fields_time_info->next_timer_num_elapsed_days)*100000+local_fields_time_info->next_timer_second,
-		                 "Error happens when executing the import/export interface \"%s\": it should but not have already been called at any time when its timer is on. Please check the model code with the annotation \"%s\"", 
-		                 local_fields_time_info->inout_interface->get_interface_name(), annotation_mgr->get_annotation(local_fields_time_info->inout_interface->get_interface_id(), "registering interface"));
-		if (time_mgr->is_timer_on(local_fields_time_info->timer->get_frequency_unit(), local_fields_time_info->timer->get_frequency_count(), local_fields_time_info->timer->get_local_lag_count())) {
-			if (((long)local_fields_time_info->current_num_elapsed_days)*100000+local_fields_time_info->current_second == ((long)local_fields_time_info->next_timer_num_elapsed_days)*100000+local_fields_time_info->next_timer_second) {
-				local_fields_time_info->last_timer_num_elapsed_days = local_fields_time_info->next_timer_num_elapsed_days;
-				local_fields_time_info->last_timer_second = local_fields_time_info->next_timer_second;
-				local_fields_time_info->get_time_of_next_timer_on(true);
-			}
-			while((((long)remote_fields_time_info->current_num_elapsed_days)*((long)SECONDS_PER_DAY))+remote_fields_time_info->current_second+lag_seconds <= (((long)local_fields_time_info->current_num_elapsed_days)*((long)SECONDS_PER_DAY)) + local_fields_time_info->current_second) {
-				if (remote_fields_time_info->timer->is_timer_on(remote_fields_time_info->current_year, remote_fields_time_info->current_month, remote_fields_time_info->current_day, remote_fields_time_info->current_second, remote_fields_time_info->current_num_elapsed_days, 
-					                                            time_mgr->get_start_year(), time_mgr->get_start_month(), time_mgr->get_start_day(), time_mgr->get_start_second(), time_mgr->get_start_num_elapsed_day())) {
-					remote_fields_time_info->last_timer_num_elapsed_days = remote_fields_time_info->current_num_elapsed_days;
-					remote_fields_time_info->last_timer_second = remote_fields_time_info->current_second;
-				}	
-				time_mgr->advance_time(remote_fields_time_info->current_year, remote_fields_time_info->current_month, remote_fields_time_info->current_day, remote_fields_time_info->current_second, remote_fields_time_info->current_num_elapsed_days,  remote_fields_time_info->time_step_in_second);
-			}			
-			remote_fields_time_info->get_time_of_next_timer_on(false);
-		}
-	}
-	
-	if (inout_interface->get_interface_type() == COUPLING_INTERFACE_MARK_IMPORT) { 
+    if (!bypass_timer) {    
+        Connection_field_time_info *local_fields_time_info, *remote_fields_time_info;        
+        if (inout_interface->get_interface_type() == COUPLING_INTERFACE_MARK_IMPORT) {
+            local_fields_time_info = fields_time_info_dst;
+            remote_fields_time_info = fields_time_info_src;
+            lag_seconds = local_fields_time_info->lag_seconds;
+        }
+        else {
+            local_fields_time_info = fields_time_info_src;
+            remote_fields_time_info = fields_time_info_dst;
+            lag_seconds = -remote_fields_time_info->lag_seconds;
+        }
+        time_mgr->get_current_time(local_fields_time_info->current_year, local_fields_time_info->current_month, local_fields_time_info->current_day, local_fields_time_info->current_second, 0, "CCPL internal");
+        local_fields_time_info->current_num_elapsed_days = time_mgr->get_current_num_elapsed_day();  
+        EXECUTION_REPORT_ERROR_OPTIONALLY(REPORT_ERROR, local_fields_time_info->inout_interface->get_comp_id(), !((local_fields_time_info->last_timer_num_elapsed_days != -1)) || ((long)local_fields_time_info->current_num_elapsed_days)*100000+local_fields_time_info->current_second >= ((long)local_fields_time_info->last_timer_num_elapsed_days)*100000+local_fields_time_info->last_timer_second,
+                         "Software error in Connection_coupling_procedure::execute: current time is earlier than last timer time");
+        EXECUTION_REPORT_ERROR_OPTIONALLY(REPORT_ERROR, local_fields_time_info->inout_interface->get_comp_id(), ((long)local_fields_time_info->current_num_elapsed_days)*100000+local_fields_time_info->current_second <= ((long)local_fields_time_info->next_timer_num_elapsed_days)*100000+local_fields_time_info->next_timer_second,
+                         "Error happens when executing the import/export interface \"%s\": it should but not have already been called at any time when its timer is on. Please check the model code with the annotation \"%s\"", 
+                         local_fields_time_info->inout_interface->get_interface_name(), annotation_mgr->get_annotation(local_fields_time_info->inout_interface->get_interface_id(), "registering interface"));
+        if (time_mgr->is_timer_on(local_fields_time_info->timer->get_frequency_unit(), local_fields_time_info->timer->get_frequency_count(), local_fields_time_info->timer->get_local_lag_count())) {
+            if (((long)local_fields_time_info->current_num_elapsed_days)*100000+local_fields_time_info->current_second == ((long)local_fields_time_info->next_timer_num_elapsed_days)*100000+local_fields_time_info->next_timer_second) {
+                local_fields_time_info->last_timer_num_elapsed_days = local_fields_time_info->next_timer_num_elapsed_days;
+				local_fields_time_info->last_timer_date = local_fields_time_info->next_timer_date;
+                local_fields_time_info->last_timer_second = local_fields_time_info->next_timer_second;
+                local_fields_time_info->get_time_of_next_timer_on(true);
+            }
+            while((((long)remote_fields_time_info->current_num_elapsed_days)*((long)SECONDS_PER_DAY))+remote_fields_time_info->current_second+lag_seconds <= (((long)local_fields_time_info->current_num_elapsed_days)*((long)SECONDS_PER_DAY)) + local_fields_time_info->current_second) {
+                if (remote_fields_time_info->timer->is_timer_on(remote_fields_time_info->current_year, remote_fields_time_info->current_month, remote_fields_time_info->current_day, remote_fields_time_info->current_second, remote_fields_time_info->current_num_elapsed_days, 
+                                                                time_mgr->get_start_year(), time_mgr->get_start_month(), time_mgr->get_start_day(), time_mgr->get_start_second(), time_mgr->get_start_num_elapsed_day())) {
+                    remote_fields_time_info->last_timer_num_elapsed_days = remote_fields_time_info->current_num_elapsed_days;
+					remote_fields_time_info->last_timer_date = remote_fields_time_info->current_year*10000 + remote_fields_time_info->current_month*100 + remote_fields_time_info->current_day;
+                    remote_fields_time_info->last_timer_second = remote_fields_time_info->current_second;
+                }    
+                time_mgr->advance_time(remote_fields_time_info->current_year, remote_fields_time_info->current_month, remote_fields_time_info->current_day, remote_fields_time_info->current_second, remote_fields_time_info->current_num_elapsed_days,  remote_fields_time_info->time_step_in_second);
+            }            
+            remote_fields_time_info->get_time_of_next_timer_on(false);
+        }
+    }
+    
+    if (inout_interface->get_interface_type() == COUPLING_INTERFACE_MARK_IMPORT) { 
 #ifdef USE_ONE_SIDED_MPI
-		((Runtime_trans_algorithm*)runtime_data_transfer_algorithm)->receive_data_in_temp_buffer();
+        ((Runtime_trans_algorithm*)runtime_data_transfer_algorithm)->receive_data_in_temp_buffer();
 #endif
-		if (bypass_timer) {
+        if (bypass_timer) {
+            current_remote_fields_elapsed_time = -1;
 			current_remote_fields_time = -1;
-			if (inout_interface->get_bypass_counter() == 1) {
-				EXECUTION_REPORT_ERROR_OPTIONALLY(REPORT_ERROR, inout_interface->get_comp_id(), !(!words_are_the_same(time_mgr->get_run_type(), RUNTYPE_CONTINUE) && !words_are_the_same(time_mgr->get_run_type(), RUNTYPE_BRANCH)) || last_remote_fields_time == -1, "Software error in Connection_coupling_procedure::execute: wrong last_remote_fields_time 1");
-			}
-			else if (!words_are_the_same(time_mgr->get_run_type(), RUNTYPE_CONTINUE) && !words_are_the_same(time_mgr->get_run_type(), RUNTYPE_BRANCH))
-				EXECUTION_REPORT_ERROR_OPTIONALLY(REPORT_ERROR, inout_interface->get_comp_id(), inout_interface->get_bypass_counter() - 1 == remote_bypass_counter, "Software error in Connection_coupling_procedure::execute: wrong last_remote_fields_time 2");
-			transfer_data = true;
-		}
-		else if (!(fields_time_info_dst->current_num_elapsed_days != fields_time_info_dst->last_timer_num_elapsed_days || fields_time_info_dst->current_second != fields_time_info_dst->last_timer_second)) {
-			if (fields_time_info_src->last_timer_num_elapsed_days != -1)
-				current_remote_fields_time = ((long)fields_time_info_src->last_timer_num_elapsed_days) * 100000 + fields_time_info_src->last_timer_second; 
-			if (current_remote_fields_time != -1 && !time_mgr->is_time_out_of_execution(current_remote_fields_time) && current_remote_fields_time != last_remote_fields_time) {
-				EXECUTION_REPORT_LOG(REPORT_LOG, inout_interface->get_comp_id(), true, "The import interface \"%s\" will receive remote data at %ld vs %ld", inout_interface->get_interface_name(), current_remote_fields_time, last_remote_fields_time);
-				last_remote_fields_time = current_remote_fields_time;
-				transfer_data = true;
-			}
- 			else {
-				EXECUTION_REPORT_LOG(REPORT_LOG, inout_interface->get_comp_id(), true, "Do not redundantly receive remote data at %ld vs %ld", last_remote_fields_time, current_remote_fields_time);
-				if (current_remote_fields_time != -1 && time_mgr->is_time_out_of_execution(current_remote_fields_time))
-					is_coupling_time_out_of_execution = true;
- 			}
-		}
+            if (inout_interface->get_bypass_counter() == 1) {
+                EXECUTION_REPORT_ERROR_OPTIONALLY(REPORT_ERROR, inout_interface->get_comp_id(), !(!words_are_the_same(time_mgr->get_run_type(), RUNTYPE_CONTINUE) && !words_are_the_same(time_mgr->get_run_type(), RUNTYPE_BRANCH)) || last_remote_fields_time == -1, "Software error in Connection_coupling_procedure::execute: wrong last_remote_fields_time 1");
+            }
+            else if (!words_are_the_same(time_mgr->get_run_type(), RUNTYPE_CONTINUE) && !words_are_the_same(time_mgr->get_run_type(), RUNTYPE_BRANCH))
+                EXECUTION_REPORT_ERROR_OPTIONALLY(REPORT_ERROR, inout_interface->get_comp_id(), (inout_interface->get_bypass_counter() - 1)%8 == remote_bypass_counter, "Software error in Connection_coupling_procedure::execute: wrong last_remote_fields_time 2");
+            transfer_data = true;
+        }
+        else if (!(fields_time_info_dst->current_num_elapsed_days != fields_time_info_dst->last_timer_num_elapsed_days || fields_time_info_dst->current_second != fields_time_info_dst->last_timer_second)) {
+            if (fields_time_info_src->last_timer_num_elapsed_days != -1) {
+                current_remote_fields_elapsed_time = ((long)fields_time_info_src->last_timer_num_elapsed_days) * 100000 + fields_time_info_src->last_timer_second; 
+				current_remote_fields_time = ((long)fields_time_info_src->last_timer_date)*100000 + fields_time_info_src->last_timer_second;
+            }	
+            if (current_remote_fields_elapsed_time != -1 && !time_mgr->is_time_out_of_execution(current_remote_fields_elapsed_time) && current_remote_fields_elapsed_time != last_remote_fields_time) {
+                EXECUTION_REPORT_LOG(REPORT_LOG, inout_interface->get_comp_id(), true, "The import interface \"%s\" will receive remote data at %ld vs %ld", inout_interface->get_interface_name(), current_remote_fields_elapsed_time, last_remote_fields_time);
+                last_remote_fields_time = current_remote_fields_elapsed_time;
+                transfer_data = true;
+            }
+             else {
+                EXECUTION_REPORT_LOG(REPORT_LOG, inout_interface->get_comp_id(), true, "Do not redundantly receive remote data at %ld vs %ld", last_remote_fields_time, current_remote_fields_elapsed_time);
+                if (current_remote_fields_elapsed_time != -1 && time_mgr->is_time_out_of_execution(current_remote_fields_elapsed_time))
+                    is_coupling_time_out_of_execution = true;
+             }
+        }
+        if (transfer_data) {
+            for (int i = fields_mem_registered.size() - 1; i >= 0; i --)
+                if (field_interface_local_index[i] != -1)
+                    field_update_status[field_interface_local_index[i]] = transfer_data? 1 : 0;
+            bool read_restart_data = (!bypass_timer && !inout_interface->get_is_child_interface() && restart_mgr->is_in_restart_read_window(current_remote_fields_elapsed_time));
+            if (!bypass_timer && !inout_interface->get_is_child_interface() && restart_mgr->is_in_restart_read_window(current_remote_fields_elapsed_time)) {
+                EXECUTION_REPORT_LOG(REPORT_LOG, inout_interface->get_comp_id(), true, "The import interface \"%s\" will not receive data from the component model \"%s\" that is at the time %ld (the restart time is %ld)", inout_interface->get_interface_name(), coupling_connection->get_src_comp_full_name(), current_remote_fields_elapsed_time, time_mgr->get_restart_full_time());
+                for (int i = 0; i < fields_mem_registered.size(); i ++)
+                    restart_mgr->read_restart_field_data(fields_mem_registered[i], inout_interface->get_interface_name(), "imported", true, NULL, false, annotation);
+                transfer_data = false;
+            }
+            else {
+                runtime_data_transfer_algorithm->pass_transfer_parameters(current_remote_fields_time, inout_interface->get_bypass_counter());
+                runtime_data_transfer_algorithm->run(bypass_timer);
+                comp_comm_group_mgt_mgr->get_global_node_of_local_comp(inout_interface->get_comp_id(),false,"")->get_performance_timing_mgr()->performance_timing_start(TIMING_TYPE_COMPUTATION, -1, -1, inout_interface->get_interface_name());
+                for (int i = fields_mem_registered.size() - 1; i >= 0; i --) {
+                        comp_comm_group_mgt_mgr->get_global_node_of_local_comp(inout_interface->get_comp_id(),false,"")->get_performance_timing_mgr()->performance_timing_start(TIMING_TYPE_COMPUTATION, -1, -1, "data interpolation");
+                        if (runtime_remap_algorithms[i] != NULL)
+                            runtime_remap_algorithms[i]->run(true);
+                        comp_comm_group_mgt_mgr->get_global_node_of_local_comp(inout_interface->get_comp_id(),false,"")->get_performance_timing_mgr()->performance_timing_stop(TIMING_TYPE_COMPUTATION, -1, -1, "data interpolation");
+                        comp_comm_group_mgt_mgr->get_global_node_of_local_comp(inout_interface->get_comp_id(),false,"")->get_performance_timing_mgr()->performance_timing_start(TIMING_TYPE_COMPUTATION, -1, -1, "data type transformation");
+                        if (runtime_datatype_transform_algorithms[i] != NULL)
+                            runtime_datatype_transform_algorithms[i]->run(true);                                
+                        comp_comm_group_mgt_mgr->get_global_node_of_local_comp(inout_interface->get_comp_id(),false,"")->get_performance_timing_mgr()->performance_timing_stop(TIMING_TYPE_COMPUTATION, -1, -1, "data type transformation");
+                        comp_comm_group_mgt_mgr->get_global_node_of_local_comp(inout_interface->get_comp_id(),false,"")->get_performance_timing_mgr()->performance_timing_start(TIMING_TYPE_COMPUTATION, -1, -1, "data average");
+                        if (runtime_inter_averaging_algorithm[i] != NULL)
+                            runtime_inter_averaging_algorithm[i]->run(true);
+                        comp_comm_group_mgt_mgr->get_global_node_of_local_comp(inout_interface->get_comp_id(),false,"")->get_performance_timing_mgr()->performance_timing_stop(TIMING_TYPE_COMPUTATION, -1, -1, "data average");
+                }
+                comp_comm_group_mgt_mgr->get_global_node_of_local_comp(inout_interface->get_comp_id(),false,"")->get_performance_timing_mgr()->performance_timing_stop(TIMING_TYPE_COMPUTATION, -1, -1, inout_interface->get_interface_name());
+                if (!bypass_timer && !inout_interface->get_is_child_interface() && (restart_mgr->is_in_restart_write_window(current_remote_fields_elapsed_time, true))) {
+                    EXECUTION_REPORT_LOG(REPORT_LOG, inout_interface->get_comp_id(), true, "Should write the remote data at the remote time %ld and local %ld into the restart data file", current_remote_fields_elapsed_time, time_mgr->get_current_num_elapsed_day()*((long)100000)+time_mgr->get_current_second());
+                    for (int i = 0; i < fields_mem_registered.size(); i ++)
+                        restart_mgr->write_restart_field_data(fields_mem_registered[i], inout_interface->get_interface_name(), "imported", true);
+                }
+            }
+        }
+        finish_status = true;
 		if (transfer_data) {
-			for (int i = fields_mem_registered.size() - 1; i >= 0; i --)
-				if (field_interface_local_index[i] != -1)
-					field_update_status[field_interface_local_index[i]] = transfer_data? 1 : 0;
-			bool read_restart_data = (!bypass_timer && !inout_interface->get_is_child_interface() && restart_mgr->is_in_restart_read_window(current_remote_fields_time));
-			if (!bypass_timer && !inout_interface->get_is_child_interface() && restart_mgr->is_in_restart_read_window(current_remote_fields_time)) {
-				EXECUTION_REPORT_LOG(REPORT_LOG, inout_interface->get_comp_id(), true, "The import interface \"%s\" will not receive data from the component model \"%s\" that is at the time %ld (the restart time is %ld)", inout_interface->get_interface_name(), coupling_connection->get_src_comp_full_name(), current_remote_fields_time, time_mgr->get_restart_full_time());
-				for (int i = 0; i < fields_mem_registered.size(); i ++)
-					restart_mgr->read_restart_field_data(fields_mem_registered[i], inout_interface->get_interface_name(), "imported", true, NULL, annotation);
-				transfer_data = false;
-			}
-			else {
-				runtime_data_transfer_algorithm->pass_transfer_parameters(current_remote_fields_time, inout_interface->get_bypass_counter());
-				runtime_data_transfer_algorithm->run(bypass_timer);
-				comp_comm_group_mgt_mgr->get_global_node_of_local_comp(inout_interface->get_comp_id(),false,"")->get_performance_timing_mgr()->performance_timing_start(TIMING_TYPE_COMPUTATION, -1, -1, inout_interface->get_interface_name());
-				for (int i = fields_mem_registered.size() - 1; i >= 0; i --) {
-						if (runtime_remap_algorithms[i] != NULL)
-							runtime_remap_algorithms[i]->run(true);
-						if (runtime_datatype_transform_algorithms[i] != NULL)
-							runtime_datatype_transform_algorithms[i]->run(true);								
-						if (runtime_inter_averaging_algorithm[i] != NULL)
-							runtime_inter_averaging_algorithm[i]->run(true);
-				}
-				if (!bypass_timer && !inout_interface->get_is_child_interface() && (restart_mgr->is_in_restart_write_window(current_remote_fields_time, true))) {
-					EXECUTION_REPORT_LOG(REPORT_LOG, inout_interface->get_comp_id(), true, "Should write the remote data at the remote time %ld and local %ld into the restart data file", current_remote_fields_time, time_mgr->get_current_num_elapsed_day()*((long)100000)+time_mgr->get_current_second());
-					for (int i = 0; i < fields_mem_registered.size(); i ++)
-						restart_mgr->write_restart_field_data(fields_mem_registered[i], inout_interface->get_interface_name(), "imported", true);
-				}
-				comp_comm_group_mgt_mgr->get_global_node_of_local_comp(inout_interface->get_comp_id(),false,"")->get_performance_timing_mgr()->performance_timing_stop(TIMING_TYPE_COMPUTATION, -1, -1, inout_interface->get_interface_name());
-			}
-		}
-		finish_status = true;
-		for (int i = fields_mem_registered.size() - 1; i >= 0; i --) {
-			if (!transfer_data)
-				continue;
-			remote_bypass_counter = runtime_data_transfer_algorithm->get_history_receive_sender_time(i) / ((long)100000000000000);
-			EXECUTION_REPORT_LOG(REPORT_LOG, inout_interface->get_comp_id(), true, "Bypass counter: remote is %d while local is %d", remote_bypass_counter, inout_interface->get_bypass_counter());
-			if (bypass_timer) {
-				EXECUTION_REPORT_ERROR_OPTIONALLY(REPORT_ERROR, inout_interface->get_comp_id(), remote_bypass_counter == inout_interface->get_bypass_counter(), "Error happens when executing the import interface \"%s\" with its timer bypassed (the corresponding input parameter \"bypass_timer\" has been set to true): the data currently obtained by this import interface should be but is not from a timer bypassed execution of the corresponding export interface \"%s\" of the component model \"%s\". Please verify.", inout_interface->get_interface_name(), coupling_connection->src_comp_interfaces[0].second, coupling_connection->src_comp_interfaces[0].first);
-			}
-			else {
-				EXECUTION_REPORT_ERROR_OPTIONALLY(REPORT_ERROR, inout_interface->get_comp_id(), remote_bypass_counter == 0, "Error happens when executing the import interface \"%s\" with its timer unbypassed (the corresponding input parameter \"bypass_timer\" has been set to false): the data currently obtained by this import interface should be but is not from a timer unbypassed execution of the corresponding export interface \"%s\" of the component model \"%s\". Please verify.", inout_interface->get_interface_name(), coupling_connection->src_comp_interfaces[0].second, coupling_connection->src_comp_interfaces[0].first);
-				EXECUTION_REPORT_ERROR_OPTIONALLY(REPORT_ERROR, inout_interface->get_comp_id(), runtime_data_transfer_algorithm->get_history_receive_sender_time(i) == current_remote_fields_time, 
-					             "Software error: Error happens when using the timer to call the import interface \"%s\": this interface call does not receive the data from the corresponding export interface \"%s\" from the component model \"%s\" at the right model time (the receiver wants the imported data at %ld but received the imported data at %ld). Please verify. ", 
-					             inout_interface->get_interface_name(), coupling_connection->src_comp_interfaces[0].second, coupling_connection->src_comp_interfaces[0].first, current_remote_fields_time, runtime_data_transfer_algorithm->get_history_receive_sender_time(i));
-			}	
+			last_receive_sender_time = runtime_data_transfer_algorithm->get_history_receive_sender_time() % ((long)10000000000000000);
+            remote_bypass_counter = runtime_data_transfer_algorithm->get_history_receive_sender_time() / ((long)10000000000000000);
+            EXECUTION_REPORT_LOG(REPORT_LOG, inout_interface->get_comp_id(), true, "interface \"%s\" last_receive_sender_time is %ld", inout_interface->get_interface_name(), last_receive_sender_time);
 		}
-		return;
-	}
-	else {
-		for (int i = fields_mem_registered.size() - 1; i >= 0; i --) {
-			if (bypass_timer) {
+        for (int i = fields_mem_registered.size() - 1; i >= 0; i --) {
+            if (!transfer_data)
+                continue;
+            EXECUTION_REPORT_LOG(REPORT_LOG, inout_interface->get_comp_id(), true, "Bypass counter: remote is %d while local is %d", remote_bypass_counter, inout_interface->get_bypass_counter());
+            if (bypass_timer) {
+                EXECUTION_REPORT_ERROR_OPTIONALLY(REPORT_ERROR, inout_interface->get_comp_id(), remote_bypass_counter == (inout_interface->get_bypass_counter()%8), "Error happens when executing the import interface \"%s\" with its timer bypassed (the corresponding input parameter \"bypass_timer\" has been set to true): the data currently obtained by this import interface should be but is not from a timer bypassed execution of the corresponding export interface \"%s\" of the component model \"%s\". Please verify.", inout_interface->get_interface_name(), coupling_connection->src_comp_interfaces[0].second, coupling_connection->src_comp_interfaces[0].first);
+            }
+            else {
+                EXECUTION_REPORT_ERROR_OPTIONALLY(REPORT_ERROR, inout_interface->get_comp_id(), remote_bypass_counter == 0, "Error happens when executing the import interface \"%s\" with its timer unbypassed (the corresponding input parameter \"bypass_timer\" has been set to false): the data currently obtained by this import interface should be but is not from a timer unbypassed execution of the corresponding export interface \"%s\" of the component model \"%s\". Please verify.", inout_interface->get_interface_name(), coupling_connection->src_comp_interfaces[0].second, coupling_connection->src_comp_interfaces[0].first);
+                EXECUTION_REPORT_ERROR_OPTIONALLY(REPORT_ERROR, inout_interface->get_comp_id(), time_mgr->get_elapsed_day_from_full_time(last_receive_sender_time)*((long)100000) + last_receive_sender_time%100000 == current_remote_fields_elapsed_time, 
+                                 "Software error: Error happens when using the timer to call the import interface \"%s\": this interface call does not receive the data from the corresponding export interface \"%s\" from the component model \"%s\" at the right model time (the receiver wants the imported data at %ld but received the imported data at %ld). Please verify. ", 
+                                 inout_interface->get_interface_name(), coupling_connection->src_comp_interfaces[0].second, coupling_connection->src_comp_interfaces[0].first, current_remote_fields_elapsed_time, runtime_data_transfer_algorithm->get_history_receive_sender_time());
+            }    
+        }
+        return;
+    }
+    else {
+        for (int i = fields_mem_registered.size() - 1; i >= 0; i --) {
+            if (bypass_timer) {
+                current_remote_fields_elapsed_time = -1;
 				current_remote_fields_time = -1;
-				EXECUTION_REPORT_ERROR_OPTIONALLY(REPORT_ERROR, -1, !(i == fields_mem_registered.size() - 1 && !words_are_the_same(time_mgr->get_run_type(), RUNTYPE_CONTINUE) && !words_are_the_same(time_mgr->get_run_type(), RUNTYPE_BRANCH)) || last_remote_fields_time == -1, "Software error in Connection_coupling_procedure::execute: wrong last_remote_fields_time");
-				transfer_data = true;
-				if (runtime_inner_averaging_algorithm[i] != NULL)
-					runtime_inner_averaging_algorithm[i]->run(true);
-				if (runtime_inter_averaging_algorithm[i] != NULL)
-					runtime_inter_averaging_algorithm[i]->run(true);
-				if (runtime_datatype_transform_algorithms[i] != NULL)
-					runtime_datatype_transform_algorithms[i]->run(true);
-			}
-			else {
-				Coupling_timer *dst_timer = fields_time_info_dst->timer;
-				Coupling_timer *src_timer = fields_time_info_src->timer;			
-				lag_seconds = -fields_time_info_dst->lag_seconds;
-				if (fields_time_info_src->current_num_elapsed_days != fields_time_info_src->last_timer_num_elapsed_days || fields_time_info_src->current_second != fields_time_info_src->last_timer_second) {
-					if (fields_time_info_dst->inst_or_aver == USING_AVERAGE_VALUE)
-						runtime_inner_averaging_algorithm[i]->run(false);
-					continue;
-				}
-				if (runtime_inner_averaging_algorithm[i] != NULL)
-					runtime_inner_averaging_algorithm[i]->run(true);
-				if (((long)fields_time_info_src->current_num_elapsed_days)*SECONDS_PER_DAY+fields_time_info_src->current_second == ((long)fields_time_info_dst->last_timer_num_elapsed_days)*SECONDS_PER_DAY+fields_time_info_dst->last_timer_second+lag_seconds) {
-					current_remote_fields_time = ((long)fields_time_info_dst->last_timer_num_elapsed_days)*100000 + fields_time_info_dst->last_timer_second;
-					EXECUTION_REPORT_ERROR_OPTIONALLY(REPORT_ERROR, -1, !(i == fields_mem_registered.size() - 1) || last_remote_fields_time != current_remote_fields_time, "Software error in Connection_coupling_procedure::execute: wrong last_remote_fields_time");
-					last_remote_fields_time = current_remote_fields_time;
-					if (runtime_inter_averaging_algorithm[i] != NULL)
-						runtime_inter_averaging_algorithm[i]->run(true);
-					if (runtime_datatype_transform_algorithms[i] != NULL) 
-						runtime_datatype_transform_algorithms[i]->run(false);
-					if (!time_mgr->is_time_out_of_execution(current_remote_fields_time))
-						transfer_data = true;
-					continue;
-				}
-				if ((((long)fields_time_info_dst->next_timer_num_elapsed_days)*((long)SECONDS_PER_DAY))+fields_time_info_dst->next_timer_second+lag_seconds < (((long)fields_time_info_src->next_timer_num_elapsed_days)*((long)SECONDS_PER_DAY)) + fields_time_info_src->next_timer_second) {
-					current_remote_fields_time = ((long)fields_time_info_dst->next_timer_num_elapsed_days)*100000 + fields_time_info_dst->next_timer_second;
-					EXECUTION_REPORT_ERROR_OPTIONALLY(REPORT_ERROR, -1, !(i == fields_mem_registered.size() - 1) || last_remote_fields_time != current_remote_fields_time, "Software error in Connection_coupling_procedure::execute: wrong last_remote_fields_time");
-					last_remote_fields_time = current_remote_fields_time;
-					if (runtime_inter_averaging_algorithm[i] != NULL)
-						runtime_inter_averaging_algorithm[i]->run(true);
-					if (runtime_datatype_transform_algorithms[i] != NULL) 
-						runtime_datatype_transform_algorithms[i]->run(false);
-					if (!time_mgr->is_time_out_of_execution(current_remote_fields_time)) {
-						transfer_data = true;
-					}
-				}
-				else {
-					if (runtime_inter_averaging_algorithm[i] != NULL)
-						runtime_inter_averaging_algorithm[i]->run(false);
-				}	
-			}
-		}
-		if (!bypass_timer && !inout_interface->get_is_child_interface() && transfer_data && restart_mgr->is_in_restart_read_window(current_remote_fields_time)) {
-			EXECUTION_REPORT_LOG(REPORT_LOG, inout_interface->get_comp_id(), true, "The export interface \"%s\" will not send data to the component model \"%s\" that is at the time %ld (the restart time is %ld)", inout_interface->get_interface_name(), coupling_connection->get_dst_comp_full_name(), current_remote_fields_time, time_mgr->get_restart_full_time());
-			transfer_data = false;
-		}
-		if (!transfer_data)
-			finish_status = true;
-		if (transfer_data)
-			((Runtime_trans_algorithm*)runtime_data_transfer_algorithm)->pass_transfer_parameters(current_remote_fields_time, inout_interface->get_bypass_counter());
-	}
+                EXECUTION_REPORT_ERROR_OPTIONALLY(REPORT_ERROR, -1, !(i == fields_mem_registered.size() - 1 && !words_are_the_same(time_mgr->get_run_type(), RUNTYPE_CONTINUE) && !words_are_the_same(time_mgr->get_run_type(), RUNTYPE_BRANCH)) || last_remote_fields_time == -1, "Software error in Connection_coupling_procedure::execute: wrong last_remote_fields_time");
+                transfer_data = true;
+                if (runtime_inner_averaging_algorithm[i] != NULL)
+                    runtime_inner_averaging_algorithm[i]->run(true);
+                if (runtime_inter_averaging_algorithm[i] != NULL)
+                    runtime_inter_averaging_algorithm[i]->run(true);
+                if (runtime_datatype_transform_algorithms[i] != NULL)
+                    runtime_datatype_transform_algorithms[i]->run(true);
+            }
+            else {
+                Coupling_timer *dst_timer = fields_time_info_dst->timer;
+                Coupling_timer *src_timer = fields_time_info_src->timer;            
+                lag_seconds = -fields_time_info_dst->lag_seconds;
+                if (fields_time_info_src->current_num_elapsed_days != fields_time_info_src->last_timer_num_elapsed_days || fields_time_info_src->current_second != fields_time_info_src->last_timer_second) {
+                    if (fields_time_info_dst->inst_or_aver == USING_AVERAGE_VALUE)
+                        runtime_inner_averaging_algorithm[i]->run(false);
+                    continue;
+                }
+                if (runtime_inner_averaging_algorithm[i] != NULL)
+                    runtime_inner_averaging_algorithm[i]->run(true);
+                if (((long)fields_time_info_src->current_num_elapsed_days)*SECONDS_PER_DAY+fields_time_info_src->current_second == ((long)fields_time_info_dst->last_timer_num_elapsed_days)*SECONDS_PER_DAY+fields_time_info_dst->last_timer_second+lag_seconds) {
+                    current_remote_fields_elapsed_time = ((long)fields_time_info_dst->last_timer_num_elapsed_days)*100000 + fields_time_info_dst->last_timer_second;
+					current_remote_fields_time = ((long)fields_time_info_dst->last_timer_date)*100000 + fields_time_info_dst->last_timer_second;
+                    EXECUTION_REPORT_ERROR_OPTIONALLY(REPORT_ERROR, -1, !(i == fields_mem_registered.size() - 1) || last_remote_fields_time != current_remote_fields_elapsed_time, "Software error in Connection_coupling_procedure::execute: wrong last_remote_fields_time");
+                    last_remote_fields_time = current_remote_fields_elapsed_time;
+                    if (runtime_inter_averaging_algorithm[i] != NULL)
+                        runtime_inter_averaging_algorithm[i]->run(true);
+                    if (runtime_datatype_transform_algorithms[i] != NULL) 
+                        runtime_datatype_transform_algorithms[i]->run(false);
+                    if (!time_mgr->is_time_out_of_execution(current_remote_fields_elapsed_time))
+                        transfer_data = true;
+                    continue;
+                }
+                if ((((long)fields_time_info_dst->next_timer_num_elapsed_days)*((long)SECONDS_PER_DAY))+fields_time_info_dst->next_timer_second+lag_seconds < (((long)fields_time_info_src->next_timer_num_elapsed_days)*((long)SECONDS_PER_DAY)) + fields_time_info_src->next_timer_second) {
+                    current_remote_fields_elapsed_time = ((long)fields_time_info_dst->next_timer_num_elapsed_days)*100000 + fields_time_info_dst->next_timer_second;
+					current_remote_fields_time = ((long)fields_time_info_dst->next_timer_date)*100000 + fields_time_info_dst->next_timer_second;
+                    EXECUTION_REPORT_ERROR_OPTIONALLY(REPORT_ERROR, -1, !(i == fields_mem_registered.size() - 1) || last_remote_fields_time != current_remote_fields_elapsed_time, "Software error in Connection_coupling_procedure::execute: wrong last_remote_fields_time");
+                    last_remote_fields_time = current_remote_fields_elapsed_time;
+                    if (runtime_inter_averaging_algorithm[i] != NULL)
+                        runtime_inter_averaging_algorithm[i]->run(true);
+                    if (runtime_datatype_transform_algorithms[i] != NULL) 
+                        runtime_datatype_transform_algorithms[i]->run(false);
+                    if (!time_mgr->is_time_out_of_execution(current_remote_fields_elapsed_time)) {
+                        transfer_data = true;
+                    }
+                }
+                else {
+                    if (runtime_inter_averaging_algorithm[i] != NULL)
+                        runtime_inter_averaging_algorithm[i]->run(false);
+                }    
+            }
+        }
+        if (!bypass_timer && !inout_interface->get_is_child_interface() && transfer_data && restart_mgr->is_in_restart_read_window(current_remote_fields_elapsed_time)) {
+            EXECUTION_REPORT_LOG(REPORT_LOG, inout_interface->get_comp_id(), true, "The export interface \"%s\" will not send data to the component model \"%s\" that is at the time %ld (the restart time is %ld)", inout_interface->get_interface_name(), coupling_connection->get_dst_comp_full_name(), current_remote_fields_elapsed_time, time_mgr->get_restart_full_time());
+            transfer_data = false;
+        }
+        if (!transfer_data)
+            finish_status = true;
+        if (transfer_data)
+            ((Runtime_trans_algorithm*)runtime_data_transfer_algorithm)->pass_transfer_parameters(current_remote_fields_time, inout_interface->get_bypass_counter());
+    }
 }
 
 
 void Connection_coupling_procedure::send_fields(bool bypass_timer)
 {
-	EXECUTION_REPORT_ERROR_OPTIONALLY(REPORT_ERROR, -1, inout_interface->get_interface_type() == COUPLING_INTERFACE_MARK_EXPORT && !finish_status && transfer_data, "Software error in Connection_coupling_procedure::send_fields");
-	finish_status = runtime_data_transfer_algorithm->run(bypass_timer);
+    EXECUTION_REPORT_ERROR_OPTIONALLY(REPORT_ERROR, -1, inout_interface->get_interface_type() == COUPLING_INTERFACE_MARK_EXPORT && !finish_status && transfer_data, "Software error in Connection_coupling_procedure::send_fields");
+    finish_status = runtime_data_transfer_algorithm->run(bypass_timer);
 }
 
 
 Field_mem_info *Connection_coupling_procedure::get_data_transfer_field_instance(int i)
 {
-	EXECUTION_REPORT(REPORT_ERROR, -1, fields_mem_transfer[i] != NULL, "Software error in Connection_coupling_procedure::get_data_transfer_field_instance");
-	return fields_mem_transfer[i]; 
+    EXECUTION_REPORT(REPORT_ERROR, -1, fields_mem_transfer[i] != NULL, "Software error in Connection_coupling_procedure::get_data_transfer_field_instance");
+    return fields_mem_transfer[i]; 
 }
 
 
 Runtime_remapping_weights *Connection_coupling_procedure::get_runtime_remapping_weights(int i) 
 {
-	return coupling_connection->dst_fields_info[i]->runtime_remapping_weights; 
+    return coupling_connection->dst_fields_info[i]->runtime_remapping_weights; 
 }
 
 
 void Connection_coupling_procedure::write_restart_mgt_info(Restart_buffer_container *restart_buffer)
 {
-	int temp_int;
-
-	
-	fields_time_info_src->write_restart_mgt_info(restart_buffer);
-	fields_time_info_dst->write_restart_mgt_info(restart_buffer);
-	restart_buffer->dump_in_data(&last_remote_fields_time, sizeof(long));
-	restart_buffer->dump_in_data(&current_remote_fields_time, sizeof(long));
-	for (int i = fields_mem_registered.size()-1; i >=0; i --)
-		restart_buffer->dump_in_string(fields_mem_registered[i]->get_field_name(), -1);
-	if (inout_interface->get_interface_type() == COUPLING_INTERFACE_MARK_EXPORT) {
-		for (int i = runtime_inner_averaging_algorithm.size()-1; i >= 0; i --) {
-			if (runtime_inner_averaging_algorithm[i] != NULL) {
-				runtime_inner_averaging_algorithm[i]->restart_write(restart_buffer, "aver_inner");
-				temp_int = 1;
-			}
-			else  temp_int = 0;
-			restart_buffer->dump_in_data(&temp_int, sizeof(int));
-		}
-		for (int i = runtime_inter_averaging_algorithm.size()-1; i >= 0; i --) {
-			if (runtime_inter_averaging_algorithm[i] != NULL) {
-				runtime_inter_averaging_algorithm[i]->restart_write(restart_buffer, "aver_inter");
-				temp_int = 1;
-			}
-			else  temp_int = 0;
-			restart_buffer->dump_in_data(&temp_int, sizeof(int));
-		}
-	}
-	temp_int = fields_mem_registered.size();
-	restart_buffer->dump_in_data(&temp_int, sizeof(int));	
+    int temp_int;
+
+    
+    fields_time_info_src->write_restart_mgt_info(restart_buffer);
+    fields_time_info_dst->write_restart_mgt_info(restart_buffer);
+    restart_buffer->dump_in_data(&last_remote_fields_time, sizeof(long));
+    restart_buffer->dump_in_data(&current_remote_fields_elapsed_time, sizeof(long));
+    for (int i = fields_mem_registered.size()-1; i >=0; i --)
+        restart_buffer->dump_in_string(fields_mem_registered[i]->get_field_name(), -1);
+    if (inout_interface->get_interface_type() == COUPLING_INTERFACE_MARK_EXPORT) {
+        for (int i = runtime_inner_averaging_algorithm.size()-1; i >= 0; i --) {
+            if (runtime_inner_averaging_algorithm[i] != NULL) {
+                runtime_inner_averaging_algorithm[i]->restart_write(restart_buffer, "aver_inner");
+                temp_int = 1;
+            }
+            else  temp_int = 0;
+            restart_buffer->dump_in_data(&temp_int, sizeof(int));
+        }
+        for (int i = runtime_inter_averaging_algorithm.size()-1; i >= 0; i --) {
+            if (runtime_inter_averaging_algorithm[i] != NULL) {
+                runtime_inter_averaging_algorithm[i]->restart_write(restart_buffer, "aver_inter");
+                temp_int = 1;
+            }
+            else  temp_int = 0;
+            restart_buffer->dump_in_data(&temp_int, sizeof(int));
+        }
+    }
+    temp_int = fields_mem_registered.size();
+    restart_buffer->dump_in_data(&temp_int, sizeof(int));    
 }
 
 
 
 void Connection_coupling_procedure::import_restart_data(Restart_buffer_container *restart_buffer)
 {
-	int num_total_fields, temp_int, i, j;
-	long str_size, temp_long;
-	char restart_field_name[NAME_STR_SIZE];
+    int num_total_fields, temp_int, i, j;
+    long str_size, temp_long;
+    char restart_field_name[NAME_STR_SIZE];
 
 
-	restart_buffer->load_restart_data(&num_total_fields, sizeof(int));
-	EXECUTION_REPORT(REPORT_ERROR, inout_interface->get_comp_id(), num_total_fields == fields_mem_registered.size(), "Error happens when loading the restart data file \"%s\": it does not match the configuration of the interface \"%s\": the original number of total fields of this interface recorded in the restart data file is %d while the current number is %d. Please check.", restart_buffer->get_input_restart_mgt_info_file(), inout_interface->get_interface_name(), num_total_fields, fields_mem_registered.size());
+    restart_buffer->load_restart_data(&num_total_fields, sizeof(int));
+    EXECUTION_REPORT(REPORT_ERROR, inout_interface->get_comp_id(), num_total_fields == fields_mem_registered.size(), "Error happens when loading the restart data file \"%s\": it does not match the configuration of the interface \"%s\": the original number of total fields of this interface recorded in the restart data file is %d while the current number is %d. Please check.", restart_buffer->get_input_restart_mgt_info_file(), inout_interface->get_interface_name(), num_total_fields, fields_mem_registered.size());
 
-	if (inout_interface->get_interface_type() == COUPLING_INTERFACE_MARK_EXPORT) {
-		for (int i = 0; i < runtime_inter_averaging_algorithm.size(); i ++) {
-			restart_buffer->load_restart_data(&temp_int, sizeof(int));
-			if (temp_int == 0) {
-				EXECUTION_REPORT(REPORT_ERROR, -1, runtime_inter_averaging_algorithm[i] == NULL, "Software error1 in Connection_coupling_procedure::import_restart_data");
-				continue;
-			}			
-			EXECUTION_REPORT(REPORT_ERROR, -1, runtime_inter_averaging_algorithm[i] != NULL, "Software error2 in Connection_coupling_procedure::import_restart_data");
-			runtime_inter_averaging_algorithm[i]->restart_read(restart_buffer, "aver_inter");
-		}
-		for (int i = 0; i < runtime_inner_averaging_algorithm.size(); i ++) {
-			restart_buffer->load_restart_data(&temp_int, sizeof(int));
-			if (temp_int == 0) {				
-				EXECUTION_REPORT(REPORT_ERROR, -1, runtime_inner_averaging_algorithm[i] == NULL, "Software error3 in Connection_coupling_procedure::import_restart_data");
-				continue;		
-			}
-			EXECUTION_REPORT(REPORT_ERROR, -1, runtime_inner_averaging_algorithm[i] != NULL, "Software error4 in Connection_coupling_procedure::import_restart_data");
-			runtime_inner_averaging_algorithm[i]->restart_read(restart_buffer, "aver_inner");
-		}
-	}
+    if (inout_interface->get_interface_type() == COUPLING_INTERFACE_MARK_EXPORT) {
+        for (int i = 0; i < runtime_inter_averaging_algorithm.size(); i ++) {
+            restart_buffer->load_restart_data(&temp_int, sizeof(int));
+            if (temp_int == 0) {
+                EXECUTION_REPORT(REPORT_ERROR, -1, runtime_inter_averaging_algorithm[i] == NULL, "Software error1 in Connection_coupling_procedure::import_restart_data");
+                continue;
+            }            
+            EXECUTION_REPORT(REPORT_ERROR, -1, runtime_inter_averaging_algorithm[i] != NULL, "Software error2 in Connection_coupling_procedure::import_restart_data");
+            runtime_inter_averaging_algorithm[i]->restart_read(restart_buffer, "aver_inter");
+        }
+        for (int i = 0; i < runtime_inner_averaging_algorithm.size(); i ++) {
+            restart_buffer->load_restart_data(&temp_int, sizeof(int));
+            if (temp_int == 0) {                
+                EXECUTION_REPORT(REPORT_ERROR, -1, runtime_inner_averaging_algorithm[i] == NULL, "Software error3 in Connection_coupling_procedure::import_restart_data");
+                continue;        
+            }
+            EXECUTION_REPORT(REPORT_ERROR, -1, runtime_inner_averaging_algorithm[i] != NULL, "Software error4 in Connection_coupling_procedure::import_restart_data");
+            runtime_inner_averaging_algorithm[i]->restart_read(restart_buffer, "aver_inner");
+        }
+    }
 
-	for (i = 0; i < num_total_fields; i ++) {
-		restart_buffer->load_restart_string(restart_field_name, str_size, NAME_STR_SIZE);
-		for (j = 0; j < fields_mem_registered.size(); j ++)
-			if (words_are_the_same(restart_field_name, fields_mem_registered[j]->get_field_name()))
-				break;
-		EXECUTION_REPORT(REPORT_ERROR, inout_interface->get_comp_id(), i == j, "Error happens when loading the restart data file \"%s\": it does not match the configuration of the interface \"%s\": its original %th field recorded in the restart data file is \"%s\" while the current %th field is \"%s\". Please check.", restart_buffer->get_input_restart_mgt_info_file(), inout_interface->get_interface_name(), i, restart_field_name, fields_mem_registered[i]->get_field_name());
-	}
-	restart_buffer->load_restart_data(&current_remote_fields_time, sizeof(long));
-	restart_buffer->load_restart_data(&last_remote_fields_time, sizeof(long));
-	fields_time_info_dst->import_restart_data(restart_buffer);
-	fields_time_info_src->import_restart_data(restart_buffer);
+    for (i = 0; i < num_total_fields; i ++) {
+        restart_buffer->load_restart_string(restart_field_name, str_size, NAME_STR_SIZE);
+        for (j = 0; j < fields_mem_registered.size(); j ++)
+            if (words_are_the_same(restart_field_name, fields_mem_registered[j]->get_field_name()))
+                break;
+        EXECUTION_REPORT(REPORT_ERROR, inout_interface->get_comp_id(), i == j, "Error happens when loading the restart data file \"%s\": it does not match the configuration of the interface \"%s\": its original %th field recorded in the restart data file is \"%s\" while the current %th field is \"%s\". Please check.", restart_buffer->get_input_restart_mgt_info_file(), inout_interface->get_interface_name(), i, restart_field_name, fields_mem_registered[i]->get_field_name());
+    }
+    restart_buffer->load_restart_data(&current_remote_fields_elapsed_time, sizeof(long));
+    restart_buffer->load_restart_data(&last_remote_fields_time, sizeof(long));
+    fields_time_info_dst->import_restart_data(restart_buffer);
+    fields_time_info_src->import_restart_data(restart_buffer);
 }
 
 
 Inout_interface::Inout_interface(const char *temp_array_buffer, long &buffer_content_iter)
 {
-	int num_interfaces;
+    int num_interfaces;
 
 
-	interface_id = 0;
-	read_data_from_array_buffer(interface_name, NAME_STR_SIZE, temp_array_buffer, buffer_content_iter, true);
-	read_data_from_array_buffer(comp_full_name, NAME_STR_SIZE, temp_array_buffer, buffer_content_iter, true);
-	read_data_from_array_buffer(&interface_type, sizeof(int), temp_array_buffer, buffer_content_iter, true);
-	read_data_from_array_buffer(&num_interfaces, sizeof(int), temp_array_buffer, buffer_content_iter, true);
-	for (int i = 0; i < num_interfaces; i ++) {
-		fields_name.push_back(strdup(temp_array_buffer+buffer_content_iter-NAME_STR_SIZE));
-		buffer_content_iter -= NAME_STR_SIZE;
-	}
-	Comp_comm_group_mgt_node *comp_node = comp_comm_group_mgt_mgr->search_global_node(comp_full_name);
-	if (comp_node != NULL)
-		comp_id = comp_node->get_local_node_id();
-	else comp_id = -1;
+    interface_id = 0;
+    read_data_from_array_buffer(interface_name, NAME_STR_SIZE, temp_array_buffer, buffer_content_iter, true);
+    read_data_from_array_buffer(comp_full_name, NAME_STR_SIZE, temp_array_buffer, buffer_content_iter, true);
+    read_data_from_array_buffer(&interface_type, sizeof(int), temp_array_buffer, buffer_content_iter, true);
+    read_data_from_array_buffer(&num_interfaces, sizeof(int), temp_array_buffer, buffer_content_iter, true);
+    for (int i = 0; i < num_interfaces; i ++) {
+        fields_name.push_back(strdup(temp_array_buffer+buffer_content_iter-NAME_STR_SIZE));
+        buffer_content_iter -= NAME_STR_SIZE;
+    }
+    Comp_comm_group_mgt_node *comp_node = comp_comm_group_mgt_mgr->search_global_node(comp_full_name);
+    if (comp_node != NULL)
+        comp_id = comp_node->get_local_node_id();
+    else comp_id = -1;
 
-	restart_mgr = NULL;
-	inversed_dst_fraction = NULL;
+    restart_mgr = NULL;
+    inversed_dst_fraction = NULL;
 }
 
 
 Inout_interface::Inout_interface(const char *interface_name, int interface_id, int num_fields, int *field_ids_src, int *field_ids_dst, int timer_id, int inst_or_aver, int array_size_src, int array_size_dst, const char *API_label, const char *annotation)
 {
-	char child_interface_name[NAME_STR_SIZE];
+    char child_interface_name[NAME_STR_SIZE];
 
 
-	sprintf(child_interface_name, "%s_child_export", interface_name);
-	children_interfaces.push_back(new Inout_interface(child_interface_name, -1, 1, num_fields, field_ids_src, array_size_src, timer_id, inst_or_aver, "field_instance_IDs_source", annotation, API_ID_INTERFACE_REG_NORMAL_REMAP, INTERFACE_SOURCE_REGISTER, true));
-	sprintf(child_interface_name, "%s_child_import", interface_name);
-	children_interfaces.push_back(new Inout_interface(child_interface_name, -1, 0, num_fields, field_ids_dst, array_size_dst, timer_id, inst_or_aver, "field_instance_IDs_target", annotation, API_ID_INTERFACE_REG_NORMAL_REMAP, INTERFACE_SOURCE_REGISTER, true));
-	initialize_data(interface_name, interface_id, 2, timer_id, inst_or_aver, field_ids_src, INTERFACE_SOURCE_REGISTER, annotation);
-	this->timer->reset_remote_lag_count();
-	children_interfaces[0]->timer->reset_remote_lag_count();
-	children_interfaces[1]->timer->reset_remote_lag_count();
+    sprintf(child_interface_name, "%s_child_export", interface_name);
+    children_interfaces.push_back(new Inout_interface(child_interface_name, -1, 1, num_fields, field_ids_src, array_size_src, timer_id, inst_or_aver, "field_instance_IDs_source", annotation, API_ID_INTERFACE_REG_NORMAL_REMAP, INTERFACE_SOURCE_REGISTER, true));
+    sprintf(child_interface_name, "%s_child_import", interface_name);
+    children_interfaces.push_back(new Inout_interface(child_interface_name, -1, 0, num_fields, field_ids_dst, array_size_dst, timer_id, inst_or_aver, "field_instance_IDs_target", annotation, API_ID_INTERFACE_REG_NORMAL_REMAP, INTERFACE_SOURCE_REGISTER, true));
+    initialize_data(interface_name, interface_id, 2, timer_id, inst_or_aver, field_ids_src, INTERFACE_SOURCE_REGISTER, annotation);
+    this->timer->reset_remote_lag_count();
+    children_interfaces[0]->timer->reset_remote_lag_count();
+    children_interfaces[1]->timer->reset_remote_lag_count();
 
-	bool same_field_name = true;
-	for (int i = 0; i < num_fields; i ++)
-		same_field_name = same_field_name && words_are_the_same(memory_manager->get_field_instance(field_ids_src[i])->get_field_name(),memory_manager->get_field_instance(field_ids_dst[i])->get_field_name());	
-	EXECUTION_REPORT(REPORT_ERROR, comp_id, same_field_name, "Error happens when calling the API \"%s\" to register an interface named \"%s\": the field instances specified by the parameter \"field_instance_IDs_source\" are not consistent with the field instances specified by the parameter \"field_instance_IDs_target\" (the ith source field instance must have the same field name with the ith target field instance). Please check the model code with the annotation \"%s\".", API_label, interface_name, annotation);	
+    for (int i = 0; i < num_fields; i ++) {    
+        EXECUTION_REPORT(REPORT_ERROR, comp_id, words_are_the_same(memory_manager->get_field_instance(field_ids_src[i])->get_field_name(),memory_manager->get_field_instance(field_ids_dst[i])->get_field_name()), "Error happens when calling the API \"%s\" to register an interface named \"%s\": the number %d field instance (\"%s\") specified by the parameter \"field_instance_IDs_source\" are not consistent with the number %d field instance (\"%s\") specified by the parameter \"field_instance_IDs_target\" (a source field instance must have the same field name with the same number of target field instance). Please check the model code with the annotation \"%s\".", API_label, interface_name, i+1, memory_manager->get_field_instance(field_ids_src[i])->get_field_name(), i+1, memory_manager->get_field_instance(field_ids_dst[i])->get_field_name(), annotation);        
+        EXECUTION_REPORT(REPORT_ERROR, comp_id, memory_manager->get_field_instance(field_ids_src[i])->get_data_buf() != memory_manager->get_field_instance(field_ids_dst[i])->get_data_buf(), "Error happens when calling the API \"%s\" to register an interface named \"%s\": the number %d field instance (\"%s\") specified by the parameter \"field_instance_IDs_source\" have the same model data buffer with the number %d field instance (\"%s\") specified by the parameter \"field_instance_IDs_target\" (the source and target field instances may be the same), which is not allowed. Please check the model code with the annotation \"%s\".", API_label, interface_name, i+1, memory_manager->get_field_instance(field_ids_src[i])->get_field_name(), i+1, memory_manager->get_field_instance(field_ids_dst[i])->get_field_name(), annotation);
+    }
 }
 
 
 Inout_interface::Inout_interface(const char *interface_name, int interface_id, int interface_type, int num_fields, int *field_ids, int array_size, int timer_id, int inst_or_aver, const char *field_ids_parameter_name, const char *annotation, int API_id, int interface_source, bool is_child_interface)
 {
-	char API_label[NAME_STR_SIZE];
-
-
-	get_API_hint(-1, API_id, API_label);
-	
-	common_checking_for_interface_registration(num_fields, field_ids, array_size, timer_id, inst_or_aver, interface_type, interface_name, API_id, interface_source, field_ids_parameter_name, annotation);
-	initialize_data(interface_name, interface_id, interface_type, timer_id, inst_or_aver, field_ids, interface_source, annotation);
-	this->is_child_interface = is_child_interface;	
-	for (int i = 0; i < num_fields; i ++) {
-		Field_mem_info *field_instance = memory_manager->get_field_instance(field_ids[i]);
-		if (!is_child_interface)
-			EXECUTION_REPORT(REPORT_ERROR, comp_id, field_instance->is_CPL_field_inst(), "Error happens when calling the API \"%s\" to register an interface named \"%s\" at the model code with the annotation \"%s\": the field instance of \"%s\" cannot not be referred by an import/export interface because it has not been declared as a coupling field instance. Please check the parameter \"usage_tag\" when registerring this field instance (at the model code with the annotation \"%s\")", API_label, interface_name, annotation, field_instance->get_field_name(), annotation_mgr->get_annotation(field_instance->get_field_instance_id(), "allocate field instance"));
-		fields_mem_registered.push_back(field_instance);
-		fields_connected_status.push_back(false);
-		if (interface_type == COUPLING_INTERFACE_MARK_IMPORT && !is_child_interface)
-			restart_mgr->add_restarted_field_instances(fields_mem_registered[fields_mem_registered.size()-1]);
-	}
-	fields_connected_status.push_back(false);
-	num_fields_connected = 0;
+    char API_label[NAME_STR_SIZE];
+
+
+    get_API_hint(-1, API_id, API_label);
+    
+    common_checking_for_interface_registration(num_fields, field_ids, array_size, timer_id, inst_or_aver, interface_type, interface_name, API_id, interface_source, field_ids_parameter_name, annotation);
+    initialize_data(interface_name, interface_id, interface_type, timer_id, inst_or_aver, field_ids, interface_source, annotation);
+    this->is_child_interface = is_child_interface;    
+    for (int i = 0; i < num_fields; i ++) {
+        Field_mem_info *field_instance = memory_manager->get_field_instance(field_ids[i]);
+        if (!is_child_interface)
+            EXECUTION_REPORT(REPORT_ERROR, comp_id, field_instance->is_CPL_field_inst(), "Error happens when calling the API \"%s\" to register an interface named \"%s\" at the model code with the annotation \"%s\": the field instance of \"%s\" cannot not be referred by an import/export interface because it has not been declared as a coupling field instance. Please check the parameter \"usage_tag\" when registering this field instance (at the model code with the annotation \"%s\")", API_label, interface_name, annotation, field_instance->get_field_name(), annotation_mgr->get_annotation(field_instance->get_field_instance_id(), "allocate field instance"));
+        fields_mem_registered.push_back(field_instance);
+        fields_connected_status.push_back(false);
+		fields_coupling_procedures.push_back(NULL);
+        if (interface_type == COUPLING_INTERFACE_MARK_IMPORT && !is_child_interface)
+            restart_mgr->add_restarted_field_instance(fields_mem_registered[fields_mem_registered.size()-1], true);
+    }
+    fields_connected_status.push_back(false);
+    num_fields_connected = 0;
 }
 
 
 void Inout_interface::initialize_data(const char *interface_name, int interface_id, int interface_type, int timer_id, int inst_or_aver, int *field_ids, int interface_source, const char *annotation)
 {
-	this->interface_id = interface_id;
-	this->interface_type = interface_type;
-	this->execution_checking_status = 0;
-	this->last_execution_time = -1;
-	this->is_child_interface = false;
-	Coupling_timer *existing_timer = timer_mgr->get_timer(timer_id);
-	this->timer = new Coupling_timer(existing_timer->get_comp_id(), -1, existing_timer);
-	timer_mgr->add_timer(this->timer);
-	this->comp_id = this->timer->get_comp_id();
-	this->interface_source = interface_source;
-	this->inversed_dst_fraction = NULL;
-	strcpy(this->interface_name, interface_name);
-	strcpy(this->comp_full_name, comp_comm_group_mgt_mgr->get_global_node_of_local_comp(comp_id,false,"in Inout_interface::initialize_data")->get_full_name());
-	this->inst_or_aver = inst_or_aver;
-	annotation_mgr->add_annotation(interface_id, "registering interface", annotation);
-	time_mgr = components_time_mgrs->get_time_mgr(comp_id);
-	this->bypass_counter = 0;
-	this->mgt_info_has_been_restarted = false;
-	restart_mgr = comp_comm_group_mgt_mgr->search_global_node(comp_id)->get_restart_mgr();
+    this->interface_id = interface_id;
+    this->interface_type = interface_type;
+    this->execution_checking_status = 0;
+    this->last_execution_time = -1;
+    this->is_child_interface = false;
+    Coupling_timer *existing_timer = timer_mgr->get_timer(timer_id);
+    this->timer = new Coupling_timer(existing_timer->get_comp_id(), -1, existing_timer);
+    timer_mgr->add_timer(this->timer);
+    this->comp_id = this->timer->get_comp_id();
+    this->interface_source = interface_source;
+    this->inversed_dst_fraction = NULL;
+    strcpy(this->interface_name, interface_name);
+    strcpy(this->comp_full_name, comp_comm_group_mgt_mgr->get_global_node_of_local_comp(comp_id,false,"in Inout_interface::initialize_data")->get_full_name());
+    this->inst_or_aver = inst_or_aver;
+    annotation_mgr->add_annotation(interface_id, "registering interface", annotation);
+    time_mgr = components_time_mgrs->get_time_mgr(comp_id);
+    this->bypass_counter = 0;
+    this->mgt_info_has_been_restarted = false;
+    restart_mgr = comp_comm_group_mgt_mgr->search_global_node(comp_id)->get_restart_mgr();
 }
 
 
 Inout_interface::~Inout_interface()
 {
-	if (inversed_dst_fraction != NULL) {
-		EXECUTION_REPORT_LOG(REPORT_LOG, -1, true, "inout interface %s %lx release %lx", interface_name, this, inversed_dst_fraction);
-		delete [] inversed_dst_fraction;
-	}
+    if (inversed_dst_fraction != NULL) {
+        EXECUTION_REPORT_LOG(REPORT_LOG, -1, true, "inout interface %s %lx release %lx", interface_name, this, inversed_dst_fraction);
+        delete [] inversed_dst_fraction;
+    }
 
-	for (int i = 0; i < fields_name.size(); i ++)
-		delete [] fields_name[i];
+    for (int i = 0; i < fields_name.size(); i ++)
+        delete [] fields_name[i];
 
-	for (int i = 0; i < coupling_procedures.size(); i ++)
-		delete coupling_procedures[i];
+    for (int i = 0; i < coupling_procedures.size(); i ++)
+        delete coupling_procedures[i];
 
-	for (int i = 0; i < children_interfaces.size(); i ++)
-		delete children_interfaces[i];
+    for (int i = 0; i < children_interfaces.size(); i ++)
+        delete children_interfaces[i];
 }
 
 
 void Inout_interface::common_checking_for_interface_registration(int num_fields, int *field_ids, int array_size, int timer_id, int inst_or_aver, int interface_type, const char *interface_name, int API_id, int interface_source, const char *field_ids_parameter_name, const char *annotation)
 {
-	int comp_id = -1;
-	char str[NAME_STR_SIZE], API_label[NAME_STR_SIZE];
+    int comp_id = -1;
+    char str[NAME_STR_SIZE], API_label[NAME_STR_SIZE];
 
 
-	get_API_hint(-1, API_id, API_label);
-	
-	EXECUTION_REPORT(REPORT_ERROR, -1, num_fields > 0 && num_fields <= 1000, "Error happens when calling the API \"%s\" to register an interface named \"%s\": the parameter \"num_field_instances\" (currently is %d) cannot be smaller than 1 or larger than the maximum number (1000). Please verify the model code with the annotation \"%s\".", API_label, interface_name, num_fields, annotation);
-	EXECUTION_REPORT(REPORT_ERROR, -1, num_fields <= array_size, "Error happens when calling the API \"%s\" to register an interface named \"%s\": the array size (currently is %d) of parameter \"%s\" cannot be smaller than the parameter \"num_field_instances\" (currently is %d). Please verify the model code with the annotation \"%s\".", API_label, interface_name, num_fields, field_ids_parameter_name, array_size, annotation);
-	for (int i = 0; i < num_fields; i ++) {
-		if (interface_source != INTERFACE_SOURCE_IO_WRITE)
-			EXECUTION_REPORT(REPORT_ERROR, -1, memory_manager->check_is_legal_field_instance_id(field_ids[i]) && memory_manager->get_field_instance(field_ids[i])->get_is_registered_model_buf(), "Error happens when calling the API \"%s\" to register an interface named \"%s\": the parameter \"%s\" contains wrong field instance ID (the %dth element of the array is wrong). Please verify the model code related to the annotation \"%s\"", API_label, interface_name, field_ids_parameter_name, i+1, annotation);
-		if (i == 0)
-			comp_id = memory_manager->get_field_instance(field_ids[i])->get_comp_id();
-		EXECUTION_REPORT_ERROR_OPTIONALLY(REPORT_ERROR, comp_id, comp_id == memory_manager->get_field_instance(field_ids[i])->get_comp_id(), "Error happens when calling the API \"%s\" to register an interface named \"%s\": the field instances specified via the parameter \"%s\" should but not correspond to the same component model currently: the first field instance corresponds to the component model \"%s\" while the %dth field instance corresponds to the component model \"%s\". Please verify the model code with the annotation \"%s\".", API_label, interface_name, field_ids_parameter_name, comp_comm_group_mgt_mgr->get_global_node_of_local_comp(comp_id,false, "")->get_comp_full_name(), i+1, comp_comm_group_mgt_mgr->get_global_node_of_local_comp(memory_manager->get_field_instance(field_ids[i])->get_comp_id(),false, "")->get_comp_full_name(), annotation);
-	}
-	EXECUTION_REPORT(REPORT_ERROR, comp_id, timer_mgr->check_is_legal_timer_id(timer_id), "Error happens when calling the API \"%s\" to register an interface named \"%s\": the parameter \"timer_ID\" (currently is 0x%x) is not the legal ID of a timer. Please verify the model code related to the annotation \"%s\"", API_label, interface_name, timer_id, annotation);
-	EXECUTION_REPORT(REPORT_ERROR, comp_id, comp_id == timer_mgr->get_timer(timer_id)->get_comp_id(), "Error happens when calling the API \"%s\" to register an interface named \"%s\": the parameter \"timer_ID\" and the parameter \"%s\" do not correspond to the same component model (the parameter \"timer_ID\" corresponds to the component model \"%s\" while \"%s\" corresponds to the component model \"%s\"). Please verify the model code related to the annotation \"%s\"", API_label, interface_name, field_ids_parameter_name, comp_comm_group_mgt_mgr->get_global_node_of_local_comp(timer_mgr->get_timer(timer_id)->get_comp_id(),false, "")->get_comp_full_name(), field_ids_parameter_name, comp_comm_group_mgt_mgr->get_global_node_of_local_comp(comp_id,false, "")->get_comp_full_name(), annotation);
-	if (interface_source != INTERFACE_SOURCE_IO_WRITE && interface_type == COUPLING_INTERFACE_MARK_EXPORT)
-		for (int i = 0; i < num_fields; i ++) 
-			for (int j = i+1; j < num_fields; j ++)
-				EXECUTION_REPORT(REPORT_ERROR, comp_id, !words_are_the_same(memory_manager->get_field_instance(field_ids[i])->get_field_name(),memory_manager->get_field_instance(field_ids[j])->get_field_name()), "Error happens when calling the API \"%s\" to register an interface named \"%s\": the parameter \"%s\" is not allowed to include more than one instance of the same field (field \"%s\"). Please verify the model code related to the annotation \"%s\"", API_label, interface_name, field_ids_parameter_name, memory_manager->get_field_instance(field_ids[i])->get_field_name(), annotation);			
-
-	sprintf(str, "registerring an interface named \"%s\"", interface_name);
-	synchronize_comp_processes_for_API(comp_id, API_id, comp_comm_group_mgt_mgr->get_comm_group_of_local_comp(comp_id, "in Inout_interface::Inout_interface"), str, annotation);
-	
-	if (interface_source == INTERFACE_SOURCE_REGISTER)
-		comp_comm_group_mgt_mgr->confirm_coupling_configuration_active(comp_id, API_id, true, annotation);	
-	check_and_verify_name_format_of_string_for_API(comp_id, interface_name, API_id, "the interface", annotation);
-	check_API_parameter_string(comp_id, API_id, comp_comm_group_mgt_mgr->get_comm_group_of_local_comp(comp_id,"executing an import/export interface"), str, interface_name, "the corresponding interface name", annotation);
-	check_API_parameter_int(comp_id, API_id, comp_comm_group_mgt_mgr->get_comm_group_of_local_comp(comp_id,"in Inout_interface::Inout_interface"), NULL, num_fields, "num_field_instances", annotation);
-	sprintf(str, "\"%s\" (the information of the field instances)", field_ids_parameter_name);
-	for (int i = 0; i < num_fields; i ++)
-		check_API_parameter_field_instance(comp_id, API_id, comp_comm_group_mgt_mgr->get_comm_group_of_local_comp(comp_id, "in Inout_interface::Inout_interface"), "registerring an interface", field_ids[i], str, annotation);
-	check_API_parameter_timer(comp_id, API_id, comp_comm_group_mgt_mgr->get_comm_group_of_local_comp(comp_id, "in Inout_interface::Inout_interface"), "registerring an interface", timer_id, "timer_ID (the information of the timer)", annotation);
-	check_API_parameter_int(comp_id, API_id, comp_comm_group_mgt_mgr->get_comm_group_of_local_comp(comp_id, "in Inout_interface::Inout_interface"), "registerring an interface", inst_or_aver, "inst_or_aver (the tag for using instantaneous or time averaged field value)", annotation);
+    get_API_hint(-1, API_id, API_label);
+    
+    EXECUTION_REPORT(REPORT_ERROR, -1, num_fields > 0 && num_fields <= 1000, "Error happens when calling the API \"%s\" to register an interface named \"%s\": the parameter \"num_field_instances\" (currently is %d) cannot be smaller than 1 or larger than the maximum number (1000). Please verify the model code with the annotation \"%s\".", API_label, interface_name, num_fields, annotation);
+    EXECUTION_REPORT(REPORT_ERROR, -1, num_fields <= array_size, "Error happens when calling the API \"%s\" to register an interface named \"%s\": the array size (currently is %d) of parameter \"%s\" cannot be smaller than the parameter \"num_field_instances\" (currently is %d). Please verify the model code with the annotation \"%s\".", API_label, interface_name, num_fields, field_ids_parameter_name, array_size, annotation);
+    for (int i = 0; i < num_fields; i ++) {
+        if (interface_source != INTERFACE_SOURCE_IO_WRITE)
+            EXECUTION_REPORT(REPORT_ERROR, -1, memory_manager->check_is_legal_field_instance_id(field_ids[i]) && memory_manager->get_field_instance(field_ids[i])->get_is_registered_model_buf(), "Error happens when calling the API \"%s\" to register an interface named \"%s\": the parameter \"%s\" contains wrong field instance ID (the %dth element of the array is wrong). Please verify the model code related to the annotation \"%s\"", API_label, interface_name, field_ids_parameter_name, i+1, annotation);
+        if (i == 0)
+            comp_id = memory_manager->get_field_instance(field_ids[i])->get_comp_id();
+        EXECUTION_REPORT_ERROR_OPTIONALLY(REPORT_ERROR, comp_id, comp_id == memory_manager->get_field_instance(field_ids[i])->get_comp_id(), "Error happens when calling the API \"%s\" to register an interface named \"%s\": the field instances specified via the parameter \"%s\" should but not correspond to the same component model currently: the first field instance corresponds to the component model \"%s\" while the %dth field instance corresponds to the component model \"%s\". Please verify the model code with the annotation \"%s\".", API_label, interface_name, field_ids_parameter_name, comp_comm_group_mgt_mgr->get_global_node_of_local_comp(comp_id,false, "")->get_comp_full_name(), i+1, comp_comm_group_mgt_mgr->get_global_node_of_local_comp(memory_manager->get_field_instance(field_ids[i])->get_comp_id(),false, "")->get_comp_full_name(), annotation);
+    }
+    EXECUTION_REPORT(REPORT_ERROR, comp_id, timer_mgr->check_is_legal_timer_id(timer_id), "Error happens when calling the API \"%s\" to register an interface named \"%s\": the parameter \"timer_ID\" (currently is 0x%x) is not the legal ID of a timer. Please verify the model code related to the annotation \"%s\"", API_label, interface_name, timer_id, annotation);
+    EXECUTION_REPORT(REPORT_ERROR, comp_id, comp_id == timer_mgr->get_timer(timer_id)->get_comp_id(), "Error happens when calling the API \"%s\" to register an interface named \"%s\": the parameter \"timer_ID\" and the parameter \"%s\" do not correspond to the same component model (the parameter \"timer_ID\" corresponds to the component model \"%s\" while \"%s\" corresponds to the component model \"%s\"). Please verify the model code related to the annotation \"%s\"", API_label, interface_name, field_ids_parameter_name, comp_comm_group_mgt_mgr->get_global_node_of_local_comp(timer_mgr->get_timer(timer_id)->get_comp_id(),false, "")->get_comp_full_name(), field_ids_parameter_name, comp_comm_group_mgt_mgr->get_global_node_of_local_comp(comp_id,false, "")->get_comp_full_name(), annotation);
+    if (interface_source != INTERFACE_SOURCE_IO_WRITE && interface_type == COUPLING_INTERFACE_MARK_EXPORT)
+        for (int i = 0; i < num_fields; i ++) 
+            for (int j = i+1; j < num_fields; j ++)
+                EXECUTION_REPORT(REPORT_ERROR, comp_id, !words_are_the_same(memory_manager->get_field_instance(field_ids[i])->get_field_name(),memory_manager->get_field_instance(field_ids[j])->get_field_name()), "Error happens when calling the API \"%s\" to register an interface named \"%s\": the parameter \"%s\" is not allowed to include more than one instance of the same field (field \"%s\"). Please verify the model code related to the annotation \"%s\"", API_label, interface_name, field_ids_parameter_name, memory_manager->get_field_instance(field_ids[i])->get_field_name(), annotation);            
+
+    sprintf(str, "registering an interface named \"%s\"", interface_name);
+    synchronize_comp_processes_for_API(comp_id, API_id, comp_comm_group_mgt_mgr->get_comm_group_of_local_comp(comp_id, "in Inout_interface::Inout_interface"), str, annotation);
+    
+    if (interface_source == INTERFACE_SOURCE_REGISTER)
+        comp_comm_group_mgt_mgr->confirm_coupling_configuration_active(comp_id, API_id, true, annotation);    
+    check_and_verify_name_format_of_string_for_API(comp_id, interface_name, API_id, "the interface", annotation);
+    check_API_parameter_string(comp_id, API_id, comp_comm_group_mgt_mgr->get_comm_group_of_local_comp(comp_id,"executing an import/export interface"), str, interface_name, "the corresponding interface name", annotation);
+    check_API_parameter_int(comp_id, API_id, comp_comm_group_mgt_mgr->get_comm_group_of_local_comp(comp_id,"in Inout_interface::Inout_interface"), NULL, num_fields, "num_field_instances", annotation);
+    sprintf(str, "\"%s\" (the information of the field instances)", field_ids_parameter_name);
+    for (int i = 0; i < num_fields; i ++)
+        check_API_parameter_field_instance(comp_id, API_id, comp_comm_group_mgt_mgr->get_comm_group_of_local_comp(comp_id, "in Inout_interface::Inout_interface"), "registering an interface", field_ids[i], str, annotation);
+    check_API_parameter_timer(comp_id, API_id, comp_comm_group_mgt_mgr->get_comm_group_of_local_comp(comp_id, "in Inout_interface::Inout_interface"), "registering an interface", timer_id, "timer_ID (the information of the timer)", annotation);
+    check_API_parameter_int(comp_id, API_id, comp_comm_group_mgt_mgr->get_comm_group_of_local_comp(comp_id, "in Inout_interface::Inout_interface"), "registering an interface", inst_or_aver, "inst_or_aver (the tag for using instantaneous or time averaged field value)", annotation);
 }
 
 
 void Inout_interface::report_common_field_instances(const Inout_interface *another_interface)
 {
-	if (this->interface_source != INTERFACE_SOURCE_REGISTER || another_interface->interface_source != INTERFACE_SOURCE_REGISTER)
-		return;
+    if (this->interface_source != INTERFACE_SOURCE_REGISTER || another_interface->interface_source != INTERFACE_SOURCE_REGISTER)
+        return;
 
-	if (this->interface_type == COUPLING_INTERFACE_MARK_IMPORT && another_interface->interface_type == COUPLING_INTERFACE_MARK_IMPORT) {
-		for (int i = 0; i < this->fields_mem_registered.size(); i ++)
-			for (int j = 0; j < another_interface->fields_mem_registered.size(); j ++)
-				EXECUTION_REPORT(REPORT_ERROR, comp_id, this->fields_mem_registered[i]->get_data_buf() != another_interface->fields_mem_registered[j]->get_data_buf(), "Two import interfaces (\"%s\" and \"%s\") share the same data buffer of the field (field name is \"%s\") which is not allowed. Please check the model code with the annotation \"%s\" and \"%s\".",
-				                 this->interface_name, another_interface->interface_name, fields_mem_registered[i]->get_field_name(), annotation_mgr->get_annotation(this->interface_id, "registering interface"), annotation_mgr->get_annotation(another_interface->interface_id, "registering interface"));		
-		return;
-	}
+    if (this->interface_type == COUPLING_INTERFACE_MARK_IMPORT && another_interface->interface_type == COUPLING_INTERFACE_MARK_IMPORT) {
+        for (int i = 0; i < this->fields_mem_registered.size(); i ++)
+            for (int j = 0; j < another_interface->fields_mem_registered.size(); j ++)
+                EXECUTION_REPORT(REPORT_ERROR, comp_id, this->fields_mem_registered[i]->get_data_buf() != another_interface->fields_mem_registered[j]->get_data_buf(), "Two import interfaces (\"%s\" and \"%s\") share the same data buffer of the field (field name is \"%s\") which is not allowed. Please check the model code with the annotation \"%s\" and \"%s\".",
+                                 this->interface_name, another_interface->interface_name, fields_mem_registered[i]->get_field_name(), annotation_mgr->get_annotation(this->interface_id, "registering interface"), annotation_mgr->get_annotation(another_interface->interface_id, "registering interface"));        
+        return;
+    }
 
-	if (this->interface_type != COUPLING_INTERFACE_MARK_EXPORT || another_interface->interface_type != COUPLING_INTERFACE_MARK_EXPORT)
-		return;
+    if (this->interface_type != COUPLING_INTERFACE_MARK_EXPORT || another_interface->interface_type != COUPLING_INTERFACE_MARK_EXPORT)
+        return;
 
-	for (int i = 0; i < this->fields_mem_registered.size(); i ++)
-		for (int j = 0; j < another_interface->fields_mem_registered.size(); j ++)
-			EXECUTION_REPORT(REPORT_ERROR, comp_id, !words_are_the_same(this->fields_mem_registered[i]->get_field_name(), another_interface->fields_mem_registered[j]->get_field_name()), "Two export interfaces (\"%s\" and \"%s\") provide the same field (field name is \"%s\") which is not allowed. Please check the model code with the annotation \"%s\" and \"%s\".",
-			                 this->interface_name, another_interface->interface_name, fields_mem_registered[i]->get_field_name(), annotation_mgr->get_annotation(this->interface_id, "registering interface"), annotation_mgr->get_annotation(another_interface->interface_id, "registering interface"));
+    for (int i = 0; i < this->fields_mem_registered.size(); i ++)
+        for (int j = 0; j < another_interface->fields_mem_registered.size(); j ++)
+            EXECUTION_REPORT(REPORT_ERROR, comp_id, !words_are_the_same(this->fields_mem_registered[i]->get_field_name(), another_interface->fields_mem_registered[j]->get_field_name()), "Two export interfaces (\"%s\" and \"%s\") provide the same field (field name is \"%s\") which is not allowed. Please check the model code with the annotation \"%s\" and \"%s\".",
+                             this->interface_name, another_interface->interface_name, fields_mem_registered[i]->get_field_name(), annotation_mgr->get_annotation(this->interface_id, "registering interface"), annotation_mgr->get_annotation(another_interface->interface_id, "registering interface"));
 }
 
 
 void Inout_interface::get_fields_name(std::vector<const char*> *fields_name)
 {
-	if (this->fields_mem_registered.size() > 0) {
-		for (int i = 0; i < this->fields_mem_registered.size(); i ++)
-			fields_name->push_back(this->fields_mem_registered[i]->get_field_name());
-	}
-	else {
-		for (int i = 0; i < this->fields_name.size(); i ++)
-			fields_name->push_back(this->fields_name[i]);
-	}
+    if (this->fields_mem_registered.size() > 0) {
+        for (int i = 0; i < this->fields_mem_registered.size(); i ++)
+            fields_name->push_back(this->fields_mem_registered[i]->get_field_name());
+    }
+    else {
+        for (int i = 0; i < this->fields_name.size(); i ++)
+            fields_name->push_back(this->fields_name[i]);
+    }
 }
 
 
 const char *Inout_interface::get_field_name(int number)
 {
-	if (number >= fields_name.size() && number >= fields_mem_registered.size())
-		return NULL;
+    if (number >= fields_name.size() && number >= fields_mem_registered.size())
+        return NULL;
 
-	if (number < fields_name.size())
-		return fields_name[number];
+    if (number < fields_name.size())
+        return fields_name[number];
 
-	return fields_mem_registered[number]->get_field_name();
+    return fields_mem_registered[number]->get_field_name();
 }
 
 
 int Inout_interface::get_num_dst_fields()
 {
-	if (interface_type == COUPLING_INTERFACE_MARK_IMPORT)
-		return fields_mem_registered.size();
-	if (interface_type == COUPLING_INTERFACE_MARK_EXPORT)
-		return 0;
-	if (interface_type == COUPLING_INTERFACE_MARK_NORMAL_REMAP)
-		return children_interfaces[1]->fields_mem_registered.size();
-	if (interface_type == COUPLING_INTERFACE_MARK_FRAC_REMAP)
-		return children_interfaces[1]->fields_mem_registered.size() - 1;
-	
-	return -1;
+    if (interface_type == COUPLING_INTERFACE_MARK_IMPORT)
+        return fields_mem_registered.size();
+    if (interface_type == COUPLING_INTERFACE_MARK_EXPORT)
+        return 0;
+    if (interface_type == COUPLING_INTERFACE_MARK_NORMAL_REMAP)
+        return children_interfaces[1]->fields_mem_registered.size();
+    if (interface_type == COUPLING_INTERFACE_MARK_FRAC_REMAP)
+        return children_interfaces[1]->fields_mem_registered.size() - 1;
+    
+    return -1;
 }
 
 
 Field_mem_info *Inout_interface::search_registered_field_instance(const char *field_name, int &field_local_index)
 {
-	field_local_index = -1;
-	for (int i = 0; i < fields_mem_registered.size(); i ++)
-		if (words_are_the_same(fields_mem_registered[i]->get_field_name(), field_name)) {
-			field_local_index = i;
-			return fields_mem_registered[i];
-		}
+    field_local_index = -1;
+    for (int i = 0; i < fields_mem_registered.size(); i ++)
+        if (words_are_the_same(fields_mem_registered[i]->get_field_name(), field_name)) {
+            field_local_index = i;
+            return fields_mem_registered[i];
+        }
 
-	return NULL;
+    return NULL;
 }
 
 
 void Inout_interface::transform_interface_into_array(char **temp_array_buffer, long &buffer_max_size, long &buffer_content_size)
 {
-	int temp_int = 0;
+    int temp_int = 0;
 
 
-	if (interface_type == COUPLING_INTERFACE_MARK_IMPORT && num_fields_connected == fields_mem_registered.size())
-		return;
-	
-	for (int i = fields_mem_registered.size()-1; i >= 0 ; i --) {
-		if (interface_type == COUPLING_INTERFACE_MARK_IMPORT && fields_connected_status[i])
-			continue;
-		write_data_into_array_buffer(fields_mem_registered[i]->get_field_name(), NAME_STR_SIZE, temp_array_buffer, buffer_max_size, buffer_content_size);
-		temp_int ++;
-	}
-	write_data_into_array_buffer(&temp_int, sizeof(int), temp_array_buffer, buffer_max_size, buffer_content_size);
-	write_data_into_array_buffer(&interface_type, sizeof(int), temp_array_buffer, buffer_max_size, buffer_content_size);
-	write_data_into_array_buffer(comp_full_name, NAME_STR_SIZE, temp_array_buffer, buffer_max_size, buffer_content_size);
-	write_data_into_array_buffer(interface_name, NAME_STR_SIZE, temp_array_buffer, buffer_max_size, buffer_content_size);
+    if (interface_type == COUPLING_INTERFACE_MARK_IMPORT && num_fields_connected == fields_mem_registered.size())
+        return;
+    
+    for (int i = fields_mem_registered.size()-1; i >= 0 ; i --) {
+        if (interface_type == COUPLING_INTERFACE_MARK_IMPORT && fields_connected_status[i])
+            continue;
+        write_data_into_array_buffer(fields_mem_registered[i]->get_field_name(), NAME_STR_SIZE, temp_array_buffer, buffer_max_size, buffer_content_size);
+        temp_int ++;
+    }
+    write_data_into_array_buffer(&temp_int, sizeof(int), temp_array_buffer, buffer_max_size, buffer_content_size);
+    write_data_into_array_buffer(&interface_type, sizeof(int), temp_array_buffer, buffer_max_size, buffer_content_size);
+    write_data_into_array_buffer(comp_full_name, NAME_STR_SIZE, temp_array_buffer, buffer_max_size, buffer_content_size);
+    write_data_into_array_buffer(interface_name, NAME_STR_SIZE, temp_array_buffer, buffer_max_size, buffer_content_size);
 }
 
 
 void Inout_interface::write_restart_mgt_info(Restart_buffer_container *restart_buffer)
 {
-	if (restart_buffer == NULL)
-		restart_buffer = restart_mgr->apply_restart_buffer(comp_full_name, RESTART_BUF_TYPE_INTERFACE, interface_name);
+    if (restart_buffer == NULL)
+        restart_buffer = restart_mgr->apply_restart_buffer(comp_full_name, RESTART_BUF_TYPE_INTERFACE, interface_name);
 
-	for (int i = coupling_procedures.size() - 1; i >= 0; i --)
-		coupling_procedures[i]->write_restart_mgt_info(restart_buffer);
-	int temp_int = coupling_procedures.size();
-	restart_buffer->dump_in_data(&temp_int, sizeof(int));
-	for (int i = children_interfaces.size()-1; i >= 0; i --)
-		children_interfaces[i]->write_restart_mgt_info(restart_buffer);
-	temp_int = children_interfaces.size();
-	restart_buffer->dump_in_data(&temp_int, sizeof(int));
-	restart_buffer->dump_in_data(&last_execution_time, sizeof(long));
-	timer->write_timer_into_array(restart_buffer->get_buffer_content_ptr(), *(restart_buffer->get_buffer_max_size_ptr()), *(restart_buffer->get_buffer_content_iter_ptr()));
+    for (int i = coupling_procedures.size() - 1; i >= 0; i --)
+        coupling_procedures[i]->write_restart_mgt_info(restart_buffer);
+    int temp_int = coupling_procedures.size();
+    restart_buffer->dump_in_data(&temp_int, sizeof(int));
+    for (int i = children_interfaces.size()-1; i >= 0; i --)
+        children_interfaces[i]->write_restart_mgt_info(restart_buffer);
+    temp_int = children_interfaces.size();
+    restart_buffer->dump_in_data(&temp_int, sizeof(int));
+    restart_buffer->dump_in_data(&last_execution_time, sizeof(long));
+    timer->write_timer_into_array(restart_buffer->get_buffer_content_ptr(), *(restart_buffer->get_buffer_max_size_ptr()), *(restart_buffer->get_buffer_content_iter_ptr()));
 }
 
 
 void Inout_interface::import_restart_data(Restart_buffer_container *restart_buffer)
 {
-	int num_children, num_procedures;
-	bool successful;
+    int num_children, num_procedures;
+    bool successful;
 
-	if (restart_buffer == NULL)
-		restart_buffer = restart_mgr->search_restart_buffer(RESTART_BUF_TYPE_INTERFACE, interface_name); 
-	EXECUTION_REPORT(REPORT_ERROR, restart_mgr->get_comp_id(), restart_buffer != NULL, "Error happens when loading the restart data file \"%s\" at the model code with the annotation \"%s\": this file does not include the data for restarting the interface \"%s\"", restart_mgr->get_input_restart_mgt_info_file(), restart_mgr->get_restart_read_annotation(), interface_name);
-	Coupling_timer *restart_timer = new Coupling_timer(restart_buffer->get_buffer_content(), *(restart_buffer->get_buffer_content_iter_ptr()), comp_id, false, successful);
-	EXECUTION_REPORT(REPORT_ERROR, -1, successful, "Fail to load the restart data file \"%s\": its format is wrong, or the information it includes is not complete. Please try a different restart time with complete restart data files.", restart_mgr->get_input_restart_mgt_info_file());
-	EXECUTION_REPORT(REPORT_ERROR, comp_id, restart_timer->is_the_same_with(timer), "Error happens when loading the restart data file \"%s\": the timer of the interface \"%s\" in the restart data file is different from the current timer speicifed by the model code. Please verify.", restart_mgr->get_input_restart_mgt_info_file(), interface_name);
-	restart_buffer->load_restart_data(&last_execution_time, sizeof(long));
-	restart_buffer->load_restart_data(&num_children, sizeof(int));
-	EXECUTION_REPORT(REPORT_ERROR, get_comp_id(), num_children == children_interfaces.size(), "Error happens when loading the restart data file \"%s\": it does not match the configuration of the interface \"%s\". Please check.", restart_mgr->get_input_restart_mgt_info_file(), get_interface_name());
-	for (int i = 0; i < num_children; i ++)
-		children_interfaces[i]->import_restart_data(restart_buffer);
-	restart_buffer->load_restart_data(&num_procedures, sizeof(int));
-	EXECUTION_REPORT(REPORT_ERROR, get_comp_id(), num_procedures == coupling_procedures.size(), "Error happens when loading the restart data file \"%s\": it does not match the configuration of the interface \"%s\". Please check.", restart_mgr->get_input_restart_mgt_info_file(), get_interface_name());
-	for (int i = 0; i < num_procedures; i ++)
-		coupling_procedures[i]->import_restart_data(restart_buffer);
+    if (restart_buffer == NULL)
+        restart_buffer = restart_mgr->search_restart_buffer(RESTART_BUF_TYPE_INTERFACE, interface_name); 
+    EXECUTION_REPORT(REPORT_ERROR, restart_mgr->get_comp_id(), restart_buffer != NULL, "Error happens when loading the restart data file \"%s\" at the model code with the annotation \"%s\": this file does not include the data for restarting the interface \"%s\"", restart_mgr->get_input_restart_mgt_info_file(), restart_mgr->get_restart_read_annotation(), interface_name);
+    Coupling_timer *restart_timer = new Coupling_timer(restart_buffer->get_buffer_content(), *(restart_buffer->get_buffer_content_iter_ptr()), comp_id, false, successful);
+    EXECUTION_REPORT(REPORT_ERROR, -1, successful, "Fail to load the restart data file \"%s\": its format is wrong, or the information it includes is not complete. Please try a different restart time with complete restart data files.", restart_mgr->get_input_restart_mgt_info_file());
+    EXECUTION_REPORT(REPORT_ERROR, comp_id, restart_timer->is_the_same_with(timer), "Error happens when loading the restart data file \"%s\": the timer of the interface \"%s\" in the restart data file is different from the current timer speicifed by the model code. Please verify.", restart_mgr->get_input_restart_mgt_info_file(), interface_name);
+    restart_buffer->load_restart_data(&last_execution_time, sizeof(long));
+    restart_buffer->load_restart_data(&num_children, sizeof(int));
+    EXECUTION_REPORT(REPORT_ERROR, get_comp_id(), num_children == children_interfaces.size(), "Error happens when loading the restart data file \"%s\": it does not match the configuration of the interface \"%s\". Please check.", restart_mgr->get_input_restart_mgt_info_file(), get_interface_name());
+    for (int i = 0; i < num_children; i ++)
+        children_interfaces[i]->import_restart_data(restart_buffer);
+    restart_buffer->load_restart_data(&num_procedures, sizeof(int));
+    EXECUTION_REPORT(REPORT_ERROR, get_comp_id(), num_procedures == coupling_procedures.size(), "Error happens when loading the restart data file \"%s\": it does not match the configuration of the interface \"%s\". Please check.", restart_mgr->get_input_restart_mgt_info_file(), get_interface_name());
+    for (int i = 0; i < num_procedures; i ++)
+        coupling_procedures[i]->import_restart_data(restart_buffer);
 }
 
 
 void Inout_interface::read_restart_fields(int API_id, const char *annotation)
 {
-	char API_label[NAME_STR_SIZE];
+    char API_label[NAME_STR_SIZE];
 
 
-	if (time_mgr->get_runtype_mark() == RUNTYPE_MARK_INITIAL)
-		return;
+    if (time_mgr->get_runtype_mark() == RUNTYPE_MARK_INITIAL)
+        return;
 
-	get_API_hint(comp_id, API_id, API_label);
+    get_API_hint(comp_id, API_id, API_label);
 
-	EXECUTION_REPORT(REPORT_ERROR, comp_id, restart_mgr->get_restart_read_data_file_name() != NULL, "Error happens when calling the API \"%s\" to read restart fields: the API \"CCPL_start_restart_read_IO\" has not been called before. Please verify the model code corresponding to the annotation %s", API_label, annotation);
-	EXECUTION_REPORT(REPORT_ERROR, comp_id, !time_mgr->get_time_has_been_advanced(), "Error happens when calling the API \"%s\" to read restart fields: the model time has already been advanced before. Please verify the model code corresponding to the annotation %s", API_label, annotation);
-	EXECUTION_REPORT(REPORT_ERROR, comp_id, interface_type == COUPLING_INTERFACE_MARK_IMPORT, "Error happens when calling the API \"CCPL_restart_read_fields_interface\": the corresponding coupling interface \"%s\" is not an import interface (this API only reads restart fields for import interfaces). Please verify the model code with the annotation \"%s\"", interface_name, annotation);
-	EXECUTION_REPORT(REPORT_ERROR, comp_id, (execution_checking_status & 0x2) == 0, "Error happens when calling the API \"CCPL_restart_read_fields_interface\": the corresponding import interface \"%s\" has been executed without bypassing the timer. Please verify the model code with the annotation \"%s\"", interface_name, annotation);
-	synchronize_comp_processes_for_API(comp_id, API_id, comp_comm_group_mgt_mgr->get_comm_group_of_local_comp(comp_id, ""), "read restart fields for the given coupling interface", annotation);
-	for (int i = 0; i < fields_mem_registered.size(); i ++)
-		restart_mgr->read_restart_field_data(fields_mem_registered[i], NULL, NULL, false, NULL, annotation);
+    EXECUTION_REPORT(REPORT_ERROR, comp_id, restart_mgr->get_restart_read_data_file_name() != NULL, "Error happens when calling the API \"%s\" to read restart fields: the API \"CCPL_start_restart_read_IO\" has not been called before. Please verify the model code corresponding to the annotation %s", API_label, annotation);
+    EXECUTION_REPORT(REPORT_ERROR, comp_id, !time_mgr->get_time_has_been_advanced(), "Error happens when calling the API \"%s\" to read restart fields: the model time has already been advanced before. Please verify the model code corresponding to the annotation %s", API_label, annotation);
+    EXECUTION_REPORT(REPORT_ERROR, comp_id, interface_type == COUPLING_INTERFACE_MARK_IMPORT, "Error happens when calling the API \"CCPL_restart_read_fields_interface\": the corresponding coupling interface \"%s\" is not an import interface (this API only reads restart fields for import interfaces). Please verify the model code with the annotation \"%s\"", interface_name, annotation);
+    EXECUTION_REPORT(REPORT_ERROR, comp_id, (execution_checking_status & 0x2) == 0, "Error happens when calling the API \"CCPL_restart_read_fields_interface\": the corresponding import interface \"%s\" has been executed without bypassing the timer. Please verify the model code with the annotation \"%s\"", interface_name, annotation);
+    synchronize_comp_processes_for_API(comp_id, API_id, comp_comm_group_mgt_mgr->get_comm_group_of_local_comp(comp_id, ""), "read restart fields for the given coupling interface", annotation);
+    for (int i = 0; i < fields_mem_registered.size(); i ++)
+        restart_mgr->read_restart_field_data(fields_mem_registered[i], NULL, NULL, false, NULL, restart_mgr->get_bypass_import_fields_at_read(), annotation);
 }
 
 
 void Inout_interface::add_coupling_procedure(Connection_coupling_procedure *coupling_procedure)
 {
-	coupling_procedures.push_back(coupling_procedure);
-	if (interface_type == COUPLING_INTERFACE_MARK_IMPORT || interface_type == COUPLING_INTERFACE_MARK_EXPORT) {
-		EXECUTION_REPORT(REPORT_ERROR, -1, fields_connected_status.size() > 0, "Software error in Inout_interface::add_coupling_procedure: %s", interface_name);
-		for (int i = 0; i < coupling_procedure->fields_mem_registered.size(); i ++)
-			for (int j = 0; j < fields_mem_registered.size(); j ++)
-				if (coupling_procedure->fields_mem_registered[i] == fields_mem_registered[j]) {
-					EXECUTION_REPORT_LOG(REPORT_LOG, comp_id, true, "Add coupling procedures to the field \"%s\" of import/export interface \"%s", fields_mem_registered[j]->get_field_name(), interface_name);
-					if (interface_type == COUPLING_INTERFACE_MARK_IMPORT)
-						EXECUTION_REPORT(REPORT_ERROR, -1, !fields_connected_status[j], "Software error in Inout_interface::add_coupling_procedure: %s %s %d", interface_name, fields_mem_registered[j]->get_field_name(), j);
-					if (!fields_connected_status[i])
-						num_fields_connected ++;
-					fields_connected_status[j] = true;
-				}
-	}
+    coupling_procedures.push_back(coupling_procedure);
+    if (interface_type == COUPLING_INTERFACE_MARK_IMPORT || interface_type == COUPLING_INTERFACE_MARK_EXPORT) {
+        EXECUTION_REPORT(REPORT_ERROR, -1, fields_connected_status.size() > 0, "Software error in Inout_interface::add_coupling_procedure: %s", interface_name);
+        for (int i = 0; i < coupling_procedure->fields_mem_registered.size(); i ++)
+            for (int j = 0; j < fields_mem_registered.size(); j ++)
+                if (coupling_procedure->fields_mem_registered[i] == fields_mem_registered[j]) {
+                    EXECUTION_REPORT_LOG(REPORT_LOG, comp_id, true, "Add coupling procedures to the field \"%s\" of import/export interface \"%s", fields_mem_registered[j]->get_field_name(), interface_name);
+                    if (interface_type == COUPLING_INTERFACE_MARK_IMPORT)
+                        EXECUTION_REPORT(REPORT_ERROR, -1, !fields_connected_status[j], "Software error in Inout_interface::add_coupling_procedure: %s %s %d", interface_name, fields_mem_registered[j]->get_field_name(), j);
+                    if (!fields_connected_status[i])
+                        num_fields_connected ++;
+                    fields_connected_status[j] = true;
+					fields_coupling_procedures[j] = coupling_procedure;
+                }
+    }
 }
 
 
 void Inout_interface::preprocessing_for_frac_based_remapping()
 {
-	EXECUTION_REPORT_LOG(REPORT_LOG, comp_id, true, "Pre-process the fraction");
+    EXECUTION_REPORT_LOG(REPORT_LOG, comp_id, true, "Pre-process the fraction");
 
-	for (int i = 0; i < fields_mem_registered.size()-1; i ++) {
-		EXECUTION_REPORT_ERROR_OPTIONALLY(REPORT_ERROR, -1, fields_mem_registered[i] != children_interfaces[0]->fields_mem_registered[i], "Software error1 in Inout_interface::preprocessing_for_frac_based_remapping");		
-		EXECUTION_REPORT_ERROR_OPTIONALLY(REPORT_ERROR, -1, fields_mem_registered[i] != children_interfaces[0]->fields_mem_registered[i], "Software error2 in Inout_interface::preprocessing_for_frac_based_remapping");
-	}
-	
-	for (int i = 0; i < fields_mem_registered.size()-1; i ++) {
-		if (words_are_the_same(fields_mem_registered[i]->get_data_type(), DATA_TYPE_FLOAT))
-			if (words_are_the_same(fields_mem_registered[fields_mem_registered.size()-1]->get_data_type(), DATA_TYPE_FLOAT))
-				arrays_multiplication_template((float*)fields_mem_registered[i]->get_data_buf(), (float*)fields_mem_registered[fields_mem_registered.size()-1]->get_data_buf(), (float*)children_interfaces[0]->fields_mem_registered[i]->get_data_buf(), fields_mem_registered[i]->get_size_of_field());
-			else arrays_multiplication_template((float*)fields_mem_registered[i]->get_data_buf(), (double*)fields_mem_registered[fields_mem_registered.size()-1]->get_data_buf(), (float*)children_interfaces[0]->fields_mem_registered[i]->get_data_buf(), fields_mem_registered[i]->get_size_of_field());
-		else if (words_are_the_same(fields_mem_registered[fields_mem_registered.size()-1]->get_data_type(), DATA_TYPE_FLOAT))
-			arrays_multiplication_template((double*)fields_mem_registered[i]->get_data_buf(), (float*)fields_mem_registered[fields_mem_registered.size()-1]->get_data_buf(), (double*)children_interfaces[0]->fields_mem_registered[i]->get_data_buf(), fields_mem_registered[i]->get_size_of_field());
-		else arrays_multiplication_template((double*)fields_mem_registered[i]->get_data_buf(), (double*)fields_mem_registered[fields_mem_registered.size()-1]->get_data_buf(), (double*)children_interfaces[0]->fields_mem_registered[i]->get_data_buf(), fields_mem_registered[i]->get_size_of_field());
-		children_interfaces[0]->fields_mem_registered[i]->define_field_values(false);
-	}	
+    for (int i = 0; i < fields_mem_registered.size()-1; i ++) {
+        EXECUTION_REPORT_ERROR_OPTIONALLY(REPORT_ERROR, -1, fields_mem_registered[i] != children_interfaces[0]->fields_mem_registered[i], "Software error1 in Inout_interface::preprocessing_for_frac_based_remapping");        
+        EXECUTION_REPORT_ERROR_OPTIONALLY(REPORT_ERROR, -1, fields_mem_registered[i] != children_interfaces[0]->fields_mem_registered[i], "Software error2 in Inout_interface::preprocessing_for_frac_based_remapping");
+    }
+    
+    for (int i = 0; i < fields_mem_registered.size()-1; i ++) {
+        if (words_are_the_same(fields_mem_registered[i]->get_data_type(), DATA_TYPE_FLOAT))
+            if (words_are_the_same(fields_mem_registered[fields_mem_registered.size()-1]->get_data_type(), DATA_TYPE_FLOAT))
+                arrays_multiplication_template((float*)fields_mem_registered[i]->get_data_buf(), (float*)fields_mem_registered[fields_mem_registered.size()-1]->get_data_buf(), (float*)children_interfaces[0]->fields_mem_registered[i]->get_data_buf(), fields_mem_registered[i]->get_size_of_field());
+            else arrays_multiplication_template((float*)fields_mem_registered[i]->get_data_buf(), (double*)fields_mem_registered[fields_mem_registered.size()-1]->get_data_buf(), (float*)children_interfaces[0]->fields_mem_registered[i]->get_data_buf(), fields_mem_registered[i]->get_size_of_field());
+        else if (words_are_the_same(fields_mem_registered[fields_mem_registered.size()-1]->get_data_type(), DATA_TYPE_FLOAT))
+            arrays_multiplication_template((double*)fields_mem_registered[i]->get_data_buf(), (float*)fields_mem_registered[fields_mem_registered.size()-1]->get_data_buf(), (double*)children_interfaces[0]->fields_mem_registered[i]->get_data_buf(), fields_mem_registered[i]->get_size_of_field());
+        else arrays_multiplication_template((double*)fields_mem_registered[i]->get_data_buf(), (double*)fields_mem_registered[fields_mem_registered.size()-1]->get_data_buf(), (double*)children_interfaces[0]->fields_mem_registered[i]->get_data_buf(), fields_mem_registered[i]->get_size_of_field());
+        children_interfaces[0]->fields_mem_registered[i]->define_field_values(false);
+    }    
 }
 
 
 void Inout_interface::postprocessing_for_frac_based_remapping(bool bypass_timer)
 {
-	Field_mem_info *dst_value_field, *dst_frac_field;
+    Field_mem_info *dst_value_field, *dst_frac_field;
 
 
-	if (children_interfaces[1]->coupling_procedures[0]->get_runtime_remap_algorithm(0) == NULL) {
-		EXECUTION_REPORT_LOG(REPORT_LOG, comp_id, true, "Does not post-process the fraction becase the runtime alogrithm is NULL");		
-		return;
-	}
-	
-	if (!timer->is_timer_on() && !bypass_timer)
-		return;
+    if (children_interfaces[1]->coupling_procedures[0]->get_runtime_remap_algorithm(0) == NULL) {
+        EXECUTION_REPORT_LOG(REPORT_LOG, comp_id, true, "Does not post-process the fraction becase the runtime alogrithm is NULL");        
+        return;
+    }
+    
+    if (!timer->is_timer_on() && !bypass_timer)
+        return;
 
-	EXECUTION_REPORT_LOG(REPORT_LOG, comp_id, true, "Post-process the fraction"); 	
+    EXECUTION_REPORT_LOG(REPORT_LOG, comp_id, true, "Post-process the fraction");     
 
-	dst_frac_field = children_interfaces[1]->fields_mem_registered[fields_mem_registered.size()-1];
+    dst_frac_field = children_interfaces[1]->fields_mem_registered[fields_mem_registered.size()-1];
 
-	if (words_are_the_same(dst_frac_field->get_data_type(), DATA_TYPE_FLOAT)) {
-		float *dst_frac_buf = (float*)dst_frac_field->get_data_buf();
-		for (int i = dst_frac_field->get_size_of_field()-1; i >= 0; i --)
-			if (dst_frac_buf[i] == (float) 0.0)
-				((float*) inversed_dst_fraction)[i] = dst_frac_buf[i];
-			else ((float*) inversed_dst_fraction)[i] = ((float)1.0) / dst_frac_buf[i];	
-	}
-	else {
-		double *dst_frac_buf = (double*)dst_frac_field->get_data_buf();
-		for (int i = dst_frac_field->get_size_of_field()-1; i >= 0; i --)
-			if (dst_frac_buf[i] == (double) 0.0)
-				((double*) inversed_dst_fraction)[i] = dst_frac_buf[i];
-			else ((double*) inversed_dst_fraction)[i] = ((double)1.0) / dst_frac_buf[i];	
-	}
-	
-	for (int i = 0; i < fields_mem_registered.size()-1; i ++) {
-		dst_value_field = children_interfaces[1]->fields_mem_registered[i];
-		if (words_are_the_same(dst_value_field->get_data_type(), DATA_TYPE_FLOAT))
-			if (words_are_the_same(dst_frac_field->get_data_type(), DATA_TYPE_FLOAT))
-				arrays_multiplication_template((float*)dst_value_field->get_data_buf(), (float*)inversed_dst_fraction, (float*)dst_value_field->get_data_buf(), dst_frac_field->get_size_of_field());
-			else arrays_multiplication_template((float*)dst_value_field->get_data_buf(), (double*)inversed_dst_fraction, (float*)dst_value_field->get_data_buf(), dst_frac_field->get_size_of_field());
-		else if (words_are_the_same(dst_frac_field->get_data_type(), DATA_TYPE_FLOAT))
-			arrays_multiplication_template((double*)dst_value_field->get_data_buf(), (float*)inversed_dst_fraction, (double*)dst_value_field->get_data_buf(), dst_frac_field->get_size_of_field());
-		else arrays_multiplication_template((double*)dst_value_field->get_data_buf(), (double*)inversed_dst_fraction, (double*)dst_value_field->get_data_buf(), dst_frac_field->get_size_of_field());
-	}	
+    if (words_are_the_same(dst_frac_field->get_data_type(), DATA_TYPE_FLOAT)) {
+        float *dst_frac_buf = (float*)dst_frac_field->get_data_buf();
+        for (int i = dst_frac_field->get_size_of_field()-1; i >= 0; i --)
+            if (dst_frac_buf[i] == (float) 0.0)
+                ((float*) inversed_dst_fraction)[i] = dst_frac_buf[i];
+            else ((float*) inversed_dst_fraction)[i] = ((float)1.0) / dst_frac_buf[i];    
+    }
+    else {
+        double *dst_frac_buf = (double*)dst_frac_field->get_data_buf();
+        for (int i = dst_frac_field->get_size_of_field()-1; i >= 0; i --)
+            if (dst_frac_buf[i] == (double) 0.0)
+                ((double*) inversed_dst_fraction)[i] = dst_frac_buf[i];
+            else ((double*) inversed_dst_fraction)[i] = ((double)1.0) / dst_frac_buf[i];    
+    }
+    
+    for (int i = 0; i < fields_mem_registered.size()-1; i ++) {
+        dst_value_field = children_interfaces[1]->fields_mem_registered[i];
+        if (words_are_the_same(dst_value_field->get_data_type(), DATA_TYPE_FLOAT))
+            if (words_are_the_same(dst_frac_field->get_data_type(), DATA_TYPE_FLOAT))
+                arrays_multiplication_template((float*)dst_value_field->get_data_buf(), (float*)inversed_dst_fraction, (float*)dst_value_field->get_data_buf(), dst_frac_field->get_size_of_field());
+            else arrays_multiplication_template((float*)dst_value_field->get_data_buf(), (double*)inversed_dst_fraction, (float*)dst_value_field->get_data_buf(), dst_frac_field->get_size_of_field());
+        else if (words_are_the_same(dst_frac_field->get_data_type(), DATA_TYPE_FLOAT))
+            arrays_multiplication_template((double*)dst_value_field->get_data_buf(), (float*)inversed_dst_fraction, (double*)dst_value_field->get_data_buf(), dst_frac_field->get_size_of_field());
+        else arrays_multiplication_template((double*)dst_value_field->get_data_buf(), (double*)inversed_dst_fraction, (double*)dst_value_field->get_data_buf(), dst_frac_field->get_size_of_field());
+    }    
 }
 
 
 void Inout_interface::execute(bool bypass_timer, int API_id, int *field_update_status, int size_field_update_status, const char *annotation)
 {
-	bool at_first_normal_step = false;
-
-
-	if (interface_type == COUPLING_INTERFACE_MARK_IMPORT) {
-		if (fields_mem_registered.size() != num_fields_connected)
-			for (int i = 0; i < fields_mem_registered.size(); i ++)
-				if (!fields_connected_status[i] && (imported_fields_necessity.size() == 0 || imported_fields_necessity[i] == FIELD_NECESSITY_NECESSARY)) {
-					std::vector<const char *> export_comp_full_names, export_interface_names;
-					inout_interface_mgr->get_all_export_interfaces_of_a_field(comp_id, fields_mem_registered[i]->get_field_name(), export_comp_full_names, export_interface_names);
-					char *error_string = NULL;
-					long string_size;
-					if (comp_comm_group_mgt_mgr->search_global_node(comp_id)->get_current_proc_local_id() == 0) {
-						error_string = new char [NAME_STR_SIZE*(export_comp_full_names.size()+2)];
-						error_string[0] = '\0';
-						for (int i = 0; i < export_comp_full_names.size(); i ++)
-							sprintf(error_string, "%s                   %d) Component model is \"%s\", export interface is \"%s\"\n", error_string, i+1, export_comp_full_names[i], export_interface_names[i]);
-						string_size = strlen(error_string) + 1;
-					}
-					bcast_array_in_one_comp(comp_comm_group_mgt_mgr->search_global_node(comp_id)->get_current_proc_local_id(), &error_string, string_size, comp_comm_group_mgt_mgr->search_global_node(comp_id)->get_comm_group());
-					EXECUTION_REPORT(REPORT_ERROR, comp_id, false, "ERROR happens when executing the import interface \"%s\" (the corresponding code annotation is \"%s\"): the coupling procedures for the import field \"%s\" have not been fully generated. The export interfaces that have been registered with this field are listed as follows. Please make sure the correct coupling generation.\n%s", interface_name, annotation, fields_mem_registered[i]->get_field_name(), error_string);
-					if (error_string != NULL)
-						delete [] error_string;
-				}	
-		if (fields_mem_registered.size() > size_field_update_status)
-			EXECUTION_REPORT(REPORT_ERROR, comp_id, false, "Fail to execute the interface \"%s\" corresponding to the model code with the annotation \"%s\": the array size of \"field_update_status\" (%d) is smaller than the number of fields (%d). Please verify.", interface_name, annotation, size_field_update_status, fields_mem_registered.size());
-		for (int i = 0; i < fields_mem_registered.size(); i ++)
-			field_update_status[i] = 0;
-	}	
-	else if (interface_type == COUPLING_INTERFACE_MARK_NORMAL_REMAP) {
-		if (((int)children_interfaces[0]->fields_mem_registered.size()) > size_field_update_status)
-			EXECUTION_REPORT(REPORT_ERROR, comp_id, false, "Fail to execute the interface \"%s\" corresponding to the model code with the annotation \"%s\": the array size of \"field_update_status\" (%d) is smaller than the number of fields (%d). Please verify.", interface_name, annotation, size_field_update_status, children_interfaces[0]->fields_mem_registered.size());
-		for (int i = 0; i < ((int)children_interfaces[0]->fields_mem_registered.size()); i ++)
-			field_update_status[i] = 0;
-	}	
-	else if (interface_type == COUPLING_INTERFACE_MARK_FRAC_REMAP) {
-		if (((int)children_interfaces[0]->fields_mem_registered.size())-1 > size_field_update_status)
-			EXECUTION_REPORT(REPORT_ERROR, comp_id, false, "Fail to execute the interface \"%s\" corresponding to the model code with the annotation \"%s\": the array size of \"field_update_status\" (%d) is smaller than the number of fields (%d). Please verify.", interface_name, annotation, size_field_update_status, children_interfaces[0]->fields_mem_registered.size()-1);
-		for (int i = 0; i < ((int)children_interfaces[0]->fields_mem_registered.size())-1; i ++)
-			field_update_status[i] = 0;
-	}
+    bool at_first_normal_step = false;
+
+
+    if (interface_type == COUPLING_INTERFACE_MARK_IMPORT) {
+        if (fields_mem_registered.size() != num_fields_connected)
+            for (int i = 0; i < fields_mem_registered.size(); i ++)
+                if (!fields_connected_status[i] && (imported_fields_necessity.size() == 0 || imported_fields_necessity[i] == FIELD_NECESSITY_NECESSARY)) {
+                    std::vector<const char *> export_comp_full_names, export_interface_names;
+                    inout_interface_mgr->get_all_export_interfaces_of_a_field(comp_id, fields_mem_registered[i]->get_field_name(), export_comp_full_names, export_interface_names);
+                    char *error_string = NULL;
+                    long string_size;
+                    if (comp_comm_group_mgt_mgr->search_global_node(comp_id)->get_current_proc_local_id() == 0) {
+                        error_string = new char [NAME_STR_SIZE*(export_comp_full_names.size()+2)];
+                        error_string[0] = '\0';
+                        for (int i = 0; i < export_comp_full_names.size(); i ++)
+                            sprintf(error_string, "%s                   %d) Component model is \"%s\", export interface is \"%s\"\n", error_string, i+1, export_comp_full_names[i], export_interface_names[i]);
+                        string_size = strlen(error_string) + 1;
+                    }
+                    bcast_array_in_one_comp(comp_comm_group_mgt_mgr->search_global_node(comp_id)->get_current_proc_local_id(), &error_string, string_size, comp_comm_group_mgt_mgr->search_global_node(comp_id)->get_comm_group());
+                    EXECUTION_REPORT(REPORT_ERROR, comp_id, false, "ERROR happens when executing the import interface \"%s\" (the corresponding code annotation is \"%s\"): the coupling procedures for the import field \"%s\" have not been fully generated. The export interfaces that have been registered with this field are listed as follows. Please make sure the correct coupling generation.\n%s", interface_name, annotation, fields_mem_registered[i]->get_field_name(), error_string);
+                    if (error_string != NULL)
+                        delete [] error_string;
+                }    
+        if (fields_mem_registered.size() > size_field_update_status)
+            EXECUTION_REPORT(REPORT_ERROR, comp_id, false, "Fail to execute the interface \"%s\" corresponding to the model code with the annotation \"%s\": the array size of \"field_update_status\" (%d) is smaller than the number of fields (%d). Please verify.", interface_name, annotation, size_field_update_status, fields_mem_registered.size());
+        for (int i = 0; i < fields_mem_registered.size(); i ++)
+            field_update_status[i] = 0;
+    }    
+    else if (interface_type == COUPLING_INTERFACE_MARK_NORMAL_REMAP) {
+        if (((int)children_interfaces[0]->fields_mem_registered.size()) > size_field_update_status)
+            EXECUTION_REPORT(REPORT_ERROR, comp_id, false, "Fail to execute the interface \"%s\" corresponding to the model code with the annotation \"%s\": the array size of \"field_update_status\" (%d) is smaller than the number of fields (%d). Please verify.", interface_name, annotation, size_field_update_status, children_interfaces[0]->fields_mem_registered.size());
+        for (int i = 0; i < ((int)children_interfaces[0]->fields_mem_registered.size()); i ++)
+            field_update_status[i] = 0;
+    }    
+    else if (interface_type == COUPLING_INTERFACE_MARK_FRAC_REMAP) {
+        if (((int)children_interfaces[0]->fields_mem_registered.size())-1 > size_field_update_status)
+            EXECUTION_REPORT(REPORT_ERROR, comp_id, false, "Fail to execute the interface \"%s\" corresponding to the model code with the annotation \"%s\": the array size of \"field_update_status\" (%d) is smaller than the number of fields (%d). Please verify.", interface_name, annotation, size_field_update_status, children_interfaces[0]->fields_mem_registered.size()-1);
+        for (int i = 0; i < ((int)children_interfaces[0]->fields_mem_registered.size())-1; i ++)
+            field_update_status[i] = 0;
+    }
 
-	if (!is_child_interface && !bypass_timer && !mgt_info_has_been_restarted && (time_mgr->get_runtype_mark() == RUNTYPE_MARK_CONTINUE || time_mgr->get_runtype_mark() == RUNTYPE_MARK_BRANCH)) {
-		EXECUTION_REPORT_LOG(REPORT_LOG, comp_id, true, "Import restart data for the interface \"%s\"\n", interface_name);
-		import_restart_data(NULL);
-		mgt_info_has_been_restarted = true;
-	}
-	
-	if (bypass_timer)
-		bypass_counter ++;
-	if (time_mgr->check_is_model_run_finished()) {
-		EXECUTION_REPORT(REPORT_WARNING, comp_id, false, "The import/export interface \"%s\" (corresponding to the model code annotation \"%s\") will not execute at time %08d-%05d because the model run has finished",
-			             interface_name, annotation_mgr->get_annotation(interface_id, "registering interface"), time_mgr->get_current_date(), time_mgr->get_current_second());
-		return;
-	}
+    if (!is_child_interface && !bypass_timer && !mgt_info_has_been_restarted && (time_mgr->get_runtype_mark() == RUNTYPE_MARK_CONTINUE || time_mgr->get_runtype_mark() == RUNTYPE_MARK_BRANCH)) {
+        EXECUTION_REPORT_LOG(REPORT_LOG, comp_id, true, "Import restart data for the interface \"%s\"\n", interface_name);
+        import_restart_data(NULL);
+        mgt_info_has_been_restarted = true;
+    }
+    
+    if (bypass_timer)
+        bypass_counter ++;
+    if (time_mgr->check_is_model_run_finished()) {
+        EXECUTION_REPORT(REPORT_WARNING, comp_id, false, "The import/export interface \"%s\" (corresponding to the model code annotation \"%s\") will not execute at time %08d-%05d because the model run has finished",
+                         interface_name, annotation_mgr->get_annotation(interface_id, "registering interface"), time_mgr->get_current_date(), time_mgr->get_current_second());
+        return;
+    }
 
-	if (bypass_timer && (execution_checking_status & 0x2) != 0)
-		EXECUTION_REPORT(REPORT_ERROR, comp_id, false, "Error happens when executing the interface \"%s\" at the model code with the corresponding annotation \"%s\": the timer of this interface cannot be bypassed again because this interface has been executed with the timer unbypassed before (at the model code with the corresponding annotation \"%s\"). Please check and verify.", interface_name, annotation, annotation_mgr->get_annotation(interface_id, "using timer"));
-	if ((execution_checking_status & 0x1) == 0 && bypass_timer || (execution_checking_status & 0x2) == 0 && !bypass_timer) {
-		synchronize_comp_processes_for_API(comp_id, API_id, comp_comm_group_mgt_mgr->get_global_node_of_local_comp(comp_id,false,"software error")->get_comm_group(), "executing an import/export interface", annotation);
-		check_API_parameter_string(comp_id, API_id, comp_comm_group_mgt_mgr->get_comm_group_of_local_comp(comp_id,"executing an import/export interface"), "executing an import/export interface", interface_name, "the corresponding interface name", annotation);
-		int bypass_timer_int;
-		if (bypass_timer)
-			bypass_timer_int = 0;
-		else bypass_timer_int = 1;
-		check_API_parameter_int(comp_id, API_id, comp_comm_group_mgt_mgr->get_comm_group_of_local_comp(comp_id,"executing an import/export interface"), NULL, bypass_timer_int, "the value for specifying whether bypass timers", annotation);
-		if (bypass_timer) {
-			execution_checking_status = execution_checking_status | 0x1;
-			annotation_mgr->add_annotation(interface_id, "bypassing timer", annotation);
-		}
-		else {
-			at_first_normal_step = (execution_checking_status & 0x2) == 0;
-			execution_checking_status = execution_checking_status | 0x2;
-			annotation_mgr->add_annotation(interface_id, "using timer", annotation);
-		}
-	}
+    if (bypass_timer && (execution_checking_status & 0x2) != 0)
+        EXECUTION_REPORT(REPORT_ERROR, comp_id, false, "Error happens when executing the interface \"%s\" at the model code with the corresponding annotation \"%s\": the timer of this interface cannot be bypassed again because this interface has been executed with the timer unbypassed before (at the model code with the corresponding annotation \"%s\"). Please check and verify.", interface_name, annotation, annotation_mgr->get_annotation(interface_id, "using timer"));
+    if ((execution_checking_status & 0x1) == 0 && bypass_timer || (execution_checking_status & 0x2) == 0 && !bypass_timer) {
+        synchronize_comp_processes_for_API(comp_id, API_id, comp_comm_group_mgt_mgr->get_global_node_of_local_comp(comp_id,false,"software error")->get_comm_group(), "executing an import/export interface", annotation);
+        check_API_parameter_string(comp_id, API_id, comp_comm_group_mgt_mgr->get_comm_group_of_local_comp(comp_id,"executing an import/export interface"), "executing an import/export interface", interface_name, "the corresponding interface name", annotation);
+        int bypass_timer_int;
+        if (bypass_timer)
+            bypass_timer_int = 0;
+        else bypass_timer_int = 1;
+        check_API_parameter_int(comp_id, API_id, comp_comm_group_mgt_mgr->get_comm_group_of_local_comp(comp_id,"executing an import/export interface"), NULL, bypass_timer_int, "the value for specifying whether bypass timers", annotation);
+        if (bypass_timer) {
+            execution_checking_status = execution_checking_status | 0x1;
+            annotation_mgr->add_annotation(interface_id, "bypassing timer", annotation);
+        }
+        else {
+            at_first_normal_step = (execution_checking_status & 0x2) == 0;
+            execution_checking_status = execution_checking_status | 0x2;
+            annotation_mgr->add_annotation(interface_id, "using timer", annotation);
+        }
+    }
 
-	long current_execution_time = ((long)time_mgr->get_current_num_elapsed_day())*100000 + components_time_mgrs->get_time_mgr(comp_id)->get_current_second();
-	if (current_execution_time == last_execution_time && !bypass_timer && !at_first_normal_step) {
-		int current_year, current_month, current_day, current_second;
-		components_time_mgrs->get_time_mgr(comp_id)->get_current_time(current_year, current_month, current_day, current_second, 0, "CCPL internal");
-		EXECUTION_REPORT(REPORT_WARNING, comp_id, false, "The import/export interface \"%s\", which is called at the model code with the annotation \"%s\", will not be executed again at the time step %04d-%02d-%02d-%05d, because it has been executed at the same time step before.",
-			             interface_name, annotation, current_year, current_month, current_day, current_second);
-		return;
-	}
+    long current_execution_time = ((long)time_mgr->get_current_num_elapsed_day())*100000 + components_time_mgrs->get_time_mgr(comp_id)->get_current_second();
+    if (current_execution_time == last_execution_time && !bypass_timer && !at_first_normal_step) {
+        int current_year, current_month, current_day, current_second;
+        components_time_mgrs->get_time_mgr(comp_id)->get_current_time(current_year, current_month, current_day, current_second, 0, "CCPL internal");
+        EXECUTION_REPORT(REPORT_WARNING, comp_id, false, "The import/export interface \"%s\", which is called at the model code with the annotation \"%s\", will not be executed again at the time step %04d-%02d-%02d-%05d, because it has been executed at the same time step before.",
+                         interface_name, annotation, current_year, current_month, current_day, current_second);
+        return;
+    }
 
-	last_execution_time = current_execution_time;
-
-	if (interface_type == COUPLING_INTERFACE_MARK_NORMAL_REMAP || interface_type == COUPLING_INTERFACE_MARK_FRAC_REMAP) {
-		for (int i = 0; i < fields_mem_registered.size(); i ++)
-			fields_mem_registered[i]->check_field_sum("before executing a remap interface");
-		if (interface_type == COUPLING_INTERFACE_MARK_FRAC_REMAP)
-			preprocessing_for_frac_based_remapping();
-		children_interfaces[0]->execute(bypass_timer, API_id, field_update_status, size_field_update_status+1, annotation);
-		children_interfaces[1]->execute(bypass_timer, API_id, field_update_status, size_field_update_status+1, annotation);
-		if (interface_type == COUPLING_INTERFACE_MARK_FRAC_REMAP)
-			postprocessing_for_frac_based_remapping(bypass_timer);
-		return;
-	}
+    last_execution_time = current_execution_time;
+
+    if (interface_type == COUPLING_INTERFACE_MARK_NORMAL_REMAP || interface_type == COUPLING_INTERFACE_MARK_FRAC_REMAP) {
+        for (int i = 0; i < fields_mem_registered.size(); i ++)
+            fields_mem_registered[i]->check_field_sum("before executing a remap interface");
+        if (interface_type == COUPLING_INTERFACE_MARK_FRAC_REMAP)
+            preprocessing_for_frac_based_remapping();
+        children_interfaces[0]->execute(bypass_timer, API_id, field_update_status, size_field_update_status+1, annotation);
+        children_interfaces[1]->execute(bypass_timer, API_id, field_update_status, size_field_update_status+1, annotation);
+        if (interface_type == COUPLING_INTERFACE_MARK_FRAC_REMAP)
+            postprocessing_for_frac_based_remapping(bypass_timer);
+        return;
+    }
 
-	if (interface_type == COUPLING_INTERFACE_MARK_EXPORT) {
-		for (int i = 0; i < fields_mem_registered.size(); i ++)
-			fields_mem_registered[i]->check_field_sum("before executing an export interface");
-		EXECUTION_REPORT_LOG(REPORT_LOG, comp_id, true, "after checking all source fields");
-	}
-	
-	for (int i = 0; i < coupling_procedures.size(); i ++)
-		coupling_procedures[i]->execute(bypass_timer, field_update_status, annotation);
+    if (interface_type == COUPLING_INTERFACE_MARK_EXPORT) {
+        for (int i = 0; i < fields_mem_registered.size(); i ++)
+            fields_mem_registered[i]->check_field_sum("before executing an export interface");
+        EXECUTION_REPORT_LOG(REPORT_LOG, comp_id, true, "after checking all source fields");
+    }
+    
+    for (int i = 0; i < coupling_procedures.size(); i ++)
+        coupling_procedures[i]->execute(bypass_timer, field_update_status, annotation);
 
-	if (interface_type == COUPLING_INTERFACE_MARK_EXPORT) {
+    if (interface_type == COUPLING_INTERFACE_MARK_EXPORT) {
 
 #ifdef USE_ONE_SIDED_MPI
-		comp_comm_group_mgt_mgr->get_global_node_of_local_comp(comp_id,false,"")->get_performance_timing_mgr()->performance_timing_start(TIMING_TYPE_COMMUNICATION, TIMING_COMMUNICATION_SEND_WAIT, -1, interface_name);
+        comp_comm_group_mgt_mgr->get_global_node_of_local_comp(comp_id,false,"")->get_performance_timing_mgr()->performance_timing_start(TIMING_TYPE_COMMUNICATION, TIMING_COMMUNICATION_SEND_WAIT, -1, interface_name);
 #endif
-		bool all_finish = false;
-		while (!all_finish) {
-			all_finish = true;
-			for (int i = 0; i < coupling_procedures.size(); i ++) {
-				if (!coupling_procedures[i]->get_finish_status())
-					coupling_procedures[i]->send_fields(bypass_timer);
-				all_finish = all_finish && coupling_procedures[i]->get_finish_status();
-			}	
-		}
+        bool all_finish = false;
+        while (!all_finish) {
+            all_finish = true;
+            for (int i = 0; i < coupling_procedures.size(); i ++) {
+                if (!coupling_procedures[i]->get_finish_status())
+                    coupling_procedures[i]->send_fields(bypass_timer);
+                all_finish = all_finish && coupling_procedures[i]->get_finish_status();
+            }    
+        }
 #ifdef USE_ONE_SIDED_MPI
-		comp_comm_group_mgt_mgr->get_global_node_of_local_comp(comp_id,false,"")->get_performance_timing_mgr()->performance_timing_stop(TIMING_TYPE_COMMUNICATION, TIMING_COMMUNICATION_SEND_WAIT, -1, interface_name);
+        comp_comm_group_mgt_mgr->get_global_node_of_local_comp(comp_id,false,"")->get_performance_timing_mgr()->performance_timing_stop(TIMING_TYPE_COMMUNICATION, TIMING_COMMUNICATION_SEND_WAIT, -1, interface_name);
 #endif
-	}
+    }
 
-	if (interface_type == COUPLING_INTERFACE_MARK_IMPORT) {
-		for (int i = 0; i < fields_mem_registered.size(); i ++)
-			fields_mem_registered[i]->check_field_sum("after executing an export interface");
-	}
+    if (interface_type == COUPLING_INTERFACE_MARK_IMPORT) {
+        for (int i = 0; i < fields_mem_registered.size(); i ++)
+            fields_mem_registered[i]->check_field_sum("after executing an export interface");
+    }
 }
 
 
 Inout_interface *Inout_interface::get_child_interface(int i)
 {
-	EXECUTION_REPORT(REPORT_ERROR, -1, i >= 0 && i < children_interfaces.size(), "Software error in Inout_interface::get_child_interface");
+    EXECUTION_REPORT(REPORT_ERROR, -1, i >= 0 && i < children_interfaces.size(), "Software error in Inout_interface::get_child_interface");
 
-	return children_interfaces[i];
+    return children_interfaces[i];
 }
 
 
 void Inout_interface::add_remappling_fraction_processing(void *frac_src, void *frac_dst, int size_frac_src, int size_frac_dst, const char *frac_data_type, const char *API_label, const char *annotation)
 {
-	for (int j = 0; j < 2; j ++) {
-		EXECUTION_REPORT(REPORT_ERROR, -1, children_interfaces[j]->coupling_procedures.size() == 1 && children_interfaces[j]->coupling_procedures[0]->get_num_runtime_remap_algorithms() == children_interfaces[j]->fields_mem_registered.size(), "Software error in Inout_interface::add_remappling_fraction_processing");
-		for (int i = 0; i < children_interfaces[j]->fields_mem_registered.size(); i ++) {
-			Original_grid_info *field_grid = original_grid_mgr->get_original_grid(children_interfaces[j]->fields_mem_registered[i]->get_grid_id());
-			EXECUTION_REPORT(REPORT_ERROR, comp_id, field_grid != NULL && field_grid->is_H2D_grid(), "Error happens when calling the API \"%s\" to register an interface named \"%s\": field \"%s\" is not on an horizontal grid. Please verify	the model code model with the annotation \"%s\"", API_label, interface_name, children_interfaces[j]->fields_mem_registered[i]->get_field_name(), annotation);
-			EXECUTION_REPORT(REPORT_ERROR, comp_id, children_interfaces[j]->coupling_procedures[0]->get_runtime_remap_algorithm(i) == NULL && children_interfaces[j]->coupling_procedures[0]->get_runtime_remap_algorithm(0) == NULL || children_interfaces[j]->coupling_procedures[0]->get_runtime_remap_algorithm(i) != NULL && children_interfaces[j]->coupling_procedures[0]->get_runtime_remap_algorithm(0) != NULL && children_interfaces[j]->coupling_procedures[0]->get_runtime_remap_algorithm(i)->get_runtime_remapping_weights() == children_interfaces[j]->coupling_procedures[0]->get_runtime_remap_algorithm(0)->get_runtime_remapping_weights(), 
-				             "Error happens when calling the API \"%s\" to register an interface named \"%s\": The fields (\"%s\" and \"%s\") to be remapped do not share the same remapping weights. Please verify the model code model with the annotation \"%s\".", API_label, interface_name, children_interfaces[j]->fields_mem_registered[0]->get_field_name(), children_interfaces[j]->fields_mem_registered[i]->get_field_name(), annotation);
-		}
-	}
-	Field_mem_info *template_field_src = children_interfaces[0]->fields_mem_registered[0];
-	Field_mem_info *template_field_dst = children_interfaces[1]->fields_mem_registered[0];
-	EXECUTION_REPORT(REPORT_ERROR, comp_id, template_field_src->get_size_of_field() == size_frac_src, "Error happens when calling the API \"%s\" to register an interface named \"%s\": the array size of the parameter \"frac_src\" is different from the size of each source field instance. Please verify the model code model with the annotation \"%s\".", API_label, interface_name, annotation);
-	int has_frac_dst = size_frac_dst == -1? 0 : 1;
-	check_API_parameter_int(comp_id, API_ID_INTERFACE_REG_FRAC_REMAP, comp_comm_group_mgt_mgr->get_global_node_of_local_comp(comp_id,false,"in add_remappling_fraction_processing")->get_comm_group(), "specification (or not)", has_frac_dst, "frac_dst", annotation);
-	if (size_frac_dst != -1)
-		EXECUTION_REPORT(REPORT_ERROR, comp_id, template_field_dst->get_size_of_field() == size_frac_dst, "Error happens when calling the API \"%s\" to register an interface named \"%s\": the array size of the parameter \"frac_dst\" is different from the size of each target field instance. Please verify the model code model with the annotation \"%s\".", API_label, interface_name, annotation);
-
-	EXECUTION_REPORT_LOG(REPORT_LOG, comp_id, true, "Finish checking for adding remappling fraction processing for the remapping interface \"%s\"", interface_name);
-
-	Field_mem_info *frac_field_src = memory_manager->alloc_mem("remap_frac", template_field_src->get_decomp_id(), template_field_src->get_comp_or_grid_id(), BUF_MARK_REMAP_FRAC ^ coupling_generator->get_latest_connection_id(), frac_data_type, "unitless", "source fraction for remapping", false);
-	frac_field_src->reset_mem_buf(frac_src, false, -1);
-	Field_mem_info *frac_field_dst = memory_manager->alloc_mem("remap_frac", template_field_dst->get_decomp_id(), template_field_dst->get_comp_or_grid_id(), BUF_MARK_REMAP_FRAC ^ coupling_generator->get_latest_connection_id(), frac_data_type, "unitless", "target fraction for remapping", false);
-	if (size_frac_dst != -1) 
-		frac_field_dst->reset_mem_buf(frac_dst, false, -1);
-	memset(frac_field_dst->get_data_buf(), 0, frac_field_dst->get_size_of_field()*get_data_type_size(frac_field_dst->get_data_type()));
-	interface_type = COUPLING_INTERFACE_MARK_FRAC_REMAP;
-	EXECUTION_REPORT(REPORT_ERROR, -1, fields_mem_registered.size() == 0, "Software error in Inout_interface::add_remappling_fraction_processing");
-	for (int i = 0; i < children_interfaces[0]->fields_mem_registered.size(); i ++) {
-		fields_mem_registered.push_back(children_interfaces[0]->fields_mem_registered[i]);
-		children_interfaces[0]->fields_mem_registered[i] = memory_manager->alloc_mem(fields_mem_registered[i], BUF_MARK_REMAP_FRAC, coupling_generator->get_latest_connection_id(), fields_mem_registered[i]->get_data_type(), true);
-	}
-	fields_mem_registered.push_back(frac_field_src);
-
-	EXECUTION_REPORT_LOG(REPORT_LOG, comp_id, true, "After field instance allocation for adding remappling fraction processing for the remapping interface \"%s\"", interface_name);
-	
-	children_interfaces[0]->fields_mem_registered.push_back(frac_field_src);
-	children_interfaces[1]->fields_mem_registered.push_back(frac_field_dst);
-	delete children_interfaces[0]->coupling_procedures[0];
-	delete children_interfaces[1]->coupling_procedures[0];
-	for (int i = 0; i < children_interfaces[1]->fields_connected_status.size(); i ++)
-		children_interfaces[1]->fields_connected_status[i] = false;
-	children_interfaces[1]->num_fields_connected = 0;
-	children_interfaces[0]->coupling_procedures.clear();
-	children_interfaces[1]->coupling_procedures.clear();
-	int num_fields = children_interfaces[0]->fields_mem_registered.size();
-	int *field_ids_src = new int [num_fields];
-	for (int i = 0; i < num_fields; i ++)
-		field_ids_src[i] = children_interfaces[0]->fields_mem_registered[i]->get_field_instance_id();
-	
-	inout_interface_mgr->generate_remapping_interface_connection(this, num_fields, field_ids_src, true);
-	delete [] field_ids_src;
-
-	if (frac_field_dst->get_size_of_field() > 0)
-		inversed_dst_fraction = new char [frac_field_dst->get_size_of_field()*get_data_type_size(frac_field_dst->get_data_type())];
+    for (int j = 0; j < 2; j ++) {
+        EXECUTION_REPORT(REPORT_ERROR, -1, children_interfaces[j]->coupling_procedures.size() == 1 && children_interfaces[j]->coupling_procedures[0]->get_num_runtime_remap_algorithms() == children_interfaces[j]->fields_mem_registered.size(), "Software error in Inout_interface::add_remappling_fraction_processing");
+        for (int i = 0; i < children_interfaces[j]->fields_mem_registered.size(); i ++) {
+            Original_grid_info *field_grid = original_grid_mgr->get_original_grid(children_interfaces[j]->fields_mem_registered[i]->get_grid_id());
+            EXECUTION_REPORT(REPORT_ERROR, comp_id, field_grid != NULL && field_grid->is_H2D_grid(), "Error happens when calling the API \"%s\" to register an interface named \"%s\": field \"%s\" is not on an horizontal grid. Please verify    the model code model with the annotation \"%s\"", API_label, interface_name, children_interfaces[j]->fields_mem_registered[i]->get_field_name(), annotation);
+            EXECUTION_REPORT(REPORT_ERROR, comp_id, children_interfaces[j]->coupling_procedures[0]->get_runtime_remap_algorithm(i) == NULL && children_interfaces[j]->coupling_procedures[0]->get_runtime_remap_algorithm(0) == NULL || children_interfaces[j]->coupling_procedures[0]->get_runtime_remap_algorithm(i) != NULL && children_interfaces[j]->coupling_procedures[0]->get_runtime_remap_algorithm(0) != NULL && children_interfaces[j]->coupling_procedures[0]->get_runtime_remap_algorithm(i)->get_runtime_remapping_weights() == children_interfaces[j]->coupling_procedures[0]->get_runtime_remap_algorithm(0)->get_runtime_remapping_weights(), 
+                             "Error happens when calling the API \"%s\" to register an interface named \"%s\": The fields (\"%s\" and \"%s\") to be remapped do not share the same remapping weights. Please verify the model code model with the annotation \"%s\".", API_label, interface_name, children_interfaces[j]->fields_mem_registered[0]->get_field_name(), children_interfaces[j]->fields_mem_registered[i]->get_field_name(), annotation);
+        }
+    }
+    Field_mem_info *template_field_src = children_interfaces[0]->fields_mem_registered[0];
+    Field_mem_info *template_field_dst = children_interfaces[1]->fields_mem_registered[0];
+    EXECUTION_REPORT(REPORT_ERROR, comp_id, template_field_src->get_size_of_field() == size_frac_src, "Error happens when calling the API \"%s\" to register an interface named \"%s\": the array size of the parameter \"frac_src\" is different from the size of each source field instance. Please verify the model code model with the annotation \"%s\".", API_label, interface_name, annotation);
+    int has_frac_dst = size_frac_dst == -1? 0 : 1;
+    check_API_parameter_int(comp_id, API_ID_INTERFACE_REG_FRAC_REMAP, comp_comm_group_mgt_mgr->get_global_node_of_local_comp(comp_id,false,"in add_remappling_fraction_processing")->get_comm_group(), "specification (or not)", has_frac_dst, "frac_dst", annotation);
+    if (size_frac_dst != -1)
+        EXECUTION_REPORT(REPORT_ERROR, comp_id, template_field_dst->get_size_of_field() == size_frac_dst, "Error happens when calling the API \"%s\" to register an interface named \"%s\": the array size of the parameter \"frac_dst\" is different from the size of each target field instance. Please verify the model code model with the annotation \"%s\".", API_label, interface_name, annotation);
+
+    EXECUTION_REPORT_LOG(REPORT_LOG, comp_id, true, "Finish checking for adding remappling fraction processing for the remapping interface \"%s\"", interface_name);
+
+    Field_mem_info *frac_field_src = memory_manager->alloc_mem("remap_frac", template_field_src->get_decomp_id(), template_field_src->get_comp_or_grid_id(), BUF_MARK_REMAP_FRAC ^ coupling_generator->get_latest_connection_id(), frac_data_type, "unitless", "source fraction for remapping", false);
+    frac_field_src->reset_mem_buf(frac_src, true, -1);
+    Field_mem_info *frac_field_dst = memory_manager->alloc_mem("remap_frac", template_field_dst->get_decomp_id(), template_field_dst->get_comp_or_grid_id(), BUF_MARK_REMAP_FRAC ^ coupling_generator->get_latest_connection_id(), frac_data_type, "unitless", "target fraction for remapping", false);
+    if (size_frac_dst != -1) 
+        frac_field_dst->reset_mem_buf(frac_dst, true, -1);
+    memset(frac_field_dst->get_data_buf(), 0, frac_field_dst->get_size_of_field()*get_data_type_size(frac_field_dst->get_data_type()));
+    interface_type = COUPLING_INTERFACE_MARK_FRAC_REMAP;
+    EXECUTION_REPORT(REPORT_ERROR, -1, fields_mem_registered.size() == 0, "Software error in Inout_interface::add_remappling_fraction_processing");
+    for (int i = 0; i < children_interfaces[0]->fields_mem_registered.size(); i ++) {
+        fields_mem_registered.push_back(children_interfaces[0]->fields_mem_registered[i]);
+        children_interfaces[0]->fields_mem_registered[i] = memory_manager->alloc_mem(fields_mem_registered[i], BUF_MARK_REMAP_FRAC, coupling_generator->get_latest_connection_id(), fields_mem_registered[i]->get_data_type(), true);
+    }
+    fields_mem_registered.push_back(frac_field_src);
+
+    EXECUTION_REPORT_LOG(REPORT_LOG, comp_id, true, "After field instance allocation for adding remappling fraction processing for the remapping interface \"%s\"", interface_name);
+    
+    children_interfaces[0]->fields_mem_registered.push_back(frac_field_src);
+    children_interfaces[1]->fields_mem_registered.push_back(frac_field_dst);
+    delete children_interfaces[0]->coupling_procedures[0];
+    delete children_interfaces[1]->coupling_procedures[0];
+    for (int i = 0; i < children_interfaces[1]->fields_connected_status.size(); i ++)
+        children_interfaces[1]->fields_connected_status[i] = false;
+    children_interfaces[1]->num_fields_connected = 0;
+    children_interfaces[0]->coupling_procedures.clear();
+    children_interfaces[1]->coupling_procedures.clear();
+    int num_fields = children_interfaces[0]->fields_mem_registered.size();
+    int *field_ids_src = new int [num_fields];
+    for (int i = 0; i < num_fields; i ++)
+        field_ids_src[i] = children_interfaces[0]->fields_mem_registered[i]->get_field_instance_id();
+    
+    inout_interface_mgr->generate_remapping_interface_connection(this, num_fields, field_ids_src, true);
+    delete [] field_ids_src;
+
+    if (frac_field_dst->get_size_of_field() > 0)
+        inversed_dst_fraction = new char [frac_field_dst->get_size_of_field()*get_data_type_size(frac_field_dst->get_data_type())];
 }
 
 
 int Inout_interface::get_h2d_grid_area_in_remapping_weights(const char *interface_name, int field_index, void *output_area_data, int area_array_size, const char *data_type, const char *annotation)
 {
-	int i, j;
-	double *selected_area_array_in_wgts = NULL;
-	bool field_has_connection = false;
-
-	
-	if (children_interfaces.size() > 0)
-		return children_interfaces[0]->get_h2d_grid_area_in_remapping_weights(interface_name, field_index, output_area_data, area_array_size, data_type, annotation);
-
-	EXECUTION_REPORT_ERROR_OPTIONALLY(REPORT_ERROR, comp_id, field_index >= 0 && field_index < fields_mem_registered.size(), "ERROR happens when calling the API \"CCPL_get_H2D_grid_area_in_remapping_wgts\" based on the coupling interface \"%s\": the parameter of field index (%d) is out of bounds ([1,%d]). Please verify the model code with the annotation \"%s\"", interface_name, field_index+1, fields_mem_registered.size(), annotation);
-	EXECUTION_REPORT_ERROR_OPTIONALLY(REPORT_ERROR, comp_id, fields_mem_registered[field_index]->get_grid_id() != -1, "ERROR happens when calling the API \"CCPL_get_H2D_grid_area_in_remapping_wgts\" based on the coupling interface \"%s\": the field \"%s\" corresponding to the field index (%d) is not on a grid. Please verify the model code with the annotation \"%s\"", interface_name, fields_mem_registered[field_index]->get_field_name(), field_index+1, fields_mem_registered.size()-1, annotation);
-	EXECUTION_REPORT_ERROR_OPTIONALLY(REPORT_ERROR, comp_id, original_grid_mgr->search_grid_info(fields_mem_registered[field_index]->get_grid_id())->is_H2D_grid(), "ERROR happens when calling the API \"CCPL_get_H2D_grid_area_in_remapping_wgts\" based on the coupling interface \"%s\": the field \"%s\" corresponding to the field index (%d) is not on a horizontal grid. Please verify the model code with the annotation \"%s\"", interface_name, fields_mem_registered[field_index]->get_field_name(), field_index+1, annotation);
-
-	for (i = 0; i < coupling_procedures.size(); i ++) {
-		for (j = 0; j < coupling_procedures[i]->coupling_connection->fields_name.size(); j ++)
-			if (words_are_the_same(fields_mem_registered[field_index]->get_field_name(),coupling_procedures[i]->coupling_connection->fields_name[j])) {
-				if (interface_type == COUPLING_INTERFACE_MARK_IMPORT) {
-					if (coupling_procedures[i]->coupling_connection->dst_fields_info[j]->runtime_remapping_weights != NULL && coupling_procedures[i]->coupling_connection->dst_fields_info[j]->runtime_remapping_weights->get_src_H2D_grid_area() != NULL) {
-						selected_area_array_in_wgts = coupling_procedures[i]->coupling_connection->dst_fields_info[j]->runtime_remapping_weights->get_dst_H2D_grid_area();
-						break;
-					}
-				}
-				else if (interface_type == COUPLING_INTERFACE_MARK_EXPORT) {
-					if (coupling_procedures[i]->coupling_connection->src_fields_info[j]->runtime_remapping_weights != NULL && coupling_procedures[i]->coupling_connection->src_fields_info[j]->runtime_remapping_weights->get_src_H2D_grid_area() != NULL) {
-						selected_area_array_in_wgts = coupling_procedures[i]->coupling_connection->src_fields_info[j]->runtime_remapping_weights->get_src_H2D_grid_area();
-						break;
-					}					
-				}
-				else EXECUTION_REPORT_ERROR_OPTIONALLY(REPORT_ERROR, -1, false, "Software error in Inout_interface::get_h2d_grid_area_in_remapping_weights");
-				field_has_connection = true;
-			}	
-		if (selected_area_array_in_wgts != NULL)
-			break;
-	}
+    int i, j;
+    double *selected_area_array_in_wgts = NULL;
+    bool field_has_connection = false;
+
+    
+    if (children_interfaces.size() > 0)
+        return children_interfaces[0]->get_h2d_grid_area_in_remapping_weights(interface_name, field_index, output_area_data, area_array_size, data_type, annotation);
+
+    EXECUTION_REPORT_ERROR_OPTIONALLY(REPORT_ERROR, comp_id, field_index >= 0 && field_index < fields_mem_registered.size(), "ERROR happens when calling the API \"CCPL_get_H2D_grid_area_in_remapping_wgts\" based on the coupling interface \"%s\": the parameter of field index (%d) is out of bounds ([1,%d]). Please verify the model code with the annotation \"%s\"", interface_name, field_index+1, fields_mem_registered.size(), annotation);
+    EXECUTION_REPORT_ERROR_OPTIONALLY(REPORT_ERROR, comp_id, fields_mem_registered[field_index]->get_grid_id() != -1, "ERROR happens when calling the API \"CCPL_get_H2D_grid_area_in_remapping_wgts\" based on the coupling interface \"%s\": the field \"%s\" corresponding to the field index (%d) is not on a grid. Please verify the model code with the annotation \"%s\"", interface_name, fields_mem_registered[field_index]->get_field_name(), field_index+1, fields_mem_registered.size()-1, annotation);
+    EXECUTION_REPORT_ERROR_OPTIONALLY(REPORT_ERROR, comp_id, original_grid_mgr->search_grid_info(fields_mem_registered[field_index]->get_grid_id())->is_H2D_grid(), "ERROR happens when calling the API \"CCPL_get_H2D_grid_area_in_remapping_wgts\" based on the coupling interface \"%s\": the field \"%s\" corresponding to the field index (%d) is not on a horizontal grid. Please verify the model code with the annotation \"%s\"", interface_name, fields_mem_registered[field_index]->get_field_name(), field_index+1, annotation);
+
+    for (i = 0; i < coupling_procedures.size(); i ++) {
+        for (j = 0; j < coupling_procedures[i]->coupling_connection->fields_name.size(); j ++)
+            if (words_are_the_same(fields_mem_registered[field_index]->get_field_name(),coupling_procedures[i]->coupling_connection->fields_name[j])) {
+                if (interface_type == COUPLING_INTERFACE_MARK_IMPORT) {
+                    if (coupling_procedures[i]->coupling_connection->dst_fields_info[j]->runtime_remapping_weights != NULL && coupling_procedures[i]->coupling_connection->dst_fields_info[j]->runtime_remapping_weights->get_src_H2D_grid_area() != NULL) {
+                        selected_area_array_in_wgts = coupling_procedures[i]->coupling_connection->dst_fields_info[j]->runtime_remapping_weights->get_dst_H2D_grid_area();
+                        break;
+                    }
+                }
+                else if (interface_type == COUPLING_INTERFACE_MARK_EXPORT) {
+                    if (coupling_procedures[i]->coupling_connection->src_fields_info[j]->runtime_remapping_weights != NULL && coupling_procedures[i]->coupling_connection->src_fields_info[j]->runtime_remapping_weights->get_src_H2D_grid_area() != NULL) {
+                        selected_area_array_in_wgts = coupling_procedures[i]->coupling_connection->src_fields_info[j]->runtime_remapping_weights->get_src_H2D_grid_area();
+                        break;
+                    }                    
+                }
+                else EXECUTION_REPORT_ERROR_OPTIONALLY(REPORT_ERROR, -1, false, "Software error in Inout_interface::get_h2d_grid_area_in_remapping_weights");
+                field_has_connection = true;
+            }    
+        if (selected_area_array_in_wgts != NULL)
+            break;
+    }
 
-	EXECUTION_REPORT(REPORT_WARNING, comp_id, field_has_connection, "WARNING happens when calling the API \"CCPL_get_H2D_grid_area_in_remapping_wgts\" based on the coupling interface \"%s\": the field \"%s\" corresponding to the field index (%d) has not been used in model coupling. Please verify the model code with the annotation \"%s\"", interface_name, fields_mem_registered[field_index]->get_field_name(), field_index+1, annotation);
+    EXECUTION_REPORT(REPORT_WARNING, comp_id, field_has_connection, "WARNING happens when calling the API \"CCPL_get_H2D_grid_area_in_remapping_wgts\" based on the coupling interface \"%s\": the field \"%s\" corresponding to the field index (%d) has not been used in model coupling. Please verify the model code with the annotation \"%s\"", interface_name, fields_mem_registered[field_index]->get_field_name(), field_index+1, annotation);
 
-	if (selected_area_array_in_wgts == NULL)
-		return 0;
+    if (selected_area_array_in_wgts == NULL)
+        return 0;
 
-	EXECUTION_REPORT_ERROR_OPTIONALLY(REPORT_ERROR, comp_id, area_array_size >= fields_mem_registered[field_index]->get_size_of_field(), "ERROR happens when calling the API \"CCPL_get_H2D_grid_area_in_remapping_wgts\" based on the field \"%s\" of the coupling interface \"%s\": the array size (%d) of the parameter \"area_array\" is smaller than required (%d). ", fields_mem_registered[field_index]->get_field_name(), interface_name, area_array_size, fields_mem_registered[field_index]->get_size_of_field());
-	Decomp_info *decomp_info = decomps_info_mgr->get_decomp_info(fields_mem_registered[field_index]->get_decomp_id());	
-	const int *local_cells_global_index = decomp_info->get_local_cell_global_indx();
-	if (words_are_the_same(data_type, DATA_TYPE_FLOAT)) {
-		float *float_output_area = (float*) output_area_data;
-		for (i = 0; i < decomp_info->get_num_local_cells(); i ++) {
-			float_output_area[i] = (float) (selected_area_array_in_wgts[local_cells_global_index[i]]);
-		}
-	}
-	else if (words_are_the_same(data_type, DATA_TYPE_DOUBLE)) {
-		double *double_output_area = (double*) output_area_data;
-		for (i = 0; i < decomp_info->get_num_local_cells(); i ++)
-			double_output_area[i] = selected_area_array_in_wgts[local_cells_global_index[i]];
-	}
-	else EXECUTION_REPORT(REPORT_ERROR, -1, false, "Software error in Inout_interface::get_h2d_grid_area_in_remapping_weights: wrong data type");
+    EXECUTION_REPORT_ERROR_OPTIONALLY(REPORT_ERROR, comp_id, area_array_size >= fields_mem_registered[field_index]->get_size_of_field(), "ERROR happens when calling the API \"CCPL_get_H2D_grid_area_in_remapping_wgts\" based on the field \"%s\" of the coupling interface \"%s\": the array size (%d) of the parameter \"area_array\" is smaller than required (%d). ", fields_mem_registered[field_index]->get_field_name(), interface_name, area_array_size, fields_mem_registered[field_index]->get_size_of_field());
+    Decomp_info *decomp_info = decomps_info_mgr->get_decomp_info(fields_mem_registered[field_index]->get_decomp_id());    
+    const int *local_cells_global_index = decomp_info->get_local_cell_global_indx();
+    if (words_are_the_same(data_type, DATA_TYPE_FLOAT)) {
+        float *float_output_area = (float*) output_area_data;
+        for (i = 0; i < decomp_info->get_num_local_cells(); i ++) {
+            if (local_cells_global_index[i] != CCPL_NULL_INT)
+                float_output_area[i] = (float) (selected_area_array_in_wgts[local_cells_global_index[i]]);
+            else float_output_area[i] = NULL_COORD_VALUE;
+        }
+    }
+    else if (words_are_the_same(data_type, DATA_TYPE_DOUBLE)) {
+        double *double_output_area = (double*) output_area_data;
+        for (i = 0; i < decomp_info->get_num_local_cells(); i ++)
+            if (local_cells_global_index[i] != CCPL_NULL_INT)
+                double_output_area[i] = selected_area_array_in_wgts[local_cells_global_index[i]];
+            else double_output_area[i] = NULL_COORD_VALUE;
+    }
+    else EXECUTION_REPORT(REPORT_ERROR, -1, false, "Software error in Inout_interface::get_h2d_grid_area_in_remapping_weights: wrong data type");
 
-	return 1;
+    return 1;
 }
 
 
 void Inout_interface::write_export_info_into_XML_file(TiXmlElement *parent_element)
 {
-	TiXmlElement *current_element = new TiXmlElement("export_interface");
-	parent_element->LinkEndChild(current_element);
-	current_element->SetAttribute("interface_name", interface_name);
-	for (int i = 0; i < fields_mem_registered.size(); i ++) {
-		TiXmlElement *field_element = new TiXmlElement("export_field");
-		current_element->LinkEndChild(field_element);
-		field_element->SetAttribute("field_name", fields_mem_registered[i]->get_field_name());
-	}
+    TiXmlElement *current_element = new TiXmlElement("export_interface");
+    parent_element->LinkEndChild(current_element);
+    current_element->SetAttribute("interface_name", interface_name);
+    for (int i = 0; i < fields_mem_registered.size(); i ++) {
+        TiXmlElement *field_element = new TiXmlElement("export_field");
+        current_element->LinkEndChild(field_element);
+        field_element->SetAttribute("field_name", fields_mem_registered[i]->get_field_name());
+    }
 }
 
 
 void Inout_interface::set_fields_necessity(int *necessity, int size_necessity, const char *annotation)
 {
-	EXECUTION_REPORT(REPORT_ERROR, comp_id, size_necessity >= fields_mem_registered.size(), "ERROR happens when calling the API \"CCPL_register_import_interface\" to register the export interface \"%s\": the array size (currently is %d) of the parameter \"necessity\" is smaller than the number of field instances (currently is %d) of this interface. Please verify the model code with the annotation \"%s\".", interface_name, size_necessity, fields_mem_registered.size(), annotation);
-	check_API_parameter_data_array(comp_id, API_ID_INTERFACE_REG_IMPORT, comp_comm_group_mgt_mgr->search_global_node(comp_id)->get_comm_group(), "registerring an import interface", fields_mem_registered.size(), sizeof(int), (const char*)necessity, "necessity", annotation);
-	for (int i = 0; i < fields_mem_registered.size(); i ++) {
-		EXECUTION_REPORT(REPORT_ERROR, comp_id, necessity[i] == FIELD_NECESSITY_NECESSARY || necessity[i] == FIELD_NECESSITY_OPTIONAL, "ERROR happens when calling the API \"CCPL_register_import_interface\" to register the export interface \"%s\": the number %d value (%d) in the parameter \"necessity\" is not either %d (means necessary) nor %d (means optional). Please verify the model code with the annotation \"%s\".", interface_name, i, necessity[i], FIELD_NECESSITY_NECESSARY, FIELD_NECESSITY_OPTIONAL, annotation);
-		imported_fields_necessity.push_back(necessity[i]);
-	}
+    EXECUTION_REPORT(REPORT_ERROR, comp_id, size_necessity >= fields_mem_registered.size(), "ERROR happens when calling the API \"CCPL_register_import_interface\" to register the export interface \"%s\": the array size (currently is %d) of the parameter \"necessity\" is smaller than the number of field instances (currently is %d) of this interface. Please verify the model code with the annotation \"%s\".", interface_name, size_necessity, fields_mem_registered.size(), annotation);
+    check_API_parameter_data_array(comp_id, API_ID_INTERFACE_REG_IMPORT, comp_comm_group_mgt_mgr->search_global_node(comp_id)->get_comm_group(), "registering an import interface", fields_mem_registered.size(), sizeof(int), (const char*)necessity, "necessity", annotation);
+    for (int i = 0; i < fields_mem_registered.size(); i ++) {
+        EXECUTION_REPORT(REPORT_ERROR, comp_id, necessity[i] == FIELD_NECESSITY_NECESSARY || necessity[i] == FIELD_NECESSITY_OPTIONAL, "ERROR happens when calling the API \"CCPL_register_import_interface\" to register the export interface \"%s\": the number %d value (%d) in the parameter \"necessity\" is not either %d (means necessary) nor %d (means optional). Please verify the model code with the annotation \"%s\".", interface_name, i, necessity[i], FIELD_NECESSITY_NECESSARY, FIELD_NECESSITY_OPTIONAL, annotation);
+        imported_fields_necessity.push_back(necessity[i]);
+    }
 }
 
 
 int Inout_interface::check_is_import_field_connected(int field_instance_id, const char *annotation)
 {
-	EXECUTION_REPORT(REPORT_ERROR, comp_id, interface_type == COUPLING_INTERFACE_MARK_IMPORT, "ERROR happens when calling the API \"CCPL_check_is_import_field_connected\": the corresponding coupling interface \"%s\" is not an import interface. Please verify the model code with the annotation \"%s\".", interface_name, annotation);
-	int i;
-	for (i = 0; i < fields_mem_registered.size(); i ++)
-		if (fields_mem_registered[i]->get_field_instance_id() == field_instance_id)
-			break;
-	EXECUTION_REPORT(REPORT_ERROR, comp_id, i < fields_mem_registered.size(), "ERROR happens when calling the API \"CCPL_check_is_import_field_connected\": the parameter \"field_instance_id\" (currently is 0x%x) fails to specify a field instance in the corresponding coupling interface \"%s\". Please verify the model code with the annotation \"%s\".", field_instance_id, interface_name, annotation);
+    EXECUTION_REPORT(REPORT_ERROR, comp_id, interface_type == COUPLING_INTERFACE_MARK_IMPORT, "ERROR happens when calling the API \"CCPL_check_is_import_field_connected\": the corresponding coupling interface \"%s\" is not an import interface. Please verify the model code with the annotation \"%s\".", interface_name, annotation);
+    int i;
+    for (i = 0; i < fields_mem_registered.size(); i ++)
+        if (fields_mem_registered[i]->get_field_instance_id() == field_instance_id)
+            break;
+    EXECUTION_REPORT(REPORT_ERROR, comp_id, i < fields_mem_registered.size(), "ERROR happens when calling the API \"CCPL_check_is_import_field_connected\": the parameter \"field_instance_id\" (currently is 0x%x) fails to specify a field instance in the corresponding coupling interface \"%s\". Please verify the model code with the annotation \"%s\".", field_instance_id, interface_name, annotation);
+
+    return (fields_connected_status[i]? 1 : 0);
+}
 
-	return (fields_connected_status[i]? 1 : 0);
+
+void Inout_interface::get_sender_time(int size_sender_date, int size_sender_elapsed_days, int size_sender_second, int *sender_date, int *sender_elapsed_days, int *sender_second, const char *annotation)
+{
+    EXECUTION_REPORT_ERROR_OPTIONALLY(REPORT_ERROR, comp_id, interface_type == COUPLING_INTERFACE_MARK_IMPORT, "ERROR happens when calling the API \"CCPL_get_import_fields_sender_time\": the corresponding coupling interface \"%s\" is not an import interface. Please verify the model code with the annotation \"%s\".", interface_name, annotation);
+	EXECUTION_REPORT_ERROR_OPTIONALLY(REPORT_ERROR, comp_id, fields_mem_registered.size() <= size_sender_elapsed_days, "ERROR happens when calling the API \"CCPL_get_import_fields_sender_time\" to get the current sender time of the field instances imported by the interface \"%s\": the array size of the input parameter \"sender_date\" (%d) is smaller than the number of fields (%d). Please verify the model code with the annotation \"%s\".", interface_name, size_sender_second, fields_mem_registered.size(), annotation);
+	EXECUTION_REPORT_ERROR_OPTIONALLY(REPORT_ERROR, comp_id, fields_mem_registered.size() <= size_sender_second, "ERROR happens when calling the API \"CCPL_get_import_fields_sender_time\" to get the current sender time of the field instances imported by the interface \"%s\": the array size of the input parameter \"sender_second\" (%d) is smaller than the number of fields (%d). Please verify the model code with the annotation \"%s\".", interface_name, size_sender_second, fields_mem_registered.size(), annotation);
+	EXECUTION_REPORT_ERROR_OPTIONALLY(REPORT_ERROR, comp_id, fields_mem_registered.size() <= size_sender_elapsed_days, "ERROR happens when calling the API \"CCPL_get_import_fields_sender_time\" to get the current sender time of the field instances imported by the interface \"%s\": the array size of the input parameter \"sender_elapsed_days\" (%d) is smaller than the number of fields (%d). Please verify the model code with the annotation \"%s\".", interface_name, size_sender_elapsed_days, fields_mem_registered.size(), annotation);	
+	
+	for (int i = 0; i < fields_mem_registered.size(); i ++) {
+		sender_elapsed_days[i] = CCPL_NULL_INT;
+		sender_second[i] = CCPL_NULL_INT;
+		sender_date[i] = CCPL_NULL_INT;
+		if (fields_coupling_procedures[i] != NULL && fields_coupling_procedures[i]->get_last_receive_sender_time() != CCPL_NULL_LONG) {
+			sender_date[i] = fields_coupling_procedures[i]->get_last_receive_sender_time() / 100000;
+			sender_second[i] = fields_coupling_procedures[i]->get_last_receive_sender_time() % 100000;
+			sender_elapsed_days[i] = time_mgr->calculate_elapsed_day(sender_date[i]/10000, (sender_date[i]%10000)/100, sender_date[i]%100);
+		}
+	}
 }
 
 
 void Inout_interface::dump_active_coupling_connections_into_XML(TiXmlElement *root_element)
 {
-	TiXmlElement *parent_element = NULL;
+    TiXmlElement *parent_element = NULL;
     TiXmlElement *interface = NULL;
-	
+    
     for (TiXmlNode *child = root_element->FirstChild(); child != NULL; child = child->NextSibling())
-    	if(interface_type == COUPLING_INTERFACE_MARK_IMPORT && words_are_the_same(child->Value(), "import_interfaces") || interface_type == COUPLING_INTERFACE_MARK_EXPORT && words_are_the_same(child->Value(), "export_interfaces")) {
-    		parent_element = child->ToElement();
-    		break;
-    	}
-	EXECUTION_REPORT(REPORT_ERROR, -1, parent_element != NULL, "Software error Inout_interface::dump_active_coupling_connections_into_XML");
-	
+        if(interface_type == COUPLING_INTERFACE_MARK_IMPORT && words_are_the_same(child->Value(), "import_interfaces") || interface_type == COUPLING_INTERFACE_MARK_EXPORT && words_are_the_same(child->Value(), "export_interfaces")) {
+            parent_element = child->ToElement();
+            break;
+        }
+    EXECUTION_REPORT(REPORT_ERROR, -1, parent_element != NULL, "Software error Inout_interface::dump_active_coupling_connections_into_XML");
+    
     for (TiXmlNode *child = parent_element->FirstChild(); child != NULL; child = child->NextSibling()) {
         TiXmlElement *temp = child->ToElement();
         if(words_are_the_same(temp->Attribute("interface_name"), interface_name)) {
@@ -1246,454 +1295,454 @@ void Inout_interface::dump_active_coupling_connections_into_XML(TiXmlElement *ro
             break;
         }
     }
-	
+    
     if (interface == NULL) {
-	    interface = new TiXmlElement("interface");
-	    parent_element->LinkEndChild(interface);
-	    interface->SetAttribute("interface_name", interface_name);
-	}
+        interface = new TiXmlElement("interface");
+        parent_element->LinkEndChild(interface);
+        interface->SetAttribute("interface_name", interface_name);
+    }
     for (int i = 0; i < coupling_procedures.size(); i++) {
-    	if (coupling_procedures[i]->get_coupling_connections_dumped())
-    		continue;
-    	Coupling_connection *coupling_connection = coupling_procedures[i]->get_coupling_connection();
-    	TiXmlElement *fields = new TiXmlElement("fields");
-    	interface->LinkEndChild(fields);
-    	if (interface_type == COUPLING_INTERFACE_MARK_IMPORT){
-    		fields->SetAttribute("comp_full_name",coupling_connection->src_comp_interfaces[0].first);
-    		fields->SetAttribute("interface_name",coupling_connection->src_comp_interfaces[0].second);
-    	}
-    	if (interface_type == COUPLING_INTERFACE_MARK_EXPORT){
-    		fields->SetAttribute("comp_full_name",coupling_connection->dst_comp_full_name);
-    		fields->SetAttribute("interface_name",coupling_connection->dst_interface_name);
-    	}
-    	for (int j = 0; j < coupling_connection->fields_name.size(); j++) {
-    		TiXmlElement *field = new TiXmlElement("field");
-    		fields->LinkEndChild(field);
-    		field->SetAttribute("name",coupling_connection->fields_name[j]);
-    	}
-    	coupling_procedures[i]->set_coupling_connections_dumped();
+        if (coupling_procedures[i]->get_coupling_connections_dumped())
+            continue;
+        Coupling_connection *coupling_connection = coupling_procedures[i]->get_coupling_connection();
+        TiXmlElement *fields = new TiXmlElement("fields");
+        interface->LinkEndChild(fields);
+        if (interface_type == COUPLING_INTERFACE_MARK_IMPORT){
+            fields->SetAttribute("comp_full_name",coupling_connection->src_comp_interfaces[0].first);
+            fields->SetAttribute("interface_name",coupling_connection->src_comp_interfaces[0].second);
+        }
+        if (interface_type == COUPLING_INTERFACE_MARK_EXPORT){
+            fields->SetAttribute("comp_full_name",coupling_connection->dst_comp_full_name);
+            fields->SetAttribute("interface_name",coupling_connection->dst_interface_name);
+        }
+        for (int j = 0; j < coupling_connection->fields_name.size(); j++) {
+            TiXmlElement *field = new TiXmlElement("field");
+            fields->LinkEndChild(field);
+            field->SetAttribute("name",coupling_connection->fields_name[j]);
+        }
+        coupling_procedures[i]->set_coupling_connections_dumped();
     }
 }
 
 
 bool Inout_interface::is_in_restart_write_window()
 {
-	if (interface_type != COUPLING_INTERFACE_MARK_IMPORT || is_child_interface)
-		return false;
-		
-	for (int i = 0; i < coupling_procedures.size(); i ++)
-		if (coupling_procedures[i]->is_in_restart_write_window() || coupling_procedures[i]->get_is_coupling_time_out_of_execution())
-			return true;
-	return false;
+    if (interface_type != COUPLING_INTERFACE_MARK_IMPORT || is_child_interface)
+        return false;
+        
+    for (int i = 0; i < coupling_procedures.size(); i ++)
+        if (coupling_procedures[i]->is_in_restart_write_window() || coupling_procedures[i]->get_is_coupling_time_out_of_execution())
+            return true;
+    return false;
 }
 
 
 void Inout_interface::dump_active_coupling_connections()
 {
-	char XML_file_name[NAME_STR_SIZE];
+    char XML_file_name[NAME_STR_SIZE];
     TiXmlElement *root_element;
-	TiXmlDocument *XML_file;
-	int i;
-
-
-	if (interface_type != COUPLING_INTERFACE_MARK_IMPORT && interface_type != COUPLING_INTERFACE_MARK_EXPORT || comp_comm_group_mgt_mgr->search_global_node(comp_id)->get_current_proc_local_id() != 0)
-		return;
-
-	for(i = 0; i < coupling_procedures.size(); i ++)
-		if(!coupling_procedures[i]->get_coupling_connections_dumped())
-			break;
-	if (i == coupling_procedures.size())
-		return;
-
-	sprintf(XML_file_name, "%s/%s.active_coupling_connections.xml", comp_comm_group_mgt_mgr->get_active_coupling_connections_dir(), comp_full_name);
-	XML_file = open_XML_file_to_read(comp_id, XML_file_name, MPI_COMM_NULL, false);
-	if (XML_file == NULL) {
-	    XML_file = new TiXmlDocument;
-	    TiXmlDeclaration *XML_declaration = new TiXmlDeclaration(("1.0"),(""),(""));
-	    XML_file->LinkEndChild(XML_declaration);
-	    root_element = new TiXmlElement("Component");
-	    XML_file->LinkEndChild(root_element);
-	    root_element->SetAttribute("name", comp_full_name);
-    	TiXmlElement *import_interfaces = new TiXmlElement("import_interfaces");
-    	TiXmlElement *export_interfaces = new TiXmlElement("export_interfaces");
-    	root_element->LinkEndChild(import_interfaces);
-    	root_element->LinkEndChild(export_interfaces);
-	}
-	else root_element = XML_file->RootElement();
-	dump_active_coupling_connections_into_XML(root_element);
-	EXECUTION_REPORT(REPORT_ERROR, -1, XML_file->SaveFile(XML_file_name), "software error in Inout_interface_mgt::dump_active_coupling_connections: fail to write the XML file %s", XML_file_name);
-	delete XML_file;
+    TiXmlDocument *XML_file;
+    int i;
+
+
+    if (interface_type != COUPLING_INTERFACE_MARK_IMPORT && interface_type != COUPLING_INTERFACE_MARK_EXPORT || comp_comm_group_mgt_mgr->search_global_node(comp_id)->get_current_proc_local_id() != 0)
+        return;
+
+    for(i = 0; i < coupling_procedures.size(); i ++)
+        if(!coupling_procedures[i]->get_coupling_connections_dumped())
+            break;
+    if (i == coupling_procedures.size())
+        return;
+
+    sprintf(XML_file_name, "%s/%s.active_coupling_connections.xml", comp_comm_group_mgt_mgr->get_active_coupling_connections_dir(), comp_full_name);
+    XML_file = open_XML_file_to_read(comp_id, XML_file_name, MPI_COMM_NULL, false);
+    if (XML_file == NULL) {
+        XML_file = new TiXmlDocument;
+        TiXmlDeclaration *XML_declaration = new TiXmlDeclaration(("1.0"),(""),(""));
+        XML_file->LinkEndChild(XML_declaration);
+        root_element = new TiXmlElement("Component");
+        XML_file->LinkEndChild(root_element);
+        root_element->SetAttribute("name", comp_full_name);
+        TiXmlElement *import_interfaces = new TiXmlElement("import_interfaces");
+        TiXmlElement *export_interfaces = new TiXmlElement("export_interfaces");
+        root_element->LinkEndChild(import_interfaces);
+        root_element->LinkEndChild(export_interfaces);
+    }
+    else root_element = XML_file->RootElement();
+    dump_active_coupling_connections_into_XML(root_element);
+    EXECUTION_REPORT(REPORT_ERROR, -1, XML_file->SaveFile(XML_file_name), "software error in Inout_interface_mgt::dump_active_coupling_connections: fail to write the XML file %s", XML_file_name);
+    delete XML_file;
 }
 
 
 Inout_interface_mgt::Inout_interface_mgt(const char *temp_array_buffer, long buffer_content_iter)
 {
-	while (buffer_content_iter > 0)
-		interfaces.push_back(new Inout_interface(temp_array_buffer, buffer_content_iter));
+    while (buffer_content_iter > 0)
+        interfaces.push_back(new Inout_interface(temp_array_buffer, buffer_content_iter));
 }
 
 
 Inout_interface_mgt::~Inout_interface_mgt()
 {
-	for (int i = 0; i < interfaces.size(); i ++)
-		delete interfaces[i];
+    for (int i = 0; i < interfaces.size(); i ++)
+        delete interfaces[i];
 }
 
 
 void Inout_interface_mgt::generate_remapping_interface_connection(Inout_interface *new_interface, int num_fields, int *field_ids_src, bool has_frac_remapping) 
 {
-	EXECUTION_REPORT_LOG(REPORT_LOG, new_interface->get_comp_id(), true, "start to generate the coupling connection of the remapping interface \"%s\"", new_interface->get_interface_name());
+    EXECUTION_REPORT_LOG(REPORT_LOG, new_interface->get_comp_id(), true, "start to generate the coupling connection of the remapping interface \"%s\"", new_interface->get_interface_name());
 
-	coupling_generator->synchronize_latest_connection_id(comp_comm_group_mgt_mgr->get_comm_group_of_local_comp(new_interface->get_comp_id(), ""));
-	Coupling_connection *coupling_connection = new Coupling_connection(coupling_generator->apply_connection_id());
-	Inout_interface *child_interface_export = new_interface->get_child_interface(0);
-	Inout_interface *child_interface_import = new_interface->get_child_interface(1);
-	std::pair<const char*, const char*> src_comp_interface;
+    coupling_generator->synchronize_latest_connection_id(comp_comm_group_mgt_mgr->get_comm_group_of_local_comp(new_interface->get_comp_id(), ""));
+    Coupling_connection *coupling_connection = new Coupling_connection(coupling_generator->apply_connection_id());
+    Inout_interface *child_interface_export = new_interface->get_child_interface(0);
+    Inout_interface *child_interface_import = new_interface->get_child_interface(1);
+    std::pair<const char*, const char*> src_comp_interface;
 
-	if (!has_frac_remapping)
-		interfaces.push_back(new_interface);
-	strcpy(coupling_connection->dst_comp_full_name, comp_comm_group_mgt_mgr->get_global_node_of_local_comp(new_interface->get_comp_id(),false,"in Inout_interface_mgt::register_normal_remap_interface")->get_full_name());
-	strcpy(coupling_connection->dst_interface_name, child_interface_import->get_interface_name());
-	for (int i = 0; i < num_fields; i ++)
-		coupling_connection->fields_name.push_back(strdup(memory_manager->get_field_instance(field_ids_src[i])->get_field_name()));
-	src_comp_interface.first = strdup(coupling_connection->dst_comp_full_name);
-	src_comp_interface.second = strdup(child_interface_export->get_interface_name());
-	coupling_connection->src_comp_interfaces.push_back(src_comp_interface);
+    if (!has_frac_remapping)
+        interfaces.push_back(new_interface);
+    strcpy(coupling_connection->dst_comp_full_name, comp_comm_group_mgt_mgr->get_global_node_of_local_comp(new_interface->get_comp_id(),false,"in Inout_interface_mgt::register_normal_remap_interface")->get_full_name());
+    strcpy(coupling_connection->dst_interface_name, child_interface_import->get_interface_name());
+    for (int i = 0; i < num_fields; i ++)
+        coupling_connection->fields_name.push_back(strdup(memory_manager->get_field_instance(field_ids_src[i])->get_field_name()));
+    src_comp_interface.first = strdup(coupling_connection->dst_comp_full_name);
+    src_comp_interface.second = strdup(child_interface_export->get_interface_name());
+    coupling_connection->src_comp_interfaces.push_back(src_comp_interface);
 
-	interfaces.push_back(child_interface_export);
-	interfaces.push_back(child_interface_import);
+    interfaces.push_back(child_interface_export);
+    interfaces.push_back(child_interface_import);
 
-	coupling_connection->generate_a_coupling_procedure(has_frac_remapping);
-//	delete coupling_connection;
+    coupling_connection->generate_a_coupling_procedure(has_frac_remapping);
+//    delete coupling_connection;
 
-	interfaces.erase(interfaces.begin()+interfaces.size()-1);
-	interfaces.erase(interfaces.begin()+interfaces.size()-1);
+    interfaces.erase(interfaces.begin()+interfaces.size()-1);
+    interfaces.erase(interfaces.begin()+interfaces.size()-1);
 
-	EXECUTION_REPORT_LOG(REPORT_LOG, new_interface->get_comp_id(), true, "Finish generating the coupling connection of the remapping interface \"%s\"", new_interface->get_interface_name());
+    EXECUTION_REPORT_LOG(REPORT_LOG, new_interface->get_comp_id(), true, "Finish generating the coupling connection of the remapping interface \"%s\"", new_interface->get_interface_name());
 }
 
 
 int Inout_interface_mgt::register_normal_remap_interface(const char *interface_name, int num_fields, int *field_ids_src, int *field_ids_dst, int timer_id, int inst_or_aver, int array_size_src, int array_size_dst, const char *API_label, const char *annotation)
 {
-	Inout_interface *new_interface = new Inout_interface(interface_name, get_next_interface_id(), num_fields, field_ids_src, field_ids_dst, timer_id, inst_or_aver, array_size_src, array_size_dst, API_label, annotation);
-	Inout_interface *existing_interface = get_interface(new_interface->get_comp_id(), interface_name);
-	if (existing_interface != NULL)
-		EXECUTION_REPORT(REPORT_ERROR, new_interface->get_comp_id(), existing_interface == NULL, "Error happens when calling the API \"%s\" to register an interface named \"%s\" at the model code model with the annotation \"%s\": an interface with the same name has already been registered at the model code with the annotation \"%s\". Please verify.", API_label, interface_name, annotation, annotation_mgr->get_annotation(existing_interface->get_interface_id(), "registering interface"));
-	generate_remapping_interface_connection(new_interface, num_fields, field_ids_src, false);
+    Inout_interface *new_interface = new Inout_interface(interface_name, get_next_interface_id(), num_fields, field_ids_src, field_ids_dst, timer_id, inst_or_aver, array_size_src, array_size_dst, API_label, annotation);
+    Inout_interface *existing_interface = get_interface(new_interface->get_comp_id(), interface_name);
+    if (existing_interface != NULL)
+        EXECUTION_REPORT(REPORT_ERROR, new_interface->get_comp_id(), existing_interface == NULL, "Error happens when calling the API \"%s\" to register an interface named \"%s\" at the model code model with the annotation \"%s\": an interface with the same name has already been registered at the model code with the annotation \"%s\". Please verify.", API_label, interface_name, annotation, annotation_mgr->get_annotation(existing_interface->get_interface_id(), "registering interface"));
+    generate_remapping_interface_connection(new_interface, num_fields, field_ids_src, false);
 
-	EXECUTION_REPORT_LOG(REPORT_LOG, new_interface->get_comp_id(), true, "Finish generating a normal remapping interface \"%s\"", new_interface->get_interface_name());
-	
-	return new_interface->get_interface_id();
+    EXECUTION_REPORT_LOG(REPORT_LOG, new_interface->get_comp_id(), true, "Finish generating a normal remapping interface \"%s\"", new_interface->get_interface_name());
+    
+    return new_interface->get_interface_id();
 }
 
 
 int Inout_interface_mgt::register_frac_based_remap_interface(const char *interface_name, int num_fields, int *field_ids_src, int *field_ids_dst, int timer_id, int inst_or_aver, int array_size_src, int array_size_dst, void *frac_src, void *frac_dst, int size_frac_src, int size_frac_dst, const char *frac_data_type, const char *API_label, const char *annotation)
 {
-	int new_remap_interface_id = register_normal_remap_interface(interface_name, num_fields, field_ids_src, field_ids_dst, timer_id, inst_or_aver, array_size_src, array_size_dst, API_label, annotation);
-	Inout_interface *new_remap_interface = get_interface(new_remap_interface_id);
-	EXECUTION_REPORT_LOG(REPORT_LOG, new_remap_interface->get_comp_id(), true, "Finish generating the normal part for a fraction based remapping interface \"%s\"", new_remap_interface->get_interface_name());
-	new_remap_interface->add_remappling_fraction_processing(frac_src, frac_dst, size_frac_src, size_frac_dst, frac_data_type, API_label, annotation);
-	EXECUTION_REPORT_LOG(REPORT_LOG, new_remap_interface->get_comp_id(), true, "Adding fraction process for the remapping interface \"%s\"", new_remap_interface->get_interface_name());
-	return new_remap_interface->get_interface_id();
+    int new_remap_interface_id = register_normal_remap_interface(interface_name, num_fields, field_ids_src, field_ids_dst, timer_id, inst_or_aver, array_size_src, array_size_dst, API_label, annotation);
+    Inout_interface *new_remap_interface = get_interface(new_remap_interface_id);
+    EXECUTION_REPORT_LOG(REPORT_LOG, new_remap_interface->get_comp_id(), true, "Finish generating the normal part for a fraction based remapping interface \"%s\"", new_remap_interface->get_interface_name());
+    new_remap_interface->add_remappling_fraction_processing(frac_src, frac_dst, size_frac_src, size_frac_dst, frac_data_type, API_label, annotation);
+    EXECUTION_REPORT_LOG(REPORT_LOG, new_remap_interface->get_comp_id(), true, "Adding fraction process for the remapping interface \"%s\"", new_remap_interface->get_interface_name());
+    return new_remap_interface->get_interface_id();
 }
 
 
 int Inout_interface_mgt::register_inout_interface(const char *interface_name, int interface_type, int num_fields, int *field_ids, int array_size, int timer_id, int inst_or_aver, const char *annotation, int interface_source)
 {
-	int API_id = interface_type == COUPLING_INTERFACE_MARK_IMPORT? API_ID_INTERFACE_REG_IMPORT : API_ID_INTERFACE_REG_EXPORT;
-	Inout_interface *new_interface = new Inout_interface(interface_name, get_next_interface_id(), interface_type, num_fields, field_ids, array_size, timer_id, inst_or_aver, "field_instance_IDs", annotation, API_id, interface_source, false);
-	for (int i = 0; i < interfaces.size(); i ++) {
-		if (new_interface->get_comp_id() != interfaces[i]->get_comp_id())
-			continue;
-		EXECUTION_REPORT(REPORT_ERROR, new_interface->get_comp_id(), !words_are_the_same(interface_name, interfaces[i]->get_interface_name()), 
-		                 "Fail to register an import/export interface named \"%s\" at the model code with the annotation \"%s\" because an interface with the same name has been registerred at the model code with the annotation \"%s\"",
-		                 interface_name, annotation, annotation_mgr->get_annotation(interfaces[i]->get_interface_id(), "registering interface"));
-		//new_interface->report_common_field_instances(interfaces[i]);
-		
-	}
-	interfaces.push_back(new_interface);
+    int API_id = interface_type == COUPLING_INTERFACE_MARK_IMPORT? API_ID_INTERFACE_REG_IMPORT : API_ID_INTERFACE_REG_EXPORT;
+    Inout_interface *new_interface = new Inout_interface(interface_name, get_next_interface_id(), interface_type, num_fields, field_ids, array_size, timer_id, inst_or_aver, "field_instance_IDs", annotation, API_id, interface_source, false);
+    for (int i = 0; i < interfaces.size(); i ++) {
+        if (new_interface->get_comp_id() != interfaces[i]->get_comp_id())
+            continue;
+        EXECUTION_REPORT(REPORT_ERROR, new_interface->get_comp_id(), !words_are_the_same(interface_name, interfaces[i]->get_interface_name()), 
+                         "Fail to register an import/export interface named \"%s\" at the model code with the annotation \"%s\" because an interface with the same name has been registered at the model code with the annotation \"%s\"",
+                         interface_name, annotation, annotation_mgr->get_annotation(interfaces[i]->get_interface_id(), "registering interface"));
+        //new_interface->report_common_field_instances(interfaces[i]);
+        
+    }
+    interfaces.push_back(new_interface);
 
-	if (interface_type == COUPLING_INTERFACE_MARK_EXPORT)
-		write_comp_export_info_into_XML_file(new_interface->get_comp_id());
-	
-	return new_interface->get_interface_id();
+    if (interface_type == COUPLING_INTERFACE_MARK_EXPORT)
+        write_comp_export_info_into_XML_file(new_interface->get_comp_id());
+    
+    return new_interface->get_interface_id();
 }
 
 
 int Inout_interface_mgt::get_next_interface_id()
 {
-	return TYPE_INOUT_INTERFACE_ID_PREFIX|interfaces.size();
+    return TYPE_INOUT_INTERFACE_ID_PREFIX|interfaces.size();
 }
 
 
 bool Inout_interface_mgt::is_interface_id_legal(int interface_id)
 {
-	if ((interface_id & TYPE_ID_PREFIX_MASK) != TYPE_INOUT_INTERFACE_ID_PREFIX)
-		return false;
+    if ((interface_id & TYPE_ID_PREFIX_MASK) != TYPE_INOUT_INTERFACE_ID_PREFIX)
+        return false;
 
-	return (interface_id&TYPE_ID_SUFFIX_MASK) < interfaces.size();
+    return (interface_id&TYPE_ID_SUFFIX_MASK) < interfaces.size();
 }
 
 
 Inout_interface *Inout_interface_mgt::get_interface(int interface_id)
 {
-	if (!is_interface_id_legal(interface_id))
-		return NULL;
+    if (!is_interface_id_legal(interface_id))
+        return NULL;
 
-	return interfaces[interface_id&TYPE_ID_SUFFIX_MASK];
+    return interfaces[interface_id&TYPE_ID_SUFFIX_MASK];
 }
 
 
 Inout_interface *Inout_interface_mgt::get_interface(const char *comp_full_name, const char *interface_name)
 {
-	for (int i = 0; i < interfaces.size(); i ++)
-		if (words_are_the_same(interfaces[i]->get_comp_full_name(),comp_full_name) && words_are_the_same(interfaces[i]->get_interface_name(), interface_name))
-			return interfaces[i];
+    for (int i = 0; i < interfaces.size(); i ++)
+        if (words_are_the_same(interfaces[i]->get_comp_full_name(),comp_full_name) && words_are_the_same(interfaces[i]->get_interface_name(), interface_name))
+            return interfaces[i];
 
-	return NULL;
+    return NULL;
 }
 
 
 Inout_interface *Inout_interface_mgt::get_interface(int comp_id, const char *interface_name)
 {
-	for (int i = 0; i < interfaces.size(); i ++)
-		if (interfaces[i]->get_comp_id() == comp_id && words_are_the_same(interfaces[i]->get_interface_name(), interface_name))
-			return interfaces[i];
+    for (int i = 0; i < interfaces.size(); i ++)
+        if (interfaces[i]->get_comp_id() == comp_id && words_are_the_same(interfaces[i]->get_interface_name(), interface_name))
+            return interfaces[i];
 
-	return NULL;
+    return NULL;
 }
 
 
 void Inout_interface_mgt::get_all_unconnected_inout_interface_fields_info(std::vector<const char*> &all_descendant_real_comp_fullnames, char **temp_array_buffer, long &buffer_content_size, MPI_Comm comm)
 {
-	char *local_temp_array_buffer = NULL;
-	long local_buffer_max_size = 0, local_buffer_content_size = 0;
-	int num_total_local_proc, current_proc_local_id, *all_array_size;
+    char *local_temp_array_buffer = NULL;
+    long local_buffer_max_size = 0, local_buffer_content_size = 0;
+    int num_total_local_proc, current_proc_local_id, *all_array_size;
 
 
-	for (int i = 0; i < all_descendant_real_comp_fullnames.size(); i ++) {
-		Comp_comm_group_mgt_node *comp_node = comp_comm_group_mgt_mgr->search_global_node(all_descendant_real_comp_fullnames[i]);
-		if (comp_node == NULL || comp_node->get_current_proc_local_id() != 0)
-			continue;
-		for (int j = 0; j < interfaces.size(); j ++)
-			if (interfaces[j]->get_comp_id() == comp_node->get_comp_id())
-				interfaces[j]->transform_interface_into_array(&local_temp_array_buffer, local_buffer_max_size, local_buffer_content_size);
-	}
+    for (int i = 0; i < all_descendant_real_comp_fullnames.size(); i ++) {
+        Comp_comm_group_mgt_node *comp_node = comp_comm_group_mgt_mgr->search_global_node(all_descendant_real_comp_fullnames[i]);
+        if (comp_node == NULL || comp_node->get_current_proc_local_id() != 0)
+            continue;
+        for (int j = 0; j < interfaces.size(); j ++)
+            if (interfaces[j]->get_comp_id() == comp_node->get_comp_id())
+                interfaces[j]->transform_interface_into_array(&local_temp_array_buffer, local_buffer_max_size, local_buffer_content_size);
+    }
 
-	EXECUTION_REPORT(REPORT_ERROR, -1, MPI_Comm_size(comm, &num_total_local_proc) == MPI_SUCCESS);
-	EXECUTION_REPORT(REPORT_ERROR, -1, MPI_Comm_rank(comm, &current_proc_local_id) == MPI_SUCCESS);
-	all_array_size = new int [num_total_local_proc];
-	gather_array_in_one_comp(num_total_local_proc, current_proc_local_id, local_temp_array_buffer, local_buffer_content_size, sizeof(char), all_array_size, (void**)temp_array_buffer, buffer_content_size, comm);
-	delete [] all_array_size;
+    EXECUTION_REPORT(REPORT_ERROR, -1, MPI_Comm_size(comm, &num_total_local_proc) == MPI_SUCCESS);
+    EXECUTION_REPORT(REPORT_ERROR, -1, MPI_Comm_rank(comm, &current_proc_local_id) == MPI_SUCCESS);
+    all_array_size = new int [num_total_local_proc];
+    gather_array_in_one_comp(num_total_local_proc, current_proc_local_id, local_temp_array_buffer, local_buffer_content_size, sizeof(char), all_array_size, (void**)temp_array_buffer, buffer_content_size, comm);
+    delete [] all_array_size;
 }
 
 
 void Inout_interface_mgt::get_all_import_interfaces_of_a_component(std::vector<Inout_interface*> &import_interfaces, int comp_id)
 {
-	import_interfaces.clear();
+    import_interfaces.clear();
 
-	for (int i = 0; i < interfaces.size(); i ++)
-		if (interfaces[i]->get_comp_id() == comp_id && interfaces[i]->get_interface_type() == COUPLING_INTERFACE_MARK_IMPORT)
-			import_interfaces.push_back(interfaces[i]);
+    for (int i = 0; i < interfaces.size(); i ++)
+        if (interfaces[i]->get_comp_id() == comp_id && interfaces[i]->get_interface_type() == COUPLING_INTERFACE_MARK_IMPORT)
+            import_interfaces.push_back(interfaces[i]);
 }
 
 
 void Inout_interface_mgt::get_all_import_interfaces_of_a_component(std::vector<Inout_interface*> &import_interfaces, const char *comp_full_name)
 {
-	import_interfaces.clear();
+    import_interfaces.clear();
 
-	for (int i = 0; i < interfaces.size(); i ++)
-		if (words_are_the_same(interfaces[i]->get_comp_full_name(), comp_full_name) && interfaces[i]->get_interface_type() == COUPLING_INTERFACE_MARK_IMPORT)
-			import_interfaces.push_back(interfaces[i]);
+    for (int i = 0; i < interfaces.size(); i ++)
+        if (words_are_the_same(interfaces[i]->get_comp_full_name(), comp_full_name) && interfaces[i]->get_interface_type() == COUPLING_INTERFACE_MARK_IMPORT)
+            import_interfaces.push_back(interfaces[i]);
 }
 
 
 void Inout_interface_mgt::execute_interface(int interface_id, int API_id, bool bypass_timer, int *field_update_status, int size_field_update_status, int *num_dst_fields, const char *annotation)
 {
-	Inout_interface *inout_interface;
-	char API_label[NAME_STR_SIZE];
+    Inout_interface *inout_interface;
+    char API_label[NAME_STR_SIZE];
 
-	
-	get_API_hint(-1, API_id, API_label);
+    
+    get_API_hint(-1, API_id, API_label);
 
-	if (!is_interface_id_legal(interface_id))
-		EXECUTION_REPORT(REPORT_ERROR, -1, false, "Error happens when executing an interface through the API \"%s\": the given interface ID 0x%x is illegal. Please check the model code with the annotation \"%s\"", API_label, interface_id, annotation);
-	inout_interface = get_interface(interface_id);
-	EXECUTION_REPORT_LOG(REPORT_LOG, inout_interface->get_comp_id(), true, "Begin to execute interface \"%s\" (model code annotation is \"%s\")", inout_interface->get_interface_name(), annotation);	
-	inout_interface->execute(bypass_timer, API_id, field_update_status, size_field_update_status, annotation);
-	*num_dst_fields = inout_interface->get_num_dst_fields();
-	EXECUTION_REPORT_LOG(REPORT_LOG, inout_interface->get_comp_id(), true, "Finishing executing interface \"%s\" (model code annotation is \"%s\")", inout_interface->get_interface_name(), annotation);
+    if (!is_interface_id_legal(interface_id))
+        EXECUTION_REPORT(REPORT_ERROR, -1, false, "Error happens when executing an interface through the API \"%s\": the given interface ID 0x%x is illegal. Please check the model code with the annotation \"%s\"", API_label, interface_id, annotation);
+    inout_interface = get_interface(interface_id);
+    EXECUTION_REPORT_LOG(REPORT_LOG, inout_interface->get_comp_id(), true, "Begin to execute interface \"%s\" (model code annotation is \"%s\")", inout_interface->get_interface_name(), annotation);    
+    inout_interface->execute(bypass_timer, API_id, field_update_status, size_field_update_status, annotation);
+    *num_dst_fields = inout_interface->get_num_dst_fields();
+    EXECUTION_REPORT_LOG(REPORT_LOG, inout_interface->get_comp_id(), true, "Finish executing interface \"%s\" (model code annotation is \"%s\")", inout_interface->get_interface_name(), annotation);
 
-	inout_interface->dump_active_coupling_connections();
+    inout_interface->dump_active_coupling_connections();
 }
 
 
 void Inout_interface_mgt::execute_interface(int comp_id, int API_id, const char *interface_name, bool bypass_timer, int *field_update_status, int size_field_update_status, int *num_dst_fields, const char *annotation)
 {
-	Inout_interface *inout_interface;
-	char API_label[NAME_STR_SIZE];
+    Inout_interface *inout_interface;
+    char API_label[NAME_STR_SIZE];
 
-	
-	get_API_hint(-1, API_id, API_label);
-	if (!comp_comm_group_mgt_mgr->is_legal_local_comp_id(comp_id,true))
-		EXECUTION_REPORT(REPORT_ERROR, -1, false, "Error happens when executing an interface through the API \"%s\": the given component model ID 0x%x is illegal. Please check the model code with the annotation \"%s\"", API_label, comp_id, annotation);
-	inout_interface = get_interface(comp_id, interface_name);
-	if (inout_interface == NULL)
-		EXECUTION_REPORT(REPORT_ERROR, comp_id, false, "Error happens when executing an interface through the API \"%s\": the corresponding component model \"%s\" does not have an interface with the given name \"%s\". Please check the model code with the annotation \"%s\"", API_label, comp_comm_group_mgt_mgr->get_global_node_of_local_comp(comp_id,false,"")->get_comp_full_name(), interface_name, annotation);
-	EXECUTION_REPORT_LOG(REPORT_LOG, inout_interface->get_comp_id(), true, "Begin to execute interface \"%s\" (model code annotation is \"%s\")", inout_interface->get_interface_name(), annotation);	
-	inout_interface->execute(bypass_timer, API_id, field_update_status, size_field_update_status, annotation);
-	*num_dst_fields = inout_interface->get_num_dst_fields();
-	EXECUTION_REPORT_LOG(REPORT_LOG, inout_interface->get_comp_id(), true, "Finishing executing interface \"%s\" (model code annotation is \"%s\")", inout_interface->get_interface_name(), annotation);
+    
+    get_API_hint(-1, API_id, API_label);
+    if (!comp_comm_group_mgt_mgr->is_legal_local_comp_id(comp_id,true))
+        EXECUTION_REPORT(REPORT_ERROR, -1, false, "Error happens when executing an interface through the API \"%s\": the given component model ID 0x%x is illegal. Please check the model code with the annotation \"%s\"", API_label, comp_id, annotation);
+    inout_interface = get_interface(comp_id, interface_name);
+    if (inout_interface == NULL)
+        EXECUTION_REPORT(REPORT_ERROR, comp_id, false, "Error happens when executing an interface through the API \"%s\": the corresponding component model \"%s\" does not have an interface with the given name \"%s\". Please check the model code with the annotation \"%s\"", API_label, comp_comm_group_mgt_mgr->get_global_node_of_local_comp(comp_id,false,"")->get_comp_full_name(), interface_name, annotation);
+    EXECUTION_REPORT_LOG(REPORT_LOG, inout_interface->get_comp_id(), true, "Begin to execute interface \"%s\" (model code annotation is \"%s\")", inout_interface->get_interface_name(), annotation);    
+    inout_interface->execute(bypass_timer, API_id, field_update_status, size_field_update_status, annotation);
+    *num_dst_fields = inout_interface->get_num_dst_fields();
+    EXECUTION_REPORT_LOG(REPORT_LOG, inout_interface->get_comp_id(), true, "Finish executing interface \"%s\" (model code annotation is \"%s\")", inout_interface->get_interface_name(), annotation);
 
-	inout_interface->dump_active_coupling_connections();
+    inout_interface->dump_active_coupling_connections();
 }
 
 
 void Inout_interface_mgt::runtime_receive_algorithms_receive_data()
 {
 #ifdef USE_ONE_SIDED_MPI
-	for (int i = 0; i < all_runtime_receive_algorithms.size(); i ++)
-		all_runtime_receive_algorithms[i]->receive_data_in_temp_buffer();
+    for (int i = 0; i < all_runtime_receive_algorithms.size(); i ++)
+        all_runtime_receive_algorithms[i]->receive_data_in_temp_buffer();
 #endif
 }
 
 
 void Inout_interface_mgt::erase_runtime_receive_algorithm(Runtime_trans_algorithm *new_algorithm)
 {
-	for (int i = 0; i < all_runtime_receive_algorithms.size(); i ++)
-		if (all_runtime_receive_algorithms[i] == new_algorithm) {
-			all_runtime_receive_algorithms.erase(all_runtime_receive_algorithms.begin()+i);
-			break;
-		}
+    for (int i = 0; i < all_runtime_receive_algorithms.size(); i ++)
+        if (all_runtime_receive_algorithms[i] == new_algorithm) {
+            all_runtime_receive_algorithms.erase(all_runtime_receive_algorithms.begin()+i);
+            break;
+        }
 }
 
 
 void Inout_interface_mgt::free_all_MPI_wins()
 {
-	for (int i = 0; i < all_MPI_wins.size(); i ++) {
-		MPI_Win mpi_win = all_MPI_wins[i];
-		MPI_Win_free(&mpi_win);
-	}
+    for (int i = 0; i < all_MPI_wins.size(); i ++) {
+        MPI_Win mpi_win = all_MPI_wins[i];
+        MPI_Win_free(&mpi_win);
+    }
 }
 
 
 void Inout_interface_mgt::write_into_restart_buffers(int comp_id)
 {
-	char *array_buffer;
-	long buffer_max_size, buffer_content_size;
+    char *array_buffer;
+    long buffer_max_size, buffer_content_size;
 
-	
-	for (int i = 0; i < interfaces.size(); i ++)
-		if (interfaces[i]->get_comp_id() == comp_id) {
-			if (!interfaces[i]->has_been_executed_with_timer())
-				continue;
-			interfaces[i]->write_restart_mgt_info(NULL);
-		}			
+    
+    for (int i = 0; i < interfaces.size(); i ++)
+        if (interfaces[i]->get_comp_id() == comp_id) {
+            if (!interfaces[i]->has_been_executed_with_timer())
+                continue;
+            interfaces[i]->write_restart_mgt_info(NULL);
+        }            
 }
 
 
 void Inout_interface_mgt::write_comp_export_info_into_XML_file(int comp_id)
 {
-	Comp_comm_group_mgt_node *comp_node = comp_comm_group_mgt_mgr->search_global_node(comp_id);
-	char XML_file_name[NAME_STR_SIZE];
-
-
-	if (comp_node->get_current_proc_local_id() == 0) {
-		TiXmlDocument *XML_file = new TiXmlDocument;
-		TiXmlDeclaration *XML_declaration = new TiXmlDeclaration(("1.0"),(""),(""));
-		EXECUTION_REPORT(REPORT_ERROR, -1, XML_file != NULL, "Software error: cannot create an xml file");
-		XML_file->LinkEndChild(XML_declaration);
-		TiXmlElement *root_element = new TiXmlElement("export_interfaces");
-		root_element->SetAttribute("comp_full_name", comp_node->get_comp_full_name());
-		XML_file->LinkEndChild(root_element);
-		for (int i = 0; i < interfaces.size(); i ++)
-			if (interfaces[i]->get_interface_type() == COUPLING_INTERFACE_MARK_EXPORT && interfaces[i]->get_comp_id() == comp_id)
-				interfaces[i]->write_export_info_into_XML_file(root_element);
-			sprintf(XML_file_name, "%s/%s.exports_info.xml", comp_comm_group_mgt_mgr->get_components_exports_dir(), comp_node->get_full_name());
-			EXECUTION_REPORT(REPORT_ERROR, -1, XML_file->SaveFile(XML_file_name), "Software error in Inout_interface_mgt::write_comp_export_info_into_XML_file: fail to write the XML file %s", XML_file_name);
-			delete XML_file;	
-	}
-	MPI_Barrier(comp_node->get_comm_group());
+    Comp_comm_group_mgt_node *comp_node = comp_comm_group_mgt_mgr->search_global_node(comp_id);
+    char XML_file_name[NAME_STR_SIZE];
+
+
+    if (comp_node->get_current_proc_local_id() == 0) {
+        TiXmlDocument *XML_file = new TiXmlDocument;
+        TiXmlDeclaration *XML_declaration = new TiXmlDeclaration(("1.0"),(""),(""));
+        EXECUTION_REPORT(REPORT_ERROR, -1, XML_file != NULL, "Software error: cannot create an xml file");
+        XML_file->LinkEndChild(XML_declaration);
+        TiXmlElement *root_element = new TiXmlElement("export_interfaces");
+        root_element->SetAttribute("comp_full_name", comp_node->get_comp_full_name());
+        XML_file->LinkEndChild(root_element);
+        for (int i = 0; i < interfaces.size(); i ++)
+            if (interfaces[i]->get_interface_type() == COUPLING_INTERFACE_MARK_EXPORT && interfaces[i]->get_comp_id() == comp_id)
+                interfaces[i]->write_export_info_into_XML_file(root_element);
+            sprintf(XML_file_name, "%s/%s.exports_info.xml", comp_comm_group_mgt_mgr->get_components_exports_dir(), comp_node->get_full_name());
+            EXECUTION_REPORT(REPORT_ERROR, -1, XML_file->SaveFile(XML_file_name), "Software error in Inout_interface_mgt::write_comp_export_info_into_XML_file: fail to write the XML file %s", XML_file_name);
+            delete XML_file;    
+    }
+    MPI_Barrier(comp_node->get_comm_group());
 }
 
 
 void Inout_interface_mgt::get_all_export_interfaces_of_a_field(int comp_id, const char *field_name, std::vector<const char*> &export_comp_full_names, std::vector<const char*> &export_interface_names)
 {
-	Comp_comm_group_mgt_node *comp_node = comp_comm_group_mgt_mgr->search_global_node(comp_id);
-	int line_number;
-	char XML_file_name[NAME_STR_SIZE];
+    Comp_comm_group_mgt_node *comp_node = comp_comm_group_mgt_mgr->search_global_node(comp_id);
+    int line_number;
+    char XML_file_name[NAME_STR_SIZE];
 
 
-	for (int i = 0; i < export_comp_full_names.size(); i ++) {
-		delete [] export_comp_full_names[i];
-		delete [] export_interface_names[i];
-	}
-	export_comp_full_names.clear();
-	export_interface_names.clear();
-	 
-	if (comp_node->get_current_proc_local_id() == 0) {
-		DIR *cur_dir = opendir(comp_comm_group_mgt_mgr->get_components_exports_dir());
-		struct dirent *ent = NULL;
-		struct stat st;
-		EXECUTION_REPORT(REPORT_ERROR, -1, cur_dir != NULL, "Software error in Inout_interface_mgt::get_all_export_interfaces_of_a_field");
-		while ((ent = readdir(cur_dir)) != NULL) {
-			stat(ent->d_name, &st);
-			if (!(strlen(ent->d_name) > 4 && words_are_the_same(ent->d_name+strlen(ent->d_name)-4, ".xml")))
-				continue;
-			sprintf(XML_file_name, "%s/%s", comp_comm_group_mgt_mgr->get_components_exports_dir(), ent->d_name);
-			TiXmlDocument *XML_file = open_XML_file_to_read(comp_id, XML_file_name, MPI_COMM_NULL, false);
-			EXECUTION_REPORT(REPORT_ERROR, -1, XML_file != NULL, "Software error in Inout_interface_mgt::get_all_export_interfaces_of_a_field: no XML file");
-			TiXmlElement *root_element = XML_file->FirstChildElement();
-			const char *comp_full_name = get_XML_attribute(comp_id, -1, root_element, "comp_full_name", XML_file_name, line_number, "the full name of the corresponding component model", "internal XML files generated by C-Coupler", true);
-			for (TiXmlNode *export_interface_node = root_element->FirstChildElement(); export_interface_node != NULL; export_interface_node = export_interface_node->NextSibling()) {
-				if (export_interface_node->Type() != TiXmlNode::TINYXML_ELEMENT)
-					continue;
-				TiXmlElement *export_interface_element = export_interface_node->ToElement();
-				const char *interface_name = get_XML_attribute(comp_id, -1, export_interface_element, "interface_name", XML_file_name, line_number, "the name of the export interface", "internal XML files generated by C-Coupler", true);
-				for (TiXmlNode *export_field_node = export_interface_element->FirstChildElement(); export_field_node != NULL; export_field_node = export_field_node->NextSibling()) {
-					if (export_field_node->Type() != TiXmlNode::TINYXML_ELEMENT)
-						continue;
-					TiXmlElement *export_field_element = export_field_node->ToElement();
-					const char *XML_field_name = get_XML_attribute(comp_id, -1, export_field_element, "field_name", XML_file_name, line_number, "the name of the export field", "internal XML files generated by C-Coupler", true);
-					if (words_are_the_same(XML_field_name, field_name)) {
-						export_comp_full_names.push_back(strdup(comp_full_name));
-						export_interface_names.push_back(strdup(interface_name));
-					}
-				}
-			}
-			
-			delete XML_file;
-		}
-	}
-	MPI_Barrier(comp_node->get_comm_group());
+    for (int i = 0; i < export_comp_full_names.size(); i ++) {
+        delete [] export_comp_full_names[i];
+        delete [] export_interface_names[i];
+    }
+    export_comp_full_names.clear();
+    export_interface_names.clear();
+     
+    if (comp_node->get_current_proc_local_id() == 0) {
+        DIR *cur_dir = opendir(comp_comm_group_mgt_mgr->get_components_exports_dir());
+        struct dirent *ent = NULL;
+        struct stat st;
+        EXECUTION_REPORT(REPORT_ERROR, -1, cur_dir != NULL, "Software error in Inout_interface_mgt::get_all_export_interfaces_of_a_field");
+        while ((ent = readdir(cur_dir)) != NULL) {
+            stat(ent->d_name, &st);
+            if (!(strlen(ent->d_name) > 4 && words_are_the_same(ent->d_name+strlen(ent->d_name)-4, ".xml")))
+                continue;
+            sprintf(XML_file_name, "%s/%s", comp_comm_group_mgt_mgr->get_components_exports_dir(), ent->d_name);
+            TiXmlDocument *XML_file = open_XML_file_to_read(comp_id, XML_file_name, MPI_COMM_NULL, false);
+            EXECUTION_REPORT(REPORT_ERROR, -1, XML_file != NULL, "Software error in Inout_interface_mgt::get_all_export_interfaces_of_a_field: no XML file");
+            TiXmlElement *root_element = XML_file->FirstChildElement();
+            const char *comp_full_name = get_XML_attribute(comp_id, -1, root_element, "comp_full_name", XML_file_name, line_number, "the full name of the corresponding component model", "internal XML files generated by C-Coupler", true);
+            for (TiXmlNode *export_interface_node = root_element->FirstChildElement(); export_interface_node != NULL; export_interface_node = export_interface_node->NextSibling()) {
+                if (export_interface_node->Type() != TiXmlNode::TINYXML_ELEMENT)
+                    continue;
+                TiXmlElement *export_interface_element = export_interface_node->ToElement();
+                const char *interface_name = get_XML_attribute(comp_id, -1, export_interface_element, "interface_name", XML_file_name, line_number, "the name of the export interface", "internal XML files generated by C-Coupler", true);
+                for (TiXmlNode *export_field_node = export_interface_element->FirstChildElement(); export_field_node != NULL; export_field_node = export_field_node->NextSibling()) {
+                    if (export_field_node->Type() != TiXmlNode::TINYXML_ELEMENT)
+                        continue;
+                    TiXmlElement *export_field_element = export_field_node->ToElement();
+                    const char *XML_field_name = get_XML_attribute(comp_id, -1, export_field_element, "field_name", XML_file_name, line_number, "the name of the export field", "internal XML files generated by C-Coupler", true);
+                    if (words_are_the_same(XML_field_name, field_name)) {
+                        export_comp_full_names.push_back(strdup(comp_full_name));
+                        export_interface_names.push_back(strdup(interface_name));
+                    }
+                }
+            }
+            
+            delete XML_file;
+        }
+    }
+    MPI_Barrier(comp_node->get_comm_group());
 }
 
 
 Inout_interface *Inout_interface_mgt::search_an_inout_interface_executed_with_timer(int comp_id)
 {
-	for (int i = 0; i < interfaces.size(); i ++)
-		if (interfaces[i]->get_comp_id() == comp_id && interfaces[i]->get_interface_type() < 2 && interfaces[i]->has_been_executed_with_timer())
-			return interfaces[i];
+    for (int i = 0; i < interfaces.size(); i ++)
+        if (interfaces[i]->get_comp_id() == comp_id && interfaces[i]->get_interface_type() < 2 && interfaces[i]->has_been_executed_with_timer())
+            return interfaces[i];
 
-	return NULL;
+    return NULL;
 }
 
 
 int Inout_interface_mgt::get_h2d_grid_area_in_remapping_weights(int interface_id, int field_index, void *output_area_data, int area_array_size, const char *data_type, const char *annotation)
 {
-	Inout_interface *inout_interface = get_interface(interface_id);
-	EXECUTION_REPORT_ERROR_OPTIONALLY(REPORT_ERROR, -1, inout_interface != NULL, "ERROR happens when calling the API \"CCPL_get_H2D_grid_area_in_remapping_wgts\": the parameter of interface ID is wrong. Please verify the model code with the annotation \"%s\"", annotation);
-	return inout_interface->get_h2d_grid_area_in_remapping_weights(inout_interface->get_interface_name(), field_index, output_area_data, area_array_size, data_type, annotation);
+    Inout_interface *inout_interface = get_interface(interface_id);
+    EXECUTION_REPORT_ERROR_OPTIONALLY(REPORT_ERROR, -1, inout_interface != NULL, "ERROR happens when calling the API \"CCPL_get_H2D_grid_area_in_remapping_wgts\": the parameter of interface ID is wrong. Please verify the model code with the annotation \"%s\"", annotation);
+    return inout_interface->get_h2d_grid_area_in_remapping_weights(inout_interface->get_interface_name(), field_index, output_area_data, area_array_size, data_type, annotation);
 }
 
 
 bool Inout_interface_mgt::is_comp_in_restart_write_window(int comp_id)
 {
-	for (int i = 0; i < interfaces.size(); i ++)
-		if (interfaces[i]->get_comp_id() == comp_id && interfaces[i]->is_in_restart_write_window())
-			return true;
-		
-	return false;	
+    for (int i = 0; i < interfaces.size(); i ++)
+        if (interfaces[i]->get_comp_id() == comp_id && interfaces[i]->is_in_restart_write_window())
+            return true;
+        
+    return false;    
 }
 
 
diff --git a/src/Runtime_MGT/inout_interface_mgt.h b/src/Runtime_MGT/inout_interface_mgt.h
old mode 100644
new mode 100755
index 8671047..2fd469d
--- a/src/Runtime_MGT/inout_interface_mgt.h
+++ b/src/Runtime_MGT/inout_interface_mgt.h
@@ -34,10 +34,10 @@
 
 enum
 {
-	COUPLING_INTERFACE_MARK_IMPORT = 0,
-	COUPLING_INTERFACE_MARK_EXPORT,
-	COUPLING_INTERFACE_MARK_NORMAL_REMAP,
-	COUPLING_INTERFACE_MARK_FRAC_REMAP
+    COUPLING_INTERFACE_MARK_IMPORT = 0,
+    COUPLING_INTERFACE_MARK_EXPORT,
+    COUPLING_INTERFACE_MARK_NORMAL_REMAP,
+    COUPLING_INTERFACE_MARK_FRAC_REMAP
 };
 
 
@@ -47,191 +47,198 @@ class Coupling_connection;
 
 class Connection_field_time_info
 {
-	public:
-		int current_year;
-		int current_month;
-		int current_day;
-		int current_second;
-		int current_num_elapsed_days;
-		int last_timer_num_elapsed_days;
-		int last_timer_second;
-		int next_timer_num_elapsed_days;
-		int next_timer_second;
-		int time_step_in_second;
-		int inst_or_aver;
-		int lag_seconds;
-		Coupling_timer *timer;
-		Inout_interface *inout_interface;
-
-		Connection_field_time_info(Inout_interface*, Coupling_timer*, int, int, int, int, int, int);
-		void get_time_of_next_timer_on(bool);
-		void reset_last_timer_info() { last_timer_num_elapsed_days = -1; last_timer_second = -1; }
-		void write_restart_mgt_info(Restart_buffer_container*);		
-		void import_restart_data(Restart_buffer_container*);
+    public:
+        int current_year;
+        int current_month;
+        int current_day;
+        int current_second;
+        int current_num_elapsed_days;
+		int last_timer_date;
+        int last_timer_num_elapsed_days;
+        int last_timer_second;
+		int next_timer_date;
+        int next_timer_num_elapsed_days;
+        int next_timer_second;
+        int time_step_in_second;
+        int inst_or_aver;
+        int lag_seconds;
+        Coupling_timer *timer;
+        Inout_interface *inout_interface;
+
+        Connection_field_time_info(Inout_interface*, Coupling_timer*, int, int, int, int, int, int);
+        void get_time_of_next_timer_on(bool);
+        void reset_last_timer_info() { last_timer_num_elapsed_days = -1; last_timer_second = -1; }
+        void write_restart_mgt_info(Restart_buffer_container*);        
+        void import_restart_data(Restart_buffer_container*);
 };
 
 
 class Connection_coupling_procedure
 {
-	private:
-		friend class Inout_interface;
-		std::vector<Field_mem_info *> fields_mem_registered;
-		std::vector<Field_mem_info *> fields_mem_inner_step_averaged;
-		std::vector<Field_mem_info *> fields_mem_inter_step_averaged;
-		std::vector<Field_mem_info *> fields_mem_remapped;
-		std::vector<Field_mem_info *> fields_mem_datatype_transformed;
-		std::vector<Field_mem_info *> fields_mem_unit_transformed;
-		std::vector<Field_mem_info *> fields_mem_transfer;
-		std::vector<int> field_interface_local_index;
-		Connection_field_time_info * fields_time_info_src;
-		Connection_field_time_info * fields_time_info_dst;
-		long last_remote_fields_time;
+    private:
+        friend class Inout_interface;
+        std::vector<Field_mem_info *> fields_mem_registered;
+        std::vector<Field_mem_info *> fields_mem_inner_step_averaged;
+        std::vector<Field_mem_info *> fields_mem_inter_step_averaged;
+        std::vector<Field_mem_info *> fields_mem_remapped;
+        std::vector<Field_mem_info *> fields_mem_datatype_transformed;
+        std::vector<Field_mem_info *> fields_mem_unit_transformed;
+        std::vector<Field_mem_info *> fields_mem_transfer;
+        std::vector<int> field_interface_local_index;
+        Connection_field_time_info * fields_time_info_src;
+        Connection_field_time_info * fields_time_info_dst;
+        long last_remote_fields_time;
 		long current_remote_fields_time;
-		Coupling_connection *coupling_connection;
-		Inout_interface *inout_interface;
-		std::vector<Runtime_cumulate_average_algorithm*> runtime_inner_averaging_algorithm;
-		std::vector<Runtime_cumulate_average_algorithm*> runtime_inter_averaging_algorithm;
-		std::vector<Runtime_remap_algorithm*> runtime_remap_algorithms;
-		std::vector<Runtime_algorithm_basis*> runtime_unit_transform_algorithms;
-		std::vector<Runtime_datatype_transformer*> runtime_datatype_transform_algorithms;
-		Runtime_trans_algorithm *runtime_data_transfer_algorithm;
-		bool finish_status;
-		bool transfer_data;
-		bool coupling_connections_dumped;
-		Restart_mgt *restart_mgr;
-		int remote_bypass_counter;
-		bool is_coupling_time_out_of_execution;
-		
-	public:
-		Connection_coupling_procedure(Inout_interface*, Coupling_connection*);
-		~Connection_coupling_procedure();
-		void add_data_transfer_algorithm(Runtime_trans_algorithm * runtime_algorithm) { runtime_data_transfer_algorithm = runtime_algorithm; }
-		void execute(bool, int*, const char*);
-		void send_fields(bool);
-		Field_mem_info *get_data_transfer_field_instance(int); 
-		int get_num_runtime_remap_algorithms() { return runtime_remap_algorithms.size(); }
-		Runtime_remap_algorithm *get_runtime_remap_algorithm(int i) { return runtime_remap_algorithms[i]; }
-		Runtime_remapping_weights *get_runtime_remapping_weights(int i);
-		bool get_finish_status() { return finish_status; }
-		void write_restart_mgt_info(Restart_buffer_container*);
-		void import_restart_data(Restart_buffer_container*);
-		Coupling_connection* get_coupling_connection(){return coupling_connection;}
-		bool get_coupling_connections_dumped(){return coupling_connections_dumped;}
-		void set_coupling_connections_dumped(){ coupling_connections_dumped = true;}
-		Inout_interface *get_inout_interface() { return inout_interface; }
-		bool is_in_restart_write_window() { return restart_mgr->is_in_restart_write_window(current_remote_fields_time, false); }
-		bool get_is_coupling_time_out_of_execution() { return is_coupling_time_out_of_execution; }
+        long current_remote_fields_elapsed_time;
+        Coupling_connection *coupling_connection;
+        Inout_interface *inout_interface;
+        std::vector<Runtime_cumulate_average_algorithm*> runtime_inner_averaging_algorithm;
+        std::vector<Runtime_cumulate_average_algorithm*> runtime_inter_averaging_algorithm;
+        std::vector<Runtime_remap_algorithm*> runtime_remap_algorithms;
+        std::vector<Runtime_algorithm_basis*> runtime_unit_transform_algorithms;
+        std::vector<Runtime_datatype_transformer*> runtime_datatype_transform_algorithms;
+        Runtime_trans_algorithm *runtime_data_transfer_algorithm;
+        bool finish_status;
+        bool transfer_data;
+        bool coupling_connections_dumped;
+        Restart_mgt *restart_mgr;
+        int remote_bypass_counter;
+        bool is_coupling_time_out_of_execution;
+		long last_receive_sender_time;
+        
+    public:
+        Connection_coupling_procedure(Inout_interface*, Coupling_connection*);
+        ~Connection_coupling_procedure();
+        void add_data_transfer_algorithm(Runtime_trans_algorithm * runtime_algorithm) { runtime_data_transfer_algorithm = runtime_algorithm; }
+        void execute(bool, int*, const char*);
+        void send_fields(bool);
+        Field_mem_info *get_data_transfer_field_instance(int); 
+        int get_num_runtime_remap_algorithms() { return runtime_remap_algorithms.size(); }
+        Runtime_remap_algorithm *get_runtime_remap_algorithm(int i) { return runtime_remap_algorithms[i]; }
+        Runtime_remapping_weights *get_runtime_remapping_weights(int i);
+        bool get_finish_status() { return finish_status; }
+        void write_restart_mgt_info(Restart_buffer_container*);
+        void import_restart_data(Restart_buffer_container*);
+        Coupling_connection* get_coupling_connection(){return coupling_connection;}
+        bool get_coupling_connections_dumped(){return coupling_connections_dumped;}
+        void set_coupling_connections_dumped(){ coupling_connections_dumped = true;}
+        Inout_interface *get_inout_interface() { return inout_interface; }
+        bool is_in_restart_write_window() { return restart_mgr->is_in_restart_write_window(current_remote_fields_elapsed_time, false); }
+        bool get_is_coupling_time_out_of_execution() { return is_coupling_time_out_of_execution; }
+		long get_last_receive_sender_time() { return last_receive_sender_time; }
 };
 
 
 class Inout_interface
 {
-	private:
-		char interface_name[NAME_STR_SIZE];
-		char comp_full_name[NAME_STR_SIZE];
-		int interface_id;
-		int interface_source;
-		int comp_id;
-		int interface_type;
-		Time_mgt *time_mgr;
-		Coupling_timer *timer;
-		int inst_or_aver;
-		std::vector<Field_mem_info *> fields_mem_registered;
-		std::vector<const char*> fields_name;
-		std::vector<bool> fields_connected_status;
-		std::vector<int> imported_fields_necessity;
-		std::vector<Connection_coupling_procedure*> coupling_procedures;
-		std::vector<Inout_interface *> children_interfaces;           // only for remap interface 
-		int execution_checking_status;
-		long last_execution_time;
-		char *inversed_dst_fraction;
-		long bypass_counter;
-		int num_fields_connected;
-		bool mgt_info_has_been_restarted;
-		bool is_child_interface;
-		Restart_mgt *restart_mgr;
-
-	public:
-		Inout_interface(const char*, long&);
-		Inout_interface(const char *, int, int, int *, int *, int, int, int, int, const char*, const char *);
-		Inout_interface(const char*, int, int, int, int*, int, int, int, const char *, const char*, int, int, bool);
-		~Inout_interface();
-		void initialize_data(const char *, int, int, int, int, int *, int, const char *);	
-		void common_checking_for_interface_registration(int, int *, int, int, int, int, const char *, int, int, const char *, const char *);
-		const char *get_interface_name() { return interface_name; }
-		const char *get_comp_full_name() { return comp_full_name; }
-		int get_comp_id() { return comp_id; }
-		int get_interface_id() { return interface_id; }
-		int get_interface_source() { return interface_source; }
-		int get_interface_type() { return interface_type; }
-		void report_common_field_instances(const Inout_interface*);
-		void get_fields_name(std::vector<const char*>*);
-		const char *get_field_name(int);
-		int get_num_dst_fields();
-		void transform_interface_into_array(char**, long&, long&);
-		Field_mem_info *search_registered_field_instance(const char*, int &);
-		Coupling_timer *get_timer() { return timer; }
-		void add_coupling_procedure(Connection_coupling_procedure*);
-		int get_inst_or_aver() { return inst_or_aver; } 
-		void execute(bool, int, int*, int, const char*);
-		Inout_interface *get_child_interface(int i);
-		int get_num_coupling_procedures() { return coupling_procedures.size(); }
-		void add_remappling_fraction_processing(void *, void *, int, int, const char *, const char *, const char *);		
-		void preprocessing_for_frac_based_remapping();
-		void postprocessing_for_frac_based_remapping(bool);
-		long get_bypass_counter() { return bypass_counter; } 
-		void write_export_info_into_XML_file(TiXmlElement*);
-		bool has_been_executed_with_timer() { return (execution_checking_status & 0x2) != 0; }		
-		int get_h2d_grid_area_in_remapping_weights(const char *, int, void *, int, const char *, const char *);
-		void set_fields_necessity(int*, int, const char *);
-		int check_is_import_field_connected(int, const char *);
-		void dump_active_coupling_connections();
-		void dump_active_coupling_connections_into_XML(TiXmlElement *);
-		void import_restart_data(Restart_buffer_container *);
-		void write_restart_mgt_info(Restart_buffer_container*);
-		bool get_is_child_interface() { return is_child_interface; }
-		bool is_in_restart_write_window();
-		void read_restart_fields(int, const char*);
+    private:
+        char interface_name[NAME_STR_SIZE];
+        char comp_full_name[NAME_STR_SIZE];
+        int interface_id;
+        int interface_source;
+        int comp_id;
+        int interface_type;
+        Time_mgt *time_mgr;
+        Coupling_timer *timer;
+        int inst_or_aver;
+        std::vector<Field_mem_info *> fields_mem_registered;
+        std::vector<const char*> fields_name;
+        std::vector<bool> fields_connected_status;
+        std::vector<int> imported_fields_necessity;
+        std::vector<Connection_coupling_procedure*> coupling_procedures;
+		std::vector<Connection_coupling_procedure*> fields_coupling_procedures;
+        std::vector<Inout_interface *> children_interfaces;           // only for remap interface 
+        int execution_checking_status;
+        long last_execution_time;
+        char *inversed_dst_fraction;
+        long bypass_counter;
+        int num_fields_connected;
+        bool mgt_info_has_been_restarted;
+        bool is_child_interface;
+        Restart_mgt *restart_mgr;
+
+    public:
+        Inout_interface(const char*, long&);
+        Inout_interface(const char *, int, int, int *, int *, int, int, int, int, const char*, const char *);
+        Inout_interface(const char*, int, int, int, int*, int, int, int, const char *, const char*, int, int, bool);
+        ~Inout_interface();
+        void initialize_data(const char *, int, int, int, int, int *, int, const char *);    
+        void common_checking_for_interface_registration(int, int *, int, int, int, int, const char *, int, int, const char *, const char *);
+        const char *get_interface_name() { return interface_name; }
+        const char *get_comp_full_name() { return comp_full_name; }
+        int get_comp_id() { return comp_id; }
+        int get_interface_id() { return interface_id; }
+        int get_interface_source() { return interface_source; }
+        int get_interface_type() { return interface_type; }
+        void report_common_field_instances(const Inout_interface*);
+        void get_fields_name(std::vector<const char*>*);
+        const char *get_field_name(int);
+        int get_num_dst_fields();
+        void transform_interface_into_array(char**, long&, long&);
+        Field_mem_info *search_registered_field_instance(const char*, int &);
+        Coupling_timer *get_timer() { return timer; }
+        void add_coupling_procedure(Connection_coupling_procedure*);
+        int get_inst_or_aver() { return inst_or_aver; } 
+        void execute(bool, int, int*, int, const char*);
+        Inout_interface *get_child_interface(int i);
+        int get_num_coupling_procedures() { return coupling_procedures.size(); }
+        void add_remappling_fraction_processing(void *, void *, int, int, const char *, const char *, const char *);        
+        void preprocessing_for_frac_based_remapping();
+        void postprocessing_for_frac_based_remapping(bool);
+        long get_bypass_counter() { return bypass_counter; } 
+        void write_export_info_into_XML_file(TiXmlElement*);
+        bool has_been_executed_with_timer() { return (execution_checking_status & 0x2) != 0; }        
+        int get_h2d_grid_area_in_remapping_weights(const char *, int, void *, int, const char *, const char *);
+        void set_fields_necessity(int*, int, const char *);
+        int check_is_import_field_connected(int, const char *);
+        void dump_active_coupling_connections();
+        void dump_active_coupling_connections_into_XML(TiXmlElement *);
+        void import_restart_data(Restart_buffer_container *);
+        void write_restart_mgt_info(Restart_buffer_container*);
+        bool get_is_child_interface() { return is_child_interface; }
+        bool is_in_restart_write_window();
+        void read_restart_fields(int, const char*);	
+		void get_sender_time(int, int, int, int*, int*, int*, const char*);
 };
 
 
 class Inout_interface_mgt
 {
-	private:
-		std::vector<Inout_interface*> interfaces;
-		std::vector<Runtime_trans_algorithm*> all_runtime_receive_algorithms;
-		std::vector<MPI_Win> all_MPI_wins;
-
-	public:
-		Inout_interface_mgt(const char*, long);
-		Inout_interface_mgt() {}
-		~Inout_interface_mgt();
-		int register_inout_interface(const char*, int, int, int*, int, int, int, const char*, int);
-		void generate_remapping_interface_connection(Inout_interface *, int, int *, bool);
-		int register_normal_remap_interface(const char *, int, int *, int *, int, int, int, int, const char *, const char *);
-		int register_frac_based_remap_interface(const char *, int, int *, int *, int, int, int, int, void *, void *, int, int, const char *, const char *, const char *);
-		int get_next_interface_id();
-		bool is_interface_id_legal(int);
-		Inout_interface *get_interface(int);
-		Inout_interface *get_interface(const char*, const char*);
-		Inout_interface *get_interface(int, const char*);
-		void get_all_import_interfaces_of_a_component(std::vector<Inout_interface*>&, int);	
-		void get_all_import_interfaces_of_a_component(std::vector<Inout_interface*>&, const char*);		
-		void get_all_unconnected_inout_interface_fields_info(std::vector<const char*> & , char **, long &, MPI_Comm);
-		void merge_unconnected_inout_interface_fields_info(int);
-		void execute_interface(int, int, bool, int*, int, int*, const char*);
-		void execute_interface(int, int, const char*, bool, int *, int, int*, const char*);
-		void add_runtime_receive_algorithm(Runtime_trans_algorithm *new_algorithm) { all_runtime_receive_algorithms.push_back(new_algorithm); }
-		void erase_runtime_receive_algorithm(Runtime_trans_algorithm *);
-		void runtime_receive_algorithms_receive_data();
-		void add_MPI_win(MPI_Win mpi_win) { all_MPI_wins.push_back(mpi_win); }
-		void free_all_MPI_wins(); 
-		void write_into_restart_buffers(int);
-		void write_comp_export_info_into_XML_file(int);
-		void get_all_export_interfaces_of_a_field(int, const char *, std::vector<const char*> &, std::vector<const char*> &);
-		Inout_interface *search_an_inout_interface_executed_with_timer(int);		
-		int get_h2d_grid_area_in_remapping_weights(int, int, void *, int, const char *, const char *);
-		bool is_comp_in_restart_write_window(int);
+    private:
+        std::vector<Inout_interface*> interfaces;
+        std::vector<Runtime_trans_algorithm*> all_runtime_receive_algorithms;
+        std::vector<MPI_Win> all_MPI_wins;
+
+    public:
+        Inout_interface_mgt(const char*, long);
+        Inout_interface_mgt() {}
+        ~Inout_interface_mgt();
+        int register_inout_interface(const char*, int, int, int*, int, int, int, const char*, int);
+        void generate_remapping_interface_connection(Inout_interface *, int, int *, bool);
+        int register_normal_remap_interface(const char *, int, int *, int *, int, int, int, int, const char *, const char *);
+        int register_frac_based_remap_interface(const char *, int, int *, int *, int, int, int, int, void *, void *, int, int, const char *, const char *, const char *);
+        int get_next_interface_id();
+        bool is_interface_id_legal(int);
+        Inout_interface *get_interface(int);
+        Inout_interface *get_interface(const char*, const char*);
+        Inout_interface *get_interface(int, const char*);
+        void get_all_import_interfaces_of_a_component(std::vector<Inout_interface*>&, int);    
+        void get_all_import_interfaces_of_a_component(std::vector<Inout_interface*>&, const char*);        
+        void get_all_unconnected_inout_interface_fields_info(std::vector<const char*> & , char **, long &, MPI_Comm);
+        void merge_unconnected_inout_interface_fields_info(int);
+        void execute_interface(int, int, bool, int*, int, int*, const char*);
+        void execute_interface(int, int, const char*, bool, int *, int, int*, const char*);
+        void add_runtime_receive_algorithm(Runtime_trans_algorithm *new_algorithm) { all_runtime_receive_algorithms.push_back(new_algorithm); }
+        void erase_runtime_receive_algorithm(Runtime_trans_algorithm *);
+        void runtime_receive_algorithms_receive_data();
+        void add_MPI_win(MPI_Win mpi_win) { all_MPI_wins.push_back(mpi_win); }
+        void free_all_MPI_wins(); 
+        void write_into_restart_buffers(int);
+        void write_comp_export_info_into_XML_file(int);
+        void get_all_export_interfaces_of_a_field(int, const char *, std::vector<const char*> &, std::vector<const char*> &);
+        Inout_interface *search_an_inout_interface_executed_with_timer(int);        
+        int get_h2d_grid_area_in_remapping_weights(int, int, void *, int, const char *, const char *);
+        bool is_comp_in_restart_write_window(int);
 };
 
 #endif
diff --git a/src/Runtime_MGT/remapping_configuration_mgt.cxx b/src/Runtime_MGT/remapping_configuration_mgt.cxx
old mode 100644
new mode 100755
index ffe44ad..701a1bc
--- a/src/Runtime_MGT/remapping_configuration_mgt.cxx
+++ b/src/Runtime_MGT/remapping_configuration_mgt.cxx
@@ -13,1065 +13,1119 @@
 
 
 H2D_remapping_wgt_file_info::H2D_remapping_wgt_file_info(const char *wgt_file_name)
-{	
-	this->wgt_file_name = strdup(wgt_file_name);
-	num_wgts = 0;
-	wgts_src_indexes = NULL;
-	wgts_dst_indexes = NULL;
-	wgts_values = NULL;
-	src_center_lon = NULL;
-	src_center_lat = NULL;
-	src_area = NULL;
-	dst_center_lon = NULL;
-	dst_center_lat = NULL;
-	dst_area = NULL;
-	checksum_src_mask = -1;
-	checksum_dst_mask = -1;
-	src_grid_size = -1;
-	dst_grid_size = -1;
+{    
+    this->wgt_file_name = strdup(wgt_file_name);
+    num_wgts = 0;
+    wgts_src_indexes = NULL;
+    wgts_dst_indexes = NULL;
+    wgts_values = NULL;
+    src_center_lon = NULL;
+    src_center_lat = NULL;
+    src_area = NULL;
+    dst_center_lon = NULL;
+    dst_center_lat = NULL;
+    dst_area = NULL;
+    checksum_src_mask = -1;
+    checksum_dst_mask = -1;
+    src_grid_size = -1;
+    dst_grid_size = -1;
 }
 
 
 H2D_remapping_wgt_file_info::H2D_remapping_wgt_file_info(const char *array, long *buffer_content_iter)
-{	
-	long str_size; 
-
-
-	wgt_file_name = load_string(NULL, str_size, 4096, array, *buffer_content_iter, NULL);
-	read_data_from_array_buffer(&checksum_dst_mask, sizeof(long), array, *buffer_content_iter, true);
-	read_data_from_array_buffer(&dst_grid_size, sizeof(int), array, *buffer_content_iter, true);
-	read_data_from_array_buffer(&checksum_src_mask, sizeof(long), array, *buffer_content_iter, true);
-	read_data_from_array_buffer(&src_grid_size, sizeof(int), array, *buffer_content_iter, true);
-	
-	num_wgts = 0;
-	wgts_src_indexes = NULL;
-	wgts_dst_indexes = NULL;
-	wgts_values = NULL;	
-	src_center_lon = NULL;
-	src_center_lat = NULL;
-	src_area = NULL;
-	dst_center_lon = NULL;
-	dst_center_lat = NULL;
-	dst_area = NULL;
-	checksum_src_mask = -1;
-	checksum_dst_mask = -1;
-	src_grid_size = -1;
-	dst_grid_size = -1;
+{    
+    long str_size; 
+
+
+    wgt_file_name = load_string(NULL, str_size, 4096, array, *buffer_content_iter, NULL);
+    read_data_from_array_buffer(&checksum_dst_mask, sizeof(long), array, *buffer_content_iter, true);
+    read_data_from_array_buffer(&dst_grid_size, sizeof(int), array, *buffer_content_iter, true);
+    read_data_from_array_buffer(&checksum_src_mask, sizeof(long), array, *buffer_content_iter, true);
+    read_data_from_array_buffer(&src_grid_size, sizeof(int), array, *buffer_content_iter, true);
+    
+    num_wgts = 0;
+    wgts_src_indexes = NULL;
+    wgts_dst_indexes = NULL;
+    wgts_values = NULL;    
+    src_center_lon = NULL;
+    src_center_lat = NULL;
+    src_area = NULL;
+    dst_center_lon = NULL;
+    dst_center_lat = NULL;
+    dst_area = NULL;
+    checksum_src_mask = -1;
+    checksum_dst_mask = -1;
+    src_grid_size = -1;
+    dst_grid_size = -1;
 }
 
 
 void H2D_remapping_wgt_file_info::write_remapping_wgt_file_info_into_array(char **array, long &buffer_max_size, long &buffer_content_size)
 {
-	write_data_into_array_buffer(&src_grid_size, sizeof(int), array, buffer_max_size, buffer_content_size);
-	write_data_into_array_buffer(&checksum_src_mask, sizeof(long), array, buffer_max_size, buffer_content_size);
-	write_data_into_array_buffer(&dst_grid_size, sizeof(int), array, buffer_max_size, buffer_content_size);
-	write_data_into_array_buffer(&checksum_dst_mask, sizeof(long), array, buffer_max_size, buffer_content_size);
-	dump_string(wgt_file_name, -1, array, buffer_max_size, buffer_content_size);
+    write_data_into_array_buffer(&src_grid_size, sizeof(int), array, buffer_max_size, buffer_content_size);
+    write_data_into_array_buffer(&checksum_src_mask, sizeof(long), array, buffer_max_size, buffer_content_size);
+    write_data_into_array_buffer(&dst_grid_size, sizeof(int), array, buffer_max_size, buffer_content_size);
+    write_data_into_array_buffer(&checksum_dst_mask, sizeof(long), array, buffer_max_size, buffer_content_size);
+    dump_string(wgt_file_name, -1, array, buffer_max_size, buffer_content_size);
 }
 
 
 long H2D_remapping_wgt_file_info::get_grid_field_checksum_value(const char *field_name, IO_netcdf *netcdf_file_object, int grid_size, MPI_Comm comm, bool is_root_proc)
 {
-	char *data_buffer, data_type[NAME_STR_SIZE];
-	int field_size;
-	long checksum;
+    char *data_buffer, data_type[NAME_STR_SIZE];
+    int field_size;
+    long checksum;
 
 
-	netcdf_file_object->read_file_field(field_name, (void**)(&data_buffer), &field_size, data_type, comm, is_root_proc);
-	EXECUTION_REPORT(REPORT_ERROR, comp_comm_group_mgt_mgr->get_global_node_root()->get_comp_id(), field_size > 0, "Error happens when reading the remapping weights file \"%s\": variable \"%s\" does not exist in the file. Please verify.", wgt_file_name, field_name);
-	EXECUTION_REPORT(REPORT_ERROR, comp_comm_group_mgt_mgr->get_global_node_root()->get_comp_id(), field_size == grid_size, "Error happens when reading the remapping weights file \"%s\": the array size of the variable \"%s\" is not the size of the corresponding grid. Please verify.", wgt_file_name, field_name);
-	EXECUTION_REPORT(REPORT_ERROR, -1, words_are_the_same(data_type, DATA_TYPE_INT), "Software error in H2D_remapping_wgt_file_info::get_grid_field_checksum_value");
-	checksum = calculate_checksum_of_array(data_buffer, field_size, get_data_type_size(data_type), NULL, NULL);
+    netcdf_file_object->read_file_field(field_name, (void**)(&data_buffer), &field_size, data_type, comm, is_root_proc);
+    EXECUTION_REPORT(REPORT_ERROR, comp_comm_group_mgt_mgr->get_global_node_root()->get_comp_id(), field_size > 0, "Error happens when reading the remapping weights file \"%s\": variable \"%s\" does not exist in the file. Please verify.", wgt_file_name, field_name);
+    EXECUTION_REPORT(REPORT_ERROR, comp_comm_group_mgt_mgr->get_global_node_root()->get_comp_id(), field_size == grid_size, "Error happens when reading the remapping weights file \"%s\": the array size of the variable \"%s\" is not the size of the corresponding grid. Please verify.", wgt_file_name, field_name);
+    EXECUTION_REPORT(REPORT_ERROR, -1, words_are_the_same(data_type, DATA_TYPE_INT), "Software error in H2D_remapping_wgt_file_info::get_grid_field_checksum_value");
+    checksum = calculate_checksum_of_array(data_buffer, field_size, get_data_type_size(data_type), NULL, NULL);
 
-	delete [] data_buffer;
+    delete [] data_buffer;
 
-	return checksum;
+    return checksum;
 }
 
 
 bool H2D_remapping_wgt_file_info::match_H2D_remapping_wgt(Original_grid_info *src_original_grid, Original_grid_info *dst_original_grid)
 {
-	read_grid_size(dst_original_grid->get_comp_id(), "n_a", src_grid_size);
-	if (src_grid_size != src_original_grid->get_H2D_sub_CoR_grid()->get_grid_size()) {
-		clean();
-		return false;
-	}
-	read_grid_size(dst_original_grid->get_comp_id(), "n_b", dst_grid_size);
-	if (dst_grid_size != dst_original_grid->get_H2D_sub_CoR_grid()->get_grid_size()) {
-		clean();
-		return false;
-	}
-	get_checksum_mask(dst_original_grid->get_comp_id(), "mask_a", src_grid_size, checksum_src_mask);
-	if (src_original_grid->get_checksum_H2D_mask() != this->checksum_src_mask) {
-		clean();
-		return false;
-	}
-	get_checksum_mask(dst_original_grid->get_comp_id(), "mask_b", dst_grid_size, checksum_dst_mask);
-	if (dst_original_grid->get_checksum_H2D_mask() != this->checksum_dst_mask) {
-		clean();
-		return false;
-	}
-	read_weight_grid_data(dst_original_grid->get_comp_id(), "xc_a", DATA_TYPE_DOUBLE, (void**)(&src_center_lon), src_grid_size);
-	if (!are_two_coord_arrays_same(src_original_grid->get_center_lon_values(), this->src_center_lon, src_original_grid->get_H2D_sub_CoR_grid()->get_grid_size(), this->src_grid_size)) {
-		clean();
-		return false;
-	}
-	read_weight_grid_data(dst_original_grid->get_comp_id(), "xc_b", DATA_TYPE_DOUBLE, (void**)(&dst_center_lon), dst_grid_size);
-	if (!are_two_coord_arrays_same(dst_original_grid->get_center_lon_values(), this->dst_center_lon, dst_original_grid->get_H2D_sub_CoR_grid()->get_grid_size(), this->dst_grid_size)) {
-		clean();
-		return false;
-	}
-	read_weight_grid_data(dst_original_grid->get_comp_id(), "yc_a", DATA_TYPE_DOUBLE, (void**)(&src_center_lat), src_grid_size);
-	if (!are_two_coord_arrays_same(src_original_grid->get_center_lat_values(), this->src_center_lat, src_original_grid->get_H2D_sub_CoR_grid()->get_grid_size(), this->src_grid_size)) {
-		clean();
-		return false;
-	}
-	read_weight_grid_data(dst_original_grid->get_comp_id(), "yc_b", DATA_TYPE_DOUBLE, (void**)(&dst_center_lat), dst_grid_size);
-	if (!are_two_coord_arrays_same(dst_original_grid->get_center_lat_values(), this->dst_center_lat, dst_original_grid->get_H2D_sub_CoR_grid()->get_grid_size(), this->dst_grid_size)) {
-		clean();
-		return false;
-	}
-	clean();
+	bool check_result;
+	double *original_grid_center_lon, *original_grid_center_lat;
 
-	read_weight_grid_data(dst_original_grid->get_comp_id(), "area_a", DATA_TYPE_DOUBLE, (void**)(&src_area), src_grid_size);
-	read_weight_grid_data(dst_original_grid->get_comp_id(), "area_b", DATA_TYPE_DOUBLE, (void**)(&dst_area), dst_grid_size);
-	read_remapping_weights(dst_original_grid->get_comp_id());
-	return true;
+	
+    for (int i = 0; i < matched_grid_pair.size(); i ++)
+        if (matched_grid_pair[i].first == src_original_grid && matched_grid_pair[i].second == dst_original_grid)
+            return true;
+
+    read_grid_size(dst_original_grid->get_comp_id(), "n_a", src_grid_size);
+    if (src_grid_size != src_original_grid->get_H2D_sub_CoR_grid()->get_grid_size()) {
+        clean();
+        return false;
+    }
+    read_grid_size(dst_original_grid->get_comp_id(), "n_b", dst_grid_size);
+    if (dst_grid_size != dst_original_grid->get_H2D_sub_CoR_grid()->get_grid_size()) {
+        clean();
+        return false;
+    }
+    get_checksum_mask(dst_original_grid->get_comp_id(), "mask_a", src_grid_size, checksum_src_mask);
+    if (src_original_grid->get_checksum_H2D_mask() != this->checksum_src_mask) {
+        clean();
+        return false;
+    }
+    get_checksum_mask(dst_original_grid->get_comp_id(), "mask_b", dst_grid_size, checksum_dst_mask);
+    if (dst_original_grid->get_checksum_H2D_mask() != this->checksum_dst_mask) {
+        clean();
+        return false;
+    }
+    read_weight_grid_data(dst_original_grid->get_comp_id(), "xc_a", DATA_TYPE_DOUBLE, (void**)(&src_center_lon), src_grid_size, true);
+	original_grid_center_lon = src_original_grid->get_center_lon_values();
+    check_result = are_two_coord_arrays_same(original_grid_center_lon, this->src_center_lon, src_original_grid->get_H2D_sub_CoR_grid()->get_grid_size(), this->src_grid_size);
+	delete [] original_grid_center_lon;
+    if (!check_result) {
+        clean();
+        return false;
+    }
+    read_weight_grid_data(dst_original_grid->get_comp_id(), "xc_b", DATA_TYPE_DOUBLE, (void**)(&dst_center_lon), dst_grid_size, true);
+	original_grid_center_lon = dst_original_grid->get_center_lon_values();
+    check_result = are_two_coord_arrays_same(original_grid_center_lon, this->dst_center_lon, dst_original_grid->get_H2D_sub_CoR_grid()->get_grid_size(), this->dst_grid_size);
+	delete [] original_grid_center_lon;
+    if (!check_result) {
+        clean();
+        return false;
+    }
+    read_weight_grid_data(dst_original_grid->get_comp_id(), "yc_a", DATA_TYPE_DOUBLE, (void**)(&src_center_lat), src_grid_size, true);
+	original_grid_center_lat = src_original_grid->get_center_lat_values();
+    check_result = are_two_coord_arrays_same(original_grid_center_lat, this->src_center_lat, src_original_grid->get_H2D_sub_CoR_grid()->get_grid_size(), this->src_grid_size);
+	delete [] original_grid_center_lat;
+    if (!check_result) {
+        clean();
+        return false;
+    }
+    read_weight_grid_data(dst_original_grid->get_comp_id(), "yc_b", DATA_TYPE_DOUBLE, (void**)(&dst_center_lat), dst_grid_size, true);
+	original_grid_center_lat = dst_original_grid->get_center_lat_values();
+    check_result = are_two_coord_arrays_same(original_grid_center_lat, this->dst_center_lat, dst_original_grid->get_H2D_sub_CoR_grid()->get_grid_size(), this->dst_grid_size);
+	delete [] original_grid_center_lat;
+    if (!check_result) {
+        clean();
+        return false;
+    }
+    read_weight_grid_data(dst_original_grid->get_comp_id(), "area_a", DATA_TYPE_DOUBLE, (void**)(&src_area), src_grid_size, false);
+    read_weight_grid_data(dst_original_grid->get_comp_id(), "area_b", DATA_TYPE_DOUBLE, (void**)(&dst_area), dst_grid_size, false);
+    read_remapping_weights(dst_original_grid->get_comp_id());
+
+    matched_grid_pair.push_back(std::make_pair(src_original_grid, dst_original_grid));
+    return true;
 }
 
 
 void H2D_remapping_wgt_file_info::get_checksum_mask(int comp_id, const char *mask_label, int grid_size, long &checksum_mask)
 {
-	int local_proc_id_in_file_read_comm, num_procs_in_file_read_comm;
-	int wgts_status_tag = checksum_mask != -1? 1 : 0;
-	Comp_comm_group_mgt_node *comp_node = comp_comm_group_mgt_mgr->get_global_node_of_local_comp(comp_id, false, "in H2D_remapping_wgt_file_info::read_remapping_weights");
-	MPI_Comm file_read_comm;
-
-
-	MPI_Comm_split(comp_node->get_comm_group(), wgts_status_tag, 0, &file_read_comm);
-	if (wgts_status_tag == 1) {
-		MPI_Comm_free(&file_read_comm);
-		return;
-	}
-	MPI_Comm_rank(file_read_comm, &local_proc_id_in_file_read_comm);
-	MPI_Comm_size(file_read_comm, &num_procs_in_file_read_comm);
-	
-	IO_netcdf *netcdf_file_object = new IO_netcdf("remapping weights file for H2D interpolation", wgt_file_name, "r", false);	
-	checksum_mask = get_grid_field_checksum_value(mask_label, netcdf_file_object, grid_size, file_read_comm, local_proc_id_in_file_read_comm == 0);	
-	delete netcdf_file_object;
-	
-	MPI_Comm_free(&file_read_comm);
+    int local_proc_id_in_file_read_comm, num_procs_in_file_read_comm;
+    int wgts_status_tag = checksum_mask != -1? 1 : 0;
+    Comp_comm_group_mgt_node *comp_node = comp_comm_group_mgt_mgr->get_global_node_of_local_comp(comp_id, false, "in H2D_remapping_wgt_file_info::read_remapping_weights");
+    MPI_Comm file_read_comm;
+
+
+    MPI_Comm_split(comp_node->get_comm_group(), wgts_status_tag, 0, &file_read_comm);
+    if (wgts_status_tag == 1) {
+        MPI_Comm_free(&file_read_comm);
+        return;
+    }
+    MPI_Comm_rank(file_read_comm, &local_proc_id_in_file_read_comm);
+    MPI_Comm_size(file_read_comm, &num_procs_in_file_read_comm);
+    
+    IO_netcdf *netcdf_file_object = new IO_netcdf("remapping weights file for H2D interpolation", wgt_file_name, "r", false);    
+    checksum_mask = get_grid_field_checksum_value(mask_label, netcdf_file_object, grid_size, file_read_comm, local_proc_id_in_file_read_comm == 0);    
+    delete netcdf_file_object;
+    
+    MPI_Comm_free(&file_read_comm);
 }
 
 
 void H2D_remapping_wgt_file_info::read_grid_size(int comp_id, const char *label, int &grid_size)
 {
-	int field_size, i, local_proc_id_in_file_read_comm, num_procs_in_file_read_comm;
-	char data_type[NAME_STR_SIZE];
-	int wgts_status_tag = grid_size != -1? 1 : 0;
-	Comp_comm_group_mgt_node *comp_node = comp_comm_group_mgt_mgr->get_global_node_of_local_comp(comp_id, false, "in H2D_remapping_wgt_file_info::read_remapping_weights");
-	MPI_Comm file_read_comm;
-
-
-	MPI_Comm_split(comp_node->get_comm_group(), wgts_status_tag, 0, &file_read_comm);
-	if (wgts_status_tag == 1) {
-		MPI_Comm_free(&file_read_comm);
-		return;
-	}
-	MPI_Comm_rank(file_read_comm, &local_proc_id_in_file_read_comm);
-	MPI_Comm_size(file_read_comm, &num_procs_in_file_read_comm);
-
-	IO_netcdf *netcdf_file_object = new IO_netcdf("remapping weights file for H2D interpolation", wgt_file_name, "r", false);
-	grid_size = netcdf_file_object->get_dimension_size(label, file_read_comm, local_proc_id_in_file_read_comm == 0);
-	delete netcdf_file_object;
-
-	MPI_Comm_free(&file_read_comm);
+    int field_size, i, local_proc_id_in_file_read_comm, num_procs_in_file_read_comm;
+    char data_type[NAME_STR_SIZE];
+    int wgts_status_tag = grid_size != -1? 1 : 0;
+    Comp_comm_group_mgt_node *comp_node = comp_comm_group_mgt_mgr->get_global_node_of_local_comp(comp_id, false, "in H2D_remapping_wgt_file_info::read_remapping_weights");
+    MPI_Comm file_read_comm;
+
+
+    MPI_Comm_split(comp_node->get_comm_group(), wgts_status_tag, 0, &file_read_comm);
+    if (wgts_status_tag == 1) {
+        MPI_Comm_free(&file_read_comm);
+        return;
+    }
+    MPI_Comm_rank(file_read_comm, &local_proc_id_in_file_read_comm);
+    MPI_Comm_size(file_read_comm, &num_procs_in_file_read_comm);
+
+    IO_netcdf *netcdf_file_object = new IO_netcdf("remapping weights file for H2D interpolation", wgt_file_name, "r", false);
+    grid_size = netcdf_file_object->get_dimension_size(label, file_read_comm, local_proc_id_in_file_read_comm == 0);
+    delete netcdf_file_object;
+
+    MPI_Comm_free(&file_read_comm);
 }
-			
+            
 
-void H2D_remapping_wgt_file_info::read_weight_grid_data(int comp_id, const char *label, const char *required_data_type, void **buffer_ptr, int buffer_size)
+void H2D_remapping_wgt_file_info::read_weight_grid_data(int comp_id, const char *label, const char *required_data_type, void **buffer_ptr, int buffer_size, bool necessary)
 {
-	int field_size, i, local_proc_id_in_file_read_comm, num_procs_in_file_read_comm;
-	char data_type[NAME_STR_SIZE];
-	int wgts_status_tag = (*buffer_ptr) != NULL? 1 : 0;
-	Comp_comm_group_mgt_node *comp_node = comp_comm_group_mgt_mgr->get_global_node_of_local_comp(comp_id, false, "in H2D_remapping_wgt_file_info::read_remapping_weights");
-	MPI_Comm file_read_comm;
-
-
-	MPI_Comm_split(comp_node->get_comm_group(), wgts_status_tag, 0, &file_read_comm);
-	if (wgts_status_tag == 1) {
-		MPI_Comm_free(&file_read_comm);
-		return;
-	}
-	MPI_Comm_rank(file_read_comm, &local_proc_id_in_file_read_comm);
-	MPI_Comm_size(file_read_comm, &num_procs_in_file_read_comm);
-
-	IO_netcdf *netcdf_file_object = new IO_netcdf("remapping weights file for H2D interpolation", wgt_file_name, "r", false);
-	netcdf_file_object->read_file_field(label, buffer_ptr, &field_size, data_type, file_read_comm, local_proc_id_in_file_read_comm == 0);
-	EXECUTION_REPORT(REPORT_ERROR, comp_comm_group_mgt_mgr->get_global_node_root()->get_comp_id(), field_size == buffer_size && words_are_the_same(data_type, required_data_type), "Error happens when reading the remapping weights file \"%s\": fail to read the variable \"%s\" because of wrong array size or wrong data type (should be %s). Please verify.", wgt_file_name, label, required_data_type);
-	delete netcdf_file_object;
-
-	MPI_Comm_free(&file_read_comm);
+    int field_size, i, local_proc_id_in_file_read_comm, num_procs_in_file_read_comm;
+    char data_type[NAME_STR_SIZE];
+    int wgts_status_tag = (*buffer_ptr) != NULL? 1 : 0;
+    Comp_comm_group_mgt_node *comp_node = comp_comm_group_mgt_mgr->get_global_node_of_local_comp(comp_id, false, "in H2D_remapping_wgt_file_info::read_remapping_weights");
+    MPI_Comm file_read_comm;
+
+
+    MPI_Comm_split(comp_node->get_comm_group(), wgts_status_tag, 0, &file_read_comm);
+    if (wgts_status_tag == 1) {
+        MPI_Comm_free(&file_read_comm);
+        return;
+    }
+    MPI_Comm_rank(file_read_comm, &local_proc_id_in_file_read_comm);
+    MPI_Comm_size(file_read_comm, &num_procs_in_file_read_comm);
+
+    IO_netcdf *netcdf_file_object = new IO_netcdf("remapping weights file for H2D interpolation", wgt_file_name, "r", false);
+    netcdf_file_object->read_file_field(label, buffer_ptr, &field_size, data_type, file_read_comm, local_proc_id_in_file_read_comm == 0);
+	if (necessary)
+	    EXECUTION_REPORT(REPORT_ERROR, comp_comm_group_mgt_mgr->get_global_node_root()->get_comp_id(), field_size == buffer_size && words_are_the_same(data_type, required_data_type), "Error happens when reading the remapping weights file \"%s\": fail to read the variable \"%s\" because of wrong array size or wrong data type (should be %s). Please verify.", wgt_file_name, label, required_data_type);
+    delete netcdf_file_object;
+
+    MPI_Comm_free(&file_read_comm);
 }
 
-	
+    
 void H2D_remapping_wgt_file_info::read_remapping_weights(int comp_id)
 {
-	int field_size, i, local_proc_id_in_file_read_comm, num_procs_in_file_read_comm;
-	char data_type[NAME_STR_SIZE];
-	int *temp_wgts_src_indexes, *temp_wgts_dst_indexes;
-	int wgts_status_tag = wgts_src_indexes != NULL? 1 : 0;
-	Comp_comm_group_mgt_node *comp_node = comp_comm_group_mgt_mgr->get_global_node_of_local_comp(comp_id, false, "in H2D_remapping_wgt_file_info::read_remapping_weights");
-	MPI_Comm file_read_comm;
-
-
-	MPI_Comm_split(comp_node->get_comm_group(), wgts_status_tag, 0, &file_read_comm);
-
-	if (wgts_status_tag == 1) {
-		MPI_Comm_free(&file_read_comm);
-		return;
-	}
-
-	MPI_Comm_rank(file_read_comm, &local_proc_id_in_file_read_comm);
-	MPI_Comm_size(file_read_comm, &num_procs_in_file_read_comm);
-
-	if (num_procs_in_file_read_comm < comp_node->get_num_procs()) {
-		EXECUTION_REPORT_LOG(REPORT_LOG, comp_id, true, "Partially load remapping weight file %s", wgt_file_name);
-	}
-	else EXECUTION_REPORT_LOG(REPORT_LOG, comp_id, true, "Load remapping weight file %s", wgt_file_name);
-
-	IO_netcdf *netcdf_file_object = new IO_netcdf("remapping weights file for H2D interpolation", wgt_file_name, "r", false);
-	EXECUTION_REPORT(REPORT_ERROR, comp_comm_group_mgt_mgr->get_global_node_root()->get_comp_id(), src_grid_size > 0, "Error happens when reading the remapping weights file \"%s\": fail to read the size of the source grid (dimension \"n_a\" in the file). Please verify.", wgt_file_name);
-	EXECUTION_REPORT(REPORT_ERROR, comp_comm_group_mgt_mgr->get_global_node_root()->get_comp_id(), dst_grid_size > 0, "Error happens when reading the remapping weights file \"%s\": fail to read the size of the target grid (dimension \"n_a\" in the file). Please verify.", wgt_file_name);
-    num_wgts = netcdf_file_object->get_dimension_size("n_s", file_read_comm, local_proc_id_in_file_read_comm == 0);	
-	netcdf_file_object->read_file_field("col", (void**)(&temp_wgts_src_indexes), &field_size, data_type, file_read_comm, local_proc_id_in_file_read_comm == 0);
-	EXECUTION_REPORT(REPORT_ERROR, comp_comm_group_mgt_mgr->get_global_node_root()->get_comp_id(), field_size == num_wgts && words_are_the_same(data_type, DATA_TYPE_INT), "Error happens when reading the remapping weights file \"%s\": fail to read the variable \"col\" because of wrong array size (should be dimension of \"n_s\") or wrong data type (should be integer). Please verify.", wgt_file_name);
-	netcdf_file_object->read_file_field("row", (void**)(&temp_wgts_dst_indexes), &field_size, data_type, file_read_comm, local_proc_id_in_file_read_comm == 0);
-	EXECUTION_REPORT(REPORT_ERROR, comp_comm_group_mgt_mgr->get_global_node_root()->get_comp_id(), field_size == num_wgts && words_are_the_same(data_type, DATA_TYPE_INT), "Error happens when reading the remapping weights file \"%s\": fail to read the variable \"row\" because of wrong array size (should be dimension of \"n_s\") or wrong data type (should be integer). Please verify.", wgt_file_name);
-	netcdf_file_object->read_file_field("S", (void**)(&wgts_values), &field_size, data_type, file_read_comm, local_proc_id_in_file_read_comm == 0);
-	EXECUTION_REPORT(REPORT_ERROR, comp_comm_group_mgt_mgr->get_global_node_root()->get_comp_id(), field_size == num_wgts && words_are_the_same(data_type, DATA_TYPE_DOUBLE), "Error happens when reading the remapping weights file \"%s\": fail to read the variable \"S\" because of wrong array size (should be dimension of \"n_s\") or wrong data type (should be double). Please verify.", wgt_file_name);
-
-	wgts_src_indexes = new long [num_wgts];
-	wgts_dst_indexes = new long [num_wgts];
-	for (int i = 0; i < num_wgts; i ++) {
-		wgts_src_indexes[i] = temp_wgts_src_indexes[i] - 1;
-		wgts_dst_indexes[i] = temp_wgts_dst_indexes[i] - 1;
-		EXECUTION_REPORT(REPORT_ERROR, comp_comm_group_mgt_mgr->get_global_node_root()->get_comp_id(), wgts_src_indexes[i] >= 0 && wgts_src_indexes[i] < src_grid_size, "Error happens when reading the remapping weights file \"%s\": some values in the variable \"col\" are out of the bound of source grid size. Please verify.", wgt_file_name);
-		EXECUTION_REPORT(REPORT_ERROR, comp_comm_group_mgt_mgr->get_global_node_root()->get_comp_id(), wgts_dst_indexes[i] >= 0 && wgts_dst_indexes[i] < dst_grid_size, "Error happens when reading the remapping weights file \"%s\": some values in the variable \"col\" are out of the bound of target grid size. Please verify.", wgt_file_name);
-	}
-
-	delete netcdf_file_object;
-	delete [] temp_wgts_dst_indexes;
-	delete [] temp_wgts_src_indexes;
-	MPI_Comm_free(&file_read_comm);
+    int field_size, i, local_proc_id_in_file_read_comm, num_procs_in_file_read_comm;
+    char data_type[NAME_STR_SIZE];
+    int *temp_wgts_src_indexes, *temp_wgts_dst_indexes;
+    int wgts_status_tag = wgts_src_indexes != NULL? 1 : 0;
+    Comp_comm_group_mgt_node *comp_node = comp_comm_group_mgt_mgr->get_global_node_of_local_comp(comp_id, false, "in H2D_remapping_wgt_file_info::read_remapping_weights");
+    MPI_Comm file_read_comm;
+
+
+    MPI_Comm_split(comp_node->get_comm_group(), wgts_status_tag, 0, &file_read_comm);
+
+    if (wgts_status_tag == 1) {
+        MPI_Comm_free(&file_read_comm);
+        return;
+    }
+
+    MPI_Comm_rank(file_read_comm, &local_proc_id_in_file_read_comm);
+    MPI_Comm_size(file_read_comm, &num_procs_in_file_read_comm);
+
+    if (num_procs_in_file_read_comm < comp_node->get_num_procs()) {
+        EXECUTION_REPORT_LOG(REPORT_LOG, comp_id, true, "Partially load remapping weight file %s", wgt_file_name);
+    }
+    else EXECUTION_REPORT_LOG(REPORT_LOG, comp_id, true, "Load remapping weight file %s", wgt_file_name);
+
+    IO_netcdf *netcdf_file_object = new IO_netcdf("remapping weights file for H2D interpolation", wgt_file_name, "r", false);
+    EXECUTION_REPORT(REPORT_ERROR, comp_comm_group_mgt_mgr->get_global_node_root()->get_comp_id(), src_grid_size > 0, "Error happens when reading the remapping weights file \"%s\": fail to read the size of the source grid (dimension \"n_a\" in the file). Please verify.", wgt_file_name);
+    EXECUTION_REPORT(REPORT_ERROR, comp_comm_group_mgt_mgr->get_global_node_root()->get_comp_id(), dst_grid_size > 0, "Error happens when reading the remapping weights file \"%s\": fail to read the size of the target grid (dimension \"n_a\" in the file). Please verify.", wgt_file_name);
+    num_wgts = netcdf_file_object->get_dimension_size("n_s", file_read_comm, local_proc_id_in_file_read_comm == 0);    
+    netcdf_file_object->read_file_field("col", (void**)(&temp_wgts_src_indexes), &field_size, data_type, file_read_comm, local_proc_id_in_file_read_comm == 0);
+    EXECUTION_REPORT(REPORT_ERROR, comp_comm_group_mgt_mgr->get_global_node_root()->get_comp_id(), field_size == num_wgts && words_are_the_same(data_type, DATA_TYPE_INT), "Error happens when reading the remapping weights file \"%s\": fail to read the variable \"col\" because of wrong array size (should be dimension of \"n_s\") or wrong data type (should be integer). Please verify.", wgt_file_name);
+    netcdf_file_object->read_file_field("row", (void**)(&temp_wgts_dst_indexes), &field_size, data_type, file_read_comm, local_proc_id_in_file_read_comm == 0);
+    EXECUTION_REPORT(REPORT_ERROR, comp_comm_group_mgt_mgr->get_global_node_root()->get_comp_id(), field_size == num_wgts && words_are_the_same(data_type, DATA_TYPE_INT), "Error happens when reading the remapping weights file \"%s\": fail to read the variable \"row\" because of wrong array size (should be dimension of \"n_s\") or wrong data type (should be integer). Please verify.", wgt_file_name);
+    netcdf_file_object->read_file_field("S", (void**)(&wgts_values), &field_size, data_type, file_read_comm, local_proc_id_in_file_read_comm == 0);
+    EXECUTION_REPORT(REPORT_ERROR, comp_comm_group_mgt_mgr->get_global_node_root()->get_comp_id(), field_size == num_wgts && words_are_the_same(data_type, DATA_TYPE_DOUBLE), "Error happens when reading the remapping weights file \"%s\": fail to read the variable \"S\" because of wrong array size (should be dimension of \"n_s\") or wrong data type (should be double). Please verify.", wgt_file_name);
+
+    wgts_src_indexes = new long [num_wgts];
+    wgts_dst_indexes = new long [num_wgts];
+    for (int i = 0; i < num_wgts; i ++) {
+        wgts_src_indexes[i] = temp_wgts_src_indexes[i] - 1;
+        wgts_dst_indexes[i] = temp_wgts_dst_indexes[i] - 1;
+        EXECUTION_REPORT(REPORT_ERROR, comp_comm_group_mgt_mgr->get_global_node_root()->get_comp_id(), wgts_src_indexes[i] >= 0 && wgts_src_indexes[i] < src_grid_size, "Error happens when reading the remapping weights file \"%s\": some values in the variable \"col\" are out of the bound of source grid size. Please verify.", wgt_file_name);
+        EXECUTION_REPORT(REPORT_ERROR, comp_comm_group_mgt_mgr->get_global_node_root()->get_comp_id(), wgts_dst_indexes[i] >= 0 && wgts_dst_indexes[i] < dst_grid_size, "Error happens when reading the remapping weights file \"%s\": some values in the variable \"col\" are out of the bound of target grid size. Please verify.", wgt_file_name);
+    }
+
+    delete netcdf_file_object;
+    delete [] temp_wgts_dst_indexes;
+    delete [] temp_wgts_src_indexes;
+    MPI_Comm_free(&file_read_comm);
 }
 
 
 void H2D_remapping_wgt_file_info::clean()
 {
-	if (wgts_src_indexes != NULL) {
-		delete [] wgts_src_indexes;
-		delete [] wgts_dst_indexes;
-		delete [] wgts_values;
-		wgts_src_indexes = NULL;
-		wgts_dst_indexes = NULL;
-		wgts_values = NULL;
-	}
-	if (src_center_lon != NULL) {
-		delete [] src_center_lon;
-		src_center_lon = NULL;
-	}
-	if (src_center_lat != NULL) {
-		delete [] src_center_lat;
-		src_center_lat = NULL;
-	}
-	if (dst_center_lon != NULL) {
-		delete [] dst_center_lon;
-		dst_center_lon = NULL;
-	}
-	if (dst_center_lat != NULL) {
-		delete [] dst_center_lat;
-		dst_center_lat = NULL;		
-	}
-	if (src_area != NULL) {
-		delete [] src_area;
-		src_area = NULL;
-	}
-	if (dst_area != NULL) {
-		delete [] dst_area;
-		dst_area = NULL;
-	}
+    if (wgts_src_indexes != NULL) {
+        delete [] wgts_src_indexes;
+        delete [] wgts_dst_indexes;
+        delete [] wgts_values;
+        wgts_src_indexes = NULL;
+        wgts_dst_indexes = NULL;
+        wgts_values = NULL;
+    }
+    if (src_center_lon != NULL) {
+        delete [] src_center_lon;
+        src_center_lon = NULL;
+    }
+    if (src_center_lat != NULL) {
+        delete [] src_center_lat;
+        src_center_lat = NULL;
+    }
+    if (dst_center_lon != NULL) {
+        delete [] dst_center_lon;
+        dst_center_lon = NULL;
+    }
+    if (dst_center_lat != NULL) {
+        delete [] dst_center_lat;
+        dst_center_lat = NULL;        
+    }
+    if (src_area != NULL) {
+        delete [] src_area;
+        src_area = NULL;
+    }
+    if (dst_area != NULL) {
+        delete [] dst_area;
+        dst_area = NULL;
+    }
 }
 
 
 H2D_remapping_wgt_file_info::~H2D_remapping_wgt_file_info()
 {
-	clean();
-	delete [] wgt_file_name;
+    clean();
+    delete [] wgt_file_name;
 }
 
 
 H2D_remapping_wgt_file_mgt::H2D_remapping_wgt_file_mgt(TiXmlElement *XML_element, const char *XML_file_name)
 {
-	char overall_XML_file_name[NAME_STR_SIZE];
-
-
-	sprintf(overall_XML_file_name, "%s/all/overall_remapping_configuration.xml", comp_comm_group_mgt_mgr->get_config_root_dir());
-	
-	for (TiXmlNode *detailed_element_node = XML_element->FirstChild(); detailed_element_node != NULL; detailed_element_node = detailed_element_node->NextSibling()) {
-		if (detailed_element_node->Type() != TiXmlNode::TINYXML_ELEMENT)
-			continue;
-		TiXmlElement *detailed_element = detailed_element_node->ToElement();
-		EXECUTION_REPORT(REPORT_ERROR, comp_comm_group_mgt_mgr->get_global_node_root()->get_comp_id(), words_are_the_same(detailed_element->Value(), "file"), "When setting a remapping weights file in the remapping configuration in the XML file \"%s\", \"%s\" is not a legal attribute. Please verify the XML file arround the line number %d.", XML_file_name, detailed_element->Value(), detailed_element->Row());
-		const char *short_file_name = get_XML_attribute(comp_comm_group_mgt_mgr->get_global_node_root()->get_comp_id(), 1000, detailed_element, "name", XML_file_name, line_number, "the name of a remapping weights file",  "remapping configuration", true);
-		char full_file_name[NAME_STR_SIZE];
-		if (words_are_the_same(overall_XML_file_name, XML_file_name))
-			sprintf(full_file_name, "%s/all/grids_weights/%s", comp_comm_group_mgt_mgr->get_config_root_dir(), short_file_name);
-		else sprintf(full_file_name, "%s/grids_weights/%s", comp_comm_group_mgt_mgr->get_root_comp_config_dir(), short_file_name);
-		H2D_remapping_wgt_file_info *existing_wgt_file_info = all_H2D_remapping_wgt_files_info->search_wgt_file_info(full_file_name);
-		if (existing_wgt_file_info == NULL) {
-			H2D_remapping_wgt_files.push_back(new H2D_remapping_wgt_file_info(full_file_name));
-			all_H2D_remapping_wgt_files_info->add_wgt_file_info(H2D_remapping_wgt_files[H2D_remapping_wgt_files.size()-1]);
-		}
-		else H2D_remapping_wgt_files.push_back(existing_wgt_file_info);
-	}
+    char overall_XML_file_name[NAME_STR_SIZE];
+
+
+    sprintf(overall_XML_file_name, "%s/all/overall_remapping_configuration.xml", comp_comm_group_mgt_mgr->get_config_root_dir());
+    
+    for (TiXmlNode *detailed_element_node = XML_element->FirstChild(); detailed_element_node != NULL; detailed_element_node = detailed_element_node->NextSibling()) {
+        if (detailed_element_node->Type() != TiXmlNode::TINYXML_ELEMENT)
+            continue;
+        TiXmlElement *detailed_element = detailed_element_node->ToElement();
+        EXECUTION_REPORT(REPORT_ERROR, comp_comm_group_mgt_mgr->get_global_node_root()->get_comp_id(), words_are_the_same(detailed_element->Value(), "file"), "When setting a remapping weights file in the remapping configuration in the XML file \"%s\", \"%s\" is not a legal attribute. Please verify the XML file arround the line number %d.", XML_file_name, detailed_element->Value(), detailed_element->Row());
+        const char *short_file_name = get_XML_attribute(comp_comm_group_mgt_mgr->get_global_node_root()->get_comp_id(), 1000, detailed_element, "name", XML_file_name, line_number, "the name of a remapping weights file",  "remapping configuration", true);
+        char full_file_name[NAME_STR_SIZE];
+        if (words_are_the_same(overall_XML_file_name, XML_file_name))
+            sprintf(full_file_name, "%s/all/grids_weights/%s", comp_comm_group_mgt_mgr->get_config_root_dir(), short_file_name);
+        else sprintf(full_file_name, "%s/grids_weights/%s", comp_comm_group_mgt_mgr->get_root_comp_config_dir(), short_file_name);
+        H2D_remapping_wgt_file_info *existing_wgt_file_info = all_H2D_remapping_wgt_files_info->search_wgt_file_info(full_file_name);
+        if (existing_wgt_file_info == NULL) {
+            H2D_remapping_wgt_files.push_back(new H2D_remapping_wgt_file_info(full_file_name));
+            all_H2D_remapping_wgt_files_info->add_wgt_file_info(H2D_remapping_wgt_files[H2D_remapping_wgt_files.size()-1]);
+        }
+        else H2D_remapping_wgt_files.push_back(existing_wgt_file_info);
+    }
 }
 
 
 H2D_remapping_wgt_file_mgt::H2D_remapping_wgt_file_mgt(const char *array, long *buffer_content_iter)
 {
-	int temp_int;
-	read_data_from_array_buffer(&temp_int, sizeof(int), array, *buffer_content_iter, true);
-	for (int i = 0; i < temp_int; i ++) {
-		H2D_remapping_wgt_file_info *new_wgt_file_info = new H2D_remapping_wgt_file_info(array, buffer_content_iter);
-		H2D_remapping_wgt_file_info *existing_wgt_file_info = all_H2D_remapping_wgt_files_info->search_wgt_file_info(new_wgt_file_info->get_wgt_file_name());
-		if (existing_wgt_file_info != NULL) {
-			delete new_wgt_file_info;
-			H2D_remapping_wgt_files.push_back(existing_wgt_file_info);
-		}
-		else {
-			H2D_remapping_wgt_files.push_back(new_wgt_file_info);
-			all_H2D_remapping_wgt_files_info->add_wgt_file_info(new_wgt_file_info);
-		}
-	}
+    int temp_int;
+    read_data_from_array_buffer(&temp_int, sizeof(int), array, *buffer_content_iter, true);
+    for (int i = 0; i < temp_int; i ++) {
+        H2D_remapping_wgt_file_info *new_wgt_file_info = new H2D_remapping_wgt_file_info(array, buffer_content_iter);
+        H2D_remapping_wgt_file_info *existing_wgt_file_info = all_H2D_remapping_wgt_files_info->search_wgt_file_info(new_wgt_file_info->get_wgt_file_name());
+        if (existing_wgt_file_info != NULL) {
+            delete new_wgt_file_info;
+            H2D_remapping_wgt_files.push_back(existing_wgt_file_info);
+        }
+        else {
+            H2D_remapping_wgt_files.push_back(new_wgt_file_info);
+            all_H2D_remapping_wgt_files_info->add_wgt_file_info(new_wgt_file_info);
+        }
+    }
 }
 
 
 void H2D_remapping_wgt_file_mgt::write_remapping_wgt_files_info_into_array(char **array, long &buffer_max_size, long &buffer_content_size)
 {
-	for (int i = H2D_remapping_wgt_files.size()-1; i >= 0; i --)
-		H2D_remapping_wgt_files[i]->write_remapping_wgt_file_info_into_array(array, buffer_max_size, buffer_content_size);
-	int temp_int = H2D_remapping_wgt_files.size();	
-	write_data_into_array_buffer(&temp_int, sizeof(int), array, buffer_max_size, buffer_content_size);	
+    for (int i = H2D_remapping_wgt_files.size()-1; i >= 0; i --)
+        H2D_remapping_wgt_files[i]->write_remapping_wgt_file_info_into_array(array, buffer_max_size, buffer_content_size);
+    int temp_int = H2D_remapping_wgt_files.size();    
+    write_data_into_array_buffer(&temp_int, sizeof(int), array, buffer_max_size, buffer_content_size);    
 }
 
 
 void H2D_remapping_wgt_file_mgt::append_remapping_weights(H2D_remapping_wgt_file_mgt *another_mgr)
 {
-	for (int i = 0; i < another_mgr->H2D_remapping_wgt_files.size(); i ++)
-		this->H2D_remapping_wgt_files.push_back(another_mgr->H2D_remapping_wgt_files[i]);
+    for (int i = 0; i < another_mgr->H2D_remapping_wgt_files.size(); i ++)
+        this->H2D_remapping_wgt_files.push_back(another_mgr->H2D_remapping_wgt_files[i]);
 }
 
 
-H2D_remapping_wgt_file_info *H2D_remapping_wgt_file_mgt::search_H2D_remapping_weight(Original_grid_info *src_original_grid, Original_grid_info *dst_original_grid)
+H2D_remapping_wgt_file_info *H2D_remapping_wgt_file_mgt::search_H2D_remapping_weight(Original_grid_info *src_original_grid, Original_grid_info *dst_original_grid, const char *algorithm_name, int comp_id)
 {
-	if (src_original_grid->get_original_CoR_grid() != src_original_grid->get_H2D_sub_CoR_grid() && 
-		(src_original_grid->get_original_CoR_grid()->get_grid_mask_field() != NULL || dst_original_grid->get_original_CoR_grid()->get_grid_mask_field() != NULL))
-		return NULL;
+	char full_default_wgt_file_name[NAME_STR_SIZE*2];
+
+	
+    if (src_original_grid->get_original_CoR_grid() != src_original_grid->get_H2D_sub_CoR_grid() && 
+        (src_original_grid->get_original_CoR_grid()->get_grid_mask_field() != NULL || dst_original_grid->get_original_CoR_grid()->get_grid_mask_field() != NULL))
+        return NULL;
+
+    for (int i = 0; i < H2D_remapping_wgt_files.size(); i ++)
+        if (H2D_remapping_wgt_files[i]->match_H2D_remapping_wgt(src_original_grid, dst_original_grid))
+            return H2D_remapping_wgt_files[i];
+
+	if (src_original_grid->get_H2D_sub_CoR_grid() != NULL && algorithm_name != NULL) {	
+		sprintf(full_default_wgt_file_name, "%s/DEFAULT_WGT_of___%s___FROM___%s___TO___%s___AT___%s.nc", comp_comm_group_mgt_mgr->get_internal_remapping_weights_dir(), algorithm_name, src_original_grid->get_H2D_sub_CoR_grid()->get_grid_name(), dst_original_grid->get_H2D_sub_CoR_grid()->get_grid_name(), comp_comm_group_mgt_mgr->search_global_node(comp_id)->get_full_name());
+		EXECUTION_REPORT_LOG(REPORT_LOG, comp_id, true, "Default remapping weight file \"%s\" will be checked if avaiable", full_default_wgt_file_name);
+		H2D_remapping_wgt_file_info *existing_wgt_file = all_H2D_remapping_wgt_files_info->search_wgt_file_info(full_default_wgt_file_name);
+		if (existing_wgt_file != NULL)
+			return existing_wgt_file;
+		if (does_file_exist(full_default_wgt_file_name)) {
+			EXECUTION_REPORT_LOG(REPORT_LOG, comp_id, true, "Default remapping weight file \"%s\" exists", full_default_wgt_file_name);
+			H2D_remapping_wgt_file_info *new_wgt_file = new H2D_remapping_wgt_file_info(full_default_wgt_file_name);
+			if (new_wgt_file->match_H2D_remapping_wgt(src_original_grid, dst_original_grid)) {
+				EXECUTION_REPORT_LOG(REPORT_LOG, comp_id, true, "Default remapping weight file \"%s\" will be used", full_default_wgt_file_name);
+				all_H2D_remapping_wgt_files_info->add_wgt_file_info(new_wgt_file);
+				return new_wgt_file;
+			}
+			else delete new_wgt_file;
+		}
+	}
+        
+    return NULL;    
+}
+
 
+H2D_remapping_wgt_file_info *H2D_remapping_wgt_file_mgt::search_H2D_remapping_weight(const char *file_name)
+{
 	for (int i = 0; i < H2D_remapping_wgt_files.size(); i ++)
-		if (H2D_remapping_wgt_files[i]->match_H2D_remapping_wgt(src_original_grid, dst_original_grid))
+		if (words_are_the_same(H2D_remapping_wgt_files[i]->get_wgt_file_name(), file_name))
 			return H2D_remapping_wgt_files[i];
 		
-	return NULL;	
+	return NULL;
 }
 
 
 void H2D_remapping_wgt_file_mgt::print()
 {
-	printf("   H2D remapping wgts files\n");
-	for(int i = 0; i < H2D_remapping_wgt_files.size(); i ++)
-		printf("        %s\n", H2D_remapping_wgt_files[i]->get_wgt_file_name());
+    printf("   H2D remapping wgts files\n");
+    for(int i = 0; i < H2D_remapping_wgt_files.size(); i ++)
+        printf("        %s\n", H2D_remapping_wgt_files[i]->get_wgt_file_name());
 }
 
 
 bool H2D_remapping_wgt_file_mgt::is_the_same_as_another(H2D_remapping_wgt_file_mgt *another_mgr)
 {
-	if (this->H2D_remapping_wgt_files.size() != another_mgr->H2D_remapping_wgt_files.size())
-		return false;
+    if (this->H2D_remapping_wgt_files.size() != another_mgr->H2D_remapping_wgt_files.size())
+        return false;
 
-	for (int i = 0; i < this->H2D_remapping_wgt_files.size(); i ++)
-		if (this->H2D_remapping_wgt_files[i] != another_mgr->H2D_remapping_wgt_files[i])
-			return false;
+    for (int i = 0; i < this->H2D_remapping_wgt_files.size(); i ++)
+        if (this->H2D_remapping_wgt_files[i] != another_mgr->H2D_remapping_wgt_files[i])
+            return false;
 
-	return true;
+    return true;
 }
 
 
 H2D_remapping_wgt_file_mgt *H2D_remapping_wgt_file_mgt::clone()
 {
     H2D_remapping_wgt_file_mgt *cloned_mgr = new H2D_remapping_wgt_file_mgt();
-	for (int i = 0; i < this->H2D_remapping_wgt_files.size(); i ++)
-		cloned_mgr->H2D_remapping_wgt_files.push_back(this->H2D_remapping_wgt_files[i]);
+    for (int i = 0; i < this->H2D_remapping_wgt_files.size(); i ++)
+        cloned_mgr->H2D_remapping_wgt_files.push_back(this->H2D_remapping_wgt_files[i]);
 
-	return cloned_mgr;
+    return cloned_mgr;
 }
 
 
 void H2D_remapping_wgt_file_mgt::shrink(Original_grid_info *src_grid, Original_grid_info *dst_grid)
 {
-	H2D_remapping_wgt_file_info *remapping_file = search_H2D_remapping_weight(src_grid, dst_grid);
-	H2D_remapping_wgt_files.clear();
-	if (remapping_file != NULL)
-		H2D_remapping_wgt_files.push_back(remapping_file);
+    H2D_remapping_wgt_file_info *remapping_file = search_H2D_remapping_weight(src_grid, dst_grid, NULL, -1);
+    H2D_remapping_wgt_files.clear();
+    if (remapping_file != NULL)
+        H2D_remapping_wgt_files.push_back(remapping_file);
 }
 
 
 H2D_remapping_wgt_file_container::~H2D_remapping_wgt_file_container()
 {
-	for (int i = 0; i < H2D_remapping_wgt_files.size(); i ++)
-		delete H2D_remapping_wgt_files[i];
+    for (int i = 0; i < H2D_remapping_wgt_files.size(); i ++)
+        delete H2D_remapping_wgt_files[i];
 }
 
 
 H2D_remapping_wgt_file_info *H2D_remapping_wgt_file_container::search_wgt_file_info(const char *wgt_file_name)
 {
-	for (int i = 0; i < H2D_remapping_wgt_files.size(); i ++)
-		if (words_are_the_same(H2D_remapping_wgt_files[i]->get_wgt_file_name(), wgt_file_name))
-			return H2D_remapping_wgt_files[i];
+    for (int i = 0; i < H2D_remapping_wgt_files.size(); i ++)
+        if (words_are_the_same(H2D_remapping_wgt_files[i]->get_wgt_file_name(), wgt_file_name))
+            return H2D_remapping_wgt_files[i];
 
-	return NULL;
+    return NULL;
 }
 
 
 void H2D_remapping_wgt_file_container::add_wgt_file_info(H2D_remapping_wgt_file_info *wgt_file_info)
 {
-	EXECUTION_REPORT(REPORT_ERROR, -1, search_wgt_file_info(wgt_file_info->get_wgt_file_name()) == NULL, "Software error in H2D_remapping_wgt_file_container::add_wgt_file_info");
-	H2D_remapping_wgt_files.push_back(wgt_file_info);
+    EXECUTION_REPORT(REPORT_ERROR, -1, search_wgt_file_info(wgt_file_info->get_wgt_file_name()) == NULL, "Software error in H2D_remapping_wgt_file_container::add_wgt_file_info");
+    H2D_remapping_wgt_files.push_back(wgt_file_info);
 }
 
 
 Remapping_algorithm_specification::Remapping_algorithm_specification(const Remapping_algorithm_specification *src_specification)
 {
-	this->type_id = src_specification->type_id;
-	this->algorithm_name = strdup(src_specification->algorithm_name);
-	for (int i = 0; i < src_specification->parameters_name.size(); i ++) {
-		this->parameters_name.push_back(new char [NAME_STR_SIZE]);
-		strcpy(this->parameters_name[this->parameters_name.size()-1], src_specification->parameters_name[i]);
-		this->parameters_value.push_back(new char [NAME_STR_SIZE]);
-		strcpy(this->parameters_value[this->parameters_value.size()-1], src_specification->parameters_value[i]);
-	}
+    this->type_id = src_specification->type_id;
+    this->algorithm_name = strdup(src_specification->algorithm_name);
+    for (int i = 0; i < src_specification->parameters_name.size(); i ++) {
+        this->parameters_name.push_back(new char [NAME_STR_SIZE]);
+        strcpy(this->parameters_name[this->parameters_name.size()-1], src_specification->parameters_name[i]);
+        this->parameters_value.push_back(new char [NAME_STR_SIZE]);
+        strcpy(this->parameters_value[this->parameters_value.size()-1], src_specification->parameters_value[i]);
+    }
 }
 
 
 Remapping_algorithm_specification::Remapping_algorithm_specification(const char *algorithm_name, int algorithm_type)
 {
-	this->algorithm_name = strdup(algorithm_name);
-	this->type_id = algorithm_type;
+    this->algorithm_name = strdup(algorithm_name);
+    this->type_id = algorithm_type;
 }
 
 
 Remapping_algorithm_specification::Remapping_algorithm_specification(int comp_id, TiXmlElement *XML_element, const char *XML_file_name, int algorithm_type)
 {
-	int line_number;
-
-	
-	this->type_id = algorithm_type;
-	this->comp_id = comp_id;
-	const char *algorithm_name = get_XML_attribute(comp_id, -1, XML_element, "name", XML_file_name, line_number, "the name of a remapping algorithm", "remapping configuration", true);
-	if (algorithm_type == REMAP_ALGORITHM_TYPE_H2D)
-		EXECUTION_REPORT(REPORT_ERROR, comp_id, remap_operator_manager->get_remap_operator_num_dim(algorithm_name) == 2, "\"%s\" is not a legal remapping operator or not a 2D remapping operator. Please verify the XML file \"%s\" around the line number %d", algorithm_name, XML_file_name, line_number);
-	else if (algorithm_type == REMAP_ALGORITHM_TYPE_V1D || algorithm_type == REMAP_ALGORITHM_TYPE_T1D)
-		EXECUTION_REPORT(REPORT_ERROR, comp_id, remap_operator_manager->get_remap_operator_num_dim(algorithm_name) == 1, "\"%s\" is not a legal remapping operator or not a 1D remapping operator. Please verify the XML file \"%s\" around the line number %d", algorithm_name, XML_file_name, line_number);
-	else EXECUTION_REPORT(REPORT_ERROR, -1, "Software error in Remapping_algorithm_specification::Remapping_algorithm_specification");
-
-	this->algorithm_name = strdup(algorithm_name);
-	for (TiXmlNode *detailed_element_node = XML_element->FirstChild(); detailed_element_node != NULL; detailed_element_node = detailed_element_node->NextSibling()) {
-		if (detailed_element_node->Type() != TiXmlNode::TINYXML_ELEMENT)
-			continue;
-		TiXmlElement *detailed_element = detailed_element_node->ToElement();
-		EXECUTION_REPORT(REPORT_ERROR, comp_id, words_are_the_same(detailed_element->Value(), "parameter"), "When setting the remapping configuration in the XML file \"%s\", \"%s\" is not a legal attribute. Please verify the XML file arround the line number %d.", XML_file_name, detailed_element->Value(), detailed_element->Row());
-		const char *parameter_name = get_XML_attribute(comp_id, -1, detailed_element, "name", XML_file_name, line_number, "the name of a parameter of the corresponding remapping algorithm",  "remapping configuration", true);
-		const char *parameter_value = get_XML_attribute(comp_id, 1000, detailed_element, "value", XML_file_name, line_number, "the value of a parameter of the corresponding remapping algorithm",  "remapping configuration", true);
-		char error_string[NAME_STR_SIZE];
-		int parameter_check_result = remap_operator_manager->check_operator_parameter(algorithm_name, parameter_name, parameter_value, error_string);
-		if (parameter_check_result == 0)
-			EXECUTION_REPORT(REPORT_ERROR, comp_id, false, "The remapping algorithm \"%s\" does not have a parameter named \"%s\". Please verify the XML file \"%s\" around the line number %d", algorithm_name, parameter_name, XML_file_name, line_number);
-		else if (parameter_check_result == 1)
-			EXECUTION_REPORT(REPORT_ERROR, comp_id, false, "The value of the parameter \"%s\" of the remapping algorithm \"%s\" is wrong. %s. Please verify the XML file \"%s\" around the line number %d", parameter_name, algorithm_name, error_string, XML_file_name, line_number);
-		parameters_name.push_back(strdup(parameter_name));
-		parameters_value.push_back(strdup(parameter_value));
-	}
+    int line_number;
+
+    
+    this->type_id = algorithm_type;
+    this->comp_id = comp_id;
+    const char *algorithm_name = get_XML_attribute(comp_id, -1, XML_element, "name", XML_file_name, line_number, "the name of a remapping algorithm", "remapping configuration", true);
+    if (algorithm_type == REMAP_ALGORITHM_TYPE_H2D)
+        EXECUTION_REPORT(REPORT_ERROR, comp_id, remap_operator_manager->get_remap_operator_num_dim(algorithm_name) == 2, "\"%s\" is not a legal remapping operator or not a 2D remapping operator. Please verify the XML file \"%s\" around the line number %d", algorithm_name, XML_file_name, line_number);
+    else if (algorithm_type == REMAP_ALGORITHM_TYPE_V1D || algorithm_type == REMAP_ALGORITHM_TYPE_T1D)
+        EXECUTION_REPORT(REPORT_ERROR, comp_id, remap_operator_manager->get_remap_operator_num_dim(algorithm_name) == 1, "\"%s\" is not a legal remapping operator or not a 1D remapping operator. Please verify the XML file \"%s\" around the line number %d", algorithm_name, XML_file_name, line_number);
+    else EXECUTION_REPORT(REPORT_ERROR, -1, "Software error in Remapping_algorithm_specification::Remapping_algorithm_specification");
+
+    this->algorithm_name = strdup(algorithm_name);
+    for (TiXmlNode *detailed_element_node = XML_element->FirstChild(); detailed_element_node != NULL; detailed_element_node = detailed_element_node->NextSibling()) {
+        if (detailed_element_node->Type() != TiXmlNode::TINYXML_ELEMENT)
+            continue;
+        TiXmlElement *detailed_element = detailed_element_node->ToElement();
+        EXECUTION_REPORT(REPORT_ERROR, comp_id, words_are_the_same(detailed_element->Value(), "parameter"), "When setting the remapping configuration in the XML file \"%s\", \"%s\" is not a legal attribute. Please verify the XML file arround the line number %d.", XML_file_name, detailed_element->Value(), detailed_element->Row());
+        const char *parameter_name = get_XML_attribute(comp_id, -1, detailed_element, "name", XML_file_name, line_number, "the name of a parameter of the corresponding remapping algorithm",  "remapping configuration", true);
+        const char *parameter_value = get_XML_attribute(comp_id, 1000, detailed_element, "value", XML_file_name, line_number, "the value of a parameter of the corresponding remapping algorithm",  "remapping configuration", true);
+        char error_string[NAME_STR_SIZE];
+        int parameter_check_result = remap_operator_manager->check_operator_parameter(algorithm_name, parameter_name, parameter_value, error_string);
+        if (parameter_check_result == 0)
+            EXECUTION_REPORT(REPORT_ERROR, comp_id, false, "The remapping algorithm \"%s\" does not have a parameter named \"%s\". Please verify the XML file \"%s\" around the line number %d", algorithm_name, parameter_name, XML_file_name, line_number);
+        else if (parameter_check_result == 1)
+            EXECUTION_REPORT(REPORT_ERROR, comp_id, false, "The value of the parameter \"%s\" of the remapping algorithm \"%s\" is wrong. %s. Please verify the XML file \"%s\" around the line number %d", parameter_name, algorithm_name, error_string, XML_file_name, line_number);
+        parameters_name.push_back(strdup(parameter_name));
+        parameters_value.push_back(strdup(parameter_value));
+    }
 }
 
 
 Remapping_algorithm_specification::Remapping_algorithm_specification(const char *array, long *buffer_content_iter)
 {
-	long str_size;
-
-	
-	read_data_from_array_buffer(&type_id, sizeof(int), array, *buffer_content_iter, true);
-	algorithm_name = load_string(NULL, str_size, NAME_STR_SIZE, array, *buffer_content_iter, NULL);
-	int temp_int;
-	read_data_from_array_buffer(&temp_int, sizeof(int), array, *buffer_content_iter, true);
-	for (int i = 0; i < temp_int; i ++) {
-		this->parameters_name.push_back(new char [NAME_STR_SIZE]);
-		read_data_from_array_buffer(this->parameters_name[this->parameters_name.size()-1], NAME_STR_SIZE, array, *buffer_content_iter, true);
-		this->parameters_value.push_back(new char [NAME_STR_SIZE]);
-		read_data_from_array_buffer(this->parameters_value[this->parameters_value.size()-1], NAME_STR_SIZE, array, *buffer_content_iter, true);		
-	}
+    long str_size;
+
+    
+    read_data_from_array_buffer(&type_id, sizeof(int), array, *buffer_content_iter, true);
+    algorithm_name = load_string(NULL, str_size, NAME_STR_SIZE, array, *buffer_content_iter, NULL);
+    int temp_int;
+    read_data_from_array_buffer(&temp_int, sizeof(int), array, *buffer_content_iter, true);
+    for (int i = 0; i < temp_int; i ++) {
+        this->parameters_name.push_back(new char [NAME_STR_SIZE]);
+        read_data_from_array_buffer(this->parameters_name[this->parameters_name.size()-1], NAME_STR_SIZE, array, *buffer_content_iter, true);
+        this->parameters_value.push_back(new char [NAME_STR_SIZE]);
+        read_data_from_array_buffer(this->parameters_value[this->parameters_value.size()-1], NAME_STR_SIZE, array, *buffer_content_iter, true);        
+    }
 }
 
 
 Remapping_algorithm_specification::~Remapping_algorithm_specification()
 {
-	for (int i = 0; i < parameters_name.size(); i ++) {
-		delete [] parameters_name[i];
-		delete [] parameters_value[i];
-	}
-	delete [] algorithm_name;
+    for (int i = 0; i < parameters_name.size(); i ++) {
+        delete [] parameters_name[i];
+        delete [] parameters_value[i];
+    }
+    delete [] algorithm_name;
 }
 
 
 void Remapping_algorithm_specification::print()
 {
-	if (type_id == REMAP_ALGORITHM_TYPE_H2D)
-		printf("   H2D remapping algorithm \"%s\" ", algorithm_name);
-	if (type_id == REMAP_ALGORITHM_TYPE_V1D)
-		printf("   V1D remapping algorithm \"%s\" ", algorithm_name);
-	if (type_id == REMAP_ALGORITHM_TYPE_T1D)
-		printf("   T1D remapping algorithm \"%s\" ", algorithm_name);
-	for (int i = 0; i < parameters_name.size(); i ++)
-		printf(": \"%s\"(\"%s\") ", parameters_name[i], parameters_value[i]);
-	printf("\n");
+    if (type_id == REMAP_ALGORITHM_TYPE_H2D)
+        printf("   H2D remapping algorithm \"%s\" ", algorithm_name);
+    if (type_id == REMAP_ALGORITHM_TYPE_V1D)
+        printf("   V1D remapping algorithm \"%s\" ", algorithm_name);
+    if (type_id == REMAP_ALGORITHM_TYPE_T1D)
+        printf("   T1D remapping algorithm \"%s\" ", algorithm_name);
+    for (int i = 0; i < parameters_name.size(); i ++)
+        printf(": \"%s\"(\"%s\") ", parameters_name[i], parameters_value[i]);
+    printf("\n");
 }
 
 
 void Remapping_algorithm_specification::clean()
 {
-	for (int i = 0; i < parameters_name.size(); i ++) {
-		delete [] parameters_value[i];
-		delete [] parameters_name[i];
-	}
-	parameters_name.clear();
-	parameters_value.clear();
-	delete [] algorithm_name;
-	algorithm_name = NULL;
-	type_id = -1;
+    for (int i = 0; i < parameters_name.size(); i ++) {
+        delete [] parameters_value[i];
+        delete [] parameters_name[i];
+    }
+    parameters_name.clear();
+    parameters_value.clear();
+    delete [] algorithm_name;
+    algorithm_name = NULL;
+    type_id = -1;
 }
 
 
 void Remapping_algorithm_specification::write_remapping_algorithm_specification_into_array(char **array, long &buffer_max_size, long &buffer_content_size)
 {
-	for (int i = parameters_name.size()-1; i >= 0; i --) {
-		write_string_into_array_buffer(parameters_value[i], NAME_STR_SIZE, array, buffer_max_size, buffer_content_size);
-		write_string_into_array_buffer(parameters_name[i], NAME_STR_SIZE, array, buffer_max_size, buffer_content_size);
-	}
-	int temp_int = parameters_name.size();
-	write_data_into_array_buffer(&temp_int, sizeof(int), array, buffer_max_size, buffer_content_size);
-	dump_string(algorithm_name, -1, array, buffer_max_size, buffer_content_size);
-	write_data_into_array_buffer(&type_id, sizeof(int), array, buffer_max_size, buffer_content_size);
+    for (int i = parameters_name.size()-1; i >= 0; i --) {
+        write_string_into_array_buffer(parameters_value[i], NAME_STR_SIZE, array, buffer_max_size, buffer_content_size);
+        write_string_into_array_buffer(parameters_name[i], NAME_STR_SIZE, array, buffer_max_size, buffer_content_size);
+    }
+    int temp_int = parameters_name.size();
+    write_data_into_array_buffer(&temp_int, sizeof(int), array, buffer_max_size, buffer_content_size);
+    dump_string(algorithm_name, -1, array, buffer_max_size, buffer_content_size);
+    write_data_into_array_buffer(&type_id, sizeof(int), array, buffer_max_size, buffer_content_size);
 }
 
 
 void Remapping_algorithm_specification::get_parameter(int i, char *parameter_name, char *parameter_value)
 {
-	EXECUTION_REPORT(REPORT_ERROR, comp_id, i >= 0 && i < parameters_name.size(), "Software error in Remapping_algorithm_specification::get_parameter");
-	strcpy(parameter_name, parameters_name[i]);
-	strcpy(parameter_value, parameters_value[i]);
+    EXECUTION_REPORT(REPORT_ERROR, comp_id, i >= 0 && i < parameters_name.size(), "Software error in Remapping_algorithm_specification::get_parameter");
+    strcpy(parameter_name, parameters_name[i]);
+    strcpy(parameter_value, parameters_value[i]);
 }
 
 
 Remapping_algorithm_specification *Remapping_algorithm_specification::clone()
 {
-	Remapping_algorithm_specification *cloned_specification = new Remapping_algorithm_specification;
-	cloned_specification->comp_id = this->comp_id;
-	cloned_specification->type_id = this->type_id;
-	if (this->algorithm_name != NULL)
-		cloned_specification->algorithm_name = strdup(this->algorithm_name);
-	for (int i = 0; i < this->parameters_name.size(); i ++) {
-		cloned_specification->parameters_name.push_back(strdup(this->parameters_name[i]));
-		cloned_specification->parameters_value.push_back(strdup(this->parameters_value[i]));
-	}
-
-	return cloned_specification;
+    Remapping_algorithm_specification *cloned_specification = new Remapping_algorithm_specification;
+    cloned_specification->comp_id = this->comp_id;
+    cloned_specification->type_id = this->type_id;
+    if (this->algorithm_name != NULL)
+        cloned_specification->algorithm_name = strdup(this->algorithm_name);
+    for (int i = 0; i < this->parameters_name.size(); i ++) {
+        cloned_specification->parameters_name.push_back(strdup(this->parameters_name[i]));
+        cloned_specification->parameters_value.push_back(strdup(this->parameters_value[i]));
+    }
+
+    return cloned_specification;
 }
 
 
 bool Remapping_algorithm_specification::is_the_same_as_another(Remapping_algorithm_specification *another)
 {
-	if (another->type_id != this->type_id)
-		return false;
-	if (!words_are_the_same(another->algorithm_name,this->algorithm_name))
-		return false;
-	if (another->parameters_name.size() != this->parameters_name.size())
-		return false;
-	for (int i = 0; i < this->parameters_name.size(); i ++) {
-		if (!words_are_the_same(another->parameters_name[i],this->parameters_name[i]) || !words_are_the_same(another->parameters_value[i],this->parameters_value[i]))
-			return false;
-	}
-
-	return true;	
+    if (another->type_id != this->type_id)
+        return false;
+    if (!words_are_the_same(another->algorithm_name,this->algorithm_name))
+        return false;
+    if (another->parameters_name.size() != this->parameters_name.size())
+        return false;
+    for (int i = 0; i < this->parameters_name.size(); i ++) {
+        if (!words_are_the_same(another->parameters_name[i],this->parameters_name[i]) || !words_are_the_same(another->parameters_value[i],this->parameters_value[i]))
+            return false;
+    }
+
+    return true;    
 }
 
 
 Remapping_setting::Remapping_setting()
 {
-	H2D_remapping_algorithm = NULL;
-	V1D_remapping_algorithm = NULL;
-	T1D_remapping_algorithm = NULL;
-	H2D_remapping_wgt_file_mgr = NULL;
+    H2D_remapping_algorithm = NULL;
+    V1D_remapping_algorithm = NULL;
+    T1D_remapping_algorithm = NULL;
+    H2D_remapping_wgt_file_mgr = NULL;
 }
 
 
 Remapping_setting::Remapping_setting(const char *H2D_remapping_algorithm_name, const char *field_type)
 {
-	this->comp_id = comp_comm_group_mgt_mgr->get_global_node_root()->get_comp_id();
-	H2D_remapping_algorithm = new Remapping_algorithm_specification(H2D_remapping_algorithm_name, REMAP_ALGORITHM_TYPE_H2D);
-	V1D_remapping_algorithm = new Remapping_algorithm_specification(REMAP_OPERATOR_NAME_LINEAR, REMAP_ALGORITHM_TYPE_V1D);
-	T1D_remapping_algorithm = new Remapping_algorithm_specification(REMAP_OPERATOR_NAME_LINEAR, REMAP_ALGORITHM_TYPE_T1D);
-	H2D_remapping_wgt_file_mgr = NULL;
-	field_specification_manner = 1;
-	fields_specification.push_back(strdup(field_type));
+    this->comp_id = comp_comm_group_mgt_mgr->get_global_node_root()->get_comp_id();
+    H2D_remapping_algorithm = new Remapping_algorithm_specification(H2D_remapping_algorithm_name, REMAP_ALGORITHM_TYPE_H2D);
+    V1D_remapping_algorithm = new Remapping_algorithm_specification(REMAP_OPERATOR_NAME_LINEAR, REMAP_ALGORITHM_TYPE_V1D);
+    T1D_remapping_algorithm = new Remapping_algorithm_specification(REMAP_OPERATOR_NAME_LINEAR, REMAP_ALGORITHM_TYPE_T1D);
+    H2D_remapping_wgt_file_mgr = NULL;
+    field_specification_manner = 1;
+    fields_specification.push_back(strdup(field_type));
 }
 
 
 Remapping_setting::Remapping_setting(int comp_id, TiXmlElement *XML_element, const char *XML_file_name)
 {
-	int i, line_number;
-	int num_remapping_algorithm_section = 0, num_fields_section = 0, num_remapping_weights_section = 0;
-
-
-	this->comp_id = comp_id;
-	this->XML_start_line_number = XML_element->Row();
-	H2D_remapping_algorithm = NULL;
-	V1D_remapping_algorithm = NULL;
-	T1D_remapping_algorithm = NULL;
-	H2D_remapping_wgt_file_mgr = NULL;
-	
-	for (TiXmlNode *detailed_element_node = XML_element->FirstChild(); detailed_element_node != NULL; detailed_element_node = detailed_element_node->NextSibling()) {
-		if (detailed_element_node->Type() != TiXmlNode::TINYXML_ELEMENT)
-			continue;
-		TiXmlElement *detailed_element = detailed_element_node->ToElement();
-		if (words_are_the_same(detailed_element->Value(), "remapping_algorithms")) {		
-			if (!is_XML_setting_on(comp_id, detailed_element, XML_file_name, "the status of the configuration of a section about remapping algorithms", "remapping configuration"))
-				continue;
-			EXECUTION_REPORT(REPORT_ERROR, comp_id, num_remapping_algorithm_section == 0, "When setting the remapping configuration in the XML file \"%s\", there are more than one section for specifying remapping algorithms. That is not allowed. Please verify the XML file arround the line number %d", XML_file_name, detailed_element->Row());		
-			for (TiXmlNode *algorithm_element_node = detailed_element_node->FirstChild(); algorithm_element_node != NULL; algorithm_element_node = algorithm_element_node->NextSibling()) {
-				if (algorithm_element_node->Type() != TiXmlNode::TINYXML_ELEMENT)
-					continue;
-				TiXmlElement *algorithm_element = algorithm_element_node->ToElement();
-				if (words_are_the_same(algorithm_element->Value(), "H2D_algorithm")) {
-					if (!is_XML_setting_on(comp_id, algorithm_element, XML_file_name, "the status of the configuration of a section about H2D_algorithm", "remapping configuration"))
-						continue;
-					EXECUTION_REPORT(REPORT_ERROR, comp_id, H2D_remapping_algorithm == NULL, "When setting the remapping configuration in the XML file \"%s\", H2D_algorithm has been set more than once. Please verify the XML file arround the line number %d", XML_file_name, detailed_element->Row());
-					H2D_remapping_algorithm = new Remapping_algorithm_specification(comp_id, algorithm_element, XML_file_name, REMAP_ALGORITHM_TYPE_H2D);
-				}
-				else if (words_are_the_same(algorithm_element->Value(), "V1D_algorithm")) {
-					if (!is_XML_setting_on(comp_id, algorithm_element, XML_file_name, "the status of the configuration of a section about V1D_algorithm", "remapping configuration"))
-						continue;
-					EXECUTION_REPORT(REPORT_ERROR, comp_id, V1D_remapping_algorithm == NULL, "When setting the remapping configuration in the XML file \"%s\", V1D_algorithm has been set more than once. Please verify the XML file arround the line number %d", XML_file_name, detailed_element->Row());
-					V1D_remapping_algorithm = new Remapping_algorithm_specification(comp_id, algorithm_element, XML_file_name, REMAP_ALGORITHM_TYPE_V1D);
-				}
-				else if (words_are_the_same(algorithm_element->Value(), "H2D_weights")) {
-					if (!is_XML_setting_on(comp_id, algorithm_element, XML_file_name, "the status of the configuration of a section about remapping weights files", "remapping configuration"))
-						continue;
-					EXECUTION_REPORT(REPORT_ERROR, comp_id, num_remapping_weights_section == 0, "When setting the remapping configuration in the XML file \"%s\", there are more than one active section for specifying remapping weights files. That is not allowed. Please verify the XML file arround the line number %d", XML_file_name, detailed_element->Row());		
-					H2D_remapping_wgt_file_mgr = new H2D_remapping_wgt_file_mgt(algorithm_element, XML_file_name);
-					num_remapping_weights_section ++;
-				}
-				else EXECUTION_REPORT(REPORT_ERROR, comp_id, false, "When setting the remapping configuration in the XML file \"%s\", \"%s\" is not a legal attribute of remapping algorithm. Please verify the XML file arround the line number %d", XML_file_name, algorithm_element->Value(), algorithm_element->Row());
-			}
-			num_remapping_algorithm_section ++;
-		}
-		else if (words_are_the_same(detailed_element->Value(),"fields")) {		
-			if (!is_XML_setting_on(comp_id, detailed_element, XML_file_name, "the status of the configuration of a section about fields", "remapping configuration"))
-				continue;
-			EXECUTION_REPORT(REPORT_ERROR, comp_id, num_fields_section == 0, "When setting the remapping configuration in the XML file \"%s\", there are more than one section for specifying fields. That is not allowed. Please verify the XML file arround the line number %d", XML_file_name, detailed_element->Row());		
-			const char *specification_type = get_XML_attribute(comp_id, -1, detailed_element, "specification", XML_file_name, line_number, "how to specify the fields corresponding to a remapping setting", "remapping configuration", true);
-			EXECUTION_REPORT(REPORT_ERROR, comp_id, words_are_the_same(specification_type, "type") || words_are_the_same(specification_type, "default") || words_are_the_same(specification_type, "name"), "In the XML file \"%s\", the manner for how to specify fields must be \"type\", \"default\" or \"name\". Please verify the XML file arround the line number %d.", XML_file_name, line_number);
-			if (words_are_the_same(specification_type, "type")) {
-				field_specification_manner = 1;
-				for (TiXmlNode *type_element_node = detailed_element_node->FirstChild(); type_element_node != NULL; type_element_node = type_element_node->NextSibling()) {
-					if (type_element_node->Type() != TiXmlNode::TINYXML_ELEMENT)
-						continue;
-					TiXmlElement *type_element = type_element_node->ToElement();
-					const char *field_type = get_XML_attribute(comp_id, -1, type_element, "value", XML_file_name, line_number, "the field type corresponding to a remapping setting", "remapping configuration", true);
-					EXECUTION_REPORT(REPORT_ERROR, comp_id, words_are_the_same(field_type, "state") || words_are_the_same(field_type, "flux"), "In the XML file \"%s\" for remapping configuration, the field type \"%s\" is wrong. C-Coupler only supports field types \"state\" and \"flux\" at this time. Please verify the XML file arround the line number %d.", XML_file_name, field_type, line_number);
-					EXECUTION_REPORT(REPORT_ERROR, comp_id, fields_specification.size() == 0, "In the XML file \"%s\" for remapping configuration, there are more than one field type specified while only one field type can be set for a remapping setting. Please verify the XML file arround the line number %d.", XML_file_name, type_element->Row());
-					fields_specification.push_back(strdup(field_type));
-				}
-				EXECUTION_REPORT(REPORT_ERROR, comp_id, fields_specification.size() > 0, "In the XML file \"%s\" for remapping configuration, no field type has been specified for a remapping setting. Please verify the XML file arround the line number %d.", XML_file_name, detailed_element->Row());
-			}
-			else if (words_are_the_same(specification_type, "default"))
-				field_specification_manner = 0;
-			else {
-				field_specification_manner = 2;
-				for (TiXmlNode *field_element_node = detailed_element_node->FirstChild(); field_element_node != NULL; field_element_node = field_element_node->NextSibling()) {
-					if (field_element_node->Type() != TiXmlNode::TINYXML_ELEMENT)
-						continue;
-					TiXmlElement *field_element = field_element_node->ToElement();
-					const char *field_name = get_XML_attribute(comp_id, CCPL_NAME_STR_LEN, field_element, "value", XML_file_name, line_number, "the field name corresponding to a remapping setting", "remapping configuration", true);
-					for (i = 0; i < fields_specification.size(); i ++)
-						if (words_are_the_same(fields_specification[i], field_name))
-							break;
-					if (i == fields_specification.size())
-						fields_specification.push_back(strdup(field_name));
-				}
-				EXECUTION_REPORT(REPORT_ERROR, comp_id, fields_specification.size() > 0, "In the XML file \"%s\" for remapping configuration, no field name has been specified for a remapping setting. Please verify the XML file arround the line number %d.", XML_file_name, detailed_element->Row());
-			}
-			num_fields_section ++;
-		}
-		else EXECUTION_REPORT(REPORT_ERROR, comp_id, false, "When setting the remapping configuration in the XML file \"%s\", \"%s\" is not a legal attribute. Please verify the XML file arround the line number %d.", XML_file_name, detailed_element->Value(), detailed_element->Row());
-	}	
-	EXECUTION_REPORT(REPORT_ERROR, comp_id, num_remapping_algorithm_section == 1 && (H2D_remapping_algorithm != NULL || V1D_remapping_algorithm != NULL || H2D_remapping_wgt_file_mgr != NULL), "For the XML file \"%s\" that is for remapping configuration, no remapping algorithms or remapping weights files is specified for the remapping setting starting from the line number %d. Please verify.", XML_file_name, XML_element->Row());
-	EXECUTION_REPORT(REPORT_ERROR, comp_id, num_fields_section == 1, "For the XML file \"%s\" that is for remapping configuration, no fields is specified for the remapping setting starting from the line number %d. Please verify.", XML_file_name, XML_element->Row());
+    int i, line_number;
+    int num_remapping_algorithm_section = 0, num_fields_section = 0, num_remapping_weights_section = 0;
+
+
+    this->comp_id = comp_id;
+    this->XML_start_line_number = XML_element->Row();
+    H2D_remapping_algorithm = NULL;
+    V1D_remapping_algorithm = NULL;
+    T1D_remapping_algorithm = NULL;
+    H2D_remapping_wgt_file_mgr = NULL;
+    
+    for (TiXmlNode *detailed_element_node = XML_element->FirstChild(); detailed_element_node != NULL; detailed_element_node = detailed_element_node->NextSibling()) {
+        if (detailed_element_node->Type() != TiXmlNode::TINYXML_ELEMENT)
+            continue;
+        TiXmlElement *detailed_element = detailed_element_node->ToElement();
+        if (words_are_the_same(detailed_element->Value(), "remapping_algorithms")) {        
+            if (!is_XML_setting_on(comp_id, detailed_element, XML_file_name, "the status of the configuration of a section about remapping algorithms", "remapping configuration"))
+                continue;
+            EXECUTION_REPORT(REPORT_ERROR, comp_id, num_remapping_algorithm_section == 0, "When setting the remapping configuration in the XML file \"%s\", there are more than one section for specifying remapping algorithms. That is not allowed. Please verify the XML file arround the line number %d", XML_file_name, detailed_element->Row());        
+            for (TiXmlNode *algorithm_element_node = detailed_element_node->FirstChild(); algorithm_element_node != NULL; algorithm_element_node = algorithm_element_node->NextSibling()) {
+                if (algorithm_element_node->Type() != TiXmlNode::TINYXML_ELEMENT)
+                    continue;
+                TiXmlElement *algorithm_element = algorithm_element_node->ToElement();
+                if (words_are_the_same(algorithm_element->Value(), "H2D_algorithm")) {
+                    if (!is_XML_setting_on(comp_id, algorithm_element, XML_file_name, "the status of the configuration of a section about H2D_algorithm", "remapping configuration"))
+                        continue;
+                    EXECUTION_REPORT(REPORT_ERROR, comp_id, H2D_remapping_algorithm == NULL, "When setting the remapping configuration in the XML file \"%s\", H2D_algorithm has been set more than once. Please verify the XML file arround the line number %d", XML_file_name, detailed_element->Row());
+                    H2D_remapping_algorithm = new Remapping_algorithm_specification(comp_id, algorithm_element, XML_file_name, REMAP_ALGORITHM_TYPE_H2D);
+                }
+                else if (words_are_the_same(algorithm_element->Value(), "V1D_algorithm")) {
+                    if (!is_XML_setting_on(comp_id, algorithm_element, XML_file_name, "the status of the configuration of a section about V1D_algorithm", "remapping configuration"))
+                        continue;
+                    EXECUTION_REPORT(REPORT_ERROR, comp_id, V1D_remapping_algorithm == NULL, "When setting the remapping configuration in the XML file \"%s\", V1D_algorithm has been set more than once. Please verify the XML file arround the line number %d", XML_file_name, detailed_element->Row());
+                    V1D_remapping_algorithm = new Remapping_algorithm_specification(comp_id, algorithm_element, XML_file_name, REMAP_ALGORITHM_TYPE_V1D);
+                }
+                else if (words_are_the_same(algorithm_element->Value(), "H2D_weights")) {
+                    if (!is_XML_setting_on(comp_id, algorithm_element, XML_file_name, "the status of the configuration of a section about remapping weights files", "remapping configuration"))
+                        continue;
+                    EXECUTION_REPORT(REPORT_ERROR, comp_id, num_remapping_weights_section == 0, "When setting the remapping configuration in the XML file \"%s\", there are more than one active section for specifying remapping weights files. That is not allowed. Please verify the XML file arround the line number %d", XML_file_name, detailed_element->Row());        
+                    H2D_remapping_wgt_file_mgr = new H2D_remapping_wgt_file_mgt(algorithm_element, XML_file_name);
+                    num_remapping_weights_section ++;
+                }
+                else EXECUTION_REPORT(REPORT_ERROR, comp_id, false, "When setting the remapping configuration in the XML file \"%s\", \"%s\" is not a legal attribute of remapping algorithm. Please verify the XML file arround the line number %d", XML_file_name, algorithm_element->Value(), algorithm_element->Row());
+            }
+            num_remapping_algorithm_section ++;
+        }
+        else if (words_are_the_same(detailed_element->Value(),"fields")) {        
+            if (!is_XML_setting_on(comp_id, detailed_element, XML_file_name, "the status of the configuration of a section about fields", "remapping configuration"))
+                continue;
+            EXECUTION_REPORT(REPORT_ERROR, comp_id, num_fields_section == 0, "When setting the remapping configuration in the XML file \"%s\", there are more than one section for specifying fields. That is not allowed. Please verify the XML file arround the line number %d", XML_file_name, detailed_element->Row());        
+            const char *specification_type = get_XML_attribute(comp_id, -1, detailed_element, "specification", XML_file_name, line_number, "how to specify the fields corresponding to a remapping setting", "remapping configuration", true);
+            EXECUTION_REPORT(REPORT_ERROR, comp_id, words_are_the_same(specification_type, "type") || words_are_the_same(specification_type, "default") || words_are_the_same(specification_type, "name"), "In the XML file \"%s\", the manner for how to specify fields must be \"type\", \"default\" or \"name\". Please verify the XML file arround the line number %d.", XML_file_name, line_number);
+            if (words_are_the_same(specification_type, "type")) {
+                field_specification_manner = 1;
+                for (TiXmlNode *type_element_node = detailed_element_node->FirstChild(); type_element_node != NULL; type_element_node = type_element_node->NextSibling()) {
+                    if (type_element_node->Type() != TiXmlNode::TINYXML_ELEMENT)
+                        continue;
+                    TiXmlElement *type_element = type_element_node->ToElement();
+                    const char *field_type = get_XML_attribute(comp_id, -1, type_element, "value", XML_file_name, line_number, "the field type corresponding to a remapping setting", "remapping configuration", true);
+                    EXECUTION_REPORT(REPORT_ERROR, comp_id, words_are_the_same(field_type, "state") || words_are_the_same(field_type, "flux"), "In the XML file \"%s\" for remapping configuration, the field type \"%s\" is wrong. C-Coupler only supports field types \"state\" and \"flux\" at this time. Please verify the XML file arround the line number %d.", XML_file_name, field_type, line_number);
+                    EXECUTION_REPORT(REPORT_ERROR, comp_id, fields_specification.size() == 0, "In the XML file \"%s\" for remapping configuration, there are more than one field type specified while only one field type can be set for a remapping setting. Please verify the XML file arround the line number %d.", XML_file_name, type_element->Row());
+                    fields_specification.push_back(strdup(field_type));
+                }
+                EXECUTION_REPORT(REPORT_ERROR, comp_id, fields_specification.size() > 0, "In the XML file \"%s\" for remapping configuration, no field type has been specified for a remapping setting. Please verify the XML file arround the line number %d.", XML_file_name, detailed_element->Row());
+            }
+            else if (words_are_the_same(specification_type, "default"))
+                field_specification_manner = 0;
+            else {
+                field_specification_manner = 2;
+                for (TiXmlNode *field_element_node = detailed_element_node->FirstChild(); field_element_node != NULL; field_element_node = field_element_node->NextSibling()) {
+                    if (field_element_node->Type() != TiXmlNode::TINYXML_ELEMENT)
+                        continue;
+                    TiXmlElement *field_element = field_element_node->ToElement();
+                    const char *field_name = get_XML_attribute(comp_id, CCPL_NAME_STR_LEN, field_element, "value", XML_file_name, line_number, "the field name corresponding to a remapping setting", "remapping configuration", true);
+                    for (i = 0; i < fields_specification.size(); i ++)
+                        if (words_are_the_same(fields_specification[i], field_name))
+                            break;
+                    if (i == fields_specification.size())
+                        fields_specification.push_back(strdup(field_name));
+                }
+                EXECUTION_REPORT(REPORT_ERROR, comp_id, fields_specification.size() > 0, "In the XML file \"%s\" for remapping configuration, no field name has been specified for a remapping setting. Please verify the XML file arround the line number %d.", XML_file_name, detailed_element->Row());
+            }
+            num_fields_section ++;
+        }
+        else EXECUTION_REPORT(REPORT_ERROR, comp_id, false, "When setting the remapping configuration in the XML file \"%s\", \"%s\" is not a legal attribute. Please verify the XML file arround the line number %d.", XML_file_name, detailed_element->Value(), detailed_element->Row());
+    }    
+    EXECUTION_REPORT(REPORT_ERROR, comp_id, num_remapping_algorithm_section == 1 && (H2D_remapping_algorithm != NULL || V1D_remapping_algorithm != NULL || H2D_remapping_wgt_file_mgr != NULL), "For the XML file \"%s\" that is for remapping configuration, no remapping algorithms or remapping weights files is specified for the remapping setting starting from the line number %d. Please verify.", XML_file_name, XML_element->Row());
+    EXECUTION_REPORT(REPORT_ERROR, comp_id, num_fields_section == 1, "For the XML file \"%s\" that is for remapping configuration, no fields is specified for the remapping setting starting from the line number %d. Please verify.", XML_file_name, XML_element->Row());
 }
 
 
 Remapping_setting::~Remapping_setting()
 {
-	for (int i = 0; i < fields_specification.size(); i ++)
-		delete [] fields_specification[i];
-
-	if (H2D_remapping_algorithm != NULL)
-		delete H2D_remapping_algorithm;
-	if (V1D_remapping_algorithm != NULL)
-		delete V1D_remapping_algorithm;
-	if (T1D_remapping_algorithm != NULL)
-		delete T1D_remapping_algorithm;
-	if (H2D_remapping_wgt_file_mgr != NULL)
-		delete H2D_remapping_wgt_file_mgr;
+    for (int i = 0; i < fields_specification.size(); i ++)
+        delete [] fields_specification[i];
+
+    if (H2D_remapping_algorithm != NULL)
+        delete H2D_remapping_algorithm;
+    if (V1D_remapping_algorithm != NULL)
+        delete V1D_remapping_algorithm;
+    if (T1D_remapping_algorithm != NULL)
+        delete T1D_remapping_algorithm;
+    if (H2D_remapping_wgt_file_mgr != NULL)
+        delete H2D_remapping_wgt_file_mgr;
 }
 
 
 void Remapping_setting::reset_remapping_setting()
 {
-	for (int i = 0; i < fields_specification.size(); i ++)
-		delete [] fields_specification[i];
-	fields_specification.clear();
-	field_specification_manner = -1;
-	H2D_remapping_algorithm = NULL;
-	V1D_remapping_algorithm = NULL;
-	T1D_remapping_algorithm = NULL;
+    for (int i = 0; i < fields_specification.size(); i ++)
+        delete [] fields_specification[i];
+    fields_specification.clear();
+    field_specification_manner = -1;
+    H2D_remapping_algorithm = NULL;
+    V1D_remapping_algorithm = NULL;
+    T1D_remapping_algorithm = NULL;
 }
 
 
 void Remapping_setting::detect_conflict(Remapping_setting *another_setting, const char *XML_file_name)
 {
-	if (this->field_specification_manner == 0 && another_setting->field_specification_manner == 0) 
-		EXECUTION_REPORT(REPORT_ERROR, comp_id, false, "In the XML file \%s\" that is for remapping configuration, there is conflict between the remapping settings starting from line %d and %d respectively: both settings specify \"default\". Please verify. ", XML_file_name, another_setting->XML_start_line_number, this->XML_start_line_number);
+    if (this->field_specification_manner == 0 && another_setting->field_specification_manner == 0) 
+        EXECUTION_REPORT(REPORT_ERROR, comp_id, false, "In the XML file \%s\" that is for remapping configuration, there is conflict between the remapping settings starting from line %d and %d respectively: both settings specify \"default\". Please verify. ", XML_file_name, another_setting->XML_start_line_number, this->XML_start_line_number);
 
-	if (this->field_specification_manner == 1 && another_setting->field_specification_manner == 1)
-		EXECUTION_REPORT(REPORT_ERROR, comp_id, !words_are_the_same(this->fields_specification[0], another_setting->fields_specification[0]), "In the XML file \%s\" that is for remapping configuration, there is conflict (the same type of fields: \"%s\") between the remapping settings starting from line %d and %d respectively. Please verify. ", XML_file_name, this->fields_specification[0], another_setting->XML_start_line_number, this->XML_start_line_number);
+    if (this->field_specification_manner == 1 && another_setting->field_specification_manner == 1)
+        EXECUTION_REPORT(REPORT_ERROR, comp_id, !words_are_the_same(this->fields_specification[0], another_setting->fields_specification[0]), "In the XML file \%s\" that is for remapping configuration, there is conflict (the same type of fields: \"%s\") between the remapping settings starting from line %d and %d respectively. Please verify. ", XML_file_name, this->fields_specification[0], another_setting->XML_start_line_number, this->XML_start_line_number);
 
-	if (this->field_specification_manner == 2 && another_setting->field_specification_manner == 2) {
-		for (int i = 0; i < this->fields_specification.size(); i ++)
-			for (int j = 0; j < another_setting->fields_specification.size(); j ++)
-				EXECUTION_REPORT(REPORT_ERROR, comp_id, words_are_the_same(this->fields_specification[i], another_setting->fields_specification[j]), "In the XML file \%s\" that is for remapping configuration, there is conflict (the same field name: \"%s\") between the remapping settings starting from line %d and %d respectively. Please verify. ", XML_file_name, this->fields_specification[i], another_setting->XML_start_line_number, this->XML_start_line_number); 
-	}
+    if (this->field_specification_manner == 2 && another_setting->field_specification_manner == 2) {
+        for (int i = 0; i < this->fields_specification.size(); i ++)
+            for (int j = 0; j < another_setting->fields_specification.size(); j ++)
+                EXECUTION_REPORT(REPORT_ERROR, comp_id, words_are_the_same(this->fields_specification[i], another_setting->fields_specification[j]), "In the XML file \%s\" that is for remapping configuration, there is conflict (the same field name: \"%s\") between the remapping settings starting from line %d and %d respectively. Please verify. ", XML_file_name, this->fields_specification[i], another_setting->XML_start_line_number, this->XML_start_line_number); 
+    }
 }
 
 
 void Remapping_setting::append_H2D_remapping_weights(Remapping_setting *comp_remapping_setting)
 {
-	if (comp_remapping_setting->H2D_remapping_wgt_file_mgr == NULL)
-		return;
+    if (comp_remapping_setting->H2D_remapping_wgt_file_mgr == NULL)
+        return;
 
-	if (this->H2D_remapping_wgt_file_mgr == NULL)
-		this->H2D_remapping_wgt_file_mgr = new H2D_remapping_wgt_file_mgt();
+    if (this->H2D_remapping_wgt_file_mgr == NULL)
+        this->H2D_remapping_wgt_file_mgr = new H2D_remapping_wgt_file_mgt();
 
-	this->H2D_remapping_wgt_file_mgr->append_remapping_weights(comp_remapping_setting->H2D_remapping_wgt_file_mgr);
+    this->H2D_remapping_wgt_file_mgr->append_remapping_weights(comp_remapping_setting->H2D_remapping_wgt_file_mgr);
 }
 
 
 void Remapping_setting::get_field_remapping_setting(Remapping_setting &field_remapping_configuration, const char *field_name)
 {
-	bool transfer_remapping_algorithms = false;
-
-		
-	if (!(field_remapping_configuration.H2D_remapping_algorithm == NULL && this->H2D_remapping_algorithm != NULL ||
-		  field_remapping_configuration.H2D_remapping_algorithm == NULL && this->H2D_remapping_wgt_file_mgr != NULL ||
-		  field_remapping_configuration.V1D_remapping_algorithm == NULL && this->V1D_remapping_algorithm != NULL ||
-		  field_remapping_configuration.T1D_remapping_algorithm == NULL && this->T1D_remapping_algorithm != NULL))
-		return;
-
-	if (field_specification_manner == 0)
-		transfer_remapping_algorithms = true;
-	else if (field_specification_manner == 1) {
-		if (fields_info->search_field_info(field_name) == NULL)
-			transfer_remapping_algorithms = true;
-		else if (words_are_the_same(fields_info->search_field_info(field_name)->field_type, fields_specification[0]))
-			transfer_remapping_algorithms = true;
-	}
-	else {
-		for (int i = 0; i < fields_specification.size(); i ++)
-			if (words_are_the_same(fields_specification[i], field_name)) {
-				transfer_remapping_algorithms = true;
-				break;
-			}
-	}
-
-	if (transfer_remapping_algorithms) {
-		if (field_remapping_configuration.H2D_remapping_algorithm == NULL) {
-			if (this->H2D_remapping_algorithm != NULL)
-				field_remapping_configuration.H2D_remapping_algorithm = new Remapping_algorithm_specification(this->H2D_remapping_algorithm);
-			if (this->H2D_remapping_wgt_file_mgr != NULL)
-				field_remapping_configuration.append_H2D_remapping_weights(this);
-		}
-		if (field_remapping_configuration.V1D_remapping_algorithm == NULL && this->V1D_remapping_algorithm != NULL)
-			field_remapping_configuration.V1D_remapping_algorithm = new Remapping_algorithm_specification(this->V1D_remapping_algorithm);
-		if (field_remapping_configuration.T1D_remapping_algorithm == NULL && this->T1D_remapping_algorithm != NULL)
-			field_remapping_configuration.T1D_remapping_algorithm = new Remapping_algorithm_specification(this->T1D_remapping_algorithm);
-	}
+    bool transfer_remapping_algorithms = false;
+
+        
+    if (!(field_remapping_configuration.H2D_remapping_algorithm == NULL && this->H2D_remapping_algorithm != NULL ||
+          field_remapping_configuration.H2D_remapping_algorithm == NULL && this->H2D_remapping_wgt_file_mgr != NULL ||
+          field_remapping_configuration.V1D_remapping_algorithm == NULL && this->V1D_remapping_algorithm != NULL ||
+          field_remapping_configuration.T1D_remapping_algorithm == NULL && this->T1D_remapping_algorithm != NULL))
+        return;
+
+    if (field_specification_manner == 0)
+        transfer_remapping_algorithms = true;
+    else if (field_specification_manner == 1) {
+        if (fields_info->search_field_info(field_name) == NULL)
+            transfer_remapping_algorithms = true;
+        else if (words_are_the_same(fields_info->search_field_info(field_name)->field_type, fields_specification[0]))
+            transfer_remapping_algorithms = true;
+    }
+    else {
+        for (int i = 0; i < fields_specification.size(); i ++)
+            if (words_are_the_same(fields_specification[i], field_name)) {
+                transfer_remapping_algorithms = true;
+                break;
+            }
+    }
+
+    if (transfer_remapping_algorithms) {
+        if (field_remapping_configuration.H2D_remapping_algorithm == NULL) {
+            if (this->H2D_remapping_algorithm != NULL)
+                field_remapping_configuration.H2D_remapping_algorithm = new Remapping_algorithm_specification(this->H2D_remapping_algorithm);
+            if (this->H2D_remapping_wgt_file_mgr != NULL)
+                field_remapping_configuration.append_H2D_remapping_weights(this);
+        }
+        if (field_remapping_configuration.V1D_remapping_algorithm == NULL && this->V1D_remapping_algorithm != NULL)
+            field_remapping_configuration.V1D_remapping_algorithm = new Remapping_algorithm_specification(this->V1D_remapping_algorithm);
+        if (field_remapping_configuration.T1D_remapping_algorithm == NULL && this->T1D_remapping_algorithm != NULL)
+            field_remapping_configuration.T1D_remapping_algorithm = new Remapping_algorithm_specification(this->T1D_remapping_algorithm);
+    }
 }
 
 
 void Remapping_setting::print()
 {
-	printf("\n\nprint a remapping setting for \"%s\":\n", comp_comm_group_mgt_mgr->get_global_node_root()->get_full_name());
-	if (H2D_remapping_algorithm != NULL)
-		H2D_remapping_algorithm->print();
-	if (V1D_remapping_algorithm != NULL)
-		V1D_remapping_algorithm->print();
-	if (T1D_remapping_algorithm != NULL)
-		T1D_remapping_algorithm->print();
-	if (H2D_remapping_wgt_file_mgr != NULL)
-		H2D_remapping_wgt_file_mgr->print();
-	printf("\n\n");
+    printf("\n\nprint a remapping setting for \"%s\":\n", comp_comm_group_mgt_mgr->get_global_node_root()->get_full_name());
+    if (H2D_remapping_algorithm != NULL)
+        H2D_remapping_algorithm->print();
+    if (V1D_remapping_algorithm != NULL)
+        V1D_remapping_algorithm->print();
+    if (T1D_remapping_algorithm != NULL)
+        T1D_remapping_algorithm->print();
+    if (H2D_remapping_wgt_file_mgr != NULL)
+        H2D_remapping_wgt_file_mgr->print();
+    printf("\n\n");
 }
 
 
 void Remapping_setting::write_remapping_setting_into_array(char **array, long &buffer_max_size, long &buffer_content_size)
 {
-	EXECUTION_REPORT(REPORT_ERROR, -1, H2D_remapping_algorithm != NULL && V1D_remapping_algorithm != NULL && T1D_remapping_algorithm != NULL, "software error in Remapping_setting::write_remapping_setting_into_array");
-	T1D_remapping_algorithm->write_remapping_algorithm_specification_into_array(array, buffer_max_size, buffer_content_size);
-	V1D_remapping_algorithm->write_remapping_algorithm_specification_into_array(array, buffer_max_size, buffer_content_size);
-	H2D_remapping_algorithm->write_remapping_algorithm_specification_into_array(array, buffer_max_size, buffer_content_size);
-	if (H2D_remapping_wgt_file_mgr == NULL)
-		H2D_remapping_wgt_file_mgr = new H2D_remapping_wgt_file_mgt();
-	H2D_remapping_wgt_file_mgr->write_remapping_wgt_files_info_into_array(array, buffer_max_size, buffer_content_size);
+    EXECUTION_REPORT(REPORT_ERROR, -1, H2D_remapping_algorithm != NULL && V1D_remapping_algorithm != NULL && T1D_remapping_algorithm != NULL, "software error in Remapping_setting::write_remapping_setting_into_array");
+    T1D_remapping_algorithm->write_remapping_algorithm_specification_into_array(array, buffer_max_size, buffer_content_size);
+    V1D_remapping_algorithm->write_remapping_algorithm_specification_into_array(array, buffer_max_size, buffer_content_size);
+    H2D_remapping_algorithm->write_remapping_algorithm_specification_into_array(array, buffer_max_size, buffer_content_size);
+    if (H2D_remapping_wgt_file_mgr == NULL)
+        H2D_remapping_wgt_file_mgr = new H2D_remapping_wgt_file_mgt();
+    H2D_remapping_wgt_file_mgr->write_remapping_wgt_files_info_into_array(array, buffer_max_size, buffer_content_size);
 }
 
 
 void Remapping_setting::read_remapping_setting_from_array(const char *array, long &buffer_content_iter)
-{	
-	H2D_remapping_wgt_file_mgr = new H2D_remapping_wgt_file_mgt(array, &buffer_content_iter);
-	H2D_remapping_algorithm = new Remapping_algorithm_specification(array, &buffer_content_iter);
-	V1D_remapping_algorithm = new Remapping_algorithm_specification(array, &buffer_content_iter);
-	T1D_remapping_algorithm = new Remapping_algorithm_specification(array, &buffer_content_iter);
-	EXECUTION_REPORT(REPORT_ERROR, -1, buffer_content_iter == 0, "Software error in Remapping_setting::read_remapping_setting_from_array");
+{    
+    H2D_remapping_wgt_file_mgr = new H2D_remapping_wgt_file_mgt(array, &buffer_content_iter);
+    H2D_remapping_algorithm = new Remapping_algorithm_specification(array, &buffer_content_iter);
+    V1D_remapping_algorithm = new Remapping_algorithm_specification(array, &buffer_content_iter);
+    T1D_remapping_algorithm = new Remapping_algorithm_specification(array, &buffer_content_iter);
+    EXECUTION_REPORT(REPORT_ERROR, -1, buffer_content_iter == 0, "Software error in Remapping_setting::read_remapping_setting_from_array");
 }
 
 
 Remapping_setting *Remapping_setting::clone()
 {
-	Remapping_setting *cloned_setting = new Remapping_setting;
-	cloned_setting->comp_id = this->comp_id;
-	cloned_setting->XML_start_line_number = this->XML_start_line_number;
-	cloned_setting->field_specification_manner = this->field_specification_manner;
-	if (this->H2D_remapping_algorithm != NULL)
-		cloned_setting->H2D_remapping_algorithm = this->H2D_remapping_algorithm->clone();
-	if (this->V1D_remapping_algorithm != NULL)
-		cloned_setting->V1D_remapping_algorithm = this->V1D_remapping_algorithm->clone();
-	if (this->T1D_remapping_algorithm != NULL)
-		cloned_setting->T1D_remapping_algorithm = this->T1D_remapping_algorithm->clone();
-	if (this->H2D_remapping_wgt_file_mgr != NULL)
-		cloned_setting->H2D_remapping_wgt_file_mgr = this->H2D_remapping_wgt_file_mgr->clone();
-	for(int i = 0; i < this->fields_specification.size(); i ++)
-		cloned_setting->fields_specification.push_back(strdup(this->fields_specification[i]));
-
-	return cloned_setting;
+    Remapping_setting *cloned_setting = new Remapping_setting;
+    cloned_setting->comp_id = this->comp_id;
+    cloned_setting->XML_start_line_number = this->XML_start_line_number;
+    cloned_setting->field_specification_manner = this->field_specification_manner;
+    if (this->H2D_remapping_algorithm != NULL)
+        cloned_setting->H2D_remapping_algorithm = this->H2D_remapping_algorithm->clone();
+    if (this->V1D_remapping_algorithm != NULL)
+        cloned_setting->V1D_remapping_algorithm = this->V1D_remapping_algorithm->clone();
+    if (this->T1D_remapping_algorithm != NULL)
+        cloned_setting->T1D_remapping_algorithm = this->T1D_remapping_algorithm->clone();
+    if (this->H2D_remapping_wgt_file_mgr != NULL)
+        cloned_setting->H2D_remapping_wgt_file_mgr = this->H2D_remapping_wgt_file_mgr->clone();
+    for(int i = 0; i < this->fields_specification.size(); i ++)
+        cloned_setting->fields_specification.push_back(strdup(this->fields_specification[i]));
+
+    return cloned_setting;
 }
 
 
 bool Remapping_setting::is_the_same_as_another(Remapping_setting *another)
 {
-	if (another->field_specification_manner != this->field_specification_manner)
-		return false;
-	if (another->H2D_remapping_algorithm == NULL && this->H2D_remapping_algorithm != NULL || another->H2D_remapping_algorithm != NULL && this->H2D_remapping_algorithm == NULL)
-		return false;
-	if (another->V1D_remapping_algorithm == NULL && this->V1D_remapping_algorithm != NULL || another->V1D_remapping_algorithm != NULL && this->V1D_remapping_algorithm == NULL)
-		return false;
-	if (another->T1D_remapping_algorithm == NULL && this->T1D_remapping_algorithm != NULL || another->T1D_remapping_algorithm != NULL && this->T1D_remapping_algorithm == NULL)
-		return false;
-
-	EXECUTION_REPORT(REPORT_ERROR, -1, this->H2D_remapping_wgt_file_mgr != NULL && another->H2D_remapping_wgt_file_mgr != NULL, "Software error in Remapping_setting::is_the_same_as_another: empty remapping file managers");
-
-	if (another->H2D_remapping_algorithm != NULL && !another->H2D_remapping_algorithm->is_the_same_as_another(this->H2D_remapping_algorithm))
-		return false;
-	if (another->V1D_remapping_algorithm != NULL && !another->V1D_remapping_algorithm->is_the_same_as_another(this->V1D_remapping_algorithm))
-		return false;
-	if (another->T1D_remapping_algorithm != NULL && !another->T1D_remapping_algorithm->is_the_same_as_another(this->T1D_remapping_algorithm))
-		return false;
-	if (!another->H2D_remapping_wgt_file_mgr->is_the_same_as_another(this->H2D_remapping_wgt_file_mgr))
-		return false;
-
-	if (another->fields_specification.size() != this->fields_specification.size())
-		return false;
-	for (int i = 0; i < this->fields_specification.size(); i ++)
-		if (!words_are_the_same(another->fields_specification[i], this->fields_specification[i]))
-			return false;
-
-	return true;
+    if (another->field_specification_manner != this->field_specification_manner)
+        return false;
+    if (another->H2D_remapping_algorithm == NULL && this->H2D_remapping_algorithm != NULL || another->H2D_remapping_algorithm != NULL && this->H2D_remapping_algorithm == NULL)
+        return false;
+    if (another->V1D_remapping_algorithm == NULL && this->V1D_remapping_algorithm != NULL || another->V1D_remapping_algorithm != NULL && this->V1D_remapping_algorithm == NULL)
+        return false;
+    if (another->T1D_remapping_algorithm == NULL && this->T1D_remapping_algorithm != NULL || another->T1D_remapping_algorithm != NULL && this->T1D_remapping_algorithm == NULL)
+        return false;
+
+    EXECUTION_REPORT(REPORT_ERROR, -1, this->H2D_remapping_wgt_file_mgr != NULL && another->H2D_remapping_wgt_file_mgr != NULL, "Software error in Remapping_setting::is_the_same_as_another: empty remapping file managers");
+
+    if (another->H2D_remapping_algorithm != NULL && !another->H2D_remapping_algorithm->is_the_same_as_another(this->H2D_remapping_algorithm))
+        return false;
+    if (another->V1D_remapping_algorithm != NULL && !another->V1D_remapping_algorithm->is_the_same_as_another(this->V1D_remapping_algorithm))
+        return false;
+    if (another->T1D_remapping_algorithm != NULL && !another->T1D_remapping_algorithm->is_the_same_as_another(this->T1D_remapping_algorithm))
+        return false;
+    if (!another->H2D_remapping_wgt_file_mgr->is_the_same_as_another(this->H2D_remapping_wgt_file_mgr))
+        return false;
+
+    if (another->fields_specification.size() != this->fields_specification.size())
+        return false;
+    for (int i = 0; i < this->fields_specification.size(); i ++)
+        if (!words_are_the_same(another->fields_specification[i], this->fields_specification[i]))
+            return false;
+
+    return true;
 }
 
 
-H2D_remapping_wgt_file_info *Remapping_setting::search_H2D_remapping_weight(Original_grid_info *src_original_grid, Original_grid_info *dst_original_grid)
+H2D_remapping_wgt_file_info *Remapping_setting::search_H2D_remapping_weight(Original_grid_info *src_original_grid, Original_grid_info *dst_original_grid, int remapping_host_comp_id)
 {
-	if (H2D_remapping_wgt_file_mgr == NULL)
-		return NULL;
-	
-	return H2D_remapping_wgt_file_mgr->search_H2D_remapping_weight(src_original_grid, dst_original_grid);
+    if (H2D_remapping_wgt_file_mgr == NULL)
+        return NULL;
+
+	if (H2D_remapping_algorithm != NULL)
+	    return H2D_remapping_wgt_file_mgr->search_H2D_remapping_weight(src_original_grid, dst_original_grid, H2D_remapping_algorithm->get_algorithm_name(), remapping_host_comp_id);
+	else return H2D_remapping_wgt_file_mgr->search_H2D_remapping_weight(src_original_grid, dst_original_grid, NULL, -1);
 }
 
 
 long Remapping_setting::calculate_checksum()
 {
-	char *temp_array = NULL;
-	long buffer_max_size, buffer_content_size;
+    char *temp_array = NULL;
+    long buffer_max_size, buffer_content_size;
 
 
-	write_remapping_setting_into_array(&temp_array, buffer_max_size, buffer_content_size);
-	long checksum = calculate_checksum_of_array(temp_array, buffer_content_size, 1, NULL, NULL);
-	delete [] temp_array;
+    write_remapping_setting_into_array(&temp_array, buffer_max_size, buffer_content_size);
+    long checksum = calculate_checksum_of_array(temp_array, buffer_content_size, 1, NULL, NULL);
+    delete [] temp_array;
 
-	return checksum;
+    return checksum;
 }
 
 
 void Remapping_setting::shrink(Original_grid_info *src_grid, Original_grid_info *dst_grid)
 {
-	if (src_grid->get_V1D_sub_CoR_grid() == NULL)
-		V1D_remapping_algorithm->clean();
-	if (src_grid->get_T1D_sub_CoR_grid() == NULL)
-		T1D_remapping_algorithm->clean();
-	if (src_grid->get_H2D_sub_CoR_grid() == NULL)
-		H2D_remapping_algorithm->clean();
-	if (src_grid->get_H2D_sub_CoR_grid() == NULL && H2D_remapping_wgt_file_mgr != NULL)
-		H2D_remapping_wgt_file_mgr->clean();
-	if (H2D_remapping_wgt_file_mgr != NULL)
-		H2D_remapping_wgt_file_mgr->shrink(src_grid, dst_grid);
-	if (H2D_remapping_wgt_file_mgr != NULL && !H2D_remapping_wgt_file_mgr->is_empty()) {
-		delete H2D_remapping_algorithm;
-		H2D_remapping_algorithm = new Remapping_algorithm_specification(REMAP_OPERATOR_NAME_BILINEAR, REMAP_ALGORITHM_TYPE_H2D);
-	}
+    if (src_grid->get_V1D_sub_CoR_grid() == NULL)
+        V1D_remapping_algorithm->clean();
+    if (src_grid->get_T1D_sub_CoR_grid() == NULL)
+        T1D_remapping_algorithm->clean();
+    if (src_grid->get_H2D_sub_CoR_grid() == NULL)
+        H2D_remapping_algorithm->clean();
+    if (src_grid->get_H2D_sub_CoR_grid() == NULL && H2D_remapping_wgt_file_mgr != NULL)
+        H2D_remapping_wgt_file_mgr->clean();
+    if (H2D_remapping_wgt_file_mgr != NULL)
+        H2D_remapping_wgt_file_mgr->shrink(src_grid, dst_grid);
+    if (H2D_remapping_wgt_file_mgr != NULL && !H2D_remapping_wgt_file_mgr->is_empty()) {
+        delete H2D_remapping_algorithm;
+        H2D_remapping_algorithm = new Remapping_algorithm_specification(REMAP_OPERATOR_NAME_BILINEAR, REMAP_ALGORITHM_TYPE_H2D);
+    }
 }
 
 
 Remapping_configuration::Remapping_configuration()
 {
-	comp_id = -1;
-	remapping_settings.push_back(new Remapping_setting(REMAP_OPERATOR_NAME_BILINEAR, "state"));
-	remapping_settings.push_back(new Remapping_setting(REMAP_OPERATOR_NAME_CONSERV_2D, "flux"));
+    comp_id = -1;
+    remapping_settings.push_back(new Remapping_setting(REMAP_OPERATOR_NAME_BILINEAR, "state"));
+    remapping_settings.push_back(new Remapping_setting(REMAP_OPERATOR_NAME_CONSERV_2D, "flux"));
 }
 
 
 Remapping_configuration::Remapping_configuration(int comp_id, const char *XML_file_name, TiXmlDocument *XML_file)
 {
-	this->comp_id = comp_id;
-	for (TiXmlNode *XML_element_node = get_XML_first_child_of_unique_root(comp_id,XML_file_name,XML_file); XML_element_node != NULL; XML_element_node = XML_element_node->NextSibling()) {
-		if (XML_element_node->Type() != TiXmlNode::TINYXML_ELEMENT)
-			continue;
-		TiXmlElement *XML_element = XML_element_node->ToElement();
-		EXECUTION_REPORT(REPORT_ERROR, comp_id, words_are_the_same(XML_element->Value(), "remapping_setting"), "\"%s\" is not a legal attribute (the legal is \"remapping_setting\") for defining a remapping setting. Please verify the XML file arround the line number %d.", XML_element->Value(), XML_element->Row());
-		if (!is_XML_setting_on(comp_id, XML_element, XML_file_name, "the status of a remapping setting", "remapping configuration"))
-			continue;
-		remapping_settings.push_back(new Remapping_setting(comp_id, XML_element, XML_file_name));
-	}
-
-	for (int i = 0; i < remapping_settings.size(); i ++)
-		for (int j = i+1; j < remapping_settings.size(); j ++)
-			remapping_settings[i]->detect_conflict(remapping_settings[j], XML_file_name);
-
-	std::vector<Remapping_setting*> temp_remapping_settings;
-	for (int i = 0; i < remapping_settings.size(); i ++)
-		if (remapping_settings[i]->get_field_specification_manner() == 2)
-			temp_remapping_settings.push_back(remapping_settings[i]);
-	for (int i = 0; i < remapping_settings.size(); i ++)
-		if (remapping_settings[i]->get_field_specification_manner() == 1)
-			temp_remapping_settings.push_back(remapping_settings[i]);
-	for (int i = 0; i < remapping_settings.size(); i ++)
-		if (remapping_settings[i]->get_field_specification_manner() == 0)
-			temp_remapping_settings.push_back(remapping_settings[i]);
-
-	EXECUTION_REPORT(REPORT_ERROR, -1, temp_remapping_settings.size() == remapping_settings.size(), "Software error in Remapping_configuration::Remapping_configuration");
-
-	remapping_settings.clear();
-	for (int i = 0; i < temp_remapping_settings.size(); i ++)
-		remapping_settings.push_back(temp_remapping_settings[i]);
+    this->comp_id = comp_id;
+    for (TiXmlNode *XML_element_node = get_XML_first_child_of_unique_root(comp_id,XML_file_name,XML_file); XML_element_node != NULL; XML_element_node = XML_element_node->NextSibling()) {
+        if (XML_element_node->Type() != TiXmlNode::TINYXML_ELEMENT)
+            continue;
+        TiXmlElement *XML_element = XML_element_node->ToElement();
+        EXECUTION_REPORT(REPORT_ERROR, comp_id, words_are_the_same(XML_element->Value(), "remapping_setting"), "\"%s\" is not a legal attribute (the legal is \"remapping_setting\") for defining a remapping setting. Please verify the XML file arround the line number %d.", XML_element->Value(), XML_element->Row());
+        if (!is_XML_setting_on(comp_id, XML_element, XML_file_name, "the status of a remapping setting", "remapping configuration"))
+            continue;
+        remapping_settings.push_back(new Remapping_setting(comp_id, XML_element, XML_file_name));
+    }
+
+    for (int i = 0; i < remapping_settings.size(); i ++)
+        for (int j = i+1; j < remapping_settings.size(); j ++)
+            remapping_settings[i]->detect_conflict(remapping_settings[j], XML_file_name);
+
+    std::vector<Remapping_setting*> temp_remapping_settings;
+    for (int i = 0; i < remapping_settings.size(); i ++)
+        if (remapping_settings[i]->get_field_specification_manner() == 2)
+            temp_remapping_settings.push_back(remapping_settings[i]);
+    for (int i = 0; i < remapping_settings.size(); i ++)
+        if (remapping_settings[i]->get_field_specification_manner() == 1)
+            temp_remapping_settings.push_back(remapping_settings[i]);
+    for (int i = 0; i < remapping_settings.size(); i ++)
+        if (remapping_settings[i]->get_field_specification_manner() == 0)
+            temp_remapping_settings.push_back(remapping_settings[i]);
+
+    EXECUTION_REPORT(REPORT_ERROR, -1, temp_remapping_settings.size() == remapping_settings.size(), "Software error in Remapping_configuration::Remapping_configuration");
+
+    remapping_settings.clear();
+    for (int i = 0; i < temp_remapping_settings.size(); i ++)
+        remapping_settings.push_back(temp_remapping_settings[i]);
 }
 
 
 Remapping_configuration::~Remapping_configuration()
 {
-	for (int i = 0; i < remapping_settings.size(); i ++)
-		delete remapping_settings[i];
+    for (int i = 0; i < remapping_settings.size(); i ++)
+        delete remapping_settings[i];
 }
 
 
 bool Remapping_configuration::get_field_remapping_setting(Remapping_setting &field_remapping_configuration, const char *field_name)
 {
-	for (int i = 0; i < remapping_settings.size(); i ++) {
-		remapping_settings[i]->get_field_remapping_setting(field_remapping_configuration, field_name);
-		if (field_remapping_configuration.get_H2D_remapping_algorithm() != NULL && field_remapping_configuration.get_V1D_remapping_algorithm() != NULL && field_remapping_configuration.get_T1D_remapping_algorithm() != NULL)
-			return true;
-	}
-	return false;
+    for (int i = 0; i < remapping_settings.size(); i ++) {
+        remapping_settings[i]->get_field_remapping_setting(field_remapping_configuration, field_name);
+        if (field_remapping_configuration.get_H2D_remapping_algorithm() != NULL && field_remapping_configuration.get_V1D_remapping_algorithm() != NULL && field_remapping_configuration.get_T1D_remapping_algorithm() != NULL)
+            return true;
+    }
+    return false;
 }
 
 
 Remapping_configuration_mgt::~Remapping_configuration_mgt()
 {
-	for (int i = 0; i < remapping_configurations.size(); i ++)
-		delete remapping_configurations[i];
+    for (int i = 0; i < remapping_configurations.size(); i ++)
+        delete remapping_configurations[i];
 }
 
 
 void Remapping_configuration_mgt::add_remapping_configuration(int comp_id)
 {
-	if (comp_id == comp_comm_group_mgt_mgr->get_global_node_root()->get_comp_id())
-		remapping_configurations.push_back(new Remapping_configuration());
-
-	char XML_file_name[NAME_STR_SIZE];
-	Comp_comm_group_mgt_node *current_comp_node = comp_comm_group_mgt_mgr->get_global_node_of_local_comp(comp_id, false,"in Remapping_configuration_mgt::add_remapping_configuration");
-	if (comp_id == comp_comm_group_mgt_mgr->get_global_node_root()->get_comp_id())
-		sprintf(XML_file_name, "%s/all/overall_remapping_configuration.xml", comp_comm_group_mgt_mgr->get_config_root_dir());
-	else sprintf(XML_file_name, "%s/remapping_configs/%s.remapping_configuration.xml", comp_comm_group_mgt_mgr->get_root_comp_config_dir(), comp_comm_group_mgt_mgr->get_global_node_of_local_comp(comp_id, false,"in Remapping_configuration_mgt::add_remapping_configuration")->get_full_name());
-	TiXmlDocument *XML_file = open_XML_file_to_read(comp_id, XML_file_name, comp_comm_group_mgt_mgr->get_comm_group_of_local_comp(comp_id,"in Remapping_configuration::Remapping_configuration"), false);
-	if (XML_file == NULL) {
-		EXECUTION_REPORT_LOG(REPORT_LOG, comp_id, true, "The remapping configuration file \"%s\" for the current component does not exist.", XML_file_name);
-		return;
-	}
-	remapping_configurations.push_back(new Remapping_configuration(comp_id, XML_file_name, XML_file));
-	delete XML_file;
+    if (comp_id == comp_comm_group_mgt_mgr->get_global_node_root()->get_comp_id())
+        remapping_configurations.push_back(new Remapping_configuration());
+
+    char XML_file_name[NAME_STR_SIZE];
+    Comp_comm_group_mgt_node *current_comp_node = comp_comm_group_mgt_mgr->get_global_node_of_local_comp(comp_id, false,"in Remapping_configuration_mgt::add_remapping_configuration");
+    if (comp_id == comp_comm_group_mgt_mgr->get_global_node_root()->get_comp_id())
+        sprintf(XML_file_name, "%s/all/overall_remapping_configuration.xml", comp_comm_group_mgt_mgr->get_config_root_dir());
+    else sprintf(XML_file_name, "%s/remapping_configs/%s.remapping_configuration.xml", comp_comm_group_mgt_mgr->get_root_comp_config_dir(), comp_comm_group_mgt_mgr->get_global_node_of_local_comp(comp_id, false,"in Remapping_configuration_mgt::add_remapping_configuration")->get_full_name());
+    TiXmlDocument *XML_file = open_XML_file_to_read(comp_id, XML_file_name, comp_comm_group_mgt_mgr->get_comm_group_of_local_comp(comp_id,"in Remapping_configuration::Remapping_configuration"), false);
+    if (XML_file == NULL) {
+        EXECUTION_REPORT_LOG(REPORT_LOG, comp_id, true, "The remapping configuration file \"%s\" for the current component does not exist.", XML_file_name);
+        return;
+    }
+    remapping_configurations.push_back(new Remapping_configuration(comp_id, XML_file_name, XML_file));
+    delete XML_file;
 }
 
 
 Remapping_configuration *Remapping_configuration_mgt::search_remapping_configuration(int comp_id)
 {
-	for (int i = 0; i < remapping_configurations.size(); i ++)
-		if (remapping_configurations[i]->get_comp_id() == comp_id)
-			return remapping_configurations[i];
+    for (int i = 0; i < remapping_configurations.size(); i ++)
+        if (remapping_configurations[i]->get_comp_id() == comp_id)
+            return remapping_configurations[i];
 
-	return NULL;
+    return NULL;
 }
 
 
 void Remapping_configuration_mgt::get_field_remapping_setting(Remapping_setting &field_remapping_setting, int comp_id, const char *field_name)
 {
-	field_remapping_setting.reset_remapping_setting();
-	Comp_comm_group_mgt_node *current_comp_node = comp_comm_group_mgt_mgr->get_global_node_of_local_comp(comp_id, false, "in Remapping_configuration_mgt::get_current_remapping_setting");
-	EXECUTION_REPORT(REPORT_ERROR, -1, current_comp_node != NULL, "Software error in Remapping_configuration_mgt::get_field_remapping_setting1");
-	for (; current_comp_node != NULL; current_comp_node = current_comp_node->get_parent()) {
-		Remapping_configuration *current_remapping_configuration = search_remapping_configuration(current_comp_node->get_comp_id());
-		if (current_remapping_configuration != NULL)
-			if (current_remapping_configuration->get_field_remapping_setting(field_remapping_setting, field_name)) {
-//				field_remapping_setting.print();
-				return;
-			}
-	}
-	EXECUTION_REPORT(REPORT_ERROR, -1, remapping_configurations[0]->get_field_remapping_setting(field_remapping_setting, field_name), "Software error in Remapping_configuration_mgt::get_field_remapping_setting for field %s", field_name);
-//	field_remapping_setting.print();
+    field_remapping_setting.reset_remapping_setting();
+    Comp_comm_group_mgt_node *current_comp_node = comp_comm_group_mgt_mgr->get_global_node_of_local_comp(comp_id, false, "in Remapping_configuration_mgt::get_current_remapping_setting");
+    EXECUTION_REPORT(REPORT_ERROR, -1, current_comp_node != NULL, "Software error in Remapping_configuration_mgt::get_field_remapping_setting1");
+    for (; current_comp_node != NULL; current_comp_node = current_comp_node->get_parent()) {
+        Remapping_configuration *current_remapping_configuration = search_remapping_configuration(current_comp_node->get_comp_id());
+        if (current_remapping_configuration != NULL)
+            if (current_remapping_configuration->get_field_remapping_setting(field_remapping_setting, field_name)) {
+//                field_remapping_setting.print();
+                return;
+            }
+    }
+    EXECUTION_REPORT(REPORT_ERROR, -1, remapping_configurations[0]->get_field_remapping_setting(field_remapping_setting, field_name), "Software error in Remapping_configuration_mgt::get_field_remapping_setting for field %s", field_name);
+//    field_remapping_setting.print();
 }
 
diff --git a/src/Runtime_MGT/remapping_configuration_mgt.h b/src/Runtime_MGT/remapping_configuration_mgt.h
old mode 100644
new mode 100755
index b0f4284..b293973
--- a/src/Runtime_MGT/remapping_configuration_mgt.h
+++ b/src/Runtime_MGT/remapping_configuration_mgt.h
@@ -26,171 +26,172 @@
 
 class H2D_remapping_wgt_file_info
 {
-	private:
-		const char *wgt_file_name;
-		int src_grid_size;
-		int dst_grid_size;
-		double *src_center_lon;
-		double *src_center_lat;
-		double *src_area;
-		long checksum_src_mask;
-		double *dst_center_lon;
-		double *dst_center_lat;
-		double *dst_area;
-		long checksum_dst_mask;
-		long num_wgts;
-		long *wgts_src_indexes;
-		long *wgts_dst_indexes;
-		double *wgts_values;
-
-
-	public:
-		H2D_remapping_wgt_file_info(const char*);
-		H2D_remapping_wgt_file_info(const char*, long*);
-		~H2D_remapping_wgt_file_info();
-		void clean();
-		long get_grid_field_checksum_value(const char *, IO_netcdf *, int, MPI_Comm, bool);
-		bool match_H2D_remapping_wgt(Original_grid_info*, Original_grid_info*);
-		const char *get_wgt_file_name() { return wgt_file_name; }
-		void write_remapping_wgt_file_info_into_array(char **, long &, long &);
-		void read_remapping_weights(int);
-		long get_num_wgts() { return num_wgts; }
-		long *get_wgts_src_indexes () { return wgts_src_indexes; }
-		long *get_wgts_dst_indexes () { return wgts_dst_indexes; }
-		double *get_wgts_values () { return wgts_values; }		
-		void get_checksum_mask(int, const char *, int, long &);
-		void read_grid_size(int, const char *, int &);
-		void read_weight_grid_data(int, const char *, const char *, void **, int);
-		double *get_src_area() { return src_area; }
-		double *get_dst_area() { return dst_area; }
+    private:
+        const char *wgt_file_name;
+        int src_grid_size;
+        int dst_grid_size;
+        double *src_center_lon;
+        double *src_center_lat;
+        double *src_area;
+        long checksum_src_mask;
+        double *dst_center_lon;
+        double *dst_center_lat;
+        double *dst_area;
+        long checksum_dst_mask;
+        long num_wgts;
+        long *wgts_src_indexes;
+        long *wgts_dst_indexes;
+        double *wgts_values;
+        std::vector<std::pair<Original_grid_info*, Original_grid_info*> > matched_grid_pair;
+
+    public:
+        H2D_remapping_wgt_file_info(const char*);
+        H2D_remapping_wgt_file_info(const char*, long*);
+        ~H2D_remapping_wgt_file_info();
+        void clean();
+        long get_grid_field_checksum_value(const char *, IO_netcdf *, int, MPI_Comm, bool);
+        bool match_H2D_remapping_wgt(Original_grid_info*, Original_grid_info*);
+        const char *get_wgt_file_name() { return wgt_file_name; }
+        void write_remapping_wgt_file_info_into_array(char **, long &, long &);
+        void read_remapping_weights(int);
+        long get_num_wgts() { return num_wgts; }
+        long *get_wgts_src_indexes () { return wgts_src_indexes; }
+        long *get_wgts_dst_indexes () { return wgts_dst_indexes; }
+        double *get_wgts_values () { return wgts_values; }        
+        void get_checksum_mask(int, const char *, int, long &);
+        void read_grid_size(int, const char *, int &);
+        void read_weight_grid_data(int, const char *, const char *, void **, int, bool);
+        double *get_src_area() { return src_area; }
+        double *get_dst_area() { return dst_area; }
 };
 
 
 class H2D_remapping_wgt_file_mgt
 {
-	private:
-		std::vector<H2D_remapping_wgt_file_info*> H2D_remapping_wgt_files;
-
-	public:
-		H2D_remapping_wgt_file_mgt() { }
-		H2D_remapping_wgt_file_mgt(TiXmlElement*, const char*);
-		H2D_remapping_wgt_file_mgt(const char *, long *);
-		~H2D_remapping_wgt_file_mgt() {}		
-		void append_remapping_weights(H2D_remapping_wgt_file_mgt *);
-		void print();
-		void clean() { H2D_remapping_wgt_files.clear(); }
-		H2D_remapping_wgt_file_info *search_H2D_remapping_weight(Original_grid_info*, Original_grid_info*);
-		void write_remapping_wgt_files_info_into_array(char **, long &, long &);
-		bool is_the_same_as_another(H2D_remapping_wgt_file_mgt*);
-		H2D_remapping_wgt_file_mgt *clone();
-		void shrink(Original_grid_info*, Original_grid_info*);
-		bool is_empty() { return H2D_remapping_wgt_files.size() == 0; } 
+    private:
+        std::vector<H2D_remapping_wgt_file_info*> H2D_remapping_wgt_files;
+
+    public:
+        H2D_remapping_wgt_file_mgt() { }
+        H2D_remapping_wgt_file_mgt(TiXmlElement*, const char*);
+        H2D_remapping_wgt_file_mgt(const char *, long *);
+        ~H2D_remapping_wgt_file_mgt() {}        
+        void append_remapping_weights(H2D_remapping_wgt_file_mgt *);
+        void print();
+        void clean() { H2D_remapping_wgt_files.clear(); }
+        H2D_remapping_wgt_file_info *search_H2D_remapping_weight(Original_grid_info*, Original_grid_info*, const char *, int);
+		H2D_remapping_wgt_file_info *search_H2D_remapping_weight(const char *);
+        void write_remapping_wgt_files_info_into_array(char **, long &, long &);
+        bool is_the_same_as_another(H2D_remapping_wgt_file_mgt*);
+        H2D_remapping_wgt_file_mgt *clone();
+        void shrink(Original_grid_info*, Original_grid_info*);
+        bool is_empty() { return H2D_remapping_wgt_files.size() == 0; } 
 };
 
 
 class H2D_remapping_wgt_file_container
 {
-	private:
-		std::vector<H2D_remapping_wgt_file_info*> H2D_remapping_wgt_files;
-
-	public:
-		H2D_remapping_wgt_file_container() {}
-		~H2D_remapping_wgt_file_container();
-		H2D_remapping_wgt_file_info *search_wgt_file_info(const char*);
-		void add_wgt_file_info(H2D_remapping_wgt_file_info *);
+    private:
+        std::vector<H2D_remapping_wgt_file_info*> H2D_remapping_wgt_files;
+
+    public:
+        H2D_remapping_wgt_file_container() {}
+        ~H2D_remapping_wgt_file_container();
+        H2D_remapping_wgt_file_info *search_wgt_file_info(const char*);
+        void add_wgt_file_info(H2D_remapping_wgt_file_info *);
 };
 
 
 
 class Remapping_algorithm_specification
 {
-	private:
-		int comp_id;		
-		int type_id;
-		const char *algorithm_name;
-		std::vector<char *> parameters_name;
-		std::vector<char *> parameters_value;
-
-	public:
-		Remapping_algorithm_specification(const Remapping_algorithm_specification*);
-		Remapping_algorithm_specification(const char*, int);
-		Remapping_algorithm_specification(const char *, long*);
-		Remapping_algorithm_specification(int, TiXmlElement*, const char*, int);
-		Remapping_algorithm_specification() { algorithm_name = NULL; }
-		~Remapping_algorithm_specification();
-		void print();
-		void clean();
-		void write_remapping_algorithm_specification_into_array(char **, long &, long &);
-		const char *get_algorithm_name() { return algorithm_name; }
-		int get_num_parameters() { return parameters_name.size(); }
-		void get_parameter(int, char *, char *);
-		Remapping_algorithm_specification *clone();
-		bool is_the_same_as_another(Remapping_algorithm_specification*);
+    private:
+        int comp_id;        
+        int type_id;
+        const char *algorithm_name;
+        std::vector<char *> parameters_name;
+        std::vector<char *> parameters_value;
+
+    public:
+        Remapping_algorithm_specification(const Remapping_algorithm_specification*);
+        Remapping_algorithm_specification(const char*, int);
+        Remapping_algorithm_specification(const char *, long*);
+        Remapping_algorithm_specification(int, TiXmlElement*, const char*, int);
+        Remapping_algorithm_specification() { algorithm_name = NULL; }
+        ~Remapping_algorithm_specification();
+        void print();
+        void clean();
+        void write_remapping_algorithm_specification_into_array(char **, long &, long &);
+        const char *get_algorithm_name() { return algorithm_name; }
+        int get_num_parameters() { return parameters_name.size(); }
+        void get_parameter(int, char *, char *);
+        Remapping_algorithm_specification *clone();
+        bool is_the_same_as_another(Remapping_algorithm_specification*);
 };
 
 
 class Remapping_setting
 {
-	private:
-		int comp_id;
-		int XML_start_line_number;
-		Remapping_algorithm_specification *H2D_remapping_algorithm;
-		Remapping_algorithm_specification *V1D_remapping_algorithm;
-		Remapping_algorithm_specification *T1D_remapping_algorithm;
-		H2D_remapping_wgt_file_mgt *H2D_remapping_wgt_file_mgr;
-		int field_specification_manner;    // 0 means default of a component; 1 means type; 2 means name
-		std::vector<const char *> fields_specification;
-
-	public:
-		Remapping_setting();
-		Remapping_setting(const char*, const char*);
-		Remapping_setting(int, TiXmlElement*, const char*);
-		~Remapping_setting();
-		void detect_conflict(Remapping_setting*, const char*);
-		void reset_remapping_setting();
-		int get_field_specification_manner() { return field_specification_manner; }
-		void get_field_remapping_setting(Remapping_setting&, const char*);
-		Remapping_algorithm_specification *get_H2D_remapping_algorithm() { return H2D_remapping_algorithm; }
-		Remapping_algorithm_specification *get_V1D_remapping_algorithm() { return V1D_remapping_algorithm; }
-		Remapping_algorithm_specification *get_T1D_remapping_algorithm() { return T1D_remapping_algorithm; }
-		void write_remapping_setting_into_array(char **, long &, long &);
-		void read_remapping_setting_from_array(const char *, long &);
-		void print();
-		Remapping_setting *clone();
-		bool is_the_same_as_another(Remapping_setting*);
-		void append_H2D_remapping_weights(Remapping_setting *);
-		H2D_remapping_wgt_file_info *search_H2D_remapping_weight(Original_grid_info *, Original_grid_info*);
-		long calculate_checksum();
-		void shrink(Original_grid_info*, Original_grid_info*);
+    private:
+        int comp_id;
+        int XML_start_line_number;
+        Remapping_algorithm_specification *H2D_remapping_algorithm;
+        Remapping_algorithm_specification *V1D_remapping_algorithm;
+        Remapping_algorithm_specification *T1D_remapping_algorithm;
+        H2D_remapping_wgt_file_mgt *H2D_remapping_wgt_file_mgr;
+        int field_specification_manner;    // 0 means default of a component; 1 means type; 2 means name
+        std::vector<const char *> fields_specification;
+
+    public:
+        Remapping_setting();
+        Remapping_setting(const char*, const char*);
+        Remapping_setting(int, TiXmlElement*, const char*);
+        ~Remapping_setting();
+        void detect_conflict(Remapping_setting*, const char*);
+        void reset_remapping_setting();
+        int get_field_specification_manner() { return field_specification_manner; }
+        void get_field_remapping_setting(Remapping_setting&, const char*);
+        Remapping_algorithm_specification *get_H2D_remapping_algorithm() { return H2D_remapping_algorithm; }
+        Remapping_algorithm_specification *get_V1D_remapping_algorithm() { return V1D_remapping_algorithm; }
+        Remapping_algorithm_specification *get_T1D_remapping_algorithm() { return T1D_remapping_algorithm; }
+        void write_remapping_setting_into_array(char **, long &, long &);
+        void read_remapping_setting_from_array(const char *, long &);
+        void print();
+        Remapping_setting *clone();
+        bool is_the_same_as_another(Remapping_setting*);
+        void append_H2D_remapping_weights(Remapping_setting *);
+        H2D_remapping_wgt_file_info *search_H2D_remapping_weight(Original_grid_info *, Original_grid_info*, int);
+        long calculate_checksum();
+        void shrink(Original_grid_info*, Original_grid_info*);
 };
 
 
 class Remapping_configuration
 {
-	private:
-		int comp_id;
-		std::vector<Remapping_setting*> remapping_settings;
-
-	public:
-		Remapping_configuration();
-		Remapping_configuration(int, const char*, TiXmlDocument *XML_file);
-		~Remapping_configuration();
-		int get_comp_id() { return comp_id; }
-		bool get_field_remapping_setting(Remapping_setting&, const char*);
+    private:
+        int comp_id;
+        std::vector<Remapping_setting*> remapping_settings;
+
+    public:
+        Remapping_configuration();
+        Remapping_configuration(int, const char*, TiXmlDocument *XML_file);
+        ~Remapping_configuration();
+        int get_comp_id() { return comp_id; }
+        bool get_field_remapping_setting(Remapping_setting&, const char*);
 };
 
 
 class Remapping_configuration_mgt
 {
-	private:
-		std::vector<Remapping_configuration*> remapping_configurations;
-
-	public:
-		Remapping_configuration_mgt() {}
-		~Remapping_configuration_mgt();
-		void add_remapping_configuration(int);
-		Remapping_configuration *search_remapping_configuration(int);
-		void get_field_remapping_setting(Remapping_setting &, int, const char*);
+    private:
+        std::vector<Remapping_configuration*> remapping_configurations;
+
+    public:
+        Remapping_configuration_mgt() {}
+        ~Remapping_configuration_mgt();
+        void add_remapping_configuration(int);
+        Remapping_configuration *search_remapping_configuration(int);
+        void get_field_remapping_setting(Remapping_setting &, int, const char*);
 };
 
 
diff --git a/src/Runtime_MGT/runtime_cumulate_average_algorithm.cxx b/src/Runtime_MGT/runtime_cumulate_average_algorithm.cxx
old mode 100644
new mode 100755
index 8bda746..3a09d8a
--- a/src/Runtime_MGT/runtime_cumulate_average_algorithm.cxx
+++ b/src/Runtime_MGT/runtime_cumulate_average_algorithm.cxx
@@ -46,28 +46,28 @@ template<typename T> void template_cumulate_or_average(T* dst, const T* src, con
 
 Runtime_cumulate_average_algorithm::Runtime_cumulate_average_algorithm(Connection_coupling_procedure *coupling_procedure, Field_mem_info *field_src, Field_mem_info *field_dst)
 {
-	cumulate_average_field_info *cumulate_average_field  = new cumulate_average_field_info;
-	this->coupling_procedure = coupling_procedure;
-	cumulate_average_field->mem_info_src = field_src;
-	cumulate_average_field->mem_info_dst = field_dst;
-	cumulate_average_field->timer = NULL;
-	cumulate_average_field->num_elements_in_field = field_src->get_size_of_field();
-	cumulate_average_field->field_data_type = field_src->get_data_type();
-	cumulate_average_field->current_computing_count = 0;
+    cumulate_average_field_info *cumulate_average_field  = new cumulate_average_field_info;
+    this->coupling_procedure = coupling_procedure;
+    cumulate_average_field->mem_info_src = field_src;
+    cumulate_average_field->mem_info_dst = field_dst;
+    cumulate_average_field->timer = NULL;
+    cumulate_average_field->num_elements_in_field = field_src->get_size_of_field();
+    cumulate_average_field->field_data_type = field_src->get_data_type();
+    cumulate_average_field->current_computing_count = 0;
     cumulate_average_fields.push_back(cumulate_average_field);
 
-	comp_id = field_src->get_comp_id();
+    comp_id = field_src->get_comp_id();
 }
 
 
 void Runtime_cumulate_average_algorithm::cumulate_or_average(bool do_average)
 {
-	EXECUTION_REPORT_LOG(REPORT_LOG, comp_id, true, "before cumulate or average");
-	for (int i = 0; i < cumulate_average_fields.size(); i ++) {
-		cumulate_average_fields[i]->mem_info_src->check_field_sum("(src value) before cumulate or average");
-		cumulate_average_fields[i]->mem_info_dst->check_field_sum("(dst value) before cumulate or average");
-	}
-	
+    EXECUTION_REPORT_LOG(REPORT_LOG, comp_id, true, "before cumulate or average");
+    for (int i = 0; i < cumulate_average_fields.size(); i ++) {
+        cumulate_average_fields[i]->mem_info_src->check_field_sum("(src value) before cumulate or average");
+        cumulate_average_fields[i]->mem_info_dst->check_field_sum("(dst value) before cumulate or average");
+    }
+    
     for (int i = 0; i < cumulate_average_fields.size(); i ++) {
         cumulate_average_fields[i]->current_computing_count ++;
         if (words_are_the_same(cumulate_average_fields[i]->field_data_type, DATA_TYPE_FLOAT))
@@ -82,7 +82,7 @@ void Runtime_cumulate_average_algorithm::cumulate_or_average(bool do_average)
                                          cumulate_average_fields[i]->num_elements_in_field,
                                          cumulate_average_fields[i]->current_computing_count,
                                          do_average);
-		else if (words_are_the_same(cumulate_average_fields[i]->field_data_type, DATA_TYPE_INT))
+        else if (words_are_the_same(cumulate_average_fields[i]->field_data_type, DATA_TYPE_INT))
             template_cumulate_or_average<int>((int *) (cumulate_average_fields[i]->mem_info_dst->get_data_buf()), 
                                          (int *) (cumulate_average_fields[i]->mem_info_src->get_data_buf()), 
                                          cumulate_average_fields[i]->num_elements_in_field,
@@ -90,25 +90,25 @@ void Runtime_cumulate_average_algorithm::cumulate_or_average(bool do_average)
                                          do_average);
         else EXECUTION_REPORT(REPORT_ERROR, -1, false, "error data type in cumulate_average algorithm\n"); 
         if (do_average) {
-			EXECUTION_REPORT_LOG(REPORT_LOG, comp_id, true, "do average at computing count is %d", cumulate_average_fields[i]->current_computing_count);
-            cumulate_average_fields[i]->current_computing_count = 0;			
+            EXECUTION_REPORT_LOG(REPORT_LOG, comp_id, true, "do average at computing count is %d", cumulate_average_fields[i]->current_computing_count);
+            cumulate_average_fields[i]->current_computing_count = 0;            
         }
-		cumulate_average_fields[i]->mem_info_src->use_field_values(NULL);
-		cumulate_average_fields[i]->mem_info_dst->define_field_values(false);
+        cumulate_average_fields[i]->mem_info_src->use_field_values(NULL);
+        cumulate_average_fields[i]->mem_info_dst->define_field_values(false);
     }
 
-	EXECUTION_REPORT_LOG(REPORT_LOG, comp_id, true, "after cumulate or average");
-	for (int i = 0; i < cumulate_average_fields.size(); i ++) {
-		cumulate_average_fields[i]->mem_info_dst->check_field_sum("(dst value) after cumulate or average");
-	}
+    EXECUTION_REPORT_LOG(REPORT_LOG, comp_id, true, "after cumulate or average");
+    for (int i = 0; i < cumulate_average_fields.size(); i ++) {
+        cumulate_average_fields[i]->mem_info_dst->check_field_sum("(dst value) after cumulate or average");
+    }
 }
 
 
 bool Runtime_cumulate_average_algorithm::run(bool do_average)
 {
     cumulate_or_average(do_average);
-	
-	return true;
+    
+    return true;
 }
 
 
@@ -123,46 +123,46 @@ Runtime_cumulate_average_algorithm::~Runtime_cumulate_average_algorithm()
 
 void Runtime_cumulate_average_algorithm::restart_write(Restart_buffer_container *restart_buffer, const char *label)
 {
-	for (int i = cumulate_average_fields.size()-1; i >= 0; i --) {
-		restart_buffer->dump_in_data(&(cumulate_average_fields[i]->current_computing_count), sizeof(int));
-		restart_buffer->dump_in_data(&(cumulate_average_fields[i]->num_elements_in_field), sizeof(int));
-		if (cumulate_average_fields[i]->current_computing_count != 0) {
-			EXECUTION_REPORT_LOG(REPORT_LOG, coupling_procedure->get_inout_interface()->get_comp_id(), true, "Detect the requirements for writing intermediate field data (%s) into restart data file for a Runtime_cumulate_average_algorithm of the export interface \"%s\" to the component model \"%s\" (%d)", label, coupling_procedure->get_inout_interface()->get_interface_name(), coupling_procedure->get_coupling_connection()->get_dst_comp_full_name(), cumulate_average_fields[i]->current_computing_count);
-			char temp_label[NAME_STR_SIZE*2];
-			sprintf(temp_label, "%s_%s_%s", label, coupling_procedure->get_coupling_connection()->get_dst_comp_full_name(), coupling_procedure->get_coupling_connection()->get_dst_interface_name());
-			restart_buffer->get_restart_mgr()->write_restart_field_data(cumulate_average_fields[i]->mem_info_dst, coupling_procedure->get_inout_interface()->get_interface_name(), temp_label, false);
-			sprintf(temp_label, "restart write of field \"%s\" average algorithm of export interface \"%s\" to the import interface \"%s\" of the component model \"%s\"", cumulate_average_fields[i]->mem_info_dst->get_field_name(), coupling_procedure->get_inout_interface()->get_interface_name(), coupling_procedure->get_coupling_connection()->get_dst_interface_name(), coupling_procedure->get_coupling_connection()->get_dst_comp_full_name());
-			cumulate_average_fields[i]->mem_info_dst->check_field_sum(temp_label);
-		}
-	}
-	int temp_int = cumulate_average_fields.size();
-	restart_buffer->dump_in_data(&temp_int, sizeof(int));
+    for (int i = cumulate_average_fields.size()-1; i >= 0; i --) {
+        restart_buffer->dump_in_data(&(cumulate_average_fields[i]->current_computing_count), sizeof(int));
+        restart_buffer->dump_in_data(&(cumulate_average_fields[i]->num_elements_in_field), sizeof(int));
+        if (cumulate_average_fields[i]->current_computing_count != 0) {
+            EXECUTION_REPORT_LOG(REPORT_LOG, coupling_procedure->get_inout_interface()->get_comp_id(), true, "Detect the requirements for writing intermediate field data (%s) into restart data file for a Runtime_cumulate_average_algorithm of the export interface \"%s\" to the component model \"%s\" (%d)", label, coupling_procedure->get_inout_interface()->get_interface_name(), coupling_procedure->get_coupling_connection()->get_dst_comp_full_name(), cumulate_average_fields[i]->current_computing_count);
+            char temp_label[NAME_STR_SIZE*2];
+            sprintf(temp_label, "%s_%s_%s", label, coupling_procedure->get_coupling_connection()->get_dst_comp_full_name(), coupling_procedure->get_coupling_connection()->get_dst_interface_name());
+            restart_buffer->get_restart_mgr()->write_restart_field_data(cumulate_average_fields[i]->mem_info_dst, coupling_procedure->get_inout_interface()->get_interface_name(), temp_label, false);
+            sprintf(temp_label, "restart write of field \"%s\" average algorithm of export interface \"%s\" to the import interface \"%s\" of the component model \"%s\"", cumulate_average_fields[i]->mem_info_dst->get_field_name(), coupling_procedure->get_inout_interface()->get_interface_name(), coupling_procedure->get_coupling_connection()->get_dst_interface_name(), coupling_procedure->get_coupling_connection()->get_dst_comp_full_name());
+            cumulate_average_fields[i]->mem_info_dst->check_field_sum(temp_label);
+        }
+    }
+    int temp_int = cumulate_average_fields.size();
+    restart_buffer->dump_in_data(&temp_int, sizeof(int));
 }
 
 
 void Runtime_cumulate_average_algorithm::restart_read(Restart_buffer_container *restart_buffer, const char *label)
 {
-	int num_fields, temp_current_computing_count, temp_num_elements_in_field;
-	Time_mgt *time_mgr = components_time_mgrs->get_time_mgr(comp_id);
-
-
-	restart_buffer->load_restart_data(&num_fields, sizeof(int));
-	if (time_mgr->get_runtype_mark() == RUNTYPE_MARK_BRANCH || time_mgr->get_runtype_mark() == RUNTYPE_MARK_CONTINUE)
-		EXECUTION_REPORT(REPORT_ERROR, comp_id, num_fields == cumulate_average_fields.size(), "Fail to restart the simulation in a branch run or continue run: the coupling configuration has been changed from the original simulation run. Please verify.");
-	for (int i = 0; i < num_fields; i ++) {
-		restart_buffer->load_restart_data(&temp_num_elements_in_field, sizeof(int));
-		restart_buffer->load_restart_data(&temp_current_computing_count, sizeof(int));
-		if (time_mgr->get_runtype_mark() == RUNTYPE_MARK_BRANCH || time_mgr->get_runtype_mark() == RUNTYPE_MARK_CONTINUE) {
-			EXECUTION_REPORT(REPORT_ERROR, comp_id, temp_num_elements_in_field == cumulate_average_fields[i]->num_elements_in_field, "Fail to restart the simulation in a branch run or continue run: the coupling configuration has been changed from the original simulation run. Please verify.");
-			cumulate_average_fields[i]->current_computing_count = temp_current_computing_count;
-			if (temp_current_computing_count != 0) {
-				char temp_label[NAME_STR_SIZE*2];
-				sprintf(temp_label, "%s_%s_%s", label, coupling_procedure->get_coupling_connection()->get_dst_comp_full_name(), coupling_procedure->get_coupling_connection()->get_dst_interface_name());
-				restart_buffer->get_restart_mgr()->read_restart_field_data(cumulate_average_fields[i]->mem_info_dst, coupling_procedure->get_inout_interface()->get_interface_name(), temp_label, false, NULL, "");
-				sprintf(temp_label, "restart read of field \"%s\" average algorithm of export interface \"%s\" to the import interface \"%s\" of the component model \"%s\"", cumulate_average_fields[i]->mem_info_dst->get_field_name(), coupling_procedure->get_inout_interface()->get_interface_name(), coupling_procedure->get_coupling_connection()->get_dst_interface_name(), coupling_procedure->get_coupling_connection()->get_dst_comp_full_name());
-				cumulate_average_fields[i]->mem_info_dst->check_field_sum(temp_label);
-			}
-		}
-	}
+    int num_fields, temp_current_computing_count, temp_num_elements_in_field;
+    Time_mgt *time_mgr = components_time_mgrs->get_time_mgr(comp_id);
+
+
+    restart_buffer->load_restart_data(&num_fields, sizeof(int));
+    if (time_mgr->get_runtype_mark() == RUNTYPE_MARK_BRANCH || time_mgr->get_runtype_mark() == RUNTYPE_MARK_CONTINUE)
+        EXECUTION_REPORT(REPORT_ERROR, comp_id, num_fields == cumulate_average_fields.size(), "Fail to restart the simulation in a branch run or continue run: the coupling configuration has been changed from the original simulation run. Please verify.");
+    for (int i = 0; i < num_fields; i ++) {
+        restart_buffer->load_restart_data(&temp_num_elements_in_field, sizeof(int));
+        restart_buffer->load_restart_data(&temp_current_computing_count, sizeof(int));
+        if (time_mgr->get_runtype_mark() == RUNTYPE_MARK_BRANCH || time_mgr->get_runtype_mark() == RUNTYPE_MARK_CONTINUE) {
+            EXECUTION_REPORT(REPORT_ERROR, comp_id, temp_num_elements_in_field == cumulate_average_fields[i]->num_elements_in_field, "Fail to restart the simulation in a branch run or continue run: the coupling configuration has been changed from the original simulation run. Please verify.");
+            cumulate_average_fields[i]->current_computing_count = temp_current_computing_count;
+            if (temp_current_computing_count != 0) {
+                char temp_label[NAME_STR_SIZE*2];
+                sprintf(temp_label, "%s_%s_%s", label, coupling_procedure->get_coupling_connection()->get_dst_comp_full_name(), coupling_procedure->get_coupling_connection()->get_dst_interface_name());
+                restart_buffer->get_restart_mgr()->read_restart_field_data(cumulate_average_fields[i]->mem_info_dst, coupling_procedure->get_inout_interface()->get_interface_name(), temp_label, false, NULL, false, "");
+                sprintf(temp_label, "restart read of field \"%s\" average algorithm of export interface \"%s\" to the import interface \"%s\" of the component model \"%s\"", cumulate_average_fields[i]->mem_info_dst->get_field_name(), coupling_procedure->get_inout_interface()->get_interface_name(), coupling_procedure->get_coupling_connection()->get_dst_interface_name(), coupling_procedure->get_coupling_connection()->get_dst_comp_full_name());
+                cumulate_average_fields[i]->mem_info_dst->check_field_sum(temp_label);
+            }
+        }
+    }
 }
 
diff --git a/src/Runtime_MGT/runtime_cumulate_average_algorithm.h b/src/Runtime_MGT/runtime_cumulate_average_algorithm.h
old mode 100644
new mode 100755
index 041bebf..4d86d3d
--- a/src/Runtime_MGT/runtime_cumulate_average_algorithm.h
+++ b/src/Runtime_MGT/runtime_cumulate_average_algorithm.h
@@ -34,16 +34,16 @@ struct cumulate_average_field_info
 class Runtime_cumulate_average_algorithm
 {
     private:
-		int comp_id;
+        int comp_id;
         std::vector<cumulate_average_field_info*> cumulate_average_fields;
-		Connection_coupling_procedure *coupling_procedure;
+        Connection_coupling_procedure *coupling_procedure;
         void cumulate_or_average(bool);
         
     public:
-		Runtime_cumulate_average_algorithm(Connection_coupling_procedure *, Field_mem_info*, Field_mem_info*);
+        Runtime_cumulate_average_algorithm(Connection_coupling_procedure *, Field_mem_info*, Field_mem_info*);
         ~Runtime_cumulate_average_algorithm();
-		void restart_write(Restart_buffer_container*, const char *);
-		void restart_read(Restart_buffer_container*, const char *);
+        void restart_write(Restart_buffer_container*, const char *);
+        void restart_read(Restart_buffer_container*, const char *);
         bool run(bool);
 };
 
diff --git a/src/Runtime_MGT/runtime_datatype_transformer.cxx b/src/Runtime_MGT/runtime_datatype_transformer.cxx
old mode 100644
new mode 100755
index 4f0988b..e1634a9
--- a/src/Runtime_MGT/runtime_datatype_transformer.cxx
+++ b/src/Runtime_MGT/runtime_datatype_transformer.cxx
@@ -13,78 +13,78 @@
 
 Runtime_datatype_transformer::Runtime_datatype_transformer(Field_mem_info *src_field, Field_mem_info *dst_field)
 {
-	src_fields.push_back(src_field);
-	dst_fields.push_back(dst_field);
+    src_fields.push_back(src_field);
+    dst_fields.push_back(dst_field);
 }
 
 
 bool Runtime_datatype_transformer::run(bool bypass_timer)
 {
-	transform_fields_datatype();
-	
-	return true;
+    transform_fields_datatype();
+    
+    return true;
 }
 
 
 void Runtime_datatype_transformer::transform_fields_datatype()
 {
-	char *data_type_src, *data_type_dst;
-	long num_local_cells;
+    char *data_type_src, *data_type_dst;
+    long num_local_cells;
 
 
-	for (int i = 0; i < src_fields.size(); i ++) {
-		src_fields[i]->use_field_values("");
-		dst_fields[i]->define_field_values(false);
-		data_type_src = src_fields[i]->get_field_data()->get_grid_data_field()->data_type_in_application;
-		data_type_dst = dst_fields[i]->get_field_data()->get_grid_data_field()->data_type_in_application;
-		num_local_cells = src_fields[i]->get_field_data()->get_grid_data_field()->required_data_size;
-		if (words_are_the_same(data_type_src, DATA_TYPE_DOUBLE)) {
-			if (words_are_the_same(data_type_dst, DATA_TYPE_FLOAT))
-				transform_datatype_of_arrays((double*)src_fields[i]->get_data_buf(), (float*) dst_fields[i]->get_data_buf(), num_local_cells);
-			else EXECUTION_REPORT(REPORT_ERROR,-1, "C-Coupler software error1 in transform_fields_datatype of Runtime_datatype_transformer");
-		}
-		else if (words_are_the_same(data_type_src, DATA_TYPE_FLOAT)) {
-			if (words_are_the_same(data_type_dst, DATA_TYPE_DOUBLE))
-				transform_datatype_of_arrays((float*)src_fields[i]->get_data_buf(), (double*) dst_fields[i]->get_data_buf(), num_local_cells);
-			else EXECUTION_REPORT(REPORT_ERROR,-1, "C-Coupler software error2 in transform_fields_datatype of Runtime_datatype_transformer");
-		}
-		else if (words_are_the_same(data_type_src, DATA_TYPE_LONG)) {
-			if (words_are_the_same(data_type_dst, DATA_TYPE_INT))
-				transform_datatype_of_arrays((long*)src_fields[i]->get_data_buf(), (int*) dst_fields[i]->get_data_buf(), num_local_cells);
-			else if (words_are_the_same(data_type_dst, DATA_TYPE_SHORT))
-				transform_datatype_of_arrays((long*)src_fields[i]->get_data_buf(), (short*) dst_fields[i]->get_data_buf(), num_local_cells);
-			else if (words_are_the_same(data_type_dst, DATA_TYPE_BOOL))
-				transform_datatype_of_arrays((long*)src_fields[i]->get_data_buf(), (bool*) dst_fields[i]->get_data_buf(), num_local_cells);
-			else EXECUTION_REPORT(REPORT_ERROR,-1, "C-Coupler software error3 in transform_fields_datatype of Runtime_datatype_transformer");
-		}
-		else if (words_are_the_same(data_type_src, DATA_TYPE_INT)) {
-			if (words_are_the_same(data_type_dst, DATA_TYPE_LONG))
-				transform_datatype_of_arrays((int*)src_fields[i]->get_data_buf(), (long*) dst_fields[i]->get_data_buf(), num_local_cells);
-			else if (words_are_the_same(data_type_dst, DATA_TYPE_SHORT))
-				transform_datatype_of_arrays((int*)src_fields[i]->get_data_buf(), (short*) dst_fields[i]->get_data_buf(), num_local_cells);
-			else if (words_are_the_same(data_type_dst, DATA_TYPE_BOOL))
-				transform_datatype_of_arrays((int*)src_fields[i]->get_data_buf(), (bool*) dst_fields[i]->get_data_buf(), num_local_cells);
-			else EXECUTION_REPORT(REPORT_ERROR,-1, "C-Coupler software error4 in transform_fields_datatype of Runtime_datatype_transformer");
-		}
-		else if (words_are_the_same(data_type_src, DATA_TYPE_SHORT)) {
-			if (words_are_the_same(data_type_dst, DATA_TYPE_LONG))
-				transform_datatype_of_arrays((short*)src_fields[i]->get_data_buf(), (long*) dst_fields[i]->get_data_buf(), num_local_cells);
-			else if (words_are_the_same(data_type_dst, DATA_TYPE_INT))
-				transform_datatype_of_arrays((short*)src_fields[i]->get_data_buf(), (int*) dst_fields[i]->get_data_buf(), num_local_cells);
-			else if (words_are_the_same(data_type_dst, DATA_TYPE_BOOL))
-				transform_datatype_of_arrays((short*)src_fields[i]->get_data_buf(), (bool*) dst_fields[i]->get_data_buf(), num_local_cells);
-			else EXECUTION_REPORT(REPORT_ERROR,-1, "C-Coupler software error5 in transform_fields_datatype of Runtime_datatype_transformer");
-		}
-		else if (words_are_the_same(data_type_src, DATA_TYPE_BOOL)) {
-			if (words_are_the_same(data_type_dst, DATA_TYPE_LONG))
-				transform_datatype_of_arrays((bool*)src_fields[i]->get_data_buf(), (long*) dst_fields[i]->get_data_buf(), num_local_cells);
-			else if (words_are_the_same(data_type_dst, DATA_TYPE_INT))
-				transform_datatype_of_arrays((bool*)src_fields[i]->get_data_buf(), (int*) dst_fields[i]->get_data_buf(), num_local_cells);
-			else if (words_are_the_same(data_type_dst, DATA_TYPE_SHORT))
-				transform_datatype_of_arrays((bool*)src_fields[i]->get_data_buf(), (short*) dst_fields[i]->get_data_buf(), num_local_cells);
-			else EXECUTION_REPORT(REPORT_ERROR,-1, "C-Coupler software error6 in transform_fields_datatype of Runtime_datatype_transformer");
-		}
-		else EXECUTION_REPORT(REPORT_ERROR,-1, "C-Coupler software error7 in transform_fields_datatype of Runtime_datatype_transformer");
-	}
+    for (int i = 0; i < src_fields.size(); i ++) {
+        src_fields[i]->use_field_values("");
+        dst_fields[i]->define_field_values(false);
+        data_type_src = src_fields[i]->get_field_data()->get_grid_data_field()->data_type_in_application;
+        data_type_dst = dst_fields[i]->get_field_data()->get_grid_data_field()->data_type_in_application;
+        num_local_cells = src_fields[i]->get_field_data()->get_grid_data_field()->required_data_size;
+        if (words_are_the_same(data_type_src, DATA_TYPE_DOUBLE)) {
+            if (words_are_the_same(data_type_dst, DATA_TYPE_FLOAT))
+                transform_datatype_of_arrays((double*)src_fields[i]->get_data_buf(), (float*) dst_fields[i]->get_data_buf(), num_local_cells);
+            else EXECUTION_REPORT(REPORT_ERROR,-1, "C-Coupler software error1 in transform_fields_datatype of Runtime_datatype_transformer");
+        }
+        else if (words_are_the_same(data_type_src, DATA_TYPE_FLOAT)) {
+            if (words_are_the_same(data_type_dst, DATA_TYPE_DOUBLE))
+                transform_datatype_of_arrays((float*)src_fields[i]->get_data_buf(), (double*) dst_fields[i]->get_data_buf(), num_local_cells);
+            else EXECUTION_REPORT(REPORT_ERROR,-1, "C-Coupler software error2 in transform_fields_datatype of Runtime_datatype_transformer");
+        }
+        else if (words_are_the_same(data_type_src, DATA_TYPE_LONG)) {
+            if (words_are_the_same(data_type_dst, DATA_TYPE_INT))
+                transform_datatype_of_arrays((long*)src_fields[i]->get_data_buf(), (int*) dst_fields[i]->get_data_buf(), num_local_cells);
+            else if (words_are_the_same(data_type_dst, DATA_TYPE_SHORT))
+                transform_datatype_of_arrays((long*)src_fields[i]->get_data_buf(), (short*) dst_fields[i]->get_data_buf(), num_local_cells);
+            else if (words_are_the_same(data_type_dst, DATA_TYPE_BOOL))
+                transform_datatype_of_arrays((long*)src_fields[i]->get_data_buf(), (bool*) dst_fields[i]->get_data_buf(), num_local_cells);
+            else EXECUTION_REPORT(REPORT_ERROR,-1, "C-Coupler software error3 in transform_fields_datatype of Runtime_datatype_transformer");
+        }
+        else if (words_are_the_same(data_type_src, DATA_TYPE_INT)) {
+            if (words_are_the_same(data_type_dst, DATA_TYPE_LONG))
+                transform_datatype_of_arrays((int*)src_fields[i]->get_data_buf(), (long*) dst_fields[i]->get_data_buf(), num_local_cells);
+            else if (words_are_the_same(data_type_dst, DATA_TYPE_SHORT))
+                transform_datatype_of_arrays((int*)src_fields[i]->get_data_buf(), (short*) dst_fields[i]->get_data_buf(), num_local_cells);
+            else if (words_are_the_same(data_type_dst, DATA_TYPE_BOOL))
+                transform_datatype_of_arrays((int*)src_fields[i]->get_data_buf(), (bool*) dst_fields[i]->get_data_buf(), num_local_cells);
+            else EXECUTION_REPORT(REPORT_ERROR,-1, "C-Coupler software error4 in transform_fields_datatype of Runtime_datatype_transformer");
+        }
+        else if (words_are_the_same(data_type_src, DATA_TYPE_SHORT)) {
+            if (words_are_the_same(data_type_dst, DATA_TYPE_LONG))
+                transform_datatype_of_arrays((short*)src_fields[i]->get_data_buf(), (long*) dst_fields[i]->get_data_buf(), num_local_cells);
+            else if (words_are_the_same(data_type_dst, DATA_TYPE_INT))
+                transform_datatype_of_arrays((short*)src_fields[i]->get_data_buf(), (int*) dst_fields[i]->get_data_buf(), num_local_cells);
+            else if (words_are_the_same(data_type_dst, DATA_TYPE_BOOL))
+                transform_datatype_of_arrays((short*)src_fields[i]->get_data_buf(), (bool*) dst_fields[i]->get_data_buf(), num_local_cells);
+            else EXECUTION_REPORT(REPORT_ERROR,-1, "C-Coupler software error5 in transform_fields_datatype of Runtime_datatype_transformer");
+        }
+        else if (words_are_the_same(data_type_src, DATA_TYPE_BOOL)) {
+            if (words_are_the_same(data_type_dst, DATA_TYPE_LONG))
+                transform_datatype_of_arrays((bool*)src_fields[i]->get_data_buf(), (long*) dst_fields[i]->get_data_buf(), num_local_cells);
+            else if (words_are_the_same(data_type_dst, DATA_TYPE_INT))
+                transform_datatype_of_arrays((bool*)src_fields[i]->get_data_buf(), (int*) dst_fields[i]->get_data_buf(), num_local_cells);
+            else if (words_are_the_same(data_type_dst, DATA_TYPE_SHORT))
+                transform_datatype_of_arrays((bool*)src_fields[i]->get_data_buf(), (short*) dst_fields[i]->get_data_buf(), num_local_cells);
+            else EXECUTION_REPORT(REPORT_ERROR,-1, "C-Coupler software error6 in transform_fields_datatype of Runtime_datatype_transformer");
+        }
+        else EXECUTION_REPORT(REPORT_ERROR,-1, "C-Coupler software error7 in transform_fields_datatype of Runtime_datatype_transformer");
+    }
 }
 
diff --git a/src/Runtime_MGT/runtime_datatype_transformer.h b/src/Runtime_MGT/runtime_datatype_transformer.h
old mode 100644
new mode 100755
index 45e6a98..869721a
--- a/src/Runtime_MGT/runtime_datatype_transformer.h
+++ b/src/Runtime_MGT/runtime_datatype_transformer.h
@@ -16,16 +16,16 @@
 
 class Runtime_datatype_transformer
 {
-	private:
-		std::vector<Field_mem_info*> src_fields;
-		std::vector<Field_mem_info*> dst_fields;
-
-	public:
-		Runtime_datatype_transformer() {}
-		Runtime_datatype_transformer(Field_mem_info*, Field_mem_info*);
-		~Runtime_datatype_transformer() {}
-		void transform_fields_datatype();
-		bool run(bool);
+    private:
+        std::vector<Field_mem_info*> src_fields;
+        std::vector<Field_mem_info*> dst_fields;
+
+    public:
+        Runtime_datatype_transformer() {}
+        Runtime_datatype_transformer(Field_mem_info*, Field_mem_info*);
+        ~Runtime_datatype_transformer() {}
+        void transform_fields_datatype();
+        bool run(bool);
 };
 
 #endif
diff --git a/src/Runtime_MGT/runtime_remap_algorithm.cxx b/src/Runtime_MGT/runtime_remap_algorithm.cxx
old mode 100644
new mode 100755
index 8918875..b9fe730
--- a/src/Runtime_MGT/runtime_remap_algorithm.cxx
+++ b/src/Runtime_MGT/runtime_remap_algorithm.cxx
@@ -16,62 +16,61 @@
 
 
 Runtime_remap_algorithm::Runtime_remap_algorithm(Runtime_remapping_weights *runtime_remapping_weights, Field_mem_info *src_field_instance, Field_mem_info *dst_field_instance, int connection_id)
-{	
-	comp_id = dst_field_instance->get_comp_id();
-	specified_src_field_instance = src_field_instance;
-	specified_dst_field_instance = dst_field_instance;
-	this->runtime_remapping_weights = runtime_remapping_weights;
-	
-	if (words_are_the_same(src_field_instance->get_field_data()->get_grid_data_field()->data_type_in_application, DATA_TYPE_FLOAT)) {
-		true_src_field_instance = memory_manager->alloc_mem(specified_src_field_instance, BUF_MARK_REMAP_DATATYPE_TRANS_SRC, connection_id, DATA_TYPE_DOUBLE, false);
-		true_dst_field_instance = memory_manager->alloc_mem(specified_dst_field_instance, BUF_MARK_REMAP_DATATYPE_TRANS_DST, connection_id, DATA_TYPE_DOUBLE, false);
-		transform_data_type = true;
-	}
-	else if (words_are_the_same(src_field_instance->get_field_data()->get_grid_data_field()->data_type_in_application, DATA_TYPE_DOUBLE)) {
-		true_src_field_instance = specified_src_field_instance;
-		true_dst_field_instance = specified_dst_field_instance;
-		transform_data_type = false;
-	}
-	else EXECUTION_REPORT(REPORT_ERROR, -1, false, "Software error in Runtime_remap_algorithm::Runtime_remap_algorithm: data type is wrong: data type %s of src field %s vs data type %s of dst field %s", src_field_instance->get_field_data()->get_grid_data_field()->data_type_in_application, src_field_instance->get_field_name(), dst_field_instance->get_field_data()->get_grid_data_field()->data_type_in_application, dst_field_instance->get_field_name());
+{    
+    comp_id = dst_field_instance->get_comp_id();
+    specified_src_field_instance = src_field_instance;
+    specified_dst_field_instance = dst_field_instance;
+    this->runtime_remapping_weights = runtime_remapping_weights;
+    
+    if (words_are_the_same(src_field_instance->get_field_data()->get_grid_data_field()->data_type_in_application, DATA_TYPE_FLOAT)) {
+        true_src_field_instance = memory_manager->alloc_mem(specified_src_field_instance, BUF_MARK_REMAP_DATATYPE_TRANS_SRC, connection_id, DATA_TYPE_DOUBLE, false);
+        true_dst_field_instance = memory_manager->alloc_mem(specified_dst_field_instance, BUF_MARK_REMAP_DATATYPE_TRANS_DST, connection_id, DATA_TYPE_DOUBLE, false);
+        transform_data_type = true;
+    }
+    else if (words_are_the_same(src_field_instance->get_field_data()->get_grid_data_field()->data_type_in_application, DATA_TYPE_DOUBLE)) {
+        true_src_field_instance = specified_src_field_instance;
+        true_dst_field_instance = specified_dst_field_instance;
+        transform_data_type = false;
+    }
+    else EXECUTION_REPORT(REPORT_ERROR, -1, false, "Software error in Runtime_remap_algorithm::Runtime_remap_algorithm: data type is wrong: data type %s of src field %s vs data type %s of dst field %s", src_field_instance->get_field_data()->get_grid_data_field()->data_type_in_application, src_field_instance->get_field_name(), dst_field_instance->get_field_data()->get_grid_data_field()->data_type_in_application, dst_field_instance->get_field_name());
 }
 
 
 Runtime_remap_algorithm::~Runtime_remap_algorithm()
 {
-	for (int i = 0; i < operations_for_dynamic_sigma_grid.size(); i ++) {
-		if (operations_for_dynamic_sigma_grid[i]->runtime_remap_algorithm != NULL)
-			delete operations_for_dynamic_sigma_grid[i]->runtime_remap_algorithm;
-		delete operations_for_dynamic_sigma_grid[i];
-	}
 }
 
 
 void Runtime_remap_algorithm::do_remap(bool is_algorithm_in_kernel_stage)
 {
     long i, j, field_size_src_before_rearrange, field_size_src_after_rearrange;
-	long field_size_dst, decomp_size_src_before_rearrange, decomp_size_src_after_rearrange, num_levels;
+    long field_size_dst, decomp_size_src_before_rearrange, decomp_size_src_after_rearrange, num_levels;
     double *src_frac_values, *dst_frac_values, *src_field_values, *dst_field_values, frac_1x;
     double *temp_src_values;
-	Remap_grid_class *decomp_grid, *original_grid;
-	Decomp_info *decomp;
-	bool grid_dynamic_surface_field_updated;
+    Remap_grid_class *decomp_grid, *original_grid;
+    Decomp_info *decomp;
 
 
-	if (runtime_remapping_weights->get_parallel_remapping_weights() == NULL)
-		return;
-	
-	specified_src_field_instance->use_field_values("");
-//	specified_src_field_instance->check_field_sum("before data interpolation");
-	if (transform_data_type)
-		for (int i = 0; i < specified_src_field_instance->get_size_of_field(); i ++)
-			((double*)true_src_field_instance->get_data_buf())[i] = ((float*)specified_src_field_instance->get_data_buf())[i];
-	runtime_remapping_weights->renew_dynamic_V1D_remapping_weights();
-	runtime_remapping_weights->get_parallel_remapping_weights()->do_remap(true_src_field_instance->get_field_data(), true_dst_field_instance->get_field_data());
-	if (transform_data_type)
-		for (int i = 0; i < specified_dst_field_instance->get_size_of_field(); i ++)
-			((float*)specified_dst_field_instance->get_data_buf())[i] = ((double*)true_dst_field_instance->get_data_buf())[i];
-	specified_dst_field_instance->define_field_values(true);
-//	specified_dst_field_instance->check_field_sum("after data interpolation");
+	EXECUTION_REPORT_LOG(REPORT_LOG, -1, true, "Data interpolation for field \"%s\"", specified_src_field_instance->get_field_name());
+
+    if (runtime_remapping_weights->get_parallel_remapping_weights() == NULL)
+        return;
+    
+    specified_src_field_instance->use_field_values("");
+//    specified_src_field_instance->check_field_sum("before data interpolation");
+    if (transform_data_type)
+        for (int i = 0; i < specified_src_field_instance->get_size_of_field(); i ++)
+            ((double*)true_src_field_instance->get_data_buf())[i] = ((float*)specified_src_field_instance->get_data_buf())[i];
+	if (!words_are_the_same(specified_src_field_instance->get_field_name(),V3D_GRID_3D_LEVEL_FIELD_NAME))
+	    runtime_remapping_weights->renew_dynamic_V1D_remapping_weights();
+    comp_comm_group_mgt_mgr->get_global_node_of_local_comp(runtime_remapping_weights->get_dst_original_grid()->get_comp_id(),false,"")->get_performance_timing_mgr()->performance_timing_start(TIMING_TYPE_COMPUTATION, -1, -1, "remapping cal");
+    runtime_remapping_weights->get_parallel_remapping_weights()->do_remap(runtime_remapping_weights->get_dst_original_grid()->get_comp_id(), true_src_field_instance->get_field_data(), true_dst_field_instance->get_field_data());
+    comp_comm_group_mgt_mgr->get_global_node_of_local_comp(runtime_remapping_weights->get_dst_original_grid()->get_comp_id(),false,"")->get_performance_timing_mgr()->performance_timing_stop(TIMING_TYPE_COMPUTATION, -1, -1, "remapping cal");
+    if (transform_data_type)
+        for (int i = 0; i < specified_dst_field_instance->get_size_of_field(); i ++)
+            ((float*)specified_dst_field_instance->get_data_buf())[i] = ((double*)true_dst_field_instance->get_data_buf())[i];
+    specified_dst_field_instance->define_field_values(true);
+//    specified_dst_field_instance->check_field_sum("after data interpolation");
 }
 
 
@@ -79,6 +78,6 @@ bool Runtime_remap_algorithm::run(bool is_algorithm_in_kernel_stage)
 {
     do_remap(is_algorithm_in_kernel_stage);
 
-	return true;
+    return true;
 }
 
diff --git a/src/Runtime_MGT/runtime_remap_algorithm.h b/src/Runtime_MGT/runtime_remap_algorithm.h
old mode 100644
new mode 100755
index eb4de42..261e9ed
--- a/src/Runtime_MGT/runtime_remap_algorithm.h
+++ b/src/Runtime_MGT/runtime_remap_algorithm.h
@@ -21,35 +21,24 @@ class Runtime_transfer_algorithm;
 class Runtime_remap_algorithm;
 
 
-struct Operation_for_dynamic_sigma_grid
-{
-	Field_mem_info *surface_field_of_sigma_grid_src;
-	Field_mem_info *surface_field_of_sigma_grid_dst;
-	Remap_grid_class *current_3D_sigma_grid_src;
-	Remap_grid_class *current_3D_sigma_grid_dst;
-	Runtime_remap_algorithm *runtime_remap_algorithm;
-};
-
-
 class Runtime_remap_algorithm
 {
     private:       
-		std::vector<Operation_for_dynamic_sigma_grid*> operations_for_dynamic_sigma_grid;
-		int comp_id;
-		Field_mem_info *specified_src_field_instance;
-		Field_mem_info *specified_dst_field_instance;
-		Field_mem_info *true_src_field_instance;
-		Field_mem_info *true_dst_field_instance;
-		Runtime_remapping_weights *runtime_remapping_weights;
-		bool transform_data_type;
-		
+        int comp_id;
+        Field_mem_info *specified_src_field_instance;
+        Field_mem_info *specified_dst_field_instance;
+        Field_mem_info *true_src_field_instance;
+        Field_mem_info *true_dst_field_instance;
+        Runtime_remapping_weights *runtime_remapping_weights;
+        bool transform_data_type;
+        
         void do_remap(bool);
 
-    public:	
-		Runtime_remap_algorithm(Runtime_remapping_weights *, Field_mem_info *, Field_mem_info *, int);
-		Runtime_remapping_weights *get_runtime_remapping_weights() { return runtime_remapping_weights; }
+    public:    
+        Runtime_remap_algorithm(Runtime_remapping_weights *, Field_mem_info *, Field_mem_info *, int);
+        Runtime_remapping_weights *get_runtime_remapping_weights() { return runtime_remapping_weights; }
         bool run(bool);
-		void allocate_src_dst_fields(bool);
+        void allocate_src_dst_fields(bool);
         ~Runtime_remap_algorithm();
 };
 
diff --git a/src/Runtime_MGT/runtime_remapping_weights_mgt.cxx b/src/Runtime_MGT/runtime_remapping_weights_mgt.cxx
old mode 100644
new mode 100755
index 26427e7..3e5ca3a
--- a/src/Runtime_MGT/runtime_remapping_weights_mgt.cxx
+++ b/src/Runtime_MGT/runtime_remapping_weights_mgt.cxx
@@ -19,58 +19,58 @@
 
 Runtime_remapping_weights::Runtime_remapping_weights()
 {
-	src_comp_full_name = NULL;
-	dst_comp_full_name = NULL;
-	src_original_grid = NULL;
-	dst_original_grid = NULL;
-	src_decomp_info = NULL;
-	dst_decomp_info = NULL;
-	remapping_setting = NULL;
-	remapping_strategy = NULL;
-	sequential_remapping_weights = NULL;
-	parallel_remapping_weights = NULL;
-	intermediate_V3D_grid_bottom_field = NULL;
-	dynamic_V1D_remap_weight_of_operator = NULL;
-	runtime_V1D_remap_grid_src = NULL;
-	runtime_V1D_remap_grid_dst = NULL;
-	src_H2D_grid_area = NULL;
-	dst_H2D_grid_area = NULL;
+    src_comp_full_name = NULL;
+    dst_comp_full_name = NULL;
+    src_original_grid = NULL;
+    dst_original_grid = NULL;
+    src_decomp_info = NULL;
+    dst_decomp_info = NULL;
+    remapping_setting = NULL;
+    remapping_strategy = NULL;
+    sequential_remapping_weights = NULL;
+    parallel_remapping_weights = NULL;
+    intermediate_V3D_grid_bottom_field = NULL;
+    dynamic_V1D_remap_weight_of_operator = NULL;
+    runtime_V1D_remap_grid_src = NULL;
+    runtime_V1D_remap_grid_dst = NULL;
+    src_H2D_grid_area = NULL;
+    dst_H2D_grid_area = NULL;
 }
 
 
 Runtime_remapping_weights::Runtime_remapping_weights(const char *src_comp_full_name, const char *dst_comp_full_name, Original_grid_info *src_original_grid, Original_grid_info *dst_original_grid, Remapping_setting *remapping_setting, Decomp_info *dst_decomp_info)
 {
-	Remap_operator_basis *remap_operator_H2D = NULL;
-	Remap_operator_basis *remap_operator_V1D = NULL;
-	Remap_operator_basis *remap_operator_T1D = NULL;
-	Remap_operator_basis *remap_operators[3];
-	Remap_grid_class *remap_grids[2];
-	Remapping_setting *cloned_remapping_setting = remapping_setting->clone();
-	char parameter_name[NAME_STR_SIZE], parameter_value[NAME_STR_SIZE], remap_weight_name[NAME_STR_SIZE];
-	int num_remap_operators = 0;
-	H2D_remapping_wgt_file_info *H2D_remapping_weight_file = NULL;
-
-
-	this->src_comp_full_name = strdup(src_comp_full_name);
-	this->dst_comp_full_name = strdup(dst_comp_full_name);
-	this->src_original_grid = src_original_grid;
-	this->dst_original_grid = dst_original_grid;
-	this->remapping_setting = cloned_remapping_setting;
-	this->dst_decomp_info = dst_decomp_info;
-	this->src_decomp_info = NULL;
-	this->sequential_remapping_weights = NULL;
-	this->parallel_remapping_weights = NULL;
-	this->intermediate_V3D_grid_bottom_field = NULL;
-	this->dynamic_V1D_remap_weight_of_operator = NULL;
-	this->runtime_V1D_remap_grid_src = NULL;
-	this->runtime_V1D_remap_grid_dst = NULL;
-	this->src_H2D_grid_area = NULL;
-	this->dst_H2D_grid_area = NULL;
-
-	if (src_original_grid->get_H2D_sub_CoR_grid() != NULL) {
-		H2D_remapping_weight_file = remapping_setting->search_H2D_remapping_weight(src_original_grid, dst_original_grid);
-		remap_grids[0] = src_original_grid->get_H2D_sub_CoR_grid();
-		remap_grids[1] = dst_original_grid->get_H2D_sub_CoR_grid();
+    Remap_operator_basis *remap_operator_H2D = NULL;
+    Remap_operator_basis *remap_operator_V1D = NULL;
+    Remap_operator_basis *remap_operator_T1D = NULL;
+    Remap_operator_basis *remap_operators[3];
+    Remap_grid_class *remap_grids[2];
+    Remapping_setting *cloned_remapping_setting = remapping_setting->clone();
+    char parameter_name[NAME_STR_SIZE], parameter_value[NAME_STR_SIZE], remap_weight_name[NAME_STR_SIZE];
+    int num_remap_operators = 0;
+    H2D_remapping_wgt_file_info *H2D_remapping_weight_file = NULL;
+
+
+    this->src_comp_full_name = strdup(src_comp_full_name);
+    this->dst_comp_full_name = strdup(dst_comp_full_name);
+    this->src_original_grid = src_original_grid;
+    this->dst_original_grid = dst_original_grid;
+    this->remapping_setting = cloned_remapping_setting;
+    this->dst_decomp_info = dst_decomp_info;
+    this->src_decomp_info = NULL;
+    this->sequential_remapping_weights = NULL;
+    this->parallel_remapping_weights = NULL;
+    this->intermediate_V3D_grid_bottom_field = NULL;
+    this->dynamic_V1D_remap_weight_of_operator = NULL;
+    this->runtime_V1D_remap_grid_src = NULL;
+    this->runtime_V1D_remap_grid_dst = NULL;
+    this->src_H2D_grid_area = NULL;
+    this->dst_H2D_grid_area = NULL;
+
+    if (src_original_grid->get_H2D_sub_CoR_grid() != NULL) {
+        H2D_remapping_weight_file = remapping_setting->search_H2D_remapping_weight(src_original_grid, dst_original_grid, comp_comm_group_mgt_mgr->search_global_node(dst_comp_full_name)->get_comp_id());
+        remap_grids[0] = src_original_grid->get_H2D_sub_CoR_grid();
+        remap_grids[1] = dst_original_grid->get_H2D_sub_CoR_grid();
         if (words_are_the_same(cloned_remapping_setting->get_H2D_remapping_algorithm()->get_algorithm_name(), REMAP_OPERATOR_NAME_BILINEAR))
             remap_operator_H2D = new Remap_operator_bilinear("H2D_algorithm", 2, remap_grids);
         else if (words_are_the_same(cloned_remapping_setting->get_H2D_remapping_algorithm()->get_algorithm_name(), REMAP_OPERATOR_NAME_CONSERV_2D)) 
@@ -78,290 +78,327 @@ Runtime_remapping_weights::Runtime_remapping_weights(const char *src_comp_full_n
         else if (words_are_the_same(cloned_remapping_setting->get_H2D_remapping_algorithm()->get_algorithm_name(), REMAP_OPERATOR_NAME_DISTWGT))
             remap_operator_H2D = new Remap_operator_distwgt("H2D_algorithm", 2,  remap_grids);
         else EXECUTION_REPORT(REPORT_ERROR, -1, "Software error in Runtime_remapping_weights::Runtime_remapping_weights: wrong H2D algorithm");
-		for (int i = 0; i < cloned_remapping_setting->get_H2D_remapping_algorithm()->get_num_parameters(); i ++) {
-			cloned_remapping_setting->get_H2D_remapping_algorithm()->get_parameter(i, parameter_name, parameter_value);
-			remap_operator_H2D->set_parameter(parameter_name, parameter_value);
-		}
-		remap_operators[num_remap_operators++] = remap_operator_H2D;
-	}
-	if (src_original_grid->get_V1D_sub_CoR_grid() != NULL) {
-		remap_grids[0] = src_original_grid->get_V1D_sub_CoR_grid();
-		remap_grids[1] = dst_original_grid->get_V1D_sub_CoR_grid();
+        for (int i = 0; i < cloned_remapping_setting->get_H2D_remapping_algorithm()->get_num_parameters(); i ++) {
+            cloned_remapping_setting->get_H2D_remapping_algorithm()->get_parameter(i, parameter_name, parameter_value);
+            remap_operator_H2D->set_parameter(parameter_name, parameter_value);
+        }
+        remap_operators[num_remap_operators++] = remap_operator_H2D;
+    }
+    if (src_original_grid->get_V1D_sub_CoR_grid() != NULL) {
+        remap_grids[0] = src_original_grid->get_V1D_sub_CoR_grid();
+        remap_grids[1] = dst_original_grid->get_V1D_sub_CoR_grid();
         if (words_are_the_same(cloned_remapping_setting->get_V1D_remapping_algorithm()->get_algorithm_name(), REMAP_OPERATOR_NAME_LINEAR))
             remap_operator_V1D = new Remap_operator_linear("V1D_algorithm", 2, remap_grids);
         else if (words_are_the_same(cloned_remapping_setting->get_V1D_remapping_algorithm()->get_algorithm_name(), REMAP_OPERATOR_NAME_SPLINE_1D))
             remap_operator_V1D = new Remap_operator_spline_1D("V1D_algorithm", 2, remap_grids);
         else EXECUTION_REPORT(REPORT_ERROR, -1, "Software error in Runtime_remapping_weights::Runtime_remapping_weights: wrong V1D algorithm");
-		for (int i = 0; i < cloned_remapping_setting->get_V1D_remapping_algorithm()->get_num_parameters(); i ++) {
-			cloned_remapping_setting->get_V1D_remapping_algorithm()->get_parameter(i, parameter_name, parameter_value);
-			remap_operator_V1D->set_parameter(parameter_name, parameter_value);
-		}
-		remap_operators[num_remap_operators++] = remap_operator_V1D;
-	}
-	if (src_original_grid->get_T1D_sub_CoR_grid() != NULL) {
-		remap_grids[0] = src_original_grid->get_T1D_sub_CoR_grid();
-		remap_grids[1] = dst_original_grid->get_T1D_sub_CoR_grid();
+        for (int i = 0; i < cloned_remapping_setting->get_V1D_remapping_algorithm()->get_num_parameters(); i ++) {
+            cloned_remapping_setting->get_V1D_remapping_algorithm()->get_parameter(i, parameter_name, parameter_value);
+            remap_operator_V1D->set_parameter(parameter_name, parameter_value);
+        }
+        remap_operators[num_remap_operators++] = remap_operator_V1D;
+		if (!src_original_grid->get_original_CoR_grid()->is_sigma_grid() && !src_original_grid->get_original_CoR_grid()->does_use_V3D_level_coord())
+			EXECUTION_REPORT_ERROR_OPTIONALLY(REPORT_ERROR, dst_original_grid->get_comp_id(), src_original_grid->get_V1D_sub_CoR_grid()->get_super_grid_of_setting_coord_values() != NULL, "Error happens when generating remapping weights from the grid \"%s\" to \"%s\": the coordinate values of the vertical sub grid \"%s\" of the source grid has not been specified. Please verify.", src_original_grid->get_grid_name(), dst_original_grid->get_grid_name(), src_original_grid->get_V1D_sub_CoR_grid()->get_grid_name());
+		if (!dst_original_grid->get_original_CoR_grid()->is_sigma_grid() && !dst_original_grid->get_original_CoR_grid()->does_use_V3D_level_coord())
+			EXECUTION_REPORT_ERROR_OPTIONALLY(REPORT_ERROR, dst_original_grid->get_comp_id(), dst_original_grid->get_V1D_sub_CoR_grid()->get_super_grid_of_setting_coord_values() != NULL, "Error happens when generating remapping weights from the grid \"%s\" to \"%s\": the coordinate values of the vertical sub grid \"%s\" of the target grid has not been specified. Please verify.", src_original_grid->get_grid_name(), dst_original_grid->get_grid_name(), dst_original_grid->get_V1D_sub_CoR_grid()->get_grid_name());
+    }
+    if (src_original_grid->get_T1D_sub_CoR_grid() != NULL) {
+        remap_grids[0] = src_original_grid->get_T1D_sub_CoR_grid();
+        remap_grids[1] = dst_original_grid->get_T1D_sub_CoR_grid();
         if (words_are_the_same(cloned_remapping_setting->get_T1D_remapping_algorithm()->get_algorithm_name(), REMAP_OPERATOR_NAME_LINEAR))
             remap_operator_T1D = new Remap_operator_linear("T1D_algorithm", 2, remap_grids);
         else if (words_are_the_same(cloned_remapping_setting->get_T1D_remapping_algorithm()->get_algorithm_name(), REMAP_OPERATOR_NAME_SPLINE_1D))
             remap_operator_T1D = new Remap_operator_spline_1D("T1D_algorithm", 2, remap_grids);
-        else EXECUTION_REPORT(REPORT_ERROR, -1, "Software error in Runtime_remapping_weights::Runtime_remapping_weights: wrong T1D algorithm");		
-		for (int i = 0; i < cloned_remapping_setting->get_T1D_remapping_algorithm()->get_num_parameters(); i ++) {
-			cloned_remapping_setting->get_T1D_remapping_algorithm()->get_parameter(i, parameter_name, parameter_value);
-			remap_operator_T1D->set_parameter(parameter_name, parameter_value);
-		}
-		remap_operators[num_remap_operators++] = remap_operator_T1D;
-	}
-
-	execution_phase_number = 1;
-	EXECUTION_REPORT(REPORT_ERROR, -1, num_remap_operators > 0, "Software error in Runtime_remapping_weights::Runtime_remapping_weights: no remapping operator");
-	remapping_strategy = new Remap_strategy_class("runtime_remapping_strategy", num_remap_operators, remap_operators);
-	EXECUTION_REPORT_LOG(REPORT_LOG, dst_decomp_info->get_host_comp_id(), true, "before generating sequential_remapping_weights from original grid %s to %s", src_original_grid->get_grid_name(), dst_original_grid->get_grid_name());	
-	sprintf(remap_weight_name, "weights_%lx_%s(%s)_to_%s(%s)", remapping_setting->calculate_checksum(), src_original_grid->get_grid_name(), src_comp_full_name, dst_original_grid->get_grid_name(), dst_comp_full_name);
-	if (H2D_remapping_weight_file != NULL) {
-		EXECUTION_REPORT(REPORT_PROGRESS, dst_decomp_info->get_host_comp_id(), true, "The remapping weight file \"%s\" will be used for data remapping from the horizontal grid \"%s\" (of the component model \"%s\") to the horizontal grid \"%s\" (of the component model \"%s\").", H2D_remapping_weight_file->get_wgt_file_name(), src_original_grid->get_grid_name(), src_comp_full_name, dst_original_grid->get_grid_name(), dst_comp_full_name);
-		sequential_remapping_weights = new Remap_weight_of_strategy_class(remap_weight_name, remapping_strategy, src_original_grid->get_original_CoR_grid(), dst_original_grid->get_original_CoR_grid(), H2D_remapping_weight_file->get_wgt_file_name());
-		if (src_original_grid->is_H2D_grid()) 
-			set_H2D_grids_area(H2D_remapping_weight_file->get_src_area(), H2D_remapping_weight_file->get_dst_area(), src_original_grid->get_original_CoR_grid()->get_grid_size(), dst_original_grid->get_original_CoR_grid()->get_grid_size());
-		H2D_remapping_weight_file->clean();
-	}	
-	else {	
-		EXECUTION_REPORT(REPORT_PROGRESS, dst_decomp_info->get_host_comp_id(), true, "No remapping weight file has been specified for data remapping from the horizontal sub grid of \"%s\" (of the component model \"%s\") to the horizontal grid of \"%s\" (of the component model \"%s\"). So the remapping weights will be generated by C-Coupler", src_original_grid->get_grid_name(), src_comp_full_name, dst_original_grid->get_grid_name(), dst_comp_full_name);
-		EXECUTION_REPORT(REPORT_ERROR, -1, H2D_grid_decomp_mask == NULL, "Software error in Runtime_remapping_weights::Runtime_remapping_weights");
-		H2D_grid_decomp_mask = new bool [dst_decomp_info->get_num_global_cells()];
-		for (int i = 0; i < dst_decomp_info->get_num_global_cells(); i ++)
-			H2D_grid_decomp_mask[i] = false;
-		for (int i = 0; i < dst_decomp_info->get_num_local_cells(); i ++)
-			H2D_grid_decomp_mask[dst_decomp_info->get_local_cell_global_indx()[i]] = true;
-		sequential_remapping_weights = new Remap_weight_of_strategy_class(remap_weight_name, remapping_strategy, src_original_grid->get_original_CoR_grid(), dst_original_grid->get_original_CoR_grid(), NULL);
-		delete [] H2D_grid_decomp_mask;
-		H2D_grid_decomp_mask = NULL;
-		if (src_original_grid->is_H2D_grid() && src_original_grid->get_original_CoR_grid()->get_area_or_volumn() != NULL)
-			set_H2D_grids_area(src_original_grid->get_original_CoR_grid()->get_area_or_volumn(), src_original_grid->get_original_CoR_grid()->get_area_or_volumn(), src_original_grid->get_original_CoR_grid()->get_grid_size(), dst_original_grid->get_original_CoR_grid()->get_grid_size());
-	}	
-	EXECUTION_REPORT_LOG(REPORT_LOG, dst_decomp_info->get_host_comp_id(), true, "after generating sequential_remapping_weights from original grid %s to %s", src_original_grid->get_grid_name(), dst_original_grid->get_grid_name());	
-	execution_phase_number = 2;
-
-	if (dst_original_grid->get_H2D_sub_CoR_grid() == NULL || dst_decomp_info == NULL) {
-		EXECUTION_REPORT(REPORT_ERROR, -1, dst_original_grid->get_H2D_sub_CoR_grid() == NULL && dst_decomp_info == NULL, "Software error in Coupling_connection::generate_interpolation: conflict between grid and decomp");
-		parallel_remapping_weights = sequential_remapping_weights;
-	}	
-	else {
-		generate_parallel_remapping_weights();
-		delete sequential_remapping_weights;
-		sequential_remapping_weights = NULL;
-	}
+        else EXECUTION_REPORT(REPORT_ERROR, -1, "Software error in Runtime_remapping_weights::Runtime_remapping_weights: wrong T1D algorithm");        
+        for (int i = 0; i < cloned_remapping_setting->get_T1D_remapping_algorithm()->get_num_parameters(); i ++) {
+            cloned_remapping_setting->get_T1D_remapping_algorithm()->get_parameter(i, parameter_name, parameter_value);
+            remap_operator_T1D->set_parameter(parameter_name, parameter_value);
+        }
+        remap_operators[num_remap_operators++] = remap_operator_T1D;
+    }
+    execution_phase_number = 1;
+    EXECUTION_REPORT(REPORT_ERROR, -1, num_remap_operators > 0, "Software error in Runtime_remapping_weights::Runtime_remapping_weights: no remapping operator");
+    remapping_strategy = new Remap_strategy_class("runtime_remapping_strategy", num_remap_operators, remap_operators);
+    EXECUTION_REPORT_LOG(REPORT_LOG, dst_decomp_info->get_host_comp_id(), true, "before generating sequential_remapping_weights from original grid %s to %s", src_original_grid->get_grid_name(), dst_original_grid->get_grid_name());    
+    sprintf(remap_weight_name, "weights_%lx_%s(%s)_to_%s(%s)", remapping_setting->calculate_checksum(), src_original_grid->get_grid_name(), src_comp_full_name, dst_original_grid->get_grid_name(), dst_comp_full_name);
+    if (H2D_remapping_weight_file != NULL) {
+        EXECUTION_REPORT(REPORT_PROGRESS, dst_decomp_info->get_host_comp_id(), true, "The remapping weight file \"%s\" will be used for data remapping from the horizontal grid \"%s\" (of the component model \"%s\") to the horizontal grid \"%s\" (of the component model \"%s\").", H2D_remapping_weight_file->get_wgt_file_name(), src_original_grid->get_grid_name(), src_comp_full_name, dst_original_grid->get_grid_name(), dst_comp_full_name);
+        sequential_remapping_weights = new Remap_weight_of_strategy_class(remap_weight_name, remapping_strategy, src_original_grid->get_original_CoR_grid(), dst_original_grid->get_original_CoR_grid(), H2D_remapping_weight_file->get_wgt_file_name(), true, comp_comm_group_mgt_mgr->search_global_node(dst_comp_full_name)->get_comp_id());
+        if (src_original_grid->is_H2D_grid()) 
+            set_H2D_grids_area(H2D_remapping_weight_file->get_src_area(), H2D_remapping_weight_file->get_dst_area(), src_original_grid->get_original_CoR_grid()->get_grid_size(), dst_original_grid->get_original_CoR_grid()->get_grid_size());
+        H2D_remapping_weight_file->clean();
+    }    
+    else {    
+        EXECUTION_REPORT(REPORT_PROGRESS, dst_decomp_info->get_host_comp_id(), true, "No remapping weight file has been specified for data remapping from the horizontal sub grid of \"%s\" (of the component model \"%s\") to the horizontal sub grid of \"%s\" (of the component model \"%s\"). So the remapping weights will be generated by C-Coupler", src_original_grid->get_grid_name(), src_comp_full_name, dst_original_grid->get_grid_name(), dst_comp_full_name);
+        EXECUTION_REPORT(REPORT_ERROR, -1, H2D_grid_decomp_mask == NULL, "Software error in Runtime_remapping_weights::Runtime_remapping_weights");
+        H2D_grid_decomp_mask = new bool [dst_decomp_info->get_num_global_cells()];
+        for (int i = 0; i < dst_decomp_info->get_num_global_cells(); i ++)
+            H2D_grid_decomp_mask[i] = false;
+        for (int i = 0; i < dst_decomp_info->get_num_local_cells(); i ++)
+        	if (dst_decomp_info->get_local_cell_global_indx()[i] != CCPL_NULL_INT)
+                H2D_grid_decomp_mask[dst_decomp_info->get_local_cell_global_indx()[i]] = true;
+        sequential_remapping_weights = new Remap_weight_of_strategy_class(remap_weight_name, remapping_strategy, src_original_grid->get_original_CoR_grid(), dst_original_grid->get_original_CoR_grid(), NULL, true, comp_comm_group_mgt_mgr->search_global_node(dst_comp_full_name)->get_comp_id());
+        delete [] H2D_grid_decomp_mask;
+        H2D_grid_decomp_mask = NULL;
+        if (src_original_grid->is_H2D_grid() && src_original_grid->get_original_CoR_grid()->get_area_or_volumn() != NULL)
+            set_H2D_grids_area(src_original_grid->get_original_CoR_grid()->get_area_or_volumn(), src_original_grid->get_original_CoR_grid()->get_area_or_volumn(), src_original_grid->get_original_CoR_grid()->get_grid_size(), dst_original_grid->get_original_CoR_grid()->get_grid_size());
+		sequential_remapping_weights->write_overall_H2D_remapping_weights(comp_comm_group_mgt_mgr->search_global_node(dst_comp_full_name)->get_comp_id());
+    }    
+    EXECUTION_REPORT_LOG(REPORT_LOG, dst_decomp_info->get_host_comp_id(), true, "after generating sequential_remapping_weights from original grid %s to %s", src_original_grid->get_grid_name(), dst_original_grid->get_grid_name());    
+    execution_phase_number = 2;
+
+    if (dst_original_grid->get_H2D_sub_CoR_grid() == NULL || dst_decomp_info == NULL) {
+        EXECUTION_REPORT(REPORT_ERROR, -1, dst_original_grid->get_H2D_sub_CoR_grid() == NULL && dst_decomp_info == NULL, "Software error in Coupling_connection::generate_interpolation: conflict between grid and decomp");
+        parallel_remapping_weights = sequential_remapping_weights;
+    }    
+    else {
+        generate_parallel_remapping_weights();
+        delete sequential_remapping_weights;
+        sequential_remapping_weights = NULL;
+    }
 }
 
 
 Runtime_remapping_weights::~Runtime_remapping_weights()
 {
-	if (src_comp_full_name != NULL)
-		delete [] src_comp_full_name;
-	if (dst_comp_full_name != NULL)
-		delete [] dst_comp_full_name;
-	if (remapping_setting != NULL)
-		delete remapping_setting;
-	if (remapping_strategy != NULL)
-		delete remapping_strategy;
-	if (parallel_remapping_weights != NULL)
-		delete parallel_remapping_weights;
-	if (runtime_V1D_remap_grid_src != NULL)
-		delete runtime_V1D_remap_grid_src;
-	if (runtime_V1D_remap_grid_dst != NULL)
-		delete runtime_V1D_remap_grid_dst;
-	if (src_H2D_grid_area != NULL)
-		delete [] src_H2D_grid_area;
-	if (dst_H2D_grid_area != NULL)
-		delete [] dst_H2D_grid_area;
+    if (src_comp_full_name != NULL)
+        delete [] src_comp_full_name;
+    if (dst_comp_full_name != NULL)
+        delete [] dst_comp_full_name;
+    if (remapping_setting != NULL)
+        delete remapping_setting;
+    if (remapping_strategy != NULL)
+        delete remapping_strategy;
+    if (parallel_remapping_weights != NULL)
+        delete parallel_remapping_weights;
+    if (runtime_V1D_remap_grid_src != NULL)
+        delete runtime_V1D_remap_grid_src;
+    if (runtime_V1D_remap_grid_dst != NULL)
+        delete runtime_V1D_remap_grid_dst;
+    if (src_H2D_grid_area != NULL)
+        delete [] src_H2D_grid_area;
+    if (dst_H2D_grid_area != NULL)
+        delete [] dst_H2D_grid_area;
 }
 
 
 Field_mem_info *Runtime_remapping_weights::allocate_intermediate_V3D_grid_bottom_field()
 {
-	if (intermediate_V3D_grid_bottom_field == NULL)
-		intermediate_V3D_grid_bottom_field = memory_manager->alloc_mem("V3D_grid_bottom_field", dst_decomp_info->get_decomp_id(), decomps_info_mgr->get_decomp_info(dst_decomp_info->get_decomp_id())->get_grid_id(), -dst_original_grid->get_grid_id(), DATA_TYPE_DOUBLE, "unitless", "Runtime_remapping_weights::allocate_intermediate_V3D_grid_bottom_field", false);
-	return intermediate_V3D_grid_bottom_field;
+    if (intermediate_V3D_grid_bottom_field == NULL) {	
+		if (src_original_grid->get_original_CoR_grid()->is_sigma_grid())
+	        intermediate_V3D_grid_bottom_field = memory_manager->alloc_mem("V3D_grid_bottom_field", dst_decomp_info->get_decomp_id(), decomps_info_mgr->get_decomp_info(dst_decomp_info->get_decomp_id())->get_grid_id(), -dst_original_grid->get_grid_id(), DATA_TYPE_DOUBLE, "unitless", "Runtime_remapping_weights::allocate_intermediate_V3D_grid_bottom_field", false);
+		else if (src_original_grid->get_original_CoR_grid()->does_use_V3D_level_coord()) {
+			Remap_grid_class *full_original_grid = decomp_grids_mgr->search_decomp_grid_original_grid(dst_decomp_info->get_decomp_id(), get_parallel_remapping_weights()->get_dynamic_V1D_remap_weight_of_operator()->get_field_data_grid_src());
+			EXECUTION_REPORT_ERROR_OPTIONALLY(REPORT_ERROR, -1, full_original_grid->does_use_V3D_level_coord(), "Software error in Runtime_remapping_weights::allocate_intermediate_V3D_grid_bottom_field");
+			int grid_id = original_grid_mgr->search_or_register_internal_grid(dst_decomp_info->get_comp_id(), full_original_grid)->get_grid_id();
+			intermediate_V3D_grid_bottom_field = memory_manager->alloc_mem(V3D_GRID_3D_LEVEL_FIELD_NAME, dst_decomp_info->get_decomp_id(), grid_id, -grid_id, DATA_TYPE_DOUBLE, "unitless", "Runtime_remapping_weights::allocate_intermediate_V3D_grid_bottom_field", false);
+		}
+		else EXECUTION_REPORT_ERROR_OPTIONALLY(REPORT_ERROR, -1, true, "Software error in Runtime_remapping_weights::allocate_intermediate_V3D_grid_bottom_field");
+    }
+    return intermediate_V3D_grid_bottom_field;
 }
 
 
 bool Runtime_remapping_weights::match_requirements(const char *src_comp_full_name, const char *dst_comp_full_name, Original_grid_info *src_original_grid, Original_grid_info *dst_original_grid, Remapping_setting *remapping_setting, Decomp_info *dst_decomp_info)
 {
-	return words_are_the_same(this->src_comp_full_name,src_comp_full_name)&& words_are_the_same(this->dst_comp_full_name, dst_comp_full_name) && 
-		   this->src_original_grid == src_original_grid && this->dst_original_grid == dst_original_grid && 
-		   this->remapping_setting->is_the_same_as_another(remapping_setting) && this->dst_decomp_info == dst_decomp_info;
+    return words_are_the_same(this->src_comp_full_name,src_comp_full_name)&& words_are_the_same(this->dst_comp_full_name, dst_comp_full_name) && 
+           this->src_original_grid == src_original_grid && this->dst_original_grid == dst_original_grid && 
+           this->remapping_setting->is_the_same_as_another(remapping_setting) && this->dst_decomp_info == dst_decomp_info;
 }
 
 
 void Runtime_remapping_weights::generate_parallel_remapping_weights()
 {
-    Remap_grid_class **remap_related_grids, **remap_related_decomp_grids;
+    Remap_grid_class **remap_related_decomp_grids;
+	std::vector<std::pair<Remap_grid_class *, bool> > remap_related_grids;
     Remap_grid_class *decomp_original_grids[256];
-    int num_remap_related_grids;
     int *global_cells_local_indexes_in_decomps[256];
     int i, j;
 
 
     EXECUTION_REPORT(REPORT_ERROR,-1, sequential_remapping_weights != NULL, "C-Coupler software error remap weights is not found\n");
     cpl_check_remap_weights_format(sequential_remapping_weights);
-	EXECUTION_REPORT(REPORT_ERROR,-1, src_original_grid->get_H2D_sub_CoR_grid()->is_subset_of_grid(sequential_remapping_weights->get_data_grid_src()) && dst_original_grid->get_H2D_sub_CoR_grid()->is_subset_of_grid(sequential_remapping_weights->get_data_grid_dst()),
-	                 "Software error in Runtime_remapping_weights::generate_parallel_remapping_weights: grid inconsistency");
+    EXECUTION_REPORT(REPORT_ERROR,-1, src_original_grid->get_H2D_sub_CoR_grid()->is_subset_of_grid(sequential_remapping_weights->get_data_grid_src()) && dst_original_grid->get_H2D_sub_CoR_grid()->is_subset_of_grid(sequential_remapping_weights->get_data_grid_dst()),
+                     "Software error in Runtime_remapping_weights::generate_parallel_remapping_weights: grid inconsistency");
 
-	EXECUTION_REPORT_LOG(REPORT_LOG, dst_decomp_info->get_comp_id(), true, "before generating remap_weights_src_decomp");
-	src_decomp_info = decomps_info_mgr->generate_remap_weights_src_decomp(dst_decomp_info, src_original_grid, dst_original_grid, sequential_remapping_weights);
-	EXECUTION_REPORT_LOG(REPORT_LOG, dst_decomp_info->get_comp_id(), true, "after generating remap_weights_src_decomp");
-	EXECUTION_REPORT_LOG(REPORT_LOG, dst_decomp_info->get_comp_id(), true, "before generating parallel remap weights for runtime_remap_algorithm");
-	if (src_decomp_info->get_num_local_cells() == 0)
-		return;
+    EXECUTION_REPORT_LOG(REPORT_LOG, dst_decomp_info->get_comp_id(), true, "before generating remap_weights_src_decomp");
+    src_decomp_info = decomps_info_mgr->generate_remap_weights_src_decomp(dst_decomp_info, src_original_grid, dst_original_grid, sequential_remapping_weights);
+    EXECUTION_REPORT_LOG(REPORT_LOG, dst_decomp_info->get_comp_id(), true, "after generating remap_weights_src_decomp");
+    EXECUTION_REPORT_LOG(REPORT_LOG, dst_decomp_info->get_comp_id(), true, "before generating parallel remap weights for runtime_remap_algorithm");
+    if (src_decomp_info->get_num_local_cells() == 0)
+        return;
 
     decomp_original_grids[0] = src_original_grid->get_H2D_sub_CoR_grid();
     decomp_original_grids[1] = dst_original_grid->get_H2D_sub_CoR_grid();
-    remap_related_grids = sequential_remapping_weights->get_remap_related_grids(num_remap_related_grids);
-    remap_related_decomp_grids = new Remap_grid_class *[num_remap_related_grids];
-
-    for (i = 0; i < num_remap_related_grids; i ++) {
-        j = 0;
-		remap_related_decomp_grids[i] = remap_related_grids[i];
-        if (decomp_original_grids[0]->is_subset_of_grid(remap_related_grids[i])) {
-            remap_related_decomp_grids[i] = decomp_grids_mgr->search_decomp_grid_info(src_decomp_info->get_decomp_id(), remap_related_grids[i], false)->get_decomp_grid();
-            j ++;
-        }
-        if (decomp_original_grids[1]->is_subset_of_grid(remap_related_grids[i])) {
-			remap_related_decomp_grids[i] = decomp_grids_mgr->search_decomp_grid_info(dst_decomp_info->get_decomp_id(), remap_related_grids[i], false)->get_decomp_grid();
-            j ++;
-        }
-		EXECUTION_REPORT(REPORT_ERROR, -1, j <= 1, "Software error in Runtime_remapping_weights::generate_parallel_remapping_weights: wrong j");
+
+	sequential_remapping_weights->get_remap_related_grids(remap_related_grids);
+	remap_related_decomp_grids = new Remap_grid_class *[remap_related_grids.size()];
+    for (i = 0; i < remap_related_grids.size(); i ++) {
+        remap_related_decomp_grids[i] = remap_related_grids[i].first;
+		if (!(remap_related_decomp_grids[i]->has_grid_coord_label(COORD_LABEL_LON) || remap_related_decomp_grids[i]->has_grid_coord_label(COORD_LABEL_LAT)))
+			continue;
+		if (!remap_related_grids[i].second) {
+				EXECUTION_REPORT_ERROR_OPTIONALLY(REPORT_ERROR, -1, decomp_original_grids[0]->is_subset_of_grid(remap_related_grids[i].first),  "Software error in Runtime_remapping_weights::generate_parallel_remapping_weights");
+            remap_related_decomp_grids[i] = decomp_grids_mgr->search_decomp_grid_info(src_decomp_info->get_decomp_id(), remap_related_grids[i].first, false)->get_decomp_grid();
+		}
+		else {
+			if (remap_related_decomp_grids[i]->has_grid_coord_label(COORD_LABEL_LON) || remap_related_decomp_grids[i]->has_grid_coord_label(COORD_LABEL_LAT))
+				EXECUTION_REPORT_ERROR_OPTIONALLY(REPORT_ERROR, -1, decomp_original_grids[1]->is_subset_of_grid(remap_related_grids[i].first), "Software error in Runtime_remapping_weights::generate_parallel_remapping_weights");
+            remap_related_decomp_grids[i] = decomp_grids_mgr->search_decomp_grid_info(dst_decomp_info->get_decomp_id(), remap_related_grids[i].first, false)->get_decomp_grid();
+		}
     }
 
     global_cells_local_indexes_in_decomps[0] = new int [decomp_original_grids[0]->get_grid_size()];
     global_cells_local_indexes_in_decomps[1] = new int [decomp_original_grids[1]->get_grid_size()];
-	for (j = 0; j < decomp_original_grids[0]->get_grid_size(); j ++)
-		global_cells_local_indexes_in_decomps[0][j] = -1;
-	for (j = 0; j < src_decomp_info->get_num_local_cells(); j ++)
-		if (src_decomp_info->get_local_cell_global_indx()[j] >= 0)
-			global_cells_local_indexes_in_decomps[0][src_decomp_info->get_local_cell_global_indx()[j]] = j;
-	for (j = 0; j < decomp_original_grids[1]->get_grid_size(); j ++)
-		global_cells_local_indexes_in_decomps[1][j] = -1;
-	for (j = 0; j < dst_decomp_info->get_num_local_cells(); j ++)
-		if (dst_decomp_info->get_local_cell_global_indx()[j] >= 0)
-			global_cells_local_indexes_in_decomps[1][dst_decomp_info->get_local_cell_global_indx()[j]] = j;  
-	parallel_remapping_weights = sequential_remapping_weights->generate_parallel_remap_weights(remap_related_decomp_grids, decomp_original_grids, global_cells_local_indexes_in_decomps);
-	dynamic_V1D_remap_weight_of_operator = parallel_remapping_weights->get_dynamic_V1D_remap_weight_of_operator();
-	if (dynamic_V1D_remap_weight_of_operator != NULL) {
-		runtime_V1D_remap_grid_src = dynamic_V1D_remap_weight_of_operator->get_field_data_grid_src()->generate_remap_operator_runtime_grid(dynamic_V1D_remap_weight_of_operator->get_original_remap_operator()->get_src_grid(),	dynamic_V1D_remap_weight_of_operator->get_original_remap_operator(), NULL);
-		runtime_V1D_remap_grid_dst = dynamic_V1D_remap_weight_of_operator->get_field_data_grid_dst()->generate_remap_operator_runtime_grid(dynamic_V1D_remap_weight_of_operator->get_original_remap_operator()->get_dst_grid(),	dynamic_V1D_remap_weight_of_operator->get_original_remap_operator(), NULL);
-	}
+    for (j = 0; j < decomp_original_grids[0]->get_grid_size(); j ++)
+        global_cells_local_indexes_in_decomps[0][j] = -1;
+    for (j = 0; j < src_decomp_info->get_num_local_cells(); j ++)
+        if (src_decomp_info->get_local_cell_global_indx()[j] != CCPL_NULL_INT)
+            global_cells_local_indexes_in_decomps[0][src_decomp_info->get_local_cell_global_indx()[j]] = j;
+    for (j = 0; j < decomp_original_grids[1]->get_grid_size(); j ++)
+        global_cells_local_indexes_in_decomps[1][j] = -1;
+    for (j = 0; j < dst_decomp_info->get_num_local_cells(); j ++)
+        if (dst_decomp_info->get_local_cell_global_indx()[j] != CCPL_NULL_INT)
+            global_cells_local_indexes_in_decomps[1][dst_decomp_info->get_local_cell_global_indx()[j]] = j;  
+    parallel_remapping_weights = sequential_remapping_weights->generate_parallel_remap_weights(remap_related_decomp_grids, decomp_original_grids, global_cells_local_indexes_in_decomps);
+    dynamic_V1D_remap_weight_of_operator = parallel_remapping_weights->get_dynamic_V1D_remap_weight_of_operator();
+    if (dynamic_V1D_remap_weight_of_operator != NULL) {
+        runtime_V1D_remap_grid_src = dynamic_V1D_remap_weight_of_operator->get_field_data_grid_src()->generate_remap_operator_runtime_grid(dynamic_V1D_remap_weight_of_operator->get_original_remap_operator()->get_src_grid(), dynamic_V1D_remap_weight_of_operator->get_original_remap_operator(), NULL);
+        runtime_V1D_remap_grid_dst = dynamic_V1D_remap_weight_of_operator->get_field_data_grid_dst()->generate_remap_operator_runtime_grid(dynamic_V1D_remap_weight_of_operator->get_original_remap_operator()->get_dst_grid(), dynamic_V1D_remap_weight_of_operator->get_original_remap_operator(), NULL);
+    }
 
-	if (dynamic_V1D_remap_weight_of_operator != NULL && get_dst_original_grid()->get_bottom_field_variation_type() != BOTTOM_FIELD_VARIATION_EXTERNAL && get_dst_original_grid()->get_bottom_field_variation_type() != BOTTOM_FIELD_VARIATION_UNSET) {
-		if (dynamic_V1D_remap_weight_of_operator->get_field_data_grid_dst()->get_sigma_grid_dynamic_surface_value_field() != NULL)
-			EXECUTION_REPORT(REPORT_ERROR, -1, dynamic_V1D_remap_weight_of_operator->get_field_data_grid_dst()->get_sigma_grid_dynamic_surface_value_field() == memory_manager->get_field_instance(get_dst_original_grid()->get_bottom_field_id())->get_field_data(), "Software error in Coupling_connection::add_bottom_field_coupling_info: the surface field of the same grid has been set to different data fields");
-		else dynamic_V1D_remap_weight_of_operator->get_field_data_grid_dst()->set_sigma_grid_dynamic_surface_value_field(memory_manager->get_field_instance(get_dst_original_grid()->get_bottom_field_id())->get_field_data());
+    if (dynamic_V1D_remap_weight_of_operator != NULL && get_dst_original_grid()->get_bottom_field_variation_type() != BOTTOM_FIELD_VARIATION_EXTERNAL && get_dst_original_grid()->get_bottom_field_variation_type() != BOTTOM_FIELD_VARIATION_UNSET) {
+        if (dynamic_V1D_remap_weight_of_operator->get_field_data_grid_dst()->get_level_V3D_coord_dynamic_trigger_field() != NULL)
+            EXECUTION_REPORT(REPORT_ERROR, -1, dynamic_V1D_remap_weight_of_operator->get_field_data_grid_dst()->get_level_V3D_coord_dynamic_trigger_field() == memory_manager->get_field_instance(get_dst_original_grid()->get_bottom_field_id())->get_field_data(), "Software error in Coupling_connection::add_bottom_field_coupling_info: the surface field of the same grid has been set to different data fields");
+        else dynamic_V1D_remap_weight_of_operator->get_field_data_grid_dst()->set_level_V3D_coord_dynamic_trigger_field(memory_manager->get_field_instance(get_dst_original_grid()->get_bottom_field_id())->get_field_data());
+    }
+	if (dynamic_V1D_remap_weight_of_operator != NULL && get_dst_original_grid()->get_V3D_lev_field_variation_type() != BOTTOM_FIELD_VARIATION_UNSET) {
+        if (dynamic_V1D_remap_weight_of_operator->get_field_data_grid_dst()->get_level_V3D_coord_dynamic_trigger_field() != NULL)
+            EXECUTION_REPORT(REPORT_ERROR, -1, dynamic_V1D_remap_weight_of_operator->get_field_data_grid_dst()->get_level_V3D_coord_dynamic_trigger_field() == memory_manager->get_field_instance(get_dst_original_grid()->get_V3D_lev_field_id())->get_field_data(), "Software error in Coupling_connection::add_bottom_field_coupling_info: the V3D field of the same grid has been set to different data fields");
+        else dynamic_V1D_remap_weight_of_operator->get_field_data_grid_dst()->set_level_V3D_coord_dynamic_trigger_field(memory_manager->get_field_instance(get_dst_original_grid()->get_V3D_lev_field_id())->get_field_data());
 	}
-	
-	EXECUTION_REPORT_LOG(REPORT_LOG, dst_decomp_info->get_comp_id(), true, "after generating parallel remap weights for runtime_remap_algorithm");
+    
+    EXECUTION_REPORT_LOG(REPORT_LOG, dst_decomp_info->get_comp_id(), true, "after generating parallel remap weights for runtime_remap_algorithm");
 
-	delete [] remap_related_decomp_grids;
-	delete [] remap_related_grids;
-	delete [] global_cells_local_indexes_in_decomps[0];
-	delete [] global_cells_local_indexes_in_decomps[1];
+    delete [] remap_related_decomp_grids;
+    remap_related_grids.clear();
+    delete [] global_cells_local_indexes_in_decomps[0];
+    delete [] global_cells_local_indexes_in_decomps[1];
 }
 
 
 void Runtime_remapping_weights::set_H2D_grids_area(const double *src_area, const double *dst_area, long src_grid_size, long dst_grid_size)
 {
-	EXECUTION_REPORT(REPORT_ERROR, -1, src_area != NULL && dst_area != NULL, "Software error in Runtime_remapping_weights::set_H2D_grids_area");
-	src_H2D_grid_area = new double [src_grid_size];
-	dst_H2D_grid_area = new double [dst_grid_size];
-	memcpy(src_H2D_grid_area, src_area, src_grid_size*sizeof(double));
-	memcpy(dst_H2D_grid_area, dst_area, dst_grid_size*sizeof(double));
-	size_src_H2D_grid_area = src_grid_size;
-	size_dst_H2D_grid_area = dst_grid_size;
+	if (src_area != NULL) {
+	    src_H2D_grid_area = new double [src_grid_size];
+    	memcpy(src_H2D_grid_area, src_area, src_grid_size*sizeof(double));
+	    size_src_H2D_grid_area = src_grid_size;
+	}
+	if (dst_area != NULL) {
+    	dst_H2D_grid_area = new double [dst_grid_size];
+	    memcpy(dst_H2D_grid_area, dst_area, dst_grid_size*sizeof(double));
+	    size_dst_H2D_grid_area = dst_grid_size;
+	}
 }
 
 
 void Runtime_remapping_weights::renew_dynamic_V1D_remapping_weights()
 {
-	bool src_bottom_value_updated = false, dst_bottom_value_updated = false;
-	bool src_bottom_value_specified = false, dst_bottom_value_specified = false;
-
-	
-	if (dynamic_V1D_remap_weight_of_operator == NULL)
-		return;
-
-	if (dynamic_V1D_remap_weight_of_operator->get_field_data_grid_src()->is_sigma_grid()) {
-		src_bottom_value_specified = dynamic_V1D_remap_weight_of_operator->get_field_data_grid_src()->is_sigma_grid_surface_value_field_specified();
-		src_bottom_value_updated = dynamic_V1D_remap_weight_of_operator->get_field_data_grid_src()->is_sigma_grid_surface_value_field_updated();
-		if (src_original_grid->get_bottom_field_variation_type() == BOTTOM_FIELD_VARIATION_STATIC)
-			EXECUTION_REPORT(REPORT_ERROR, src_original_grid->get_comp_id(), !src_bottom_value_updated || !src_bottom_value_specified, "the surface field of the 3-D grid \"%s\" (registered in the component \"%s\") is updated while the surface field has been specified as a static one. Please verify", src_original_grid->get_grid_name(), comp_comm_group_mgt_mgr->get_global_node_of_local_comp(src_original_grid->get_comp_id(),false,"in Runtime_remapping_weights::renew_dynamic_V1D_remapping_weights")->get_full_name());
-	}
-	if (dynamic_V1D_remap_weight_of_operator->get_field_data_grid_dst()->is_sigma_grid()) {
-		dst_bottom_value_specified = dynamic_V1D_remap_weight_of_operator->get_field_data_grid_dst()->is_sigma_grid_surface_value_field_specified();
-		dst_bottom_value_updated = dynamic_V1D_remap_weight_of_operator->get_field_data_grid_dst()->is_sigma_grid_surface_value_field_updated();
-		if (dst_original_grid->get_bottom_field_variation_type() == BOTTOM_FIELD_VARIATION_STATIC)
-			EXECUTION_REPORT(REPORT_ERROR, dst_original_grid->get_comp_id(), !dst_bottom_value_updated || !dst_bottom_value_specified, "the surface field of the 3-D grid \"%s\" is updated while the surface field has been specified as a static one. Please verify", dst_original_grid->get_grid_name());
-	}
-
-	if (src_bottom_value_updated)
-		dynamic_V1D_remap_weight_of_operator->get_field_data_grid_src()->calculate_lev_sigma_values();
-	if (dst_bottom_value_updated)
-		dynamic_V1D_remap_weight_of_operator->get_field_data_grid_dst()->calculate_lev_sigma_values();
+    bool src_bottom_value_updated = false, dst_bottom_value_updated = false;
+    bool src_bottom_value_specified = false, dst_bottom_value_specified = false;
+
+    
+    if (dynamic_V1D_remap_weight_of_operator == NULL)
+        return;
+
+    if (dynamic_V1D_remap_weight_of_operator->get_field_data_grid_src()->is_sigma_grid() || dynamic_V1D_remap_weight_of_operator->get_field_data_grid_src()->does_use_V3D_level_coord()) {
+        src_bottom_value_specified = dynamic_V1D_remap_weight_of_operator->get_field_data_grid_src()->is_level_V3D_coord_trigger_field_specified();
+        src_bottom_value_updated = dynamic_V1D_remap_weight_of_operator->get_field_data_grid_src()->is_level_V3D_coord_trigger_field_updated();
+        if (src_original_grid->get_bottom_field_variation_type() == BOTTOM_FIELD_VARIATION_STATIC)
+            EXECUTION_REPORT(REPORT_WARNING, src_original_grid->get_comp_id(), !src_bottom_value_updated || !src_bottom_value_specified, "the surface field of the 3-D grid \"%s\" (registered in the component \"%s\") is updated while the surface field has been specified as a static one. Please check.", src_original_grid->get_grid_name(), src_original_grid->get_comp_full_name());
+        if (src_original_grid->get_V3D_lev_field_variation_type() == BOTTOM_FIELD_VARIATION_STATIC)
+            EXECUTION_REPORT(REPORT_WARNING, src_original_grid->get_comp_id(), !src_bottom_value_updated || !src_bottom_value_specified, "the 3-D level field of the 3-D grid \"%s\" (registered in the component \"%s\") is updated while the 3-D level field has been specified as a static one. Please check.", src_original_grid->get_grid_name(), src_original_grid->get_comp_full_name());
+    }
+    if (dynamic_V1D_remap_weight_of_operator->get_field_data_grid_dst()->is_sigma_grid() || dynamic_V1D_remap_weight_of_operator->get_field_data_grid_dst()->does_use_V3D_level_coord()) {
+        dst_bottom_value_specified = dynamic_V1D_remap_weight_of_operator->get_field_data_grid_dst()->is_level_V3D_coord_trigger_field_specified();
+        dst_bottom_value_updated = dynamic_V1D_remap_weight_of_operator->get_field_data_grid_dst()->is_level_V3D_coord_trigger_field_updated();
+        if (dst_original_grid->get_bottom_field_variation_type() == BOTTOM_FIELD_VARIATION_STATIC)
+            EXECUTION_REPORT(REPORT_ERROR, dst_original_grid->get_comp_id(), !dst_bottom_value_updated || !dst_bottom_value_specified, "the surface field of the 3-D grid \"%s\" is updated while the surface field has been specified as a static one. Please verify", dst_original_grid->get_grid_name());
+        if (dst_original_grid->get_V3D_lev_field_variation_type() == BOTTOM_FIELD_VARIATION_STATIC)
+            EXECUTION_REPORT(REPORT_ERROR, dst_original_grid->get_comp_id(), !dst_bottom_value_updated || !dst_bottom_value_specified, "the 3-D level field of the 3-D grid \"%s\" (registered in the component \"%s\") is updated while the 3-D level field has been specified as a static one. Please verify", dst_original_grid->get_grid_name(), dst_original_grid->get_comp_full_name());
+    }
 
-	if (src_bottom_value_updated || dst_bottom_value_updated)
-		dynamic_V1D_remap_weight_of_operator->renew_vertical_remap_weights(runtime_V1D_remap_grid_src, runtime_V1D_remap_grid_dst);
+	comp_comm_group_mgt_mgr->get_global_node_of_local_comp(dst_original_grid->get_comp_id(),false,"")->get_performance_timing_mgr()->performance_timing_start(TIMING_TYPE_COMPUTATION, -1, -1, "vertical coord update");
+    if (src_bottom_value_updated)
+		if (dynamic_V1D_remap_weight_of_operator->get_field_data_grid_src()->is_sigma_grid())
+	        dynamic_V1D_remap_weight_of_operator->get_field_data_grid_src()->calculate_lev_sigma_values();
+		else dynamic_V1D_remap_weight_of_operator->get_field_data_grid_src()->update_grid_center_3D_level_field_from_external();
+    if (dst_bottom_value_updated)
+		if (dynamic_V1D_remap_weight_of_operator->get_field_data_grid_dst()->is_sigma_grid())
+	        dynamic_V1D_remap_weight_of_operator->get_field_data_grid_dst()->calculate_lev_sigma_values();
+		else dynamic_V1D_remap_weight_of_operator->get_field_data_grid_dst()->update_grid_center_3D_level_field_from_external();
+	comp_comm_group_mgt_mgr->get_global_node_of_local_comp(dst_original_grid->get_comp_id(),false,"")->get_performance_timing_mgr()->performance_timing_stop(TIMING_TYPE_COMPUTATION, -1, -1, "vertical coord update");
+
+	comp_comm_group_mgt_mgr->get_global_node_of_local_comp(dst_original_grid->get_comp_id(),false,"")->get_performance_timing_mgr()->performance_timing_start(TIMING_TYPE_COMPUTATION, -1, -1, "dyn v1d wgt");
+    if (src_bottom_value_updated || dst_bottom_value_updated)
+        dynamic_V1D_remap_weight_of_operator->renew_vertical_remap_weights(runtime_V1D_remap_grid_src, runtime_V1D_remap_grid_dst);
+	comp_comm_group_mgt_mgr->get_global_node_of_local_comp(dst_original_grid->get_comp_id(),false,"")->get_performance_timing_mgr()->performance_timing_stop(TIMING_TYPE_COMPUTATION, -1, -1, "dyn v1d wgt");
 }
 
 
 Runtime_remapping_weights_mgt::~Runtime_remapping_weights_mgt()
 {
-	for (int i = 0; i < runtime_remapping_weights.size(); i ++)
-		delete runtime_remapping_weights[i];
+    for (int i = 0; i < runtime_remapping_weights.size(); i ++)
+        delete runtime_remapping_weights[i];
 }
 
 
 Runtime_remapping_weights *Runtime_remapping_weights_mgt::search_or_generate_runtime_remapping_weights(const char *src_comp_full_name, const char *dst_comp_full_name, Original_grid_info *src_original_grid, Original_grid_info *dst_original_grid, Remapping_setting *remapping_setting, Decomp_info *dst_decomp_info)
 {
-	remapping_setting->shrink(src_original_grid, dst_original_grid);
-	
-	for (int i = 0; i < runtime_remapping_weights.size(); i ++)
-		if (runtime_remapping_weights[i]->match_requirements(src_comp_full_name, dst_comp_full_name, src_original_grid, dst_original_grid, remapping_setting, dst_decomp_info))
-			return runtime_remapping_weights[i];
-
-	runtime_remapping_weights.push_back(new Runtime_remapping_weights(src_comp_full_name, dst_comp_full_name, src_original_grid, dst_original_grid, remapping_setting, dst_decomp_info));
-	return runtime_remapping_weights[runtime_remapping_weights.size()-1];
+    remapping_setting->shrink(src_original_grid, dst_original_grid);
+    
+    for (int i = 0; i < runtime_remapping_weights.size(); i ++)
+        if (runtime_remapping_weights[i]->match_requirements(src_comp_full_name, dst_comp_full_name, src_original_grid, dst_original_grid, remapping_setting, dst_decomp_info))
+            return runtime_remapping_weights[i];
+
+    runtime_remapping_weights.push_back(new Runtime_remapping_weights(src_comp_full_name, dst_comp_full_name, src_original_grid, dst_original_grid, remapping_setting, dst_decomp_info));
+    return runtime_remapping_weights[runtime_remapping_weights.size()-1];
 }
 
 
 void Runtime_remapping_weights_mgt::transfer_runtime_remapping_weights(Runtime_remapping_weights *remapping_weights_from, Runtime_remapping_weights **remapping_weights_to, Comp_comm_group_mgt_node *comp_node_from, Comp_comm_group_mgt_node *comp_node_to)
 {
-	double *temp_src_H2D_grid_area = NULL, *temp_dst_H2D_grid_area = NULL;
-	long temp_src_H2D_grid_size = 0, temp_dst_H2D_grid_size = 0;
-
-
-	if (comp_node_from->get_current_proc_local_id() != -1) {
-		if (remapping_weights_from->get_src_H2D_grid_area() != NULL) {
-			temp_src_H2D_grid_size = remapping_weights_from->get_src_original_grid()->get_original_CoR_grid()->get_grid_size()*sizeof(double);
-			temp_dst_H2D_grid_size = remapping_weights_from->get_dst_original_grid()->get_original_CoR_grid()->get_grid_size()*sizeof(double);
-			temp_src_H2D_grid_area = new double [remapping_weights_from->get_src_original_grid()->get_original_CoR_grid()->get_grid_size()];
-			temp_dst_H2D_grid_area = new double [remapping_weights_from->get_dst_original_grid()->get_original_CoR_grid()->get_grid_size()];
-			memcpy(temp_src_H2D_grid_area, remapping_weights_from->get_src_H2D_grid_area(), temp_src_H2D_grid_size);
-			memcpy(temp_dst_H2D_grid_area, remapping_weights_from->get_dst_H2D_grid_area(), temp_dst_H2D_grid_size);
-		}
-	}
-	transfer_array_from_one_comp_to_another(comp_node_from->get_current_proc_local_id(), comp_node_from->get_local_proc_global_id(0), comp_node_to->get_current_proc_local_id(), comp_node_to->get_local_proc_global_id(0), comp_node_to->get_comm_group(), (char**)(&temp_src_H2D_grid_area), temp_src_H2D_grid_size);
-	transfer_array_from_one_comp_to_another(comp_node_from->get_current_proc_local_id(), comp_node_from->get_local_proc_global_id(0), comp_node_to->get_current_proc_local_id(), comp_node_to->get_local_proc_global_id(0), comp_node_to->get_comm_group(), (char**)(&temp_dst_H2D_grid_area), temp_dst_H2D_grid_size);
-	
-	if (comp_node_to->get_current_proc_local_id() != -1) {
-		EXECUTION_REPORT(REPORT_ERROR, -1, *remapping_weights_to == NULL, "Software error in Runtime_remapping_weights_mgt::transfer_runtime_remapping_weights");
-		*remapping_weights_to = new Runtime_remapping_weights();
-		if (temp_src_H2D_grid_size != 0)
-			(*remapping_weights_to)->set_H2D_grids_area(temp_src_H2D_grid_area, temp_dst_H2D_grid_area, temp_src_H2D_grid_size/sizeof(double), temp_dst_H2D_grid_size/sizeof(double));
-		runtime_remapping_weights.push_back(*remapping_weights_to);
-	}
+    double *temp_src_H2D_grid_area = NULL, *temp_dst_H2D_grid_area = NULL;
+    long temp_src_H2D_grid_size = 0, temp_dst_H2D_grid_size = 0;
 
-	if (temp_src_H2D_grid_area != NULL) {
-		delete [] temp_src_H2D_grid_area;
-		delete [] temp_dst_H2D_grid_area;
-	}
+
+    if (comp_node_from->get_current_proc_local_id() != -1) {
+        if (remapping_weights_from->get_src_H2D_grid_area() != NULL) {
+            temp_src_H2D_grid_size = remapping_weights_from->get_src_original_grid()->get_original_CoR_grid()->get_grid_size()*sizeof(double);
+            temp_src_H2D_grid_area = new double [remapping_weights_from->get_src_original_grid()->get_original_CoR_grid()->get_grid_size()];
+            memcpy(temp_src_H2D_grid_area, remapping_weights_from->get_src_H2D_grid_area(), temp_src_H2D_grid_size);
+        }
+        if (remapping_weights_from->get_dst_H2D_grid_area() != NULL) {
+            temp_dst_H2D_grid_size = remapping_weights_from->get_dst_original_grid()->get_original_CoR_grid()->get_grid_size()*sizeof(double);
+            temp_dst_H2D_grid_area = new double [remapping_weights_from->get_dst_original_grid()->get_original_CoR_grid()->get_grid_size()];
+            memcpy(temp_dst_H2D_grid_area, remapping_weights_from->get_dst_H2D_grid_area(), temp_dst_H2D_grid_size);
+        }
+    }
+    transfer_array_from_one_comp_to_another(comp_node_from->get_current_proc_local_id(), comp_node_from->get_local_proc_global_id(0), comp_node_to->get_current_proc_local_id(), comp_node_to->get_local_proc_global_id(0), comp_node_to->get_comm_group(), (char**)(&temp_src_H2D_grid_area), temp_src_H2D_grid_size);
+    transfer_array_from_one_comp_to_another(comp_node_from->get_current_proc_local_id(), comp_node_from->get_local_proc_global_id(0), comp_node_to->get_current_proc_local_id(), comp_node_to->get_local_proc_global_id(0), comp_node_to->get_comm_group(), (char**)(&temp_dst_H2D_grid_area), temp_dst_H2D_grid_size);
+    
+    if (comp_node_to->get_current_proc_local_id() != -1) {
+        EXECUTION_REPORT(REPORT_ERROR, -1, *remapping_weights_to == NULL, "Software error in Runtime_remapping_weights_mgt::transfer_runtime_remapping_weights");
+        *remapping_weights_to = new Runtime_remapping_weights();
+        if (temp_src_H2D_grid_size != 0)
+            (*remapping_weights_to)->set_H2D_grids_area(temp_src_H2D_grid_area, temp_dst_H2D_grid_area, temp_src_H2D_grid_size/sizeof(double), temp_dst_H2D_grid_size/sizeof(double));
+        runtime_remapping_weights.push_back(*remapping_weights_to);
+    }
+
+    if (temp_src_H2D_grid_area != NULL) {
+        delete [] temp_src_H2D_grid_area;
+        delete [] temp_dst_H2D_grid_area;
+    }
 }
 
 
diff --git a/src/Runtime_MGT/runtime_remapping_weights_mgt.h b/src/Runtime_MGT/runtime_remapping_weights_mgt.h
old mode 100644
new mode 100755
index 856ad48..82e11e7
--- a/src/Runtime_MGT/runtime_remapping_weights_mgt.h
+++ b/src/Runtime_MGT/runtime_remapping_weights_mgt.h
@@ -24,57 +24,57 @@
 
 class Runtime_remapping_weights
 {
-	private:
-		const char *src_comp_full_name;
-		const char *dst_comp_full_name;
-		Original_grid_info *src_original_grid;
-		Original_grid_info *dst_original_grid;
-		Decomp_info *src_decomp_info;
-		Decomp_info *dst_decomp_info;
-		Remapping_setting *remapping_setting;
-		Remap_strategy_class *remapping_strategy;
-		Remap_weight_of_strategy_class *sequential_remapping_weights;
-		Remap_weight_of_strategy_class *parallel_remapping_weights;
-		Field_mem_info *intermediate_V3D_grid_bottom_field;
-		Remap_weight_of_operator_class *dynamic_V1D_remap_weight_of_operator;
-		Remap_grid_class *runtime_V1D_remap_grid_src;
-		Remap_grid_class *runtime_V1D_remap_grid_dst;
-		double *src_H2D_grid_area;
-		double *dst_H2D_grid_area;
-		int size_src_H2D_grid_area;
-		int size_dst_H2D_grid_area;
+    private:
+        const char *src_comp_full_name;
+        const char *dst_comp_full_name;
+        Original_grid_info *src_original_grid;
+        Original_grid_info *dst_original_grid;
+        Decomp_info *src_decomp_info;
+        Decomp_info *dst_decomp_info;
+        Remapping_setting *remapping_setting;
+        Remap_strategy_class *remapping_strategy;
+        Remap_weight_of_strategy_class *sequential_remapping_weights;
+        Remap_weight_of_strategy_class *parallel_remapping_weights;
+        Field_mem_info *intermediate_V3D_grid_bottom_field;
+        Remap_weight_of_operator_class *dynamic_V1D_remap_weight_of_operator;
+        Remap_grid_class *runtime_V1D_remap_grid_src;
+        Remap_grid_class *runtime_V1D_remap_grid_dst;
+        double *src_H2D_grid_area;
+        double *dst_H2D_grid_area;
+        int size_src_H2D_grid_area;
+        int size_dst_H2D_grid_area;
 
-		void generate_parallel_remapping_weights();
-		
-	public:
-		Runtime_remapping_weights(const char*, const char*, Original_grid_info *, Original_grid_info *, Remapping_setting *, Decomp_info*);
-		Runtime_remapping_weights();
-		~Runtime_remapping_weights();
-		Remap_weight_of_strategy_class *get_sequential_remapping_weights() { return sequential_remapping_weights; }
-		Remap_weight_of_strategy_class *get_parallel_remapping_weights() { return parallel_remapping_weights; }
-		Original_grid_info *get_src_original_grid() { return src_original_grid; }
-		Original_grid_info *get_dst_original_grid() { return dst_original_grid; }
-		Decomp_info *get_src_decomp_info() { return src_decomp_info; }
-		Decomp_info *get_dst_decomp_info() { return dst_decomp_info; }
-		bool match_requirements(const char*, const char*, Original_grid_info *, Original_grid_info *, Remapping_setting *, Decomp_info*);
-		Field_mem_info *allocate_intermediate_V3D_grid_bottom_field();
-		void renew_dynamic_V1D_remapping_weights();
-		void set_H2D_grids_area(const double*, const double*, long, long);
-		double *get_src_H2D_grid_area() { return src_H2D_grid_area; }
-		double *get_dst_H2D_grid_area() { return dst_H2D_grid_area; }
+        void generate_parallel_remapping_weights();
+        
+    public:
+        Runtime_remapping_weights(const char*, const char*, Original_grid_info *, Original_grid_info *, Remapping_setting *, Decomp_info*);
+        Runtime_remapping_weights();
+        ~Runtime_remapping_weights();
+        Remap_weight_of_strategy_class *get_sequential_remapping_weights() { return sequential_remapping_weights; }
+        Remap_weight_of_strategy_class *get_parallel_remapping_weights() { return parallel_remapping_weights; }
+        Original_grid_info *get_src_original_grid() { return src_original_grid; }
+        Original_grid_info *get_dst_original_grid() { return dst_original_grid; }
+        Decomp_info *get_src_decomp_info() { return src_decomp_info; }
+        Decomp_info *get_dst_decomp_info() { return dst_decomp_info; }
+        bool match_requirements(const char*, const char*, Original_grid_info *, Original_grid_info *, Remapping_setting *, Decomp_info*);
+        Field_mem_info *allocate_intermediate_V3D_grid_bottom_field();
+        void renew_dynamic_V1D_remapping_weights();
+        void set_H2D_grids_area(const double*, const double*, long, long);
+        double *get_src_H2D_grid_area() { return src_H2D_grid_area; }
+        double *get_dst_H2D_grid_area() { return dst_H2D_grid_area; }
 };
 
 
 class Runtime_remapping_weights_mgt
 {
-	private:
-		std::vector<Runtime_remapping_weights*> runtime_remapping_weights;
+    private:
+        std::vector<Runtime_remapping_weights*> runtime_remapping_weights;
 
-	public:
-		Runtime_remapping_weights_mgt() {}
-		~Runtime_remapping_weights_mgt();
-		Runtime_remapping_weights *search_or_generate_runtime_remapping_weights(const char *, const char*, Original_grid_info *, Original_grid_info *, Remapping_setting *, Decomp_info*);
-		void transfer_runtime_remapping_weights(Runtime_remapping_weights *, Runtime_remapping_weights **, Comp_comm_group_mgt_node *, Comp_comm_group_mgt_node *);
+    public:
+        Runtime_remapping_weights_mgt() {}
+        ~Runtime_remapping_weights_mgt();
+        Runtime_remapping_weights *search_or_generate_runtime_remapping_weights(const char *, const char*, Original_grid_info *, Original_grid_info *, Remapping_setting *, Decomp_info*);
+        void transfer_runtime_remapping_weights(Runtime_remapping_weights *, Runtime_remapping_weights **, Comp_comm_group_mgt_node *, Comp_comm_group_mgt_node *);
 };
 
 
diff --git a/src/Runtime_MGT/runtime_trans_algorithm.cxx b/src/Runtime_MGT/runtime_trans_algorithm.cxx
old mode 100644
new mode 100755
index f820336..0a1ceed
--- a/src/Runtime_MGT/runtime_trans_algorithm.cxx
+++ b/src/Runtime_MGT/runtime_trans_algorithm.cxx
@@ -57,7 +57,7 @@ Runtime_trans_algorithm::Runtime_trans_algorithm(bool send_or_receive, int num_t
 
     this->send_or_receive = send_or_receive;
     this->num_transfered_fields = num_transfered_fields;
-	this->comm_tag = connection_id;
+    this->comm_tag = connection_id;
     EXECUTION_REPORT(REPORT_ERROR,-1, num_transfered_fields > 0, "Software error: Runtime_trans_algorithm does not have transfer fields");
 
     union_comm = comm;
@@ -69,7 +69,7 @@ Runtime_trans_algorithm::Runtime_trans_algorithm(bool send_or_receive, int num_t
     last_history_receive_buffer_index = -1;
     last_field_remote_recv_count = -1;
     current_field_local_recv_count = 1;
-	last_receive_sender_time = -1;
+    last_receive_sender_time = -1;
 
     for (int i = 0; i < num_transfered_fields; i ++) {
         this->fields_mem[i] = fields_mem[i];
@@ -86,14 +86,14 @@ Runtime_trans_algorithm::Runtime_trans_algorithm(bool send_or_receive, int num_t
         remote_comp_node = fields_routers[0]->get_src_comp_node();
     }
     strcpy(remote_comp_full_name, remote_comp_node->get_comp_full_name());
-	remote_comp_node_updated = false;
-	timer_not_bypassed = false;
+    remote_comp_node_updated = false;
+    timer_not_bypassed = false;
     comp_id = local_comp_node->get_comp_id();
-	comp_node = comp_comm_group_mgt_mgr->get_global_node_of_local_comp(comp_id,false, "in Runtime_trans_algorithm::Runtime_trans_algorithm");
+    comp_node = comp_comm_group_mgt_mgr->get_global_node_of_local_comp(comp_id,false, "in Runtime_trans_algorithm::Runtime_trans_algorithm");
     current_proc_local_id = local_comp_node->get_current_proc_local_id();
     current_proc_global_id = comp_comm_group_mgt_mgr->get_current_proc_global_id();
     time_mgr = components_time_mgrs->get_time_mgr(comp_id);
-	EXECUTION_REPORT(REPORT_ERROR, -1, time_mgr != NULL, "software error in Runtime_trans_algorithm::Runtime_trans_algorithm: wrong time mgr: %x: %d: %d: %s : %s: %s %s %s", comp_id, comp_comm_group_mgt_mgr->get_global_node_of_local_comp(comp_id,false, "C-Coupler native code get time manager")->get_current_proc_local_id(), current_proc_local_id, comp_comm_group_mgt_mgr->get_global_node_of_local_comp(comp_id,false, "C-Coupler native code get time manager")->get_comp_full_name(), local_comp_node->get_comp_full_name(), remote_comp_node->get_comp_full_name(), fields_routers[0]->get_src_comp_node()->get_comp_name(), fields_routers[0]->get_dst_comp_node()->get_comp_name());
+    EXECUTION_REPORT(REPORT_ERROR, -1, time_mgr != NULL, "software error in Runtime_trans_algorithm::Runtime_trans_algorithm: wrong time mgr: %x: %d: %d: %s : %s: %s %s %s", comp_id, comp_comm_group_mgt_mgr->get_global_node_of_local_comp(comp_id,false, "C-Coupler native code get time manager")->get_current_proc_local_id(), current_proc_local_id, comp_comm_group_mgt_mgr->get_global_node_of_local_comp(comp_id,false, "C-Coupler native code get time manager")->get_comp_full_name(), local_comp_node->get_comp_full_name(), remote_comp_node->get_comp_full_name(), fields_routers[0]->get_src_comp_node()->get_comp_name(), fields_routers[0]->get_dst_comp_node()->get_comp_name());
     num_remote_procs = remote_comp_node->get_num_procs();
     num_local_procs = local_comp_node->get_num_procs();
     remote_proc_ranks_in_union_comm = new int [num_remote_procs];
@@ -176,19 +176,19 @@ Runtime_trans_algorithm::Runtime_trans_algorithm(bool send_or_receive, int num_t
     for (int i = 1; i < num_remote_procs; i ++)
         recv_displs_in_current_proc[i] = recv_displs_in_current_proc[i-1] + transfer_size_with_remote_procs[i-1] + 4*sizeof(long);
 
-	current_receive_field_sender_time = -1;
-	last_receive_field_sender_time = -1;
+    current_receive_field_sender_time = -1;
+    last_receive_field_sender_time = -1;
     data_buf_size = 0;
     for (int j = 0; j < num_remote_procs; j ++) 
         data_buf_size += transfer_size_with_remote_procs[j];
 
     total_buf_size = data_buf_size + (4*num_remote_procs + 4) * sizeof(long);
     total_buf = (char*) (new long[(total_buf_size+sizeof(long)-1)/sizeof(long)]);
-    send_tag_buf = (long *) total_buf;	
-	temp_receive_data_buffer = (char*)(new long [(data_buf_size+sizeof(long)-1)/sizeof(long)]);
+    send_tag_buf = (long *) total_buf;
+    temp_receive_data_buffer = (char*)(new long [(data_buf_size+sizeof(long)-1)/sizeof(long)]);
 
-	for (int i = 0; i < 4; i ++)
-	    send_tag_buf[i] = -1;
+    for (int i = 0; i < 4; i ++)
+        send_tag_buf[i] = -1;
     for (int i = 0; i < num_remote_procs; i ++) {
         tag_buf = (long *) (total_buf + recv_displs_in_current_proc[i]);
         for (int j = 0; j < 2; j ++)
@@ -232,7 +232,7 @@ Runtime_trans_algorithm::~Runtime_trans_algorithm()
     delete [] field_grids_num_lev;
     delete [] fields_data_type_sizes;
     delete [] is_V1D_sub_grid_after_H2D_sub_grid;
-	delete [] total_buf;
+    delete [] total_buf;
     delete [] transfer_size_with_remote_procs;
     delete [] send_displs_in_remote_procs;
     delete [] recv_displs_in_current_proc;
@@ -246,8 +246,8 @@ Runtime_trans_algorithm::~Runtime_trans_algorithm()
 
 void Runtime_trans_algorithm::pass_transfer_parameters(long current_remote_fields_time, int bypass_counter)
 {
-	this->current_remote_fields_time = current_remote_fields_time;
-	this->bypass_counter = bypass_counter;
+    this->current_remote_fields_time = current_remote_fields_time;
+    this->bypass_counter = bypass_counter;
 }
 
 
@@ -255,9 +255,9 @@ bool Runtime_trans_algorithm::set_local_tags()
 {
     MPI_Win_lock(MPI_LOCK_SHARED, current_proc_id_union_comm, 0, data_win);
     send_tag_buf[0] = current_field_local_recv_count;
-	send_tag_buf[1] = ((long)time_mgr->get_current_num_elapsed_day())*100000 + ((long)time_mgr->get_current_second());
-	send_tag_buf[2] = (long) time_mgr->get_runtype_mark();
-	send_tag_buf[3] = time_mgr->get_restart_full_time();
+    send_tag_buf[1] = time_mgr->get_current_full_time();
+    send_tag_buf[2] = (long) time_mgr->get_runtype_mark();
+    send_tag_buf[3] = time_mgr->get_restart_full_time();
     current_field_local_recv_count ++;
     MPI_Win_unlock(current_proc_id_union_comm, data_win);
 
@@ -268,47 +268,47 @@ bool Runtime_trans_algorithm::set_local_tags()
 bool Runtime_trans_algorithm::is_remote_data_buf_ready(bool bypass_timer)
 {
     long temp_field_remote_recv_count = -100;
-	double time1, time2;
+    double time1, time2;
 
     if (index_remote_procs_with_common_data.size() == 0)
         return true;
 
-	wtime(&time1);
+    wtime(&time1);
     for (int i = 0; i < index_remote_procs_with_common_data.size(); i ++) {
         int remote_proc_index = index_remote_procs_with_common_data[i];
         if (transfer_size_with_remote_procs[remote_proc_index] > 0) {
- 			if (remote_comp_node_updated && last_receive_sender_time < remote_comp_node->get_proc_latest_model_time(remote_proc_index)) {
-				EXECUTION_REPORT_LOG(REPORT_LOG, comp_id, true, "Can bypass MPI_Get for proc %d", remote_proc_index);
-				continue;
-			}
+             if (remote_comp_node_updated && last_receive_sender_time < remote_comp_node->get_proc_latest_model_time(remote_proc_index)) {
+                EXECUTION_REPORT_LOG(REPORT_LOG, comp_id, true, "Can bypass MPI_Get for proc %d", remote_proc_index);
+                continue;
+            }
             int remote_proc_id = remote_proc_ranks_in_union_comm[remote_proc_index];
             MPI_Win_lock(MPI_LOCK_SHARED, remote_proc_id, 0, data_win);
             MPI_Get(send_tag_buf, sizeof(long)*4, MPI_CHAR, remote_proc_id, 0, sizeof(long)*4, MPI_CHAR, data_win);
             MPI_Win_unlock(remote_proc_id, data_win);
-			if (remote_comp_node_updated)
-				remote_comp_node->set_proc_latest_model_time(remote_proc_index, send_tag_buf[1]);
-			if (send_tag_buf[0] != -1 && send_tag_buf[0] != last_field_remote_recv_count + 1)
-				return false;
-			if (temp_field_remote_recv_count == -100)
-				temp_field_remote_recv_count = send_tag_buf[0];
-			if (temp_field_remote_recv_count != send_tag_buf[0])
-				return false;
+            if (remote_comp_node_updated)
+                remote_comp_node->set_proc_latest_model_time(remote_proc_index, send_tag_buf[1]);
+            if (send_tag_buf[0] != -1 && send_tag_buf[0] != last_field_remote_recv_count + 1)
+                return false;
+            if (temp_field_remote_recv_count == -100)
+                temp_field_remote_recv_count = send_tag_buf[0];
+            if (temp_field_remote_recv_count != send_tag_buf[0])
+                return false;
         }
     }
 
     if (temp_field_remote_recv_count == -1) {
         EXECUTION_REPORT_ERROR_OPTIONALLY(REPORT_ERROR, -1, last_field_remote_recv_count == -1 || last_field_remote_recv_count == 0, "Software error in Runtime_trans_algorithm::is_remote_data_buf_ready");
         if (last_field_remote_recv_count != -1) 
-	        return false;
+            return false;
     }
 
-    EXECUTION_REPORT_LOG(REPORT_LOG, comp_id, true, "Remote buffer component \"%s\" is ready for receiving data: %ld vs %ld vs %ld : %d: %d  %ld", remote_comp_full_name, temp_field_remote_recv_count, last_field_remote_recv_count, last_receive_sender_time, bypass_counter, send_tag_buf[2], send_tag_buf[3]);	
+    EXECUTION_REPORT_LOG(REPORT_LOG, comp_id, true, "Remote buffer component \"%s\" is ready for receiving data: %ld vs %ld vs %ld : %d: %d  %ld", remote_comp_full_name, temp_field_remote_recv_count, last_field_remote_recv_count, last_receive_sender_time, bypass_counter, send_tag_buf[2], send_tag_buf[3]);    
 
-	last_field_remote_recv_count ++;
+    last_field_remote_recv_count ++;
 
-	wtime(&time2);
-	local_comp_node->get_performance_timing_mgr()->performance_timing_add(TIMING_TYPE_COMMUNICATION, TIMING_COMMUNICATION_SEND_QUERRY, -1, remote_comp_full_name, time2-time1);
-	
+    wtime(&time2);
+    local_comp_node->get_performance_timing_mgr()->performance_timing_add(TIMING_TYPE_COMMUNICATION, TIMING_COMMUNICATION_SEND_QUERRY, -1, remote_comp_full_name, time2-time1);
+    
     return true;
 }
 
@@ -316,43 +316,43 @@ bool Runtime_trans_algorithm::is_remote_data_buf_ready(bool bypass_timer)
 void Runtime_trans_algorithm::receive_data_in_temp_buffer()
 {
     bool is_ready = true;
-	double time1, time2, time3;
+    double time1, time2, time3;
 
 
     if (index_remote_procs_with_common_data.size() == 0)
         return;
 
-	if (timer_not_bypassed && last_history_receive_buffer_index != -1) {
-		int comp_min_remote_lag_seconds = comp_node->get_min_remote_lag_seconds();
-		long current_receiver_full_seconds = ((long)time_mgr->get_current_num_elapsed_day())*86400 + time_mgr->get_current_second();
-		long current_sender_full_seconds = ((current_receive_field_sender_time%((long)100000000000000))/((long)100000))*86400 + (current_receive_field_sender_time%((long)100000));
-		if (current_sender_full_seconds + 2*comp_min_remote_lag_seconds > current_receiver_full_seconds)
-			return;
-	}
+    if (timer_not_bypassed && last_history_receive_buffer_index != -1) {
+        int comp_min_remote_lag_seconds = comp_node->get_min_remote_lag_seconds();
+        long current_receiver_full_seconds = ((long)time_mgr->get_current_num_elapsed_day())*86400 + time_mgr->get_current_second();
+        long current_sender_full_seconds = time_mgr->get_elapsed_day_from_full_time(current_receive_field_sender_time%((long)10000000000000000))*86400 + (current_receive_field_sender_time%((long)100000));
+        if (current_sender_full_seconds + 2*comp_min_remote_lag_seconds > current_receiver_full_seconds)
+            return;
+    }
 
 #ifndef USE_ONE_SIDED_MPI
-	local_comp_node->get_performance_timing_mgr()->performance_timing_start(TIMING_TYPE_COMMUNICATION, TIMING_COMMUNICATION_RECV, -1, remote_comp_full_name);
+    local_comp_node->get_performance_timing_mgr()->performance_timing_start(TIMING_TYPE_COMMUNICATION, TIMING_COMMUNICATION_RECV, -1, remote_comp_full_name);
     for (int i = 0; i < index_remote_procs_with_common_data.size(); i ++) {
         int remote_proc_index = index_remote_procs_with_common_data[i];
         if (transfer_size_with_remote_procs[remote_proc_index] == 0) 
-			continue;
+            continue;
         data_buf = (void *) (total_buf + recv_displs_in_current_proc[remote_proc_index]);
         int remote_proc_id = remote_proc_ranks_in_union_comm[remote_proc_index];
         MPI_Irecv((char *)data_buf, 4*sizeof(long)+transfer_size_with_remote_procs[remote_proc_index], MPI_CHAR, remote_proc_id, comm_tag, union_comm, &request[i]);
     }    
-	local_comp_node->get_performance_timing_mgr()->performance_timing_stop(TIMING_TYPE_COMMUNICATION, TIMING_COMMUNICATION_RECV, -1, remote_comp_full_name);
-	local_comp_node->get_performance_timing_mgr()->performance_timing_start(TIMING_TYPE_COMMUNICATION, TIMING_COMMUNICATION_RECV_WAIT, -1, remote_comp_full_name);
+    local_comp_node->get_performance_timing_mgr()->performance_timing_stop(TIMING_TYPE_COMMUNICATION, TIMING_COMMUNICATION_RECV, -1, remote_comp_full_name);
+    local_comp_node->get_performance_timing_mgr()->performance_timing_start(TIMING_TYPE_COMMUNICATION, TIMING_COMMUNICATION_RECV_WAIT, -1, remote_comp_full_name);
     for (int i = 0; i < index_remote_procs_with_common_data.size(); i ++) {
         int remote_proc_index = index_remote_procs_with_common_data[i];
         if (transfer_size_with_remote_procs[remote_proc_index] == 0) 
-			continue;
+            continue;
         MPI_Status state;
         MPI_Wait(&request[i], &state);
     }
-	local_comp_node->get_performance_timing_mgr()->performance_timing_stop(TIMING_TYPE_COMMUNICATION, TIMING_COMMUNICATION_RECV_WAIT, -1, remote_comp_full_name);
+    local_comp_node->get_performance_timing_mgr()->performance_timing_stop(TIMING_TYPE_COMMUNICATION, TIMING_COMMUNICATION_RECV_WAIT, -1, remote_comp_full_name);
 #endif
 
-	wtime(&time1);
+    wtime(&time1);
 
 #ifdef USE_ONE_SIDED_MPI
     MPI_Win_lock(MPI_LOCK_EXCLUSIVE, current_proc_id_union_comm, 0, data_win);
@@ -372,36 +372,36 @@ void Runtime_trans_algorithm::receive_data_in_temp_buffer()
 
     if (!is_ready) {
 #ifndef USE_ONE_SIDED_MPI
-		EXECUTION_REPORT_ERROR_OPTIONALLY(REPORT_ERROR, -1, false, "Software error1 in MPI_send/recv implementation in Runtime_trans_algorithm::receive_data_in_temp_buffer");
+        EXECUTION_REPORT_ERROR_OPTIONALLY(REPORT_ERROR, -1, false, "Software error1 in MPI_send/recv implementation in Runtime_trans_algorithm::receive_data_in_temp_buffer");
 #endif
         return;
     }
 
     if (last_receive_field_sender_time == current_receive_field_sender_time) {
 #ifndef USE_ONE_SIDED_MPI
-		EXECUTION_REPORT_ERROR_OPTIONALLY(REPORT_ERROR, -1, false, "Software error2 in MPI_send/recv implementation in Runtime_trans_algorithm::receive_data_in_temp_buffer");
+        EXECUTION_REPORT_ERROR_OPTIONALLY(REPORT_ERROR, -1, false, "Software error2 in MPI_send/recv implementation in Runtime_trans_algorithm::receive_data_in_temp_buffer");
 #endif
         return;
     }
 
-	for (int i = 0; i < index_remote_procs_with_common_data.size(); i ++) {
-		int remote_proc_index = index_remote_procs_with_common_data[i];
-		tag_buf = (long *) (total_buf + recv_displs_in_current_proc[remote_proc_index]);
-		if (tag_buf[2] != -1) {
-			if (tag_buf[2] == RUNTYPE_MARK_INITIAL || tag_buf[2] == RUNTYPE_MARK_HYBRID) 
-				EXECUTION_REPORT(REPORT_ERROR, comp_id, time_mgr->get_runtype_mark() == RUNTYPE_MARK_INITIAL || time_mgr->get_runtype_mark() == RUNTYPE_MARK_HYBRID, "Inconsistency of run type between component models is detected: the component model \"%s\" is in an initial run or hybrid run, while the component model \"%s\" is in a continue run or branch run. Please verify.", remote_comp_full_name, local_comp_node->get_comp_full_name());
-			else {		
-				EXECUTION_REPORT(REPORT_ERROR, comp_id, time_mgr->get_runtype_mark() == RUNTYPE_MARK_CONTINUE || time_mgr->get_runtype_mark() == RUNTYPE_MARK_BRANCH, "Inconsistency of run type between component models is detected: the component model \"%s\" is in an initial run or hybrid run, while the component model \"%s\" is in a continue run or branch run. Please verify.", local_comp_node->get_comp_full_name(), remote_comp_full_name);
-				if (time_mgr->get_restart_full_time() != -1 && tag_buf[3] != -1)
-					EXECUTION_REPORT(REPORT_ERROR, comp_id, time_mgr->get_restart_full_time() == tag_buf[3], "The restart time between the two component models \"%s\" and \"%s\" are inconsistent: %ld vs %ld. Please verify.", local_comp_node->get_comp_full_name(), remote_comp_full_name, time_mgr->get_restart_full_time(), tag_buf[3]);
-			}
-		}
-	}
+    for (int i = 0; i < index_remote_procs_with_common_data.size(); i ++) {
+        int remote_proc_index = index_remote_procs_with_common_data[i];
+        tag_buf = (long *) (total_buf + recv_displs_in_current_proc[remote_proc_index]);
+        if (tag_buf[2] != -1) {
+            if (tag_buf[2] == RUNTYPE_MARK_INITIAL || tag_buf[2] == RUNTYPE_MARK_HYBRID) 
+                EXECUTION_REPORT(REPORT_ERROR, comp_id, time_mgr->get_runtype_mark() == RUNTYPE_MARK_INITIAL || time_mgr->get_runtype_mark() == RUNTYPE_MARK_HYBRID, "Inconsistency of run type between component models is detected: the component model \"%s\" is in an initial run or hybrid run, while the component model \"%s\" is in a continue run or branch run. Please verify.", remote_comp_full_name, local_comp_node->get_comp_full_name());
+            else {        
+                EXECUTION_REPORT(REPORT_ERROR, comp_id, time_mgr->get_runtype_mark() == RUNTYPE_MARK_CONTINUE || time_mgr->get_runtype_mark() == RUNTYPE_MARK_BRANCH, "Inconsistency of run type between component models is detected: the component model \"%s\" is in an initial run or hybrid run, while the component model \"%s\" is in a continue run or branch run. Please verify.", local_comp_node->get_comp_full_name(), remote_comp_full_name);
+                if (time_mgr->get_restart_full_time() != -1 && tag_buf[3] != -1)
+                    EXECUTION_REPORT(REPORT_ERROR, comp_id, time_mgr->get_restart_full_time() == tag_buf[3], "The restart time between the two component models \"%s\" and \"%s\" are inconsistent: %ld vs %ld. Please verify.", local_comp_node->get_comp_full_name(), remote_comp_full_name, time_mgr->get_restart_full_time(), tag_buf[3]);
+            }
+        }
+    }
 
 #ifdef USE_ONE_SIDED_MPI
-	wtime(&time2);	
-	local_comp_node->get_performance_timing_mgr()->performance_timing_add(TIMING_TYPE_COMMUNICATION, TIMING_COMMUNICATION_RECV_QUERRY, -1, remote_comp_full_name, time2-time1);
-#endif	
+    wtime(&time2);    
+    local_comp_node->get_performance_timing_mgr()->performance_timing_add(TIMING_TYPE_COMMUNICATION, TIMING_COMMUNICATION_RECV_QUERRY, -1, remote_comp_full_name, time2-time1);
+#endif    
 
     int empty_history_receive_buffer_index = -1;
     if (last_history_receive_buffer_index != -1) {
@@ -417,36 +417,36 @@ void Runtime_trans_algorithm::receive_data_in_temp_buffer()
         std::vector<bool> temp_history_receive_buffer_status;
         std::vector<long> temp_history_receive_sender_time;
         std::vector<long> temp_history_receive_usage_time;
-		std::vector<std::vector<Field_mem_info *> > temp_history_receive_fields_mem;
+        std::vector<std::vector<Field_mem_info *> > temp_history_receive_fields_mem;
         for (int i = 0; i < history_receive_fields_mem.size(); i ++) {
             int index_iter = (last_history_receive_buffer_index+i) % history_receive_fields_mem.size();
             temp_history_receive_buffer_status.push_back(history_receive_buffer_status[index_iter]);
             temp_history_receive_sender_time.push_back(history_receive_sender_time[index_iter]);
             temp_history_receive_usage_time.push_back(history_receive_usage_time[index_iter]);
-			temp_history_receive_fields_mem.push_back(history_receive_fields_mem[index_iter]);
+            temp_history_receive_fields_mem.push_back(history_receive_fields_mem[index_iter]);
         }
         history_receive_buffer_status.clear();
         history_receive_sender_time.clear();
         history_receive_usage_time.clear();
-		history_receive_fields_mem.clear();
+        history_receive_fields_mem.clear();
         for (int i = 0; i < temp_history_receive_fields_mem.size(); i ++) {
             history_receive_buffer_status.push_back(temp_history_receive_buffer_status[i]);
             history_receive_sender_time.push_back(temp_history_receive_sender_time[i]);
             history_receive_usage_time.push_back(temp_history_receive_usage_time[i]);
-			history_receive_fields_mem.push_back(temp_history_receive_fields_mem[i]);
+            history_receive_fields_mem.push_back(temp_history_receive_fields_mem[i]);
         }
         last_history_receive_buffer_index = 0;
         empty_history_receive_buffer_index = history_receive_buffer_status.size();
         history_receive_buffer_status.push_back(false);
         history_receive_sender_time.push_back(-1);
         history_receive_usage_time.push_back(-1);
-		std::vector<Field_mem_info *> new_receive_fields_mem;
-		for (int i = 0; i < num_transfered_fields; i ++) {
-			new_receive_fields_mem.push_back(memory_manager->alloc_mem(fields_mem[i], BUF_MARK_DATA_TRANSFER, history_receive_fields_mem.size(), fields_mem[i]->get_data_type(), false));
-			for (int j = 0; j < history_receive_fields_mem.size(); j ++)
-				EXECUTION_REPORT_ERROR_OPTIONALLY(REPORT_ERROR, -1, history_receive_fields_mem[j][i] != new_receive_fields_mem[i], "Software error in Runtime_trans_algorithm::receive_data_in_temp_buffer");
-		}	
-		history_receive_fields_mem.push_back(new_receive_fields_mem);
+        std::vector<Field_mem_info *> new_receive_fields_mem;
+        for (int i = 0; i < num_transfered_fields; i ++) {
+            new_receive_fields_mem.push_back(memory_manager->alloc_mem(fields_mem[i], BUF_MARK_DATA_TRANSFER, history_receive_fields_mem.size(), fields_mem[i]->get_data_type(), false));
+            for (int j = 0; j < history_receive_fields_mem.size(); j ++)
+                EXECUTION_REPORT_ERROR_OPTIONALLY(REPORT_ERROR, -1, history_receive_fields_mem[j][i] != new_receive_fields_mem[i], "Software error in Runtime_trans_algorithm::receive_data_in_temp_buffer");
+        }    
+        history_receive_fields_mem.push_back(new_receive_fields_mem);
     }
 
     history_receive_buffer_status[empty_history_receive_buffer_index] = true;
@@ -461,45 +461,47 @@ void Runtime_trans_algorithm::receive_data_in_temp_buffer()
     for (int i = 0; i < index_remote_procs_with_common_data.size(); i ++) {
         int remote_proc_index = index_remote_procs_with_common_data[i];
         if (transfer_size_with_remote_procs[remote_proc_index] == 0) 
-			continue;
+            continue;
         data_buf = (void *) (total_buf + recv_displs_in_current_proc[remote_proc_index] + 4*sizeof(long));
+		EXECUTION_REPORT_ERROR_OPTIONALLY(REPORT_ERROR, -1, recv_displs_in_current_proc[remote_proc_index] + 4*sizeof(long) >= 0 && recv_displs_in_current_proc[remote_proc_index] + 4*sizeof(long) + transfer_size_with_remote_procs[remote_proc_index] <= total_buf_size, "Software error in Runtime_trans_algorithm::receive_data_in_temp_buffer: %d + %d vs %d", recv_displs_in_current_proc[remote_proc_index] + 4*sizeof(long), transfer_size_with_remote_procs[remote_proc_index], total_buf_size);
+		EXECUTION_REPORT_ERROR_OPTIONALLY(REPORT_ERROR, -1, offset >= 0 && offset + transfer_size_with_remote_procs[remote_proc_index] <= data_buf_size, "Software error in Runtime_trans_algorithm::receive_data_in_temp_buffer: %d + %d vs %d", offset, transfer_size_with_remote_procs[remote_proc_index], data_buf_size);
         memcpy(temp_receive_data_buffer+offset, data_buf, transfer_size_with_remote_procs[remote_proc_index]);
         offset += transfer_size_with_remote_procs[remote_proc_index];
     }    
 #ifdef USE_ONE_SIDED_MPI
     MPI_Win_unlock(current_proc_id_union_comm, data_win);
 #endif
-	
-	offset = 0;
-	for (int i = 0; i < num_remote_procs; i ++) {
-		if (transfer_size_with_remote_procs[i] == 0) 
-			continue;
-		int old_offset = offset;
-		//int offset = recv_displs_in_current_proc[i];
-		for (int j = 0; j < num_transfered_fields; j ++) {
-			if (fields_routers[j]->get_num_dimensions() == 0) {
-				memcpy(history_receive_fields_mem[empty_history_receive_buffer_index][j]->get_data_buf(), temp_receive_data_buffer + offset, fields_data_type_sizes[j]);
-				offset += fields_data_type_sizes[j];
-			}
-			else unpack_MD_data(temp_receive_data_buffer, i, j, history_receive_fields_mem[empty_history_receive_buffer_index][j]->get_data_buf(), &offset);
-		}	
-		EXECUTION_REPORT_ERROR_OPTIONALLY(REPORT_ERROR, -1, offset - old_offset == transfer_size_with_remote_procs[i], "C-Coupler software error in recv of runtime_trans_algorithm.");
-	}
+    
+    offset = 0;
+    for (int i = 0; i < num_remote_procs; i ++) {
+        if (transfer_size_with_remote_procs[i] == 0) 
+            continue;
+        int old_offset = offset;
+        //int offset = recv_displs_in_current_proc[i];
+        for (int j = 0; j < num_transfered_fields; j ++) {
+            if (fields_routers[j]->get_num_dimensions() == 0) {
+                memcpy(history_receive_fields_mem[empty_history_receive_buffer_index][j]->get_data_buf(), temp_receive_data_buffer + offset, fields_data_type_sizes[j]);
+                offset += fields_data_type_sizes[j];
+            }
+            else unpack_MD_data(temp_receive_data_buffer, i, j, history_receive_fields_mem[empty_history_receive_buffer_index][j]->get_data_buf(), &offset);
+        }    
+        EXECUTION_REPORT_ERROR_OPTIONALLY(REPORT_ERROR, -1, offset - old_offset == transfer_size_with_remote_procs[i], "C-Coupler software error in recv of runtime_trans_algorithm.");
+    }
 
     EXECUTION_REPORT_LOG(REPORT_LOG, comp_id, true, "Get receiving data from component \"%s\" (at time %ld) into temp buffer", remote_comp_full_name, last_receive_field_sender_time);
 
 #ifdef USE_ONE_SIDED_MPI
     set_local_tags();
-	wtime(&time3);
-	local_comp_node->get_performance_timing_mgr()->performance_timing_add(TIMING_TYPE_COMMUNICATION, TIMING_COMMUNICATION_RECV, -1, remote_comp_full_name, time3-time2);
-#endif	
+    wtime(&time3);
+    local_comp_node->get_performance_timing_mgr()->performance_timing_add(TIMING_TYPE_COMMUNICATION, TIMING_COMMUNICATION_RECV, -1, remote_comp_full_name, time3-time2);
+#endif    
 }
 
 
 bool Runtime_trans_algorithm::run(bool bypass_timer)
 {
-	if (!bypass_timer)
-		timer_not_bypassed = true;
+    if (!bypass_timer)
+        timer_not_bypassed = true;
     if (send_or_receive)
         return send(bypass_timer);
     else return recv(bypass_timer);
@@ -508,18 +510,18 @@ bool Runtime_trans_algorithm::run(bool bypass_timer)
 
 bool Runtime_trans_algorithm::send(bool bypass_timer)
 {
-	if (!remote_comp_node_updated) {
-		remote_comp_node = comp_comm_group_mgt_mgr->load_comp_info_from_XML(local_comp_node->get_comp_id(), remote_comp_full_name, local_comp_node->get_comm_group());
-		Comp_comm_group_mgt_node *existing_remote_comp_node = comp_comm_group_mgt_mgr->search_global_node(remote_comp_full_name);
-		if (existing_remote_comp_node != NULL) {
-			delete remote_comp_node;
-			remote_comp_node = existing_remote_comp_node;
-		}
-		remote_comp_node_updated = true;
-		remote_comp_node->allocate_proc_latest_model_time();
-	}
+    if (!remote_comp_node_updated) {
+        remote_comp_node = comp_comm_group_mgt_mgr->load_comp_info_from_XML(local_comp_node->get_comp_id(), remote_comp_full_name, local_comp_node->get_comm_group());
+        Comp_comm_group_mgt_node *existing_remote_comp_node = comp_comm_group_mgt_mgr->search_global_node(remote_comp_full_name);
+        if (existing_remote_comp_node != NULL) {
+            delete remote_comp_node;
+            remote_comp_node = existing_remote_comp_node;
+        }
+        remote_comp_node_updated = true;
+        remote_comp_node->allocate_proc_latest_model_time();
+    }
 #ifndef USE_ONE_SIDED_MPI
-	comp_comm_group_mgt_mgr->get_global_node_of_local_comp(comp_id,false,"")->get_performance_timing_mgr()->performance_timing_start(TIMING_TYPE_COMMUNICATION, TIMING_COMMUNICATION_SEND_WAIT, -1, remote_comp_full_name);
+    comp_comm_group_mgt_mgr->get_global_node_of_local_comp(comp_id,false,"")->get_performance_timing_mgr()->performance_timing_start(TIMING_TYPE_COMMUNICATION, TIMING_COMMUNICATION_SEND_WAIT, -1, remote_comp_full_name);
     if (!is_first_run) {
         for (int i = 0; i < index_remote_procs_with_common_data.size(); i ++) {
             int remote_proc_index = index_remote_procs_with_common_data[i];
@@ -527,7 +529,7 @@ bool Runtime_trans_algorithm::send(bool bypass_timer)
             MPI_Wait(&request[i], &state);
         }
     }
-	comp_comm_group_mgt_mgr->get_global_node_of_local_comp(comp_id,false,"")->get_performance_timing_mgr()->performance_timing_stop(TIMING_TYPE_COMMUNICATION, TIMING_COMMUNICATION_SEND_WAIT, -1, remote_comp_full_name);
+    comp_comm_group_mgt_mgr->get_global_node_of_local_comp(comp_id,false,"")->get_performance_timing_mgr()->performance_timing_stop(TIMING_TYPE_COMMUNICATION, TIMING_COMMUNICATION_SEND_WAIT, -1, remote_comp_full_name);
     is_first_run = false;
 #endif
 
@@ -535,7 +537,7 @@ bool Runtime_trans_algorithm::send(bool bypass_timer)
         preprocess();
 #ifdef USE_ONE_SIDED_MPI
         if (!is_remote_data_buf_ready(bypass_timer)) {
-			inout_interface_mgr->runtime_receive_algorithms_receive_data();
+            inout_interface_mgr->runtime_receive_algorithms_receive_data();
             return false;
         }
 #endif
@@ -549,9 +551,9 @@ bool Runtime_trans_algorithm::send(bool bypass_timer)
     if (index_remote_procs_with_common_data.size() == 0)
         return true;
 
-	local_comp_node->get_performance_timing_mgr()->performance_timing_start(TIMING_TYPE_COMMUNICATION, TIMING_COMMUNICATION_SEND, -1, remote_comp_full_name);
+    local_comp_node->get_performance_timing_mgr()->performance_timing_start(TIMING_TYPE_COMMUNICATION, TIMING_COMMUNICATION_SEND, -1, remote_comp_full_name);
 
-    long current_full_time = ((long)time_mgr->get_current_num_elapsed_day())*100000 + time_mgr->get_current_second();
+    long current_full_time = time_mgr->get_current_full_time();
     int offset = 0;
     //for (int i = 0; i < num_remote_procs; i ++) {
     for (int i = 0; i < index_remote_procs_with_common_data.size(); i ++) {
@@ -572,15 +574,15 @@ bool Runtime_trans_algorithm::send(bool bypass_timer)
 
         tag_buf = (long *) (total_buf + recv_displs_in_current_proc[remote_proc_index]);
         if (bypass_timer) {
-            tag_buf[0] = current_full_time + bypass_counter*((long)100000000000000);
+            tag_buf[0] = current_full_time + (bypass_counter%8)*((long)10000000000000000);
             tag_buf[1] = -999;
         }
         else {
             tag_buf[0] = current_full_time;
             tag_buf[1] = current_remote_fields_time;
         }
-		tag_buf[2] = (long) time_mgr->get_runtype_mark();
-		tag_buf[3] = time_mgr->get_restart_full_time();
+        tag_buf[2] = (long) time_mgr->get_runtype_mark();
+        tag_buf[3] = time_mgr->get_restart_full_time();
 
         int remote_proc_id = remote_proc_ranks_in_union_comm[remote_proc_index];
 
@@ -598,12 +600,12 @@ bool Runtime_trans_algorithm::send(bool bypass_timer)
     EXECUTION_REPORT_ERROR_OPTIONALLY(REPORT_ERROR, -1, offset <= data_buf_size, "Software error in Runtime_trans_algorithm::send: wrong data_buf_size: %d vs %d", offset, data_buf_size);
 
     if (bypass_timer)
-        last_receive_sender_time = bypass_counter*((long)100000000000000);
+        last_receive_sender_time = (bypass_counter%8)*((long)10000000000000000);
     else last_receive_sender_time = current_remote_fields_time;
 
     EXECUTION_REPORT_LOG(REPORT_LOG, comp_id, true, "Finish sending data to component \"%s\": %d", remote_comp_full_name, comm_tag);
 
-	local_comp_node->get_performance_timing_mgr()->performance_timing_stop(TIMING_TYPE_COMMUNICATION, TIMING_COMMUNICATION_SEND, -1, remote_comp_full_name);
+    local_comp_node->get_performance_timing_mgr()->performance_timing_stop(TIMING_TYPE_COMMUNICATION, TIMING_COMMUNICATION_SEND, -1, remote_comp_full_name);
 
     return true;
 }
@@ -612,14 +614,14 @@ bool Runtime_trans_algorithm::send(bool bypass_timer)
 bool Runtime_trans_algorithm::recv(bool bypass_timer)
 {
     bool received_data_ready = false;
-	
+    
 
 #ifdef USE_ONE_SIDED_MPI
-	local_comp_node->get_performance_timing_mgr()->performance_timing_start(TIMING_TYPE_COMMUNICATION, TIMING_COMMUNICATION_RECV_WAIT, -1, remote_comp_full_name);
+    local_comp_node->get_performance_timing_mgr()->performance_timing_start(TIMING_TYPE_COMMUNICATION, TIMING_COMMUNICATION_RECV_WAIT, -1, remote_comp_full_name);
 #endif
     if (bypass_timer) {
         EXECUTION_REPORT_LOG(REPORT_LOG, comp_id, true, "Bypass timer to begin to receive data from component \"%s\": %ld: %d: %d", remote_comp_full_name, current_remote_fields_time, bypass_counter, comm_tag);
-    }	
+    }    
     else EXECUTION_REPORT_LOG(REPORT_LOG, comp_id, true, "Use timer to begin to receive data from component \"%s\": %ld %d", remote_comp_full_name, current_remote_fields_time, comm_tag);
 
     if (index_remote_procs_with_common_data.size() > 0) {
@@ -634,16 +636,16 @@ bool Runtime_trans_algorithm::recv(bool bypass_timer)
                 inout_interface_mgr->runtime_receive_algorithms_receive_data();
         }
 #endif
-		EXECUTION_REPORT_ERROR_OPTIONALLY(REPORT_ERROR, -1, last_history_receive_buffer_index >= 0, "Software error with last_history_receive_buffer_index: %d", last_history_receive_buffer_index);
-		for (int j = 0; j < num_transfered_fields; j ++)
-			memcpy(fields_mem[j]->get_data_buf(), history_receive_fields_mem[last_history_receive_buffer_index][j]->get_data_buf(), fields_mem[j]->get_size_of_field()*get_data_type_size(fields_mem[j]->get_data_type()));
+        EXECUTION_REPORT_ERROR_OPTIONALLY(REPORT_ERROR, -1, last_history_receive_buffer_index >= 0, "Software error with last_history_receive_buffer_index: %d", last_history_receive_buffer_index);
+        for (int j = 0; j < num_transfered_fields; j ++)
+            memcpy(fields_mem[j]->get_data_buf(), history_receive_fields_mem[last_history_receive_buffer_index][j]->get_data_buf(), fields_mem[j]->get_size_of_field()*get_data_type_size(fields_mem[j]->get_data_type()));
     }
 
-	if (index_remote_procs_with_common_data.size() > 0)
-		last_receive_sender_time = history_receive_sender_time[last_history_receive_buffer_index];
-	else if (bypass_timer)
-		last_receive_sender_time = bypass_counter*((long)100000000000000);
-	else last_receive_sender_time = current_remote_fields_time;
+    if (index_remote_procs_with_common_data.size() > 0)
+        last_receive_sender_time = history_receive_sender_time[last_history_receive_buffer_index];
+    else if (bypass_timer)
+        last_receive_sender_time = (bypass_counter%8)*((long)10000000000000000);
+    else last_receive_sender_time = current_remote_fields_time;
 
     for (int j = 0; j < num_transfered_fields; j ++) {
          fields_mem[j]->check_field_sum("after receiving data");
@@ -658,14 +660,14 @@ bool Runtime_trans_algorithm::recv(bool bypass_timer)
     EXECUTION_REPORT_LOG(REPORT_LOG, comp_id, true, "Finish receiving data from component \"%s\" at the remote model time %ld vs %ld", remote_comp_full_name, last_receive_sender_time, current_remote_fields_time);
 
 #ifdef USE_ONE_SIDED_MPI
-	local_comp_node->get_performance_timing_mgr()->performance_timing_stop(TIMING_TYPE_COMMUNICATION, TIMING_COMMUNICATION_RECV_WAIT, -1, remote_comp_full_name);
+    local_comp_node->get_performance_timing_mgr()->performance_timing_stop(TIMING_TYPE_COMMUNICATION, TIMING_COMMUNICATION_RECV_WAIT, -1, remote_comp_full_name);
 #endif
 
     return true;
 }
 
 
-long Runtime_trans_algorithm::get_history_receive_sender_time(int j)
+long Runtime_trans_algorithm::get_history_receive_sender_time()
 {
     return last_receive_sender_time;
 }
diff --git a/src/Runtime_MGT/runtime_trans_algorithm.h b/src/Runtime_MGT/runtime_trans_algorithm.h
old mode 100644
new mode 100755
index 5f421d9..8e7a57b
--- a/src/Runtime_MGT/runtime_trans_algorithm.h
+++ b/src/Runtime_MGT/runtime_trans_algorithm.h
@@ -24,7 +24,7 @@ class Runtime_trans_algorithm
         int remote_proc_idx_begin;
         bool send_or_receive;    // true means send and false means receive
         int comp_id;
-		Comp_comm_group_mgt_node *comp_node;
+        Comp_comm_group_mgt_node *comp_node;
         int num_transfered_fields;
         Field_mem_info **fields_mem;
         void **fields_data_buffers;
@@ -58,12 +58,12 @@ class Runtime_trans_algorithm
         std::vector<long> history_receive_sender_time;
         std::vector<long> history_receive_usage_time;
         char *temp_receive_data_buffer;
-		std::vector<std::vector<Field_mem_info *> > history_receive_fields_mem;
+        std::vector<std::vector<Field_mem_info *> > history_receive_fields_mem;
         long last_receive_sender_time;
         int last_history_receive_buffer_index;
         Comp_comm_group_mgt_node * local_comp_node;
         Comp_comm_group_mgt_node * remote_comp_node;
-		bool remote_comp_node_updated;
+        bool remote_comp_node_updated;
         char remote_comp_full_name[NAME_STR_SIZE];
         int current_proc_local_id;
         int current_proc_global_id;
@@ -75,9 +75,9 @@ class Runtime_trans_algorithm
         std::vector<int> index_recv_procs_with_common_data;
         int num_recv_procs_related;
         int recv_proc_start;
-		int bypass_counter;
-		bool timer_not_bypassed;
-		int comm_tag;
+        int bypass_counter;
+        bool timer_not_bypassed;
+        int comm_tag;
 
         bool send(bool);
         bool recv(bool);
@@ -106,7 +106,7 @@ class Runtime_trans_algorithm
         void set_data_win(MPI_Win win) {data_win = win;}
         void set_tag_win(MPI_Win win) {tag_win = win;}
         void receive_data_in_temp_buffer();
-        long get_history_receive_sender_time(int);
+        long get_history_receive_sender_time();
 };
 
 
diff --git a/src/Utils/annotation_mgt.cxx b/src/Utils/annotation_mgt.cxx
old mode 100644
new mode 100755
index ac94a6f..e7c3893
--- a/src/Utils/annotation_mgt.cxx
+++ b/src/Utils/annotation_mgt.cxx
@@ -18,39 +18,39 @@
 
 Annotation_mgt::Annotation_mgt()
 {
-	annoation_lookup_table = new Dictionary<const char*>(1024);
+    annoation_lookup_table = new Dictionary<const char*>(1024);
 }
 
 
 Annotation_mgt::~Annotation_mgt()
 {
-	delete annoation_lookup_table;
-	for (int i = 0; i < annotations.size(); i ++)
-		delete annotations[i];
+    delete annoation_lookup_table;
+    for (int i = 0; i < annotations.size(); i ++)
+        delete annotations[i];
 }
 
 
 void Annotation_mgt::add_annotation(int object_id, const char *tag, const char *annotation)
 {
-	char key[NAME_STR_SIZE];
-	char *local_annotation = strdup(annotation);
+    char key[NAME_STR_SIZE];
+    char *local_annotation = strdup(annotation);
 
 
-	sprintf(key, "%x @ %s", object_id, tag);
-	annoation_lookup_table->insert(key, local_annotation);
-	annotations.push_back(local_annotation);
+    sprintf(key, "%x @ %s", object_id, tag);
+    annoation_lookup_table->insert(key, local_annotation);
+    annotations.push_back(local_annotation);
 }
 
 
 const char *Annotation_mgt::get_annotation(int object_id, const char *tag)
 {
-	char key[NAME_STR_SIZE];
-	const char *annotation;
+    char key[NAME_STR_SIZE];
+    const char *annotation;
 
 
-	sprintf(key, "%x @ %s", object_id, tag);
-	annotation = annoation_lookup_table->search(key, true);
-	EXECUTION_REPORT(REPORT_ERROR, -1, annotation != NULL, "Software error in Annotation_mgt::get_annotation");
-	return annotation;
+    sprintf(key, "%x @ %s", object_id, tag);
+    annotation = annoation_lookup_table->search(key, true);
+    EXECUTION_REPORT(REPORT_ERROR, -1, annotation != NULL, "Software error in Annotation_mgt::get_annotation");
+    return annotation;
 }
 
diff --git a/src/Utils/annotation_mgt.h b/src/Utils/annotation_mgt.h
old mode 100644
new mode 100755
index 45e3e4c..78aed37
--- a/src/Utils/annotation_mgt.h
+++ b/src/Utils/annotation_mgt.h
@@ -17,15 +17,15 @@
 
 class Annotation_mgt
 {
-	private:
-		Dictionary<const char*> *annoation_lookup_table;
-		std::vector<const char *> annotations;
-
-	public:
-		Annotation_mgt();
-		~Annotation_mgt();
-		void add_annotation(int, const char*, const char*);
-		const char *get_annotation(int, const char*);
+    private:
+        Dictionary<const char*> *annoation_lookup_table;
+        std::vector<const char *> annotations;
+
+    public:
+        Annotation_mgt();
+        ~Annotation_mgt();
+        void add_annotation(int, const char*, const char*);
+        const char *get_annotation(int, const char*);
 };
 
 #endif
diff --git a/src/Utils/common_utils.cxx b/src/Utils/common_utils.cxx
old mode 100644
new mode 100755
index 6ea3492..efc2371
--- a/src/Utils/common_utils.cxx
+++ b/src/Utils/common_utils.cxx
@@ -16,46 +16,46 @@
 
 void write_string_into_array_buffer(const char *full_string, long array_size, char **temp_array_buffer, long &buffer_max_size, long &buffer_content_size)
 {
-	write_data_into_array_buffer(full_string, array_size, temp_array_buffer, buffer_max_size, buffer_content_size);
-	memset((*temp_array_buffer)+buffer_content_size-array_size+strlen(full_string), 0, array_size-strlen(full_string));
+    write_data_into_array_buffer(full_string, array_size, temp_array_buffer, buffer_max_size, buffer_content_size);
+    memset((*temp_array_buffer)+buffer_content_size-array_size+strlen(full_string), 0, array_size-strlen(full_string));
 }
 
 
 void write_data_into_array_buffer(const void *data, long data_size, char **temp_array_buffer, long &buffer_max_size, long &buffer_content_size)
 {
-	if (*temp_array_buffer == NULL) {
-		buffer_max_size = 2 * data_size;
-		buffer_content_size = 0;
-		*temp_array_buffer = new char [buffer_max_size];
-	}
-
-	if (buffer_max_size < buffer_content_size+data_size) {
-		buffer_max_size = (buffer_content_size+data_size) * 2;
-		char *temp_buffer = new char [buffer_max_size];
-		for (int i = 0; i < buffer_content_size; i ++)
-			temp_buffer[i] = (*temp_array_buffer)[i];
-		delete [] *temp_array_buffer;
-		*temp_array_buffer = temp_buffer;
-	}
-
-	for (int i = 0; i < data_size; i ++)
-		(*temp_array_buffer)[buffer_content_size++] = ((char*)data)[i];
+    if (*temp_array_buffer == NULL) {
+        buffer_max_size = 2 * data_size;
+        buffer_content_size = 0;
+        *temp_array_buffer = new char [buffer_max_size];
+    }
+
+    if (buffer_max_size < buffer_content_size+data_size) {
+        buffer_max_size = (buffer_content_size+data_size) * 2;
+        char *temp_buffer = new char [buffer_max_size];
+        for (int i = 0; i < buffer_content_size; i ++)
+            temp_buffer[i] = (*temp_array_buffer)[i];
+        delete [] *temp_array_buffer;
+        *temp_array_buffer = temp_buffer;
+    }
+
+    for (int i = 0; i < data_size; i ++)
+        (*temp_array_buffer)[buffer_content_size++] = ((char*)data)[i];
 }
 
 
 bool read_data_from_array_buffer(void *data, long data_size, const char *temp_array_buffer, long &buffer_content_iter, bool report_error)
 {
-	if (data_size > buffer_content_iter)
-		if (report_error)
-			EXECUTION_REPORT(REPORT_ERROR,-1, false, "Software error in read_data_from_array_buffer");
-		else return false;
-	
-	for (int i = 0; i < data_size; i ++)
-		((char*) data)[i] = temp_array_buffer[buffer_content_iter-data_size+i];
-	
-	buffer_content_iter -= data_size;
-
-	return true;
+    if (data_size > buffer_content_iter)
+        if (report_error)
+            EXECUTION_REPORT(REPORT_ERROR,-1, false, "Software error in read_data_from_array_buffer");
+        else return false;
+    
+    for (int i = 0; i < data_size; i ++)
+        ((char*) data)[i] = temp_array_buffer[buffer_content_iter-data_size+i];
+    
+    buffer_content_iter -= data_size;
+
+    return true;
 }
 
 
@@ -80,8 +80,8 @@ bool get_next_line(char *line, FILE *fp)
 
 bool get_next_attr(char *attr, char **line)
 {
-	EXECUTION_REPORT(REPORT_ERROR, -1, *line != NULL, "Can not get next attribute from the configuration file. There may be problem in the configuration file");
-	
+    EXECUTION_REPORT(REPORT_ERROR, -1, *line != NULL, "Can not get next attribute from the configuration file. There may be problem in the configuration file");
+    
     if ((*line)[0] == '\0') {
         (*line) = NULL;
         return false;
@@ -127,218 +127,220 @@ bool get_next_integer_attr(char **line, int &value)
 {
     char attr[NAME_STR_SIZE];
 
-	
-	value = -1;
+    
+    value = -1;
 
     if (!get_next_attr(attr, line))
-		return false;
-	for (int i = 0; i < strlen(attr); i ++) {
-		if (i == 0 && attr[0] == '-')
-			continue;
+        return false;
+    for (int i = 0; i < strlen(attr); i ++) {
+        if (i == 0 && attr[0] == '-')
+            continue;
         if (attr[i]-'0'< 0 || attr[i]-'9' > 0) 
-            return false;		
-	}
+            return false;        
+    }
     value = atoi(attr);
 
-	return true;
+    return true;
 }
 
 
 bool get_next_double_attr(char **line, double &value)
 {
     char attr[NAME_STR_SIZE];
-	int dot_number = 0;
-	int figure_number = 0;
-
-
-	if (!get_next_attr(attr, line))
-		return false;
-
-	for (int i = 0; i < strlen(attr); i ++) {
-		if (i == 0 && attr[0] == '-')
-			continue;
-		if (attr[i] == '.') {
-			dot_number ++;
-			if (figure_number == 0)
-				return false;
-			if (dot_number > 1)
-				return false;
-			continue;
-		}
+    int dot_number = 0;
+    int figure_number = 0;
+
+
+    if (!get_next_attr(attr, line))
+        return false;
+
+    for (int i = 0; i < strlen(attr); i ++) {
+        if (i == 0 && attr[0] == '-')
+            continue;
+        if (attr[i] == '.') {
+            dot_number ++;
+            if (figure_number == 0)
+                return false;
+            if (dot_number > 1)
+                return false;
+            continue;
+        }
         if (attr[i]-'0' < 0 || attr[i]-'9' > 0) 
             return false;
-		figure_number ++;
-	}
+        figure_number ++;
+    }
     value = atof(attr);
 
-	return true;
+    return true;
 }
 
 
 void check_for_ccpl_managers_allocated(int API_ID, const char *annotation)
 {
-	char API_label[NAME_STR_SIZE];
-	
+    char API_label[NAME_STR_SIZE];
+    
 
-	get_API_hint(-1, API_ID, API_label);
-	EXECUTION_REPORT(REPORT_ERROR, -1, comp_comm_group_mgt_mgr != NULL, "Error happens when calling the API \"%s\": the stage of registering coupling configurations has not been started or the C-Coupler has been finalized. Please call the API \"CCPL_register_component\" for the registration of the root component model (parameter \"parent_id\" should be -1) to start the configuration stage. Please check the model code related to the annotation \"%s\".", API_label, annotation);
+    get_API_hint(-1, API_ID, API_label);
+    EXECUTION_REPORT(REPORT_ERROR, -1, comp_comm_group_mgt_mgr != NULL, "Error happens when calling the API \"%s\": the stage of registering coupling configurations has not been started or the C-Coupler has been finalized. Please call the API \"CCPL_register_component\" for the registration of the root component model (parameter \"parent_id\" should be -1) to start the configuration stage. Please check the model code related to the annotation \"%s\".", API_label, annotation);
 }
 
 
 void check_for_coupling_registration_stage(int comp_id, int API_ID, bool require_real_model, const char *annotation)
 {
-	char API_label[NAME_STR_SIZE];
-	
+    char API_label[NAME_STR_SIZE];
+    
 
-	get_API_hint(-1, API_ID, API_label);
-	check_for_ccpl_managers_allocated(API_ID, annotation);
-	EXECUTION_REPORT(REPORT_ERROR, -1, comp_comm_group_mgt_mgr->is_legal_local_comp_id(comp_id,true), "Error happens when calling the API \"%s\": The ID of the given component model (currently is 0x%x) is wrong (not the legal ID of a component). Please check the model code with the annotation \"%s\"", API_label, comp_id, annotation);
-	comp_comm_group_mgt_mgr->confirm_coupling_configuration_active(comp_id, API_ID, require_real_model, annotation);		
+    get_API_hint(-1, API_ID, API_label);
+    check_for_ccpl_managers_allocated(API_ID, annotation);
+    EXECUTION_REPORT(REPORT_ERROR, -1, comp_comm_group_mgt_mgr->is_legal_local_comp_id(comp_id,true), "Error happens when calling the API \"%s\": The ID of the given component model (currently is 0x%x) is wrong (not the legal ID of a component). Please check the model code with the annotation \"%s\"", API_label, comp_id, annotation);
+    comp_comm_group_mgt_mgr->confirm_coupling_configuration_active(comp_id, API_ID, require_real_model, annotation);        
 }
 
 
 void common_checking_for_grid_registration(int comp_id, const char *grid_name, const char *coord_unit, int API_id, const char *annotation)
 {
-	char API_label[NAME_STR_SIZE];
-	Original_grid_info *existing_grid;
-
-	
-	get_API_hint(comp_id, API_id, API_label);
-	check_for_coupling_registration_stage(comp_id, API_id, true, annotation);
-	check_API_parameter_string_length(comp_id, API_id, CCPL_NAME_STR_LEN, grid_name, "grid_name", annotation);
-	if (coord_unit != NULL)
-		check_API_parameter_string_length(comp_id, API_id, CCPL_NAME_STR_LEN, coord_unit, "coord_unit", annotation);
-	existing_grid = original_grid_mgr->search_grid_info(grid_name, comp_id);
-	if (existing_grid != NULL)
-		EXECUTION_REPORT(REPORT_ERROR, comp_id, false, "Error happens when calling the API \"%s\" to register a grid \"%s\" at the model code with the annotation \"%s\": another grid with the same name has already been registered before (at the model code with the annotation \"%s\"). Please verify.", API_label, grid_name, annotation, annotation_mgr->get_annotation(existing_grid->get_grid_id(), "grid_registration"));
-	check_and_verify_name_format_of_string_for_API(comp_id, grid_name, API_id, "the C-Coupler grid", annotation);
-	MPI_Comm comm = comp_comm_group_mgt_mgr->get_comm_group_of_local_comp(comp_id, "in grid registration");
-	synchronize_comp_processes_for_API(comp_id, API_id, comm, "registering a grid", annotation);
-	check_API_parameter_string(comp_id, API_id, comm, "registering a grid", grid_name, "grid_name", annotation);	
-	if (coord_unit != NULL)
-		check_API_parameter_string(comp_id, API_id, comm, "registering a grid", coord_unit, "coord_unit", annotation);
+    char API_label[NAME_STR_SIZE];
+    Original_grid_info *existing_grid;
+
+    
+    get_API_hint(comp_id, API_id, API_label);
+    check_for_coupling_registration_stage(comp_id, API_id, true, annotation);
+    check_API_parameter_string_length(comp_id, API_id, CCPL_NAME_STR_LEN, grid_name, "grid_name", annotation);
+    if (coord_unit != NULL)
+        check_API_parameter_string_length(comp_id, API_id, CCPL_NAME_STR_LEN, coord_unit, "coord_unit", annotation);
+    existing_grid = original_grid_mgr->search_grid_info(grid_name, comp_id);
+    if (existing_grid != NULL)
+        EXECUTION_REPORT(REPORT_ERROR, comp_id, false, "Error happens when calling the API \"%s\" to register a grid \"%s\" at the model code with the annotation \"%s\": another grid with the same name has already been registered before (at the model code with the annotation \"%s\"). Please verify.", API_label, grid_name, annotation, annotation_mgr->get_annotation(existing_grid->get_grid_id(), "grid_registration"));
+    check_and_verify_name_format_of_string_for_API(comp_id, grid_name, API_id, "the C-Coupler grid", annotation);
+    MPI_Comm comm = comp_comm_group_mgt_mgr->get_comm_group_of_local_comp(comp_id, "in grid registration");
+    synchronize_comp_processes_for_API(comp_id, API_id, comm, "registering a grid", annotation);
+    check_API_parameter_string(comp_id, API_id, comm, "registering a grid", grid_name, "grid_name", annotation);    
+    if (coord_unit != NULL)
+        check_API_parameter_string(comp_id, API_id, comm, "registering a grid", coord_unit, "coord_unit", annotation);
 }
 
 
 bool are_two_coord_arrays_same(double *array1, double *array2, int array_size1, int array_size2)
 {
-	double eps = 0.00001;
+    double eps = 0.00001;
 
-	
-	if (array_size1 != array_size2)
-		return false;
+    
+    if (array_size1 != array_size2)
+        return false;
 
-	for (int i = 0; i < array_size1; i ++)
-		if (fabs(array1[i]-array2[i]) >= eps)
-			return false;
+    for (int i = 0; i < array_size1; i ++)
+        if (fabs(array1[i]-array2[i]) >= eps)
+            return false;
 
-	return true;
+    return true;
 }
 
 
 void transform_datatype_of_arrays(const char *src_array, char *dst_array, const char *src_data_type, const char *dst_data_type, long num_local_cells)
 {
-	if (words_are_the_same(src_data_type,DATA_TYPE_FLOAT) && words_are_the_same(dst_data_type,DATA_TYPE_FLOAT))
-		transform_datatype_of_arrays((const float*)src_array, (float*) dst_array, num_local_cells);
-	else if (words_are_the_same(src_data_type,DATA_TYPE_DOUBLE) && words_are_the_same(dst_data_type,DATA_TYPE_DOUBLE))
-		transform_datatype_of_arrays((const double*)src_array, (double*) dst_array, num_local_cells);
-	else if (words_are_the_same(src_data_type,DATA_TYPE_FLOAT) && words_are_the_same(dst_data_type,DATA_TYPE_DOUBLE))
-		transform_datatype_of_arrays((const float*)src_array, (double*) dst_array, num_local_cells);
-	else if (words_are_the_same(src_data_type,DATA_TYPE_DOUBLE) && words_are_the_same(dst_data_type,DATA_TYPE_FLOAT))
-		transform_datatype_of_arrays((const double*)src_array, (float*) dst_array, num_local_cells);
-	else EXECUTION_REPORT(REPORT_ERROR, -1, false, "Software error in transform_datatype_of_arrays: data type transformation from %s to %s is not supported", src_data_type, dst_data_type);
+    if (words_are_the_same(src_data_type,DATA_TYPE_FLOAT) && words_are_the_same(dst_data_type,DATA_TYPE_FLOAT))
+        transform_datatype_of_arrays((const float*)src_array, (float*) dst_array, num_local_cells);
+    else if (words_are_the_same(src_data_type,DATA_TYPE_DOUBLE) && words_are_the_same(dst_data_type,DATA_TYPE_DOUBLE))
+        transform_datatype_of_arrays((const double*)src_array, (double*) dst_array, num_local_cells);
+    else if (words_are_the_same(src_data_type,DATA_TYPE_FLOAT) && words_are_the_same(dst_data_type,DATA_TYPE_DOUBLE))
+        transform_datatype_of_arrays((const float*)src_array, (double*) dst_array, num_local_cells);
+    else if (words_are_the_same(src_data_type,DATA_TYPE_DOUBLE) && words_are_the_same(dst_data_type,DATA_TYPE_FLOAT))
+        transform_datatype_of_arrays((const double*)src_array, (float*) dst_array, num_local_cells);
+    else EXECUTION_REPORT(REPORT_ERROR, -1, false, "Software error in transform_datatype_of_arrays: data type transformation from %s to %s is not supported", src_data_type, dst_data_type);
 }
 
 
 void check_API_parameter_string_length(int comp_id, int API_ID, int str_max_size, const char *str, const char *parameter_name, const char *annotation)
 {
-	char API_label[NAME_STR_SIZE];
+    char API_label[NAME_STR_SIZE];
 
 
-	get_API_hint(-1, API_ID, API_label);
-	
-	EXECUTION_REPORT(REPORT_ERROR, comp_id, strlen(str) <= str_max_size, "Error happens when calling the API \"%s\": the string size (currently is %d) of the parameter \"%s\" (the string is \"%s\") is larger than the limit (%d). Please verify the model code with the annotation \"%s\".", API_label, strlen(str), parameter_name, str, str_max_size, annotation);
-	EXECUTION_REPORT(REPORT_ERROR, comp_id, !words_are_the_same(str, "NULL"), "Error happens when calling the API \"%s\": the parameter \"%s\" cannot be \"NULL\". Please verify the model code with the annotation \"%s\".", API_label, parameter_name, str, annotation);
+    get_API_hint(-1, API_ID, API_label);
+    
+    EXECUTION_REPORT(REPORT_ERROR, comp_id, strlen(str) <= str_max_size, "Error happens when calling the API \"%s\": the string size (currently is %d) of the parameter \"%s\" (the string is \"%s\") is larger than the limit (%d). Please verify the model code with the annotation \"%s\".", API_label, strlen(str), parameter_name, str, str_max_size, annotation);
+    EXECUTION_REPORT(REPORT_ERROR, comp_id, !words_are_the_same(str, "NULL"), "Error happens when calling the API \"%s\": the parameter \"%s\" cannot be \"NULL\". Please verify the model code with the annotation \"%s\".", API_label, parameter_name, str, annotation);
 }
 
 
 void check_XML_attribute_value_string_length(int comp_id, int str_max_size, const char *XML_attribute, const char *XML_value, const char *XML_file_name, int line_number)
 {
-	EXECUTION_REPORT(REPORT_ERROR, comp_id, strlen(XML_value) <= str_max_size, "Error happens when using the XML configuration file \"%s\": the string size (currently is %d) of the value (\"%s\") the XML attribute \"%s\" is larger than the limit (%d). Please verify XML file arround the line %d.", XML_file_name, strlen(XML_value), XML_value, XML_attribute, str_max_size, line_number);
+    EXECUTION_REPORT(REPORT_ERROR, comp_id, strlen(XML_value) <= str_max_size, "Error happens when using the XML configuration file \"%s\": the string size (currently is %d) of the value (\"%s\") the XML attribute \"%s\" is larger than the limit (%d). Please verify XML file arround the line %d.", XML_file_name, strlen(XML_value), XML_value, XML_attribute, str_max_size, line_number);
 }
 
 
 bool is_string_decimal_number(const char *string)
 {
-	int length = strlen(string);
-
-	if (length == 0)
-		return false;
-	
-	for (int i = 0; i < length; i ++) {
-		if (i == 0 && string[i] == '-' && length > 1)
-			continue;
-		if (!(string[i] >= '0' && string[i] <= '9'))
-			return false;
-	}
-	
-	return true;
+    int length = strlen(string);
+
+    if (length == 0)
+        return false;
+    
+    for (int i = 0; i < length; i ++) {
+        if (i == 0 && string[i] == '-' && length > 1)
+            continue;
+        if (!(string[i] >= '0' && string[i] <= '9'))
+            return false;
+    }
+    
+    return true;
 }
 
 
 char *load_string(char *str, long &str_size, long max_size, const char *array_buffer, long &buffer_content_iter, const char *file_name)
 {
-	char *local_str = str;
-	
-
-	if (!read_data_from_array_buffer(&str_size, sizeof(long), array_buffer, buffer_content_iter, file_name == NULL))
-		if (file_name != NULL)
-			EXECUTION_REPORT(REPORT_ERROR, -1, false, "Fail to load the restart data file \"%s\": its format is wrong, or the information it includes is not complete. Please try a different restart time with complete restart data files.", file_name);	
-		else EXECUTION_REPORT(REPORT_ERROR, -1, false, "Software error in load_string");
-	EXECUTION_REPORT(REPORT_ERROR, -1, str_size > 0, "Fail to load the restart data file \"%s\": its format is wrong, or the information it includes is not complete. Please try a different restart time with complete restart data files.", file_name);
-	if (local_str != NULL)
-		EXECUTION_REPORT(REPORT_ERROR, -1, str_size < max_size, "Fail to load the restart data file \"%s\": its format is wrong, or the information it includes is not complete. Please try a different restart time with complete restart data files.", file_name);
-	if (local_str == NULL)
-		local_str = new char [str_size+1];
-	EXECUTION_REPORT(REPORT_ERROR, -1, read_data_from_array_buffer(local_str, str_size, array_buffer, buffer_content_iter, file_name == NULL), "Fail to load the restart data file \"%s\": its format is wrong, or the information it includes is not complete. Please try a different restart time with complete restart data files.", file_name);
-	local_str[str_size] = '\0';
-
-	return local_str;
+    char *local_str = str;
+    
+
+    if (!read_data_from_array_buffer(&str_size, sizeof(long), array_buffer, buffer_content_iter, file_name == NULL))
+        if (file_name != NULL)
+            EXECUTION_REPORT(REPORT_ERROR, -1, false, "Fail to load the restart data file \"%s\": its format is wrong, or the information it includes is not complete. Please try a different restart time with complete restart data files.", file_name);    
+        else EXECUTION_REPORT(REPORT_ERROR, -1, false, "Software error in load_string");
+    EXECUTION_REPORT(REPORT_ERROR, -1, str_size > 0, "Fail to load the restart data file \"%s\": its format is wrong, or the information it includes is not complete. Please try a different restart time with complete restart data files.", file_name);
+    if (local_str != NULL)
+        EXECUTION_REPORT(REPORT_ERROR, -1, str_size < max_size, "Fail to load the restart data file \"%s\": its format is wrong, or the information it includes is not complete. Please try a different restart time with complete restart data files.", file_name);
+    if (local_str == NULL)
+        local_str = new char [str_size+1];
+    EXECUTION_REPORT(REPORT_ERROR, -1, read_data_from_array_buffer(local_str, str_size, array_buffer, buffer_content_iter, file_name == NULL), "Fail to load the restart data file \"%s\": its format is wrong, or the information it includes is not complete. Please try a different restart time with complete restart data files.", file_name);
+    local_str[str_size] = '\0';
+
+    return local_str;
 }
 
 
 void dump_string(const char *str, long str_size, char **array_buffer, long &buffer_max_size, long &buffer_content_size)
 {
-	if (str_size == -1)
-		if (str != NULL)
-			str_size = strlen(str);
-		else str_size = 0;
-	if (str != NULL)
-		write_data_into_array_buffer(str, str_size, array_buffer, buffer_max_size, buffer_content_size);
-	write_data_into_array_buffer(&str_size, sizeof(long), array_buffer, buffer_max_size, buffer_content_size);
+    if (str_size == -1)
+        if (str != NULL)
+            str_size = strlen(str);
+        else str_size = 0;
+    if (str != NULL)
+        write_data_into_array_buffer(str, str_size, array_buffer, buffer_max_size, buffer_content_size);
+    write_data_into_array_buffer(&str_size, sizeof(long), array_buffer, buffer_max_size, buffer_content_size);
 }
 
 
 long get_restart_time_in_rpointer_file(const char *file_name)
 {
-	char line[NAME_STR_SIZE*16], date_str[NAME_STR_SIZE], second_str[NAME_STR_SIZE];
-	int date, second, special_pos;
-	FILE *rpointer_file;
-
-
-	rpointer_file = fopen(file_name, "r");
-	get_next_line(line, rpointer_file);
-	fclose(rpointer_file);
-	for (special_pos = strlen(line)-1; special_pos >= 0; special_pos --)
-		if (line[special_pos] == '-')
-			break;
-	EXECUTION_REPORT(REPORT_ERROR, -1, special_pos > 10, "Error happens in a continue run: the restart file name \"%s\" in the rpointer file \"%s\" is not in a right format", file_name);
-	EXECUTION_REPORT(REPORT_ERROR, -1, line[special_pos-9] == '.' && line[special_pos-10] == 'r', "Error happens in a continue run: the restart file name \"%s\" in the rpointer file \"%s\" is not in a right format", file_name);
-	strncpy(date_str, line+special_pos-8, 8);
-	strncpy(second_str, line+special_pos+1, 5);
-	EXECUTION_REPORT(REPORT_ERROR, -1, sscanf(date_str, "%d", &date) == 1, "Error happens in a continue run: the restart file name \"%s\" in the rpointer file \"%s\" is not in a right format", file_name);
-	EXECUTION_REPORT(REPORT_ERROR, -1, sscanf(second_str, "%d", &second) == 1, "Error happens in a continue run: the restart file name \"%s\" in the rpointer file \"%s\" is not in a right format", file_name);
-
-	return ((long)date)*((long)100000) + second;
+    char line[NAME_STR_SIZE*16], date_str[NAME_STR_SIZE], second_str[NAME_STR_SIZE];
+    int date, second, special_pos;
+    FILE *rpointer_file;
+
+
+    rpointer_file = fopen(file_name, "r");
+    get_next_line(line, rpointer_file);
+    fclose(rpointer_file);
+    for (special_pos = strlen(line)-1; special_pos >= 0; special_pos --)
+        if (line[special_pos] == '-')
+            break;
+    EXECUTION_REPORT(REPORT_ERROR, -1, special_pos > 10, "Error happens in a continue run: the restart file name \"%s\" in the rpointer file \"%s\" is not in a right format", file_name);
+    EXECUTION_REPORT(REPORT_ERROR, -1, line[special_pos-9] == '.' && line[special_pos-10] == 'r', "Error happens in a continue run: the restart file name \"%s\" in the rpointer file \"%s\" is not in a right format", file_name);
+    strncpy(date_str, line+special_pos-8, 8);
+    strncpy(second_str, line+special_pos+1, 5);
+	date_str[8] = '\0';
+	second_str[5] = '\0';
+    EXECUTION_REPORT(REPORT_ERROR, -1, sscanf(date_str, "%d", &date) == 1, "Error happens in a continue run: the restart file name \"%s\" in the rpointer file \"%s\" is not in a right format", file_name);
+    EXECUTION_REPORT(REPORT_ERROR, -1, sscanf(second_str, "%d", &second) == 1, "Error happens in a continue run: the restart file name \"%s\" in the rpointer file \"%s\" is not in a right format", file_name);
+
+    return ((long)date)*((long)100000) + second;
 }
 
diff --git a/src/Utils/common_utils.h b/src/Utils/common_utils.h
old mode 100644
new mode 100755
index f8c6601..5d3f310
--- a/src/Utils/common_utils.h
+++ b/src/Utils/common_utils.h
@@ -40,17 +40,17 @@ extern long get_restart_time_in_rpointer_file(const char *);
 
 template <typename T> bool are_floating_values_equal(T value1, T value2)
 {
-	T eps = (T)1.0000001;
-	if (value1 < 0)
-		return value2 >= value1*eps && value2 <= value1/eps;
-	else return value2 <= value1*eps && value2 >= value1/eps;
+    T eps = (T)1.0000001;
+    if (value1 < 0)
+        return value2 >= value1*eps && value2 <= value1/eps;
+    else return value2 <= value1*eps && value2 >= value1/eps;
 }
 
 
 template <typename T1, typename T2> void transform_datatype_of_arrays(const T1 *src_array, T2 *dst_array, long num_local_cells)
 {
-	for (long i = 0; i < num_local_cells; i ++)
-		dst_array[i] = (T2) src_array[i];
+    for (long i = 0; i < num_local_cells; i ++)
+        dst_array[i] = (T2) src_array[i];
 }
 
 
@@ -59,98 +59,98 @@ extern void transform_datatype_of_arrays(const char *, char *, const char *, con
 
 template <typename T1, typename T2, typename T3> void arrays_multiplication_template(T1 *src_array1, T2 *src_array2, T3 *dst_array, int array_size)
 {
-	for (int i = 0; i < array_size; i ++)
-		dst_array[i] = ((T3)(src_array1[i])) * ((T3)(src_array2[i]));
+    for (int i = 0; i < array_size; i ++)
+        dst_array[i] = ((T3)(src_array1[i])) * ((T3)(src_array2[i]));
 }
 
 
 template <typename T1, typename T2, typename T3> void arrays_division_template(T1 *src_array, T2 *divisor, T3 *dst_array, int array_size)
 {
-	for (int i = 0; i < array_size; i ++)
-		if (divisor[i] != (T2) 0)
-			dst_array[i] = ((T3)(src_array[i])) / ((T3)(divisor[i]));
+    for (int i = 0; i < array_size; i ++)
+        if (divisor[i] != (T2) 0)
+            dst_array[i] = ((T3)(src_array[i])) / ((T3)(divisor[i]));
 }
 
 
 template <typename T> bool are_array_values_between_boundaries_kernel(const T *data_array, int array_size, T lower_bound, T upper_bound, T missing_value, bool has_missing_value)
-{	
-	for (int i = 0; i < array_size; i ++) {
-		if (has_missing_value && are_floating_values_equal(data_array[i], missing_value))
-			continue;
-		if (lower_bound <= upper_bound) {
-			if (data_array[i] < lower_bound || data_array[i] > upper_bound)
-				return false;
-		}
-		else {
-			if (data_array[i] < lower_bound && data_array[i] > upper_bound)
-				return false;		
-		}
-	}
-
-	return true;
+{    
+    for (int i = 0; i < array_size; i ++) {
+        if (has_missing_value && are_floating_values_equal(data_array[i], missing_value))
+            continue;
+        if (lower_bound <= upper_bound) {
+            if (data_array[i] < lower_bound || data_array[i] > upper_bound)
+                return false;
+        }
+        else {
+            if (data_array[i] < lower_bound && data_array[i] > upper_bound)
+                return false;        
+        }
+    }
+
+    return true;
 }
 
 
 template <typename T> bool are_array_values_between_boundaries(const char *data_type, const T *data_array, int array_size, T lower_bound, T upper_bound, T missing_value, bool has_missing_value)
 {
-	if (array_size <= 0)
-		return true;
+    if (array_size <= 0)
+        return true;
 
-	if (strcmp(data_type, "integer") == 0)
-		return are_array_values_between_boundaries_kernel((const int *) data_array, (int) array_size, (int) lower_bound, (int) upper_bound, (int) missing_value, has_missing_value);
-	else if (strcmp(data_type, "real4") == 0)
-		return are_array_values_between_boundaries_kernel((const float *) data_array, (float) array_size, (float) lower_bound, (float) upper_bound, (float) missing_value, has_missing_value);	
-	else if (strcmp(data_type, "real8") == 0)
-		return are_array_values_between_boundaries_kernel((const double *) data_array, (double) array_size, (double) lower_bound, (double) upper_bound, (double) missing_value, has_missing_value);
+    if (strcmp(data_type, "integer") == 0)
+        return are_array_values_between_boundaries_kernel((const int *) data_array, (int) array_size, (int) lower_bound, (int) upper_bound, (int) missing_value, has_missing_value);
+    else if (strcmp(data_type, "real4") == 0)
+        return are_array_values_between_boundaries_kernel((const float *) data_array, (float) array_size, (float) lower_bound, (float) upper_bound, (float) missing_value, has_missing_value);    
+    else if (strcmp(data_type, "real8") == 0)
+        return are_array_values_between_boundaries_kernel((const double *) data_array, (double) array_size, (double) lower_bound, (double) upper_bound, (double) missing_value, has_missing_value);
 
-	return false;
+    return false;
 }
 
 
 template <typename T> int is_array_in_sorting_order(T *array, int array_size)    // 0 for non-sorting order; 1 for ascending order; 2 for descending order
 {
-	int i;
-
-	i = 1;
-	while (i < array_size && array[i-1] <= array[i])
-		i ++;
-	if (i == array_size) {
-		if (array[0] == array[array_size-1])
-			return 0;
-		return 1;
-	}
-
-	i = 1;
-	while (i < array_size && array[i-1] >= array[i])
-		i ++;
-	if (i == array_size)
-		return 2;
-
-	return 0;
+    int i;
+
+    i = 1;
+    while (i < array_size && array[i-1] <= array[i])
+        i ++;
+    if (i == array_size) {
+        if (array[0] == array[array_size-1])
+            return 0;
+        return 1;
+    }
+
+    i = 1;
+    while (i < array_size && array[i-1] >= array[i])
+        i ++;
+    if (i == array_size)
+        return 2;
+
+    return 0;
 }
 
 
 template <typename T> void get_min_value_in_array(T *array, int array_size, bool have_missing_value, T missing_value, T &min_value)
 {
-	for (int i = 0; i < array_size; i ++) {
-		if (have_missing_value && are_floating_values_equal(min_value, missing_value))
-			min_value = array[i];
-		else if (have_missing_value && are_floating_values_equal(array[i], missing_value))
-			continue;
-		else min_value = min_value < array[i]? min_value : array[i];
-	}
+    for (int i = 0; i < array_size; i ++) {
+        if (have_missing_value && are_floating_values_equal(min_value, missing_value))
+            min_value = array[i];
+        else if (have_missing_value && are_floating_values_equal(array[i], missing_value))
+            continue;
+        else min_value = min_value < array[i]? min_value : array[i];
+    }
 }
 
 
 template <typename T> void get_max_value_in_array(T *array, int array_size, bool have_missing_value, T missing_value, T &max_value)
 {
-	for (int i = 0; i < array_size; i ++) {
-		if (have_missing_value && are_floating_values_equal(max_value, missing_value))
-			max_value = array[i];
-		else if (have_missing_value && are_floating_values_equal(array[i], missing_value))
-			continue;
-		else max_value = max_value > array[i]? max_value : array[i];
-	}
+    for (int i = 0; i < array_size; i ++) {
+        if (have_missing_value && are_floating_values_equal(max_value, missing_value))
+            max_value = array[i];
+        else if (have_missing_value && are_floating_values_equal(array[i], missing_value))
+            continue;
+        else max_value = max_value > array[i]? max_value : array[i];
+    }
 }
 
 
diff --git a/src/Utils/dictionary.h b/src/Utils/dictionary.h
old mode 100644
new mode 100755
index 9e0686c..16fb8c5
--- a/src/Utils/dictionary.h
+++ b/src/Utils/dictionary.h
@@ -36,139 +36,139 @@ struct Dictionary_node {
 template <class T>
 class Dictionary
 {
-	private:
-		int num_hashing_entries;
-		int num_elements;
-		struct Dictionary_node<T> **hashing_table;
-		
-		unsigned long hash_function(const char*);	
-		void initialize_hashing_table(int);
-		void delete_hashing_table();
-		void increase_hashing_entries();
-
-	public:
-		Dictionary(int);
-		~Dictionary();
-		T search(const char*, bool);
-		void insert(const char*, T);
-		void remove(const char*);
+    private:
+        int num_hashing_entries;
+        int num_elements;
+        struct Dictionary_node<T> **hashing_table;
+        
+        unsigned long hash_function(const char*);    
+        void initialize_hashing_table(int);
+        void delete_hashing_table();
+        void increase_hashing_entries();
+
+    public:
+        Dictionary(int);
+        ~Dictionary();
+        T search(const char*, bool);
+        void insert(const char*, T);
+        void remove(const char*);
 };
 
 
 template <class T>  
 Dictionary<T>::Dictionary(int size)
 {
-	int true_size = size / 4;
+    int true_size = size / 4;
   
   
-	if (true_size < INITIAL_SIZE)
-		true_size = INITIAL_SIZE;
-	if (true_size > size)
-		true_size = size;
+    if (true_size < INITIAL_SIZE)
+        true_size = INITIAL_SIZE;
+    if (true_size > size)
+        true_size = size;
   
-	num_elements = 0;
-	initialize_hashing_table(true_size);
+    num_elements = 0;
+    initialize_hashing_table(true_size);
 }
   
 
 template <class T>  
 void Dictionary<T>::initialize_hashing_table(int size)
 {
-	num_hashing_entries = size;
-	hashing_table = (Dictionary_node<T>**) new Dictionary_node<T> *[size];
-	for(int i = 0; i < size; i++) 
-		hashing_table[i] = NULL;
+    num_hashing_entries = size;
+    hashing_table = (Dictionary_node<T>**) new Dictionary_node<T> *[size];
+    for(int i = 0; i < size; i++) 
+        hashing_table[i] = NULL;
 }
 
 
 template <class T>
 void Dictionary<T>::delete_hashing_table()
 {
-	int i;
-	Dictionary_node<T> *e, *next;
+    int i;
+    Dictionary_node<T> *e, *next;
 
 
     for(i = 0; i < num_hashing_entries; i++) {
-		for(e = hashing_table[i]; e != NULL; e = next) {
-			next = e->next;
-			delete [] e->key;
-			delete e;
-		}
-	}
-  
-	delete [] hashing_table;
+        for(e = hashing_table[i]; e != NULL; e = next) {
+            next = e->next;
+            delete [] e->key;
+            delete e;
+        }
+    }
+  
+    delete [] hashing_table;
 }
   
 
 template <class T>  
 Dictionary<T>::~Dictionary()
 {
-	delete_hashing_table();
+    delete_hashing_table();
 }
   
 
 template <class T>
 unsigned long Dictionary<T>::hash_function(const char *keyword)
 {
-	unsigned const char *us;
-	unsigned long h;
+    unsigned const char *us;
+    unsigned long h;
   
-	h = 0;
+    h = 0;
   
-	for(us = (unsigned const char *) keyword; *us; us++) {
-		h = (h << 6) + (h << 16) - h + *us;
-	}
+    for(us = (unsigned const char *) keyword; *us; us++) {
+        h = (h << 6) + (h << 16) - h + *us;
+    }
 
-	return h % num_hashing_entries;
+    return h % num_hashing_entries;
 }
   
 
 template <class T>
 void Dictionary<T>::increase_hashing_entries()
 {   
-	int old_num_hashing_entries = num_hashing_entries, new_num_hashing_entries;
-	Dictionary_node<T> **old_hashing_table = hashing_table, **new_hashing_table;
-	Dictionary_node<T> *e, *next;
-	  
-  
-	initialize_hashing_table(num_hashing_entries * GROWTH_FACTOR);
-	new_hashing_table = hashing_table;
-	new_num_hashing_entries = num_hashing_entries;
-	num_elements = 0;
-  
-	for(int i = 0; i < old_num_hashing_entries; i++) {
-		for(e = old_hashing_table[i]; e != NULL; e = e->next)
-			insert(e->key, e->value);
-	}
-  
-	hashing_table = old_hashing_table;
-	num_hashing_entries = old_num_hashing_entries;
-	delete_hashing_table();
-	hashing_table = new_hashing_table;
-	num_hashing_entries = new_num_hashing_entries;
+    int old_num_hashing_entries = num_hashing_entries, new_num_hashing_entries;
+    Dictionary_node<T> **old_hashing_table = hashing_table, **new_hashing_table;
+    Dictionary_node<T> *e, *next;
+      
+  
+    initialize_hashing_table(num_hashing_entries * GROWTH_FACTOR);
+    new_hashing_table = hashing_table;
+    new_num_hashing_entries = num_hashing_entries;
+    num_elements = 0;
+  
+    for(int i = 0; i < old_num_hashing_entries; i++) {
+        for(e = old_hashing_table[i]; e != NULL; e = e->next)
+            insert(e->key, e->value);
+    }
+  
+    hashing_table = old_hashing_table;
+    num_hashing_entries = old_num_hashing_entries;
+    delete_hashing_table();
+    hashing_table = new_hashing_table;
+    num_hashing_entries = new_num_hashing_entries;
 }
   
 
 template <class T>
 void Dictionary<T>::insert(const char *key, T value)
 {
-	Dictionary_node<T> *e;
-	unsigned long h;
-	  
-  
-	EXECUTION_REPORT(REPORT_ERROR, !words_are_the_same(key,""), "The key to be inserted into the dictionary cannot be empty!");
-	EXECUTION_REPORT(REPORT_ERROR, search(key, false) == NULL, "The key \"%s\" has been inserted into the dictionary before. It cannot be inserted again. Please check.");
-	e = new Dictionary_node<T>;
-	e->key = strdup(key);
-	e->value = value;
-	h = hash_function(key);
-	e->next = hashing_table[h];
-	hashing_table[h] = e;
-	num_elements ++;
-  
-	/* increase_hashing_entries hashing_table if there is not enough room */
-	if(num_elements >= num_hashing_entries * MAX_LOAD_FACTOR)
-	increase_hashing_entries();
+    Dictionary_node<T> *e;
+    unsigned long h;
+      
+  
+    EXECUTION_REPORT(REPORT_ERROR, !words_are_the_same(key,""), "The key to be inserted into the dictionary cannot be empty!");
+    EXECUTION_REPORT(REPORT_ERROR, search(key, false) == NULL, "The key \"%s\" has been inserted into the dictionary before. It cannot be inserted again. Please check.");
+    e = new Dictionary_node<T>;
+    e->key = strdup(key);
+    e->value = value;
+    h = hash_function(key);
+    e->next = hashing_table[h];
+    hashing_table[h] = e;
+    num_elements ++;
+  
+    /* increase_hashing_entries hashing_table if there is not enough room */
+    if(num_elements >= num_hashing_entries * MAX_LOAD_FACTOR)
+    increase_hashing_entries();
 }
 
   
@@ -177,40 +177,40 @@ void Dictionary<T>::insert(const char *key, T value)
 template <class T>
 T Dictionary<T>::search(const char *key, bool check)
 {
-	Dictionary_node<T> *e;
+    Dictionary_node<T> *e;
   
   
-	for(e = hashing_table[hash_function(key)]; e != NULL; e = e->next) {
-		if(strcmp(e->key, key) == 0) {
-			/* got it */
-			return e->value;
-		}
-	}
+    for(e = hashing_table[hash_function(key)]; e != NULL; e = e->next) {
+        if(strcmp(e->key, key) == 0) {
+            /* got it */
+            return e->value;
+        }
+    }
   
-	if (check)
-		EXECUTION_REPORT(REPORT_ERROR, false, "Cannot find the entry for the keyword \"%s\" in the dictionary", key);
+    if (check)
+        EXECUTION_REPORT(REPORT_ERROR, false, "Cannot find the entry for the keyword \"%s\" in the dictionary", key);
   
-	return (T) 0;
+    return (T) 0;
 }
   
 
 template <class T>
 void Dictionary<T>::remove(const char *key)
 {
-	Dictionary_node<T> **prev, *e;  
-  
-  
-	for(prev = &(hashing_table[hash_function(key)]); *prev != 0; prev = &((*prev)->next)) {
-		if(strcmp((*prev)->key, key) == 0) {
-			/* got it */
-			e = *prev;
-			*prev = e->next;
-			delete [] e->key;
-			delete e;
-			num_elements --;
-			break;
-		}
-	}
+    Dictionary_node<T> **prev, *e;  
+  
+  
+    for(prev = &(hashing_table[hash_function(key)]); *prev != 0; prev = &((*prev)->next)) {
+        if(strcmp((*prev)->key, key) == 0) {
+            /* got it */
+            e = *prev;
+            *prev = e->next;
+            delete [] e->key;
+            delete e;
+            num_elements --;
+            break;
+        }
+    }
 }
   
 
diff --git a/src/Utils/execution_report.cxx b/src/Utils/execution_report.cxx
old mode 100644
new mode 100755
index 834e126..dc6444a
--- a/src/Utils/execution_report.cxx
+++ b/src/Utils/execution_report.cxx
@@ -7,11 +7,7 @@
   ***************************************************************/
 
 
-#ifndef ONLY_CoR
 #include "global_data.h"
-#else
-#define NAME_STR_SIZE 1024
-#endif
 #include "execution_report.h"
 #include "cor_global_data.h"
 #include <assert.h>
@@ -28,211 +24,185 @@ bool flush_log_file;
 
 void import_report_setting()
 {
-	char XML_file_name[NAME_STR_SIZE];
-	int line_number;
-	char keywords[5][NAME_STR_SIZE];
-	bool report_setting[5];
-
-
-	report_external_log_enabled = false;
-	report_error_enabled = false;
-	report_internal_log_enabled = false;
-	report_progress_enabled = false;
-	flush_log_file = false;
-
-	sprintf(XML_file_name, "%s/all/CCPL_report.xml", comp_comm_group_mgt_mgr->get_config_root_dir());
-	TiXmlDocument *XML_file = open_XML_file_to_read(-1, XML_file_name, MPI_COMM_WORLD, false);
-	if (XML_file == NULL)
-		return;
-
-	sprintf(keywords[0], "report_internal_log");
-	sprintf(keywords[1], "report_external_log");
-	sprintf(keywords[2], "report_progress");
-	sprintf(keywords[3], "report_error");
-	sprintf(keywords[4], "flush_log_file");
-	
-	TiXmlElement *XML_element = XML_file->FirstChildElement();
-	for (int i = 0; i < 5; i ++) {
-		report_setting[i] = false;
-		const char *setting = XML_element->Attribute(keywords[i], &line_number);
-		if (setting == NULL)
-			continue;
-		EXECUTION_REPORT(REPORT_ERROR, -1, words_are_the_same(setting, "on") || words_are_the_same(setting, "off"), "Error happens when loading the XML file \"%s\": the value of \"%s\" must be \"on\" or \"off\". Please verify the XML file around line number %d", XML_file_name, keywords[i]);
-		report_setting[i] = words_are_the_same(setting,"on");
-	}
-
-	delete XML_file;
-
-	report_internal_log_enabled = report_setting[0];
-	report_external_log_enabled = report_setting[1];
-	report_progress_enabled = report_setting[2];
-	report_error_enabled = report_setting[3];
-	flush_log_file = report_setting[4];
+    char XML_file_name[NAME_STR_SIZE];
+    int line_number;
+    char keywords[5][NAME_STR_SIZE];
+    bool report_setting[5];
+
+
+    report_external_log_enabled = false;
+    report_error_enabled = false;
+    report_internal_log_enabled = false;
+    report_progress_enabled = false;
+    flush_log_file = false;
+
+    sprintf(XML_file_name, "%s/all/CCPL_report.xml", comp_comm_group_mgt_mgr->get_config_root_dir());
+    TiXmlDocument *XML_file = open_XML_file_to_read(-1, XML_file_name, MPI_COMM_WORLD, false);
+    if (XML_file == NULL)
+        return;
+
+    sprintf(keywords[0], "report_internal_log");
+    sprintf(keywords[1], "report_external_log");
+    sprintf(keywords[2], "report_progress");
+    sprintf(keywords[3], "report_error");
+    sprintf(keywords[4], "flush_log_file");
+    
+    TiXmlElement *XML_element = XML_file->FirstChildElement();
+    for (int i = 0; i < 5; i ++) {
+        report_setting[i] = false;
+        const char *setting = XML_element->Attribute(keywords[i], &line_number);
+        if (setting == NULL)
+            continue;
+        EXECUTION_REPORT(REPORT_ERROR, -1, words_are_the_same(setting, "on") || words_are_the_same(setting, "off"), "Error happens when loading the XML file \"%s\": the value of \"%s\" must be \"on\" or \"off\". Please verify the XML file around line number %d", XML_file_name, keywords[i]);
+        report_setting[i] = words_are_the_same(setting,"on");
+    }
+
+    delete XML_file;
+
+    report_internal_log_enabled = report_setting[0];
+    report_external_log_enabled = report_setting[1];
+    report_progress_enabled = report_setting[2];
+    report_error_enabled = report_setting[3];
+    flush_log_file = report_setting[4];
 }
 
 
 void wtime(double *t)
 {
-  static int sec = -1;
+    static int sec = -1;
 
-  struct timeval tv;
-  gettimeofday(&tv, NULL);
-  if (sec < 0) 
-    sec = tv.tv_sec;
-  *t = (tv.tv_sec - sec) + 1.0e-6*tv.tv_usec;
+    struct timeval tv;
+    gettimeofday(&tv, NULL);
+    if (sec < 0) 
+        sec = tv.tv_sec;
+    *t = (tv.tv_sec - sec) + 1.0e-6*tv.tv_usec;
 }
 
 
 void report_header(int report_type, int comp_id, bool &condition, char *output_format)
 {
-	if (comp_id != -1 && (comp_id == comp_comm_group_mgt_mgr->get_global_node_root()->get_comp_id() || !comp_comm_group_mgt_mgr->is_legal_local_comp_id(comp_id, true) || components_time_mgrs->get_time_mgr(comp_id) == NULL))
-		comp_id = -1;
-	
-	output_format[0] = '\0';
-	
-	switch (report_type) {
-		case REPORT_ERROR:
-			condition = !condition;
-			break;
-		case REPORT_LOG:
-			condition = report_internal_log_enabled;
-			break;
-		case REPORT_EXTERNAL_LOG:
-			condition = report_external_log_enabled;
-			break;
-		case REPORT_WARNING:
-			condition = !condition;
-			break;
-		case REPORT_PROGRESS:
-			if (comp_id == -1)
-				condition = comp_comm_group_mgt_mgr->get_current_proc_global_id() == 0 && report_progress_enabled;
-			else condition = comp_comm_group_mgt_mgr->get_global_node_of_local_comp(comp_id,true,"")->get_current_proc_local_id() == 0 && report_progress_enabled;
-			break;
-		case REPORT_CONSTANTLY:
-			condition = true;
-			break;
-		default:
-			printf("report type %d is not support\n", report_type);
-			assert(false);
-	}
-
-	if (!condition)
-		return;
-
-	switch (report_type) {
-		case REPORT_ERROR:
-			if (line_number > 0 && execution_phase_number < 2)
-				sprintf(output_format+strlen(output_format), "CoR REPORT ERROR at script line %d: ", line_number);
-#ifndef ONLY_CoR
-			else sprintf(output_format+strlen(output_format), "C-Coupler REPORT ERROR: ");
-#endif
-			break;
-		case REPORT_LOG:
-			if (line_number > 0 && execution_phase_number < 2)
-				sprintf(output_format+strlen(output_format), "CoR REPORT LOG at script line %d: ", line_number);
-#ifndef ONLY_CoR
-			else sprintf(output_format+strlen(output_format), "C-Coupler REPORT LOG: ");
-#endif			
-			break;
-			case REPORT_EXTERNAL_LOG:
-				if (line_number > 0 && execution_phase_number < 2)
-					sprintf(output_format+strlen(output_format), "CoR REPORT LOG at script line %d: ", line_number);
-#ifndef ONLY_CoR
-				else sprintf(output_format+strlen(output_format), "C-Coupler REPORT LOG: ");
-#endif			
-				break;
-		case REPORT_WARNING:
-			if (line_number > 0 && execution_phase_number < 2)
-				sprintf(output_format+strlen(output_format), "CoR REPORT WARNING at script line %d: ", line_number);
-#ifndef ONLY_CoR
-			else sprintf(output_format+strlen(output_format), "C-Coupler REPORT WARNING: ");
-#endif
-			break;
-		case REPORT_PROGRESS:
-			if (line_number > 0 && execution_phase_number < 2)
-				sprintf(output_format+strlen(output_format), "CoR REPORT PROGRESS at script line %d: ", line_number);
-#ifndef ONLY_CoR
- 			else sprintf(output_format+strlen(output_format), "C-Coupler REPORT PROGRESS: ");
-#endif
-			break;
-		case REPORT_CONSTANTLY:
-			if (line_number > 0 && execution_phase_number < 2)
-				sprintf(output_format+strlen(output_format), "CoR REPORT at script line %d: ", line_number);
-#ifndef ONLY_CoR
-				else sprintf(output_format+strlen(output_format), "C-Coupler REPORT PROGRESS: ");
-#endif
-				break;
-		default:
-			printf("Software error: report type %d is not supported\n", report_type);
-			assert(false);
-			break;
-	}
-#ifndef ONLY_CoR
-	if (!(line_number > 0 && execution_phase_number < 2) && comp_comm_group_mgt_mgr != NULL) {
-		if (comp_id == -1)
-			sprintf(output_format+strlen(output_format)-2, " in the root component model corresponding to the executable named \"%s\": ", comp_comm_group_mgt_mgr->get_executable_name());
-		else {
-			int current_date = components_time_mgrs->get_time_mgr(comp_id)->get_current_date();
-			int current_second = components_time_mgrs->get_time_mgr(comp_id)->get_current_second();
-			int current_step_id = components_time_mgrs->get_time_mgr(comp_id)->get_current_step_id();
-			sprintf(output_format+strlen(output_format)-2, " in the component model \"%s\" corresponding to the executable named \"%s\", at the current simulation time of %08d-%05d (the current step number is %d): ", 
-				    comp_comm_group_mgt_mgr->get_global_node_of_local_comp(comp_id,true,"execution report")->get_full_name(), comp_comm_group_mgt_mgr->get_executable_name(), current_date, current_second, current_step_id);
-		}
-	}
-#endif
+    if (comp_id != -1 && (comp_id == comp_comm_group_mgt_mgr->get_global_node_root()->get_comp_id() || !comp_comm_group_mgt_mgr->is_legal_local_comp_id(comp_id, true) || components_time_mgrs->get_time_mgr(comp_id) == NULL))
+        comp_id = -1;
+    
+    output_format[0] = '\0';
+    
+    switch (report_type) {
+        case REPORT_ERROR:
+            condition = !condition;
+            break;
+        case REPORT_LOG:
+            condition = report_internal_log_enabled;
+            break;
+        case REPORT_EXTERNAL_LOG:
+            condition = report_external_log_enabled;
+            break;
+        case REPORT_WARNING:
+            condition = !condition;
+            break;
+        case REPORT_PROGRESS:
+            if (comp_id == -1)
+                condition = comp_comm_group_mgt_mgr->get_current_proc_global_id() == 0 && report_progress_enabled;
+            else condition = comp_comm_group_mgt_mgr->get_global_node_of_local_comp(comp_id,true,"")->get_current_proc_local_id() == 0 && report_progress_enabled;
+            break;
+        case REPORT_CONSTANTLY:
+            condition = true;
+            break;
+        default:
+            printf("report type %d is not support\n", report_type);
+            assert(false);
+    }
+
+    if (!condition)
+        return;
+
+    switch (report_type) {
+        case REPORT_ERROR:
+            sprintf(output_format+strlen(output_format), "C-Coupler REPORT ERROR: ");
+            break;
+        case REPORT_LOG:
+            sprintf(output_format+strlen(output_format), "C-Coupler REPORT LOG: ");    
+            break;
+        case REPORT_EXTERNAL_LOG:
+            sprintf(output_format+strlen(output_format), "C-Coupler REPORT LOG: ");
+            break;
+        case REPORT_WARNING:
+            sprintf(output_format+strlen(output_format), "C-Coupler REPORT WARNING: ");
+            break;
+        case REPORT_PROGRESS:
+             sprintf(output_format+strlen(output_format), "C-Coupler REPORT PROGRESS: ");
+            break;
+        case REPORT_CONSTANTLY:
+            sprintf(output_format+strlen(output_format), "C-Coupler REPORT PROGRESS: ");
+            break;
+        default:
+            printf("Software error: report type %d is not supported\n", report_type);
+            assert(false);
+            break;
+    }
+    if (comp_comm_group_mgt_mgr != NULL) {
+        if (comp_id == -1)
+            sprintf(output_format+strlen(output_format)-2, " in the root component model corresponding to the executable named \"%s\": ", comp_comm_group_mgt_mgr->get_executable_name());
+        else {
+            int current_date = components_time_mgrs->get_time_mgr(comp_id)->get_current_date();
+            int current_second = components_time_mgrs->get_time_mgr(comp_id)->get_current_second();
+            int current_step_id = components_time_mgrs->get_time_mgr(comp_id)->get_current_step_id();
+            sprintf(output_format+strlen(output_format)-2, " in the component model \"%s\" corresponding to the executable named \"%s\", at the current simulation time of %08d-%05d (the current step number is %d): ", 
+                    comp_comm_group_mgt_mgr->get_global_node_of_local_comp(comp_id,true,"execution report")->get_full_name(), comp_comm_group_mgt_mgr->get_executable_name(), current_date, current_second, current_step_id);
+        }
+    }
 }
 
 
 void execution_report(int report_type, int comp_id, bool condition, const char *format, ...)
 {
-	char output_format[NAME_STR_SIZE*16];
-	char output_string[NAME_STR_SIZE*16*16];
+    char output_format[NAME_STR_SIZE*16];
+    char output_string[NAME_STR_SIZE*16*16];
 
 
-	report_header(report_type, comp_id, condition, output_format);
-	
-	if (!condition)
-		return;
-	
-	strcat(output_format, format);
-	strcat(output_format, "\n\n");
+    report_header(report_type, comp_id, condition, output_format);
+    
+    if (!condition)
+        return;
+    
+    strcat(output_format, format);
+    strcat(output_format, "\n\n");
 
-	if (comp_id != -1 && (comp_id == comp_comm_group_mgt_mgr->get_global_node_root()->get_comp_id() || !comp_comm_group_mgt_mgr->is_legal_local_comp_id(comp_id, true) || components_time_mgrs->get_time_mgr(comp_id) == NULL))
-		comp_id = -1;
+    if (comp_id != -1 && (comp_id == comp_comm_group_mgt_mgr->get_global_node_root()->get_comp_id() || !comp_comm_group_mgt_mgr->is_legal_local_comp_id(comp_id, true) || components_time_mgrs->get_time_mgr(comp_id) == NULL))
+        comp_id = -1;
 
-	va_list pArgList;
+    va_list pArgList;
     va_start(pArgList, format);
-	vsprintf(output_string, output_format, pArgList);
-	va_end(pArgList);	
-	if (comp_comm_group_mgt_mgr == NULL) {
-		fprintf(stdout, output_string);
-		if (flush_log_file || report_type == REPORT_ERROR)
-			fflush(stdout);
-	}
-	else {
-		const char *log_file_name1 = comp_comm_group_mgt_mgr->get_exe_log_file_name();
-		const char *log_file_name2 = NULL;
-		comp_comm_group_mgt_mgr->output_log(output_string, flush_log_file || report_type == REPORT_ERROR);
-		if (comp_id != -1) {
-			log_file_name2 = comp_comm_group_mgt_mgr->search_global_node(comp_id)->get_comp_ccpl_log_file_name();
-			comp_comm_group_mgt_mgr->search_global_node(comp_id)->output_log(output_string, flush_log_file || report_type == REPORT_ERROR);
-		}
-		if (report_type == REPORT_ERROR) {
-			if (log_file_name2 == NULL)
-				printf("ERROR happens. Please check the log file \"%s\"\n\n", log_file_name1);
-			else printf("ERROR happens. Please check the log file \"%s\" or \"%s\"\n\n", log_file_name1, log_file_name2);
-		}
-	}
-
-	if (report_type == REPORT_ERROR)
-		assert(false);
+    vsprintf(output_string, output_format, pArgList);
+    va_end(pArgList);    
+    if (comp_comm_group_mgt_mgr == NULL) {
+        fprintf(stdout, output_string);
+        if (flush_log_file || report_type == REPORT_ERROR)
+            fflush(stdout);
+    }
+    else {
+        const char *log_file_name1 = comp_comm_group_mgt_mgr->get_exe_log_file_name();
+        const char *log_file_name2 = NULL;
+        comp_comm_group_mgt_mgr->output_log(output_string, flush_log_file || report_type == REPORT_ERROR);
+        if (comp_id != -1) {
+            log_file_name2 = comp_comm_group_mgt_mgr->search_global_node(comp_id)->get_comp_ccpl_log_file_name();
+            comp_comm_group_mgt_mgr->search_global_node(comp_id)->output_log(output_string, flush_log_file || report_type == REPORT_ERROR);
+        }
+        if (report_type == REPORT_ERROR) {
+            if (log_file_name2 == NULL)
+                printf("ERROR happens. Please check the log file \"%s\"\n\n", log_file_name1);
+            else printf("ERROR happens. Please check the log file \"%s\" or \"%s\"\n\n", log_file_name1, log_file_name2);
+        }
+    }
+
+    if (report_type == REPORT_ERROR)
+        assert(false);
 }
 
 
 
 void execution_report(int report_type, int comp_id, bool condition) 
 {
-	execution_report(report_type, comp_id, condition, "report without explicit hint");
+    execution_report(report_type, comp_id, condition, "report without explicit hint");
 }
 
 
diff --git a/src/Utils/execution_report.h b/src/Utils/execution_report.h
old mode 100644
new mode 100755
index bf4c446..e3de30f
--- a/src/Utils/execution_report.h
+++ b/src/Utils/execution_report.h
@@ -28,6 +28,8 @@
 
 
 #define CCPL_NULL_INT                                   ((int)(0x7FFFFFFF))
+#define CCPL_NULL_LONG                                  ((long)(0x7FFFFFFFFFFFFFFF))
+
 
 extern bool report_external_log_enabled;
 extern bool report_error_enabled;
diff --git a/src/XML/tinystr.cxx b/src/XML/tinystr.cxx
old mode 100644
new mode 100755
diff --git a/src/XML/tinystr.h b/src/XML/tinystr.h
old mode 100644
new mode 100755
diff --git a/src/XML/tinyxml.cxx b/src/XML/tinyxml.cxx
old mode 100644
new mode 100755
diff --git a/src/XML/tinyxml.h b/src/XML/tinyxml.h
old mode 100644
new mode 100755
diff --git a/src/XML/tinyxmlerror.cxx b/src/XML/tinyxmlerror.cxx
old mode 100644
new mode 100755
diff --git a/src/XML/tinyxmlparser.cxx b/src/XML/tinyxmlparser.cxx
old mode 100644
new mode 100755
